================================================================
RepopackPy Output File
================================================================

This file was generated by RepopackPy on: 2025-03-19T19:56:48.453977

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and RepopackPy's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

For more information about RepopackPy, visit: https://github.com/abinthomasonline/repopack-py

================================================================
Repository Structure
================================================================
POTFILES
agos.cpp
agos.h
animation.cpp
animation.h
charset-fontdata.cpp
charset.cpp
configure.engine
contain.cpp
credits.pl
cursor.cpp
debug.cpp
debug.h
debugger.cpp
debugger.h
detection.cpp
detection.h
detection_fallback.h
detection_tables.h
draw.cpp
drivers\accolade\adlib.cpp
drivers\accolade\adlib.h
drivers\accolade\casio.cpp
drivers\accolade\casio.h
drivers\accolade\cms.cpp
drivers\accolade\cms.h
drivers\accolade\driverfile.cpp
drivers\accolade\mididriver.h
drivers\accolade\mt32.cpp
drivers\accolade\mt32.h
drivers\accolade\pc98.cpp
drivers\simon1\adlib.cpp
drivers\simon1\adlib.h
event.cpp
feeble.cpp
gfx.cpp
icons.cpp
input.cpp
input_pn.cpp
intern.h
intern_detection.h
items.cpp
menus.cpp
metaengine.cpp
midi.cpp
midi.h
midiparser_gmf.cpp
midiparser_gmf.h
midiparser_s1d.cpp
midiparser_simonwin.cpp
midiparser_simonwin.h
module.mk
obsolete.h
oracle.cpp
pn.cpp
res.cpp
res_ami.cpp
res_snd.cpp
rooms.cpp
saveload.cpp
script.cpp
script_dp.cpp
script_e1.cpp
script_e2.cpp
script_ff.cpp
script_pn.cpp
script_pp.cpp
script_s1.cpp
script_s2.cpp
script_ww.cpp
sfxparser_accolade.cpp
sfxparser_accolade.h
sound.cpp
sound.h
string.cpp
string_pn.cpp
subroutine.cpp
verb.cpp
verb_pn.cpp
vga.cpp
vga.h
vga_e2.cpp
vga_ff.cpp
vga_pn.cpp
vga_s1.cpp
vga_s2.cpp
vga_ww.cpp
window.cpp
zones.cpp

================================================================
Repository Files
================================================================

================
File: agos.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/config-manager.h"
#include "common/debug-channels.h"
#include "common/file.h"
#include "common/fs.h"
#include "common/textconsole.h"

#include "engines/util.h"

#include "agos/debugger.h"
#include "agos/intern.h"
#include "agos/agos.h"
#include "agos/midi.h"
#include "agos/sound.h"

#include "backends/audiocd/audiocd.h"

#include "graphics/surface.h"
#include "graphics/sjis.h"

#include "audio/mididrv.h"

namespace AGOS {

static const GameSpecificSettings simon1_settings = {
	"",                                     // base_filename
	"",                                     // restore_filename
	"",                                     // tbl_filename
	"EFFECTS",                              // effects_filename
	"SIMON",                                // speech_filename
};

static const GameSpecificSettings simon2_settings = {
	"",                                     // base_filename
	"",                                     // restore_filename
	"",                                     // tbl_filename
	"",                                     // effects_filename
	"SIMON2",                               // speech_filename
};

#ifdef ENABLE_AGOS2
static const GameSpecificSettings dimp_settings = {
	"Gdimp",                                // base_filename
	"",                                     // restore_filename
	"",                                     // tbl_filename
	"",                                     // effects_filename
	"MUSIC",                                // speech_filename
};

static const GameSpecificSettings jumble_settings = {
	"Gjumble",                              // base_filename
	"",                                     // restore_filename
	"",                                     // tbl_filename
	"",                                     // effects_filename
	"MUSIC",                                // speech_filename
};

static const GameSpecificSettings puzzle_settings = {
	"Gpuzzle",                              // base_filename
	"",                                     // restore_filename
	"",                                     // tbl_filename
	"",                                     // effects_filename
	"MUSIC",                                // speech_filename
};

static const GameSpecificSettings swampy_settings = {
	"Gswampy",                              // base_filename
	"",                                     // restore_filename
	"",                                     // tbl_filename
	"",                                     // effects_filename
	"MUSIC",                                // speech_filename
};

AGOSEngine_DIMP::AGOSEngine_DIMP(OSystem *system, const AGOSGameDescription *gd)
	: AGOSEngine_PuzzlePack(system, gd) {

	_iconToggleCount = 0;
	_voiceCount = 0;

	_lastTickCount = 0;
	_startSecondCount = 0;
	_tSecondCount = 0;
}

AGOSEngine_PuzzlePack::AGOSEngine_PuzzlePack(OSystem *system, const AGOSGameDescription *gd)
	: AGOSEngine_Feeble(system, gd) {

	_oopsValid = false;
	_gameTime = 0;
}
#endif

AGOSEngine_Simon2::AGOSEngine_Simon2(OSystem *system, const AGOSGameDescription *gd)
	: AGOSEngine_Simon1(system, gd) {
}

AGOSEngine_Simon1::AGOSEngine_Simon1(OSystem *system, const AGOSGameDescription *gd)
	: AGOSEngine_Waxworks(system, gd) {
}

AGOSEngine_Waxworks::AGOSEngine_Waxworks(OSystem *system, const AGOSGameDescription *gd)
	: AGOSEngine_Elvira2(system, gd) {

	_boxCR = false;
	_boxLineCount = 0;
	memset(_boxBuffer, 0, sizeof(_boxBuffer));
	_boxBufferPtr = _boxBuffer;

	_linePtrs[0] = nullptr;
	_linePtrs[1] = nullptr;
	_linePtrs[2] = nullptr;
	_linePtrs[3] = nullptr;
	_linePtrs[4] = nullptr;
	_linePtrs[5] = nullptr;
	memset(_lineCounts, 0, sizeof(_lineCounts));
}

AGOSEngine_Elvira2::AGOSEngine_Elvira2(OSystem *system, const AGOSGameDescription *gd)
	: AGOSEngine_Elvira1(system, gd) {
}

AGOSEngine_Elvira1::AGOSEngine_Elvira1(OSystem *system, const AGOSGameDescription *gd)
	: AGOSEngine(system, gd), _sjisCurChar(0), _sjisFont(nullptr) {
}

AGOSEngine_Elvira1::~AGOSEngine_Elvira1() {
	delete _sjisFont;
}

Common::Error AGOSEngine_Elvira1::init() {
	Common::Error ret = AGOSEngine::init();
	if (ret.getCode() == Common::kNoError && getPlatform() == Common::kPlatformPC98) {
		_sjisFont = Graphics::FontSJIS::createFont(Common::kPlatformPC98);
		if (_sjisFont)
			_sjisFont->toggleFatPrint(true);
		else
			error("AGOSEngine_Elvira1::init(): Failed to load SJIS font.");
	}
	return ret;
}

AGOSEngine::AGOSEngine(OSystem *system, const AGOSGameDescription *gd)
	: Engine(system), _rnd("agos"), _gameDescription(gd) {

	//Image dumping command disabled as it doesn't work well
#if 0
	DebugMan.addDebugChannel(kDebugImageDump, "image_dump", "Enable dumping of images to files");
#endif
	_vcPtr = nullptr;
	_vcGetOutOfCode = 0;
	_gameOffsetsPtr = nullptr;

	_gameFile = nullptr;
	_opcode = 0;

	_itemMemSize = 0;
	_tableMemSize = 0;
	_vgaMemSize = 0;

	_musicIndexBase = 0;
	_soundIndexBase = 0;
	_tableIndexBase = 0;
	_textIndexBase = 0;

	_numMusic = 0;
	_numSFX = 0;
	_numSpeech = 0;
	_numZone = 0;

	_numBitArray1 = 0;
	_numBitArray2 = 0;
	_numBitArray3 = 0;
	_numItemStore = 0;
	_numTextBoxes = 0;
	_numVars = 0;
	_numVideoOpcodes = 0;
	_vgaBaseDelay = 0;
	_vgaPeriod = 0;

	_strippedTxtMem = nullptr;
	_textMem = nullptr;
	_textSize = 0;
	_stringTabNum = 0;
	_stringTabPos = 0;
	_stringTabSize = 0;
	_stringTabPtr = nullptr;

	_itemArrayPtr = nullptr;
	_itemArraySize = 0;
	_itemArrayInited = 0;

	_iconFilePtr = nullptr;

	_codePtr = nullptr;

	_localStringtable = nullptr;
	_stringIdLocalMin = 0;
	_stringIdLocalMax = 0;

	_roomStates = nullptr;
	_numRoomStates = 0;

	_menuBase = nullptr;
	_roomsList = nullptr;
	_roomsListPtr = nullptr;

	_xtblList = nullptr;
	_xtablesHeapPtrOrg = nullptr;
	_xtablesHeapCurPosOrg = 0;
	_xsubroutineListOrg = nullptr;

	_tblList = nullptr;
	_tablesHeapPtr = nullptr;
	_tablesHeapPtrOrg = nullptr;
	_tablesheapPtrNew = nullptr;
	_tablesHeapSize = 0;
	_tablesHeapCurPos = 0;
	_tablesHeapCurPosOrg = 0;
	_tablesHeapCurPosNew = 0;
	_subroutineListOrg = nullptr;

	_subroutineList = nullptr;

	_recursionDepth = 0;

	_lastVgaTick = 0;

	_marks = 0;
	_scanFlag = false;

	_scriptVar2 = 0;
	_runScriptReturn1 = false;
	_skipVgaWait = false;
	_noParentNotify = false;
	_beardLoaded = false;
	_litBoxFlag = false;
	_mortalFlag = false;
	_displayFlag = 0;
	_syncFlag2 = false;
	_inCallBack = false;
	_cepeFlag = false;
	_fastMode = false;

	_backFlag = false;

	_copyProtection = false;
	_pause = false;
	_speech = false;
	_subtitles = false;

	_animatePointer = 0;
	_maxCursorWidth = 0;
	_maxCursorHeight = 0;
	_mouseAnim = 0;
	_mouseAnimMax = 0;
	_mouseCursor = 0;
	_mouseData = nullptr;
	_oldMouseCursor = 0;
	_currentMouseCursor = 0;
	_currentMouseAnim = 0;
	_oldMouseAnimMax = 0;

	_vgaVar9 = 0;
	_chanceModifier = 0;
	_restoreWindow6 = 0;
	_scrollX = 0;
	_scrollY = 0;
	_scrollXMax = 0;
	_scrollYMax = 0;
	_scrollCount = 0;
	_scrollFlag = 0;
	_scrollHeight = 0;
	_scrollWidth = 0;
	_scrollImage = nullptr;
	_boxStarHeight = 0;

	_scriptVerb = 0;
	_scriptNoun1 = 0;
	_scriptNoun2 = 0;
	_scriptAdj1 = 0;
	_scriptAdj2 = 0;

	_curWindow = 0;
	_textWindow = nullptr;

	_subjectItem = nullptr;
	_objectItem = nullptr;
	_currentPlayer = nullptr;

	_iOverflow = false;
	_nameLocked = false;
	_hitAreaObjectItem = nullptr;
	_lastHitArea = nullptr;
	_lastNameOn = nullptr;
	_lastHitArea3 = nullptr;
	_hitAreaSubjectItem = nullptr;
	_currentBox = nullptr;
	_currentBoxNum = 0;
	_currentVerbBox = nullptr;
	_lastVerbOn = nullptr;
	_needHitAreaRecalc = 0;
	_verbHitArea = 0;
	_defaultVerb = 0;
	_mouseHideCount = 0;

	_dragAccept = false;
	_dragEnd = false;
	_dragFlag = false;
	_dragMode = false;
	_dragCount = 0;
	_lastClickRem = nullptr;

	_windowNum = 0;

	_printCharCurPos = 0;
	_printCharMaxPos = 0;
	_printCharPixelCount = 0;
	_numLettersToPrint = 0;

	_clockStopped = 0;
	_gameStoppedClock = 0;
	_lastTime = 0;
	_lastMinute = 0;

	_firstTimeStruct = nullptr;
	_pendingDeleteTimeEvent = nullptr;

	_initMouse = 0;
	_leftButtonDown = false;
	_rightButtonDown = false;
	_clickOnly = false;
	_oneClick = 0;
	_leftClick = 0;
	_rightClick = 0;
	_noRightClick = false;

	_leftButton = 0;
	_leftButtonCount = 0;
	_leftButtonOld = 0;

	_dummyItem1 = new Item();
	_dummyItem2 = new Item();
	_dummyItem3 = new Item();

	_videoLockOut = 0;
	_scrollUpHitArea = 0;
	_scrollDownHitArea = 0;

	_noOverWrite = 0;
	_rejectBlock = false;

	_fastFadeCount = 0;
	_fastFadeInFlag = 0;
	_fastFadeOutFlag = false;
	_neverFade = false;
	_exitCutscene = 0;
	_paletteFlag = 0;
	_bottomPalette = false;
	_picture8600 = 0;

	_soundFileId = 0;
	_lastMusicPlayed = 0;
	_nextMusicToPlay = 0;
	_sampleEnd = 0;
	_sampleWait = 0;

	_showPreposition = 0;
	_showMessageFlag = 0;

	_newDirtyClip = false;
	_wiped = false;
	_copyScnFlag = 0;
	_vgaSpriteChanged = 0;

	_block = nullptr;
	_blockEnd = nullptr;
	_vgaMemPtr = nullptr;
	_vgaMemEnd = nullptr;
	_vgaMemBase = nullptr;
	_vgaFrozenBase = nullptr;
	_vgaRealBase = nullptr;
	_zoneBuffers = nullptr;

	_curVgaFile1 = nullptr;
	_curVgaFile2 = nullptr;
	_curSfxFile = nullptr;
	_curSfxFileSize = 0;

	_syncCount = 0;

	_frameCount = 0;

	_zoneNumber = 0;

	_vgaWaitFor = 0;
	_lastVgaWaitFor = 0;

	_vgaCurZoneNum = 0;
	_vgaCurSpriteId = 0;

	_baseY = 0;
	_scale = 0;

	_feebleRect.left = 0;
	_feebleRect.right = 0;
	_feebleRect.top = 0;
	_feebleRect.bottom = 0;

	_scaleX = 0;
	_scaleY = 0;
	_scaleWidth = 0;
	_scaleHeight = 0;

	_nextVgaTimerToProcess = nullptr;

	_opcode177Var1 = 1;
	_opcode177Var2 = 0;
	_opcode178Var1 = 1;
	_opcode178Var2 = 0;

	_classLine = nullptr;
	_classMask = 0;
	_classMode1 = 0;
	_classMode2 = 0;
	_currentLine = nullptr;
	_currentTable = nullptr;
	_findNextPtr = nullptr;

	_agosMenu = 0;
	_currentRoom = 0;
	_superRoomNumber = 0;
	_wallOn = 0;

	memset(_objectArray, 0, sizeof(_objectArray));
	memset(_itemStore, 0, sizeof(_itemStore));
	memset(_textMenu, 0, sizeof(_textMenu));

	memset(_shortText, 0, sizeof(_shortText));
	memset(_shortTextX, 0, sizeof(_shortText));
	memset(_shortTextY, 0, sizeof(_shortText));
	memset(_longText, 0, sizeof(_longText));
	memset(_longSound, 0, sizeof(_longSound));

	memset(_bitArray, 0, sizeof(_bitArray));
	memset(_bitArrayTwo, 0, sizeof(_bitArrayTwo));
	memset(_bitArrayThree, 0, sizeof(_bitArrayThree));

	_variableArray = nullptr;
	_variableArray2 = nullptr;
	_variableArrayPtr = nullptr;

	memset(_windowArray, 0, sizeof(_windowArray));

	memset(_fcsData1, 0, sizeof(_fcsData1));
	memset(_fcsData2, 0, sizeof(_fcsData2));

	_awaitTwoByteToken = 0;
	_byteTokens = nullptr;
	_byteTokenStrings = nullptr;
	_twoByteTokens = nullptr;
	_twoByteTokenStrings = nullptr;
	_secondTwoByteTokenStrings = nullptr;
	_thirdTwoByteTokenStrings = nullptr;
	memset(_textBuffer, 0, sizeof(_textBuffer));
	_textCount = 0;

	_freeStringSlot = 0;

	memset(_stringReturnBuffer, 0, sizeof(_stringReturnBuffer));

	memset(_pathFindArray, 0, sizeof(_pathFindArray));

	memset(_pathValues, 0, sizeof(_pathValues));
	_PVCount = 0;
	_GPVCount = 0;

	memset(_pathValues1, 0, sizeof(_pathValues1));
	_PVCount1 = 0;
	_GPVCount1 = 0;

	memset(_currentPalette, 0, sizeof(_currentPalette));
	memset(_displayPalette, 0, sizeof(_displayPalette));

	memset(_videoBuf1, 0, sizeof(_videoBuf1));
	memset(_videoWindows, 0, sizeof(_videoWindows));

	_dummyWindow = new WindowBlock;
	_windowList = new WindowBlock[16];

	memset(_lettersToPrintBuf, 0, sizeof(_lettersToPrintBuf));

	_planarBuf = nullptr;
	_pak98Buf = nullptr;
	_paletteModNext = 16;

	_midiEnabled = false;

	_vgaTickCounter = 0;

	_sound = nullptr;

	_effectsMuted = false;
	_ambientMuted = false;
	_musicMuted = false;
	// Initialize at default ScummVM volumes; these will be overwritten by
	// syncSoundSettings.
	_musicVolume = 192;
	_effectsVolume = 192;
	_useDigitalSfx = true;

	_saveLoadType = 0;
	_saveLoadSlot = 0;
	memset(_saveLoadName, 0, sizeof(_saveLoadName));
	memset(_saveBuf, 0, sizeof(_saveBuf));

	_saveGameNameLen = 0;
	_saveLoadRowCurPos = 0;
	_numSaveGameRows = 0;
	_saveDialogFlag = false;
	_saveOrLoad = false;
	_saveLoadEdit = false;

	_hyperLink = 0;
	_interactY = 0;
	_oracleMaxScrollY = 0;
	_noOracleScroll = 0;

	_backGroundBuf = nullptr;
	_backBuf = nullptr;
	_scaleBuf = nullptr;
	_window4BackScn = nullptr;
	_window6BackScn = nullptr;

	_window3Flag = 0;
	_window4Flag = 0;
	_window6Flag = 0;

	_moveXMin = 0;
	_moveYMin = 0;
	_moveXMax = 0;
	_moveYMax = 0;

	_forceAscii = false;

	_vc10BasePtrOld = nullptr;
	memcpy (_hebrewCharWidths,
		"\x5\x5\x4\x6\x5\x3\x4\x5\x6\x3\x5\x5\x4\x6\x5\x3\x4\x6\x5\x6\x6\x6\x5\x5\x5\x6\x5\x6\x6\x6\x6\x6", 32);

	const Common::FSNode gameDataDir(ConfMan.getPath("path"));

	// Add default file directories for Acorn version of
	// Simon the Sorcerer 1
	SearchMan.addSubDirectoryMatching(gameDataDir, "execute");
	SearchMan.addSubDirectoryMatching(gameDataDir, "tables");
	SearchMan.addSubDirectoryMatching(gameDataDir, "text");
	SearchMan.addSubDirectoryMatching(gameDataDir, "tunes");

	// Add default file directories for Amiga/Macintosh
	// versions of Simon the Sorcerer 2
	SearchMan.addSubDirectoryMatching(gameDataDir, "voices");

	// Add default file directories for Amiga & Macintosh
	// versions of The Feeble Files
	SearchMan.addSubDirectoryMatching(gameDataDir, "gfx");
	SearchMan.addSubDirectoryMatching(gameDataDir, "movies");
	SearchMan.addSubDirectoryMatching(gameDataDir, "sfx");
	SearchMan.addSubDirectoryMatching(gameDataDir, "speech");
}

Common::Error AGOSEngine::init() {
	if (getGameId() == GID_DIMP) {
		_screenWidth = 496;
		_screenHeight = 400;
	} else if (getGameType() == GType_FF || getGameType() == GType_PP) {
		_screenWidth = 640;
		_screenHeight = 480;
	} else {
		_screenWidth = 320;
		_screenHeight = 200;
	}

	_internalWidth = _screenWidth;
	_internalHeight = _screenHeight;

	if (getPlatform() == Common::kPlatformPC98) {
		_internalWidth <<= 1;
		_internalHeight <<= 1;
	}

	if (ConfMan.hasKey("disable_fade_effects"))
		_neverFade = ConfMan.getBool("disable_fade_effects");

	initGraphics(_internalWidth, _internalHeight);

	_midi = new MidiPlayer(this);

	if ((getGameType() == GType_SIMON2 && getPlatform() == Common::kPlatformWindows) ||
			(getGameType() == GType_SIMON1 && getPlatform() == Common::kPlatformWindows) ||
			((getFeatures() & GF_TALKIE) && getPlatform() == Common::kPlatformAcorn) ||
			(getPlatform() == Common::kPlatformDOS && getGameType() != GType_PN && getGameType() != GType_FF) ||
			getPlatform() == Common::kPlatformPC98) {

		int ret = _midi->open();
		if (ret)
			warning("MIDI Player init failed: \"%s\"", MidiDriver::getErrorName(ret));

		_midiEnabled = true;
	}
	// Digital SFX are used if MIDI SFX are not available or if the "prefer
	// digital SFX" setting is set to true or is not present at all.
	// Two exceptions to this are:
	// - Elvira 2 DOS needs an optional file to enable digital SFX. If it is
	//   not present, MIDI SFX are used.
	// - Simon 1 DOS floppy has only MIDI SFX.
	// Note that MIDI SFX can be safely used if the MidiPlayer failed to
	// initialize; they just will not play.
	_useDigitalSfx = !_midiEnabled || !_midi->hasMidiSfx() || !ConfMan.hasKey("prefer_digitalsfx") || ConfMan.getBool("prefer_digitalsfx");
	if ((getGameType() == GType_ELVIRA2 && getPlatform() == Common::kPlatformDOS && !SearchMan.hasFile("013.VGA")) ||
			(getGameType() == GType_SIMON1 && getPlatform() == Common::kPlatformDOS && !(getFeatures() & GF_TALKIE))) {
		_useDigitalSfx = false;
	}
	if (!_useDigitalSfx && (getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) && getPlatform() == Common::kPlatformDOS) {
		// Load the MIDI SFX data file for Elvira 2 and Waxworks DOS.
		loadMidiSfx();
	}

	// allocate buffers
	_backGroundBuf = new Graphics::Surface();
	_backGroundBuf->create(_screenWidth, _screenHeight, Graphics::PixelFormat::createFormatCLUT8());

	if (getGameType() == GType_FF || getGameType() == GType_PP || (getGameType() == GType_ELVIRA1 && getPlatform() == Common::kPlatformPC98)) {
		_backBuf = new Graphics::Surface();
		_backBuf->create(_screenWidth, _screenHeight, Graphics::PixelFormat::createFormatCLUT8());
		_scaleBuf = new Graphics::Surface();
		_scaleBuf->create(_internalWidth, _internalHeight, Graphics::PixelFormat::createFormatCLUT8());
	}

	if (getGameType() == GType_SIMON2) {
		_window4BackScn = new Graphics::Surface();
		_window4BackScn->create(_screenWidth, _screenHeight, Graphics::PixelFormat::createFormatCLUT8());
	} else if (getGameType() == GType_SIMON1) {
		_window4BackScn = new Graphics::Surface();
		_window4BackScn->create(_screenWidth, 134, Graphics::PixelFormat::createFormatCLUT8());
	} else if (getGameType() == GType_WW || getGameType() == GType_ELVIRA2) {
		_window4BackScn = new Graphics::Surface();
		_window4BackScn->create(224, 127, Graphics::PixelFormat::createFormatCLUT8());
	} else if (getGameType() == GType_ELVIRA1) {
		_window4BackScn = new Graphics::Surface();
		if (getPlatform() == Common::kPlatformAmiga && (getFeatures() & GF_DEMO)) {
			_window4BackScn->create(224, 196, Graphics::PixelFormat::createFormatCLUT8());
		} else {
			_window4BackScn->create(224, 144, Graphics::PixelFormat::createFormatCLUT8());
		}
		_window6BackScn = new Graphics::Surface();
		_window6BackScn->create(48, 80, Graphics::PixelFormat::createFormatCLUT8());
	}

	setupGame();

	setDebugger(new Debugger(this));
	_sound = new Sound(this, gss, _mixer);

	_copyProtection = ConfMan.getBool("copy_protection");
	_language = Common::parseLanguage(ConfMan.get("language"));

	if (getGameType() == GType_PP) {
		_speech = true;
		_subtitles = false;
	} else if (getFeatures() & GF_TALKIE) {
		_speech = !ConfMan.getBool("speech_mute");
		_subtitles = ConfMan.getBool("subtitles");

		if (getGameType() == GType_SIMON1) {
			// English and German versions don't have full subtitles
			if (_language == Common::EN_ANY || _language == Common::DE_DEU)
				_subtitles = false;
			// Other versions require speech to be enabled
			else
				_speech = true;
		}

		// Default to speech only, if both speech and subtitles disabled
		if (!_speech && !_subtitles)
			_speech = true;
	} else {
		_speech = false;
		_subtitles = true;
	}

	// Setup mixer
	syncSoundSettings();

	return Common::kNoError;
}

static const uint16 initialVideoWindows_Simon[20] = {
	0,  0, 20, 200,
	0,  0,  3, 136,
	17, 0,  3, 136,
	0,  0, 20, 200,
	0,  0, 20, 134
};

static const uint16 initialVideoWindows_Common[20] = {
	 3, 0, 14, 136,
	 0, 0,  3, 136,
	17, 0,  3, 136,
	 0, 0, 20, 200,
	 3, 3, 14, 127,
};

static const uint16 initialVideoWindows_PN[20] = {
	 3, 0, 14, 136,
	 0, 0,  3, 136,
	17, 0,  3, 136,
	 0, 0, 20, 200,
	 3, 2, 14, 129,
};

#ifdef ENABLE_AGOS2
void AGOSEngine_PuzzlePack::setupGame() {
	if (getGameId() == GID_DIMP) {
		gss = &dimp_settings;
	} else if (getGameId() == GID_JUMBLE) {
		gss = &jumble_settings;
	} else if (getGameId() == GID_PUZZLE) {
		gss = &puzzle_settings;
	} else if (getGameId() == GID_SWAMPY) {
		gss = &swampy_settings;
	}
	_numVideoOpcodes = 85;
	_vgaMemSize = 7500000;
	_itemMemSize = 20000;
	_tableMemSize = 200000;
	_frameCount = 1;
	_vgaBaseDelay = 5;
	_vgaPeriod = (getGameId() == GID_DIMP) ? 35 : 30;
	_numBitArray1 = 128;
	_numItemStore = 10;
	_numTextBoxes = 40;
	_numVars = 2048;

	_numZone = 450;

	AGOSEngine::setupGame();
}
#endif

void AGOSEngine_Simon2::setupGame() {
	gss = &simon2_settings;
	_tableIndexBase = 1580 / 4;
	_textIndexBase = 1500 / 4;
	_numVideoOpcodes = 75;
#if defined(__DS__)
	_vgaMemSize = 1300000;
#else
	_vgaMemSize = 2000000;
#endif
	_itemMemSize = 20000;
	_tableMemSize = 100000;
	// Check whether to use MT-32 MIDI tracks in Simon the Sorcerer 2
	if (getGameType() == GType_SIMON2 && getPlatform() == Common::kPlatformDOS && _midi->usesMT32Data())
		_musicIndexBase = MUSIC_INDEX_BASE_SIMON2_MT32;
	else
		_musicIndexBase = MUSIC_INDEX_BASE_SIMON2_GM;
	_soundIndexBase = 1660 / 4;
	_frameCount = 1;
	_vgaBaseDelay = 1;
	_vgaPeriod = 45;
	_numBitArray1 = 16;
	_numBitArray2 = 16;
	_numItemStore = 10;
	_numTextBoxes = 20;
	_numVars = 255;

	_numMusic = 93;
	_numSFX = 222;
	_numSpeech = 11997;
	_numZone = 140;

	AGOSEngine::setupGame();
}

void AGOSEngine_Simon1::setupGame() {
	gss = &simon1_settings;
	_tableIndexBase = 1576 / 4;
	_textIndexBase = 1460 / 4;
	_numVideoOpcodes = 64;
	_vgaMemSize = 1000000;
	_itemMemSize = 20000;
	_tableMemSize = 50000;
	_musicIndexBase = 1316 / 4;
	_soundIndexBase = 0;
	_frameCount = 1;
	_vgaBaseDelay = 1;
	_vgaPeriod = 50;
	_numBitArray1 = 16;
	_numBitArray2 = 16;
	_numItemStore = 10;
	_numTextBoxes = 20;
	_numVars = 255;

	_numMusic = 34;
	_numSFX = 127;
	_numSpeech = 3623;
	_numZone = 164;

	AGOSEngine::setupGame();
}

void AGOSEngine_Waxworks::setupGame() {
	gss = &simon1_settings;
	_numVideoOpcodes = 64;
	_vgaMemSize = 1000000;
	_itemMemSize = 80000;
	_tableMemSize = 50000;
	_frameCount = 4;
	_vgaBaseDelay = 1;
	_vgaPeriod = 50;
	_numBitArray1 = 16;
	_numBitArray2 = 15;
	_numItemStore = 50;
	_numTextBoxes = 10;
	_numVars = 255;

	_numMusic = 26;
	_numZone = 155;

	AGOSEngine::setupGame();
}

void AGOSEngine_Elvira2::setupGame() {
	gss = &simon1_settings;
	_numVideoOpcodes = 60;
	_vgaMemSize = 1000000;
	_itemMemSize = 64000;
	_tableMemSize = 100000;
	_frameCount = 4;
	_vgaBaseDelay = 1;
	_vgaPeriod = 50;
	_numBitArray1 = 16;
	_numBitArray2 = 15;
	_numItemStore = 50;
	_numVars = 255;

	_numMusic = 9;
	_numZone = 99;

	AGOSEngine::setupGame();
}

void AGOSEngine_Elvira1::setupGame() {
	gss = &simon1_settings;
	_numVideoOpcodes = 57;
	_vgaMemSize = 1000000;
	_itemMemSize = 64000;
	_tableMemSize = 256000;
	_frameCount = 4;
	_vgaBaseDelay = 1;
	_vgaPeriod = 50;
	_numVars = 512;

	_numMusic = 14;
	_numZone = 74;

	AGOSEngine::setupGame();
}

void AGOSEngine_PN::setupGame() {
	gss = &simon1_settings;
	_numVideoOpcodes = 57;
	_vgaMemSize = 1000000;
	_frameCount = 4;
	_vgaBaseDelay = 1;
	_vgaPeriod = 50;
	_numVars = 256;

	_numZone = 26;

	AGOSEngine::setupGame();
}

void AGOSEngine::setupGame() {
	allocItemHeap();
	allocTablesHeap();

	if (getGameType() != GType_SIMON2)
		initMouse();

	_variableArray = (int16 *)calloc(_numVars, sizeof(int16));
	_variableArrayPtr = _variableArray;
	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		_variableArray2 = (int16 *)calloc(_numVars, sizeof(int16));
	}

	setupOpcodes();
	setupVgaOpcodes();

	setZoneBuffers();

	_currentMouseCursor = 255;
	_currentMouseAnim = 255;

	_lastMusicPlayed = -1;
	_nextMusicToPlay = -1;

	_noOverWrite = 0xFFFF;

	_stringIdLocalMin = 1;

	_agosMenu = 1;
	_superRoomNumber = 1;

	for (int i = 0; i < 20; i++) {
		if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
			_videoWindows[i] = initialVideoWindows_Simon[i];
		} else if (getGameType() == GType_PN) {
			_videoWindows[i] = initialVideoWindows_PN[i];
		} else {
			_videoWindows[i] = initialVideoWindows_Common[i];
		}
	}

	if (getGameType() == GType_ELVIRA2 && getPlatform() == Common::kPlatformAtariST) {
		_videoWindows[9] = 75;
	}
}

AGOSEngine::~AGOSEngine() {
	_system->getAudioCDManager()->stop();

	for (uint i = 0; i < _itemHeap.size(); i++) {
		delete[] _itemHeap[i];
	}
	_itemHeap.clear();

	free(_tablesHeapPtr - _tablesHeapCurPos);

	free(_mouseData);

	free(_gameOffsetsPtr);
	free(_iconFilePtr);
	free(_itemArrayPtr);
	free(_menuBase);
	free(_roomsList);
	free(_roomStates);
	free(_stringTabPtr);
	free(_strippedTxtMem);
	free(_tblList);
	free(_textMem);
	free(_xtblList);

	if (_backGroundBuf)
		_backGroundBuf->free();
	delete _backGroundBuf;
	if (_backBuf)
		_backBuf->free();
	delete _backBuf;
	free(_planarBuf);
	delete[] _pak98Buf;
	if (_scaleBuf)
		_scaleBuf->free();
	delete _scaleBuf;
	free(_zoneBuffers);

	if (_window4BackScn)
		_window4BackScn->free();
	delete _window4BackScn;
	if (_window6BackScn)
		_window6BackScn->free();
	delete _window6BackScn;

	delete _midi;

	free(_firstTimeStruct);
	free(_pendingDeleteTimeEvent);

	free(_variableArray);
	free(_variableArray2);

	delete _dummyItem1;
	delete _dummyItem2;
	delete _dummyItem3;

	delete _dummyWindow;
	delete[] _windowList;

	delete _sound;
	delete _gameFile;
}

void AGOSEngine::pauseEngineIntern(bool pauseIt) {
	if (pauseIt) {
		_keyPressed.reset();
		_action = kActionNone;
		_pause = true;

		_midi->pause(true);
		_mixer->pauseAll(true);
	} else {
		_pause = false;

		_midi->pause(false);
		_mixer->pauseAll(false);
	}
}

void AGOSEngine::pause() {
	PauseToken pt = pauseEngine();

	while (_pause && !shouldQuit()) {
		delay(1);
		if (_action == kActionPause) {
			pt.clear();
			_keyPressed.reset();
			_action = kActionNone;
		}
	}
}

Common::Error AGOSEngine::go() {
#ifdef ENABLE_AGOS2
	loadArchives();
#endif

	loadGamePcFile();

	addTimeEvent(0, 1);

	if (getFileName(GAME_GMEFILE) != nullptr) {
		openGameFile();
	}

	if (getGameType() == GType_FF) {
		loadIconData();
	} else if (getFileName(GAME_ICONFILE) != nullptr) {
		loadIconFile();
	}

	if (getFileName(GAME_MENUFILE) != nullptr) {
		loadMenuFile();
	}

	vc34_setMouseOff();

	if (getGameType() != GType_PP && getGameType() != GType_FF) {
		uint16 count = (getGameType() == GType_SIMON2) ? 5 : _frameCount;
		addVgaEvent(count, ANIMATE_INT, nullptr, 0, 0);
	}

	if (getGameType() == GType_ELVIRA1 && getPlatform() == Common::kPlatformAtariST &&
		(getFeatures() & GF_DEMO)) {
		setWindowImage(3, 9900);
		while (!shouldQuit())
			delay(0);
	}

	if (getGameType() == GType_ELVIRA1 && getPlatform() == Common::kPlatformAmiga &&
		(getFeatures() & GF_DEMO)) {
		playMusic(0, 0);
	}

	runSubroutine101();
	permitInput();

	while (!shouldQuit()) {
		waitForInput();
		handleVerbClicked(_verbHitArea);
		delay(100);
	}

	return Common::kNoError;
}


uint32 AGOSEngine::getTime() const {
	return _system->getMillis() / 1000;
}

void AGOSEngine::syncSoundSettings() {
	Engine::syncSoundSettings();

	int newMusicVolume = ConfMan.getInt("music_volume");
	int newEffectsVolume = ConfMan.getInt("sfx_volume");

	_musicMuted = newMusicVolume == 0;
	if (newMusicVolume != 0)
		_musicVolume = newMusicVolume;
	if (getGameType() == GType_SIMON2) {
		// Simon 2 has regular and ambient SFX, which can be toggled on and off
		// separately.
		if (newEffectsVolume == 0) {
			// Global SFX volume 0 mutes both regular and ambient SFX.
			_effectsMuted = _ambientMuted = true;
		} else {
			// If global SFX volume is > 0 and both regular and ambient SFX are
			// muted, unmute them. If only one of them is muted, the volume
			// change will only affect that type of SFX. If both are not muted,
			// it will affect both types.
			if (_effectsMuted && _ambientMuted)
				_effectsMuted = _ambientMuted = false;
			_effectsVolume = newEffectsVolume;
		}
		// Engine::syncSoundSettings applies SFX volume to all SFX handles,
		// so manage the regular and ambient handles separately here.
		_sound->effectsMute(_effectsMuted, _effectsVolume);
		_sound->ambientMute(_ambientMuted, _effectsVolume);
	} else {
		// Other games only have one SFX setting.
		_effectsMuted = newEffectsVolume == 0;
		if (newEffectsVolume != 0)
			_effectsVolume = newEffectsVolume;
	}
	_speech = !ConfMan.getBool("speech_mute");

	if (_midiEnabled)
		_midi->syncSoundSettings();
}

void AGOSEngine::syncSoundSettingsIntern() {
	ConfMan.setBool("speech_mute", !_speech);
	ConfMan.setInt("music_volume", _musicMuted ? 0 : _musicVolume);
	bool sfxMute = getGameType() == GType_SIMON2 ?
		_effectsMuted && _ambientMuted : _effectsMuted;
	ConfMan.setInt("sfx_volume", sfxMute ? 0 : _effectsVolume);

	Engine::syncSoundSettings();

	if (getGameType() == GType_SIMON2) {
		// Simon 2 has ambient sound effects, which can be toggled on and off
		// separately from the other SFX.
		// Engine::syncSoundSettings applies SFX volume to all SFX handles,
		// so manage the regular and ambient handles separately here.
		_sound->effectsMute(_effectsMuted, _effectsVolume);
		_sound->ambientMute(_ambientMuted, _effectsVolume);
	}

	if (_midiEnabled)
		_midi->syncSoundSettings();
}

} // End of namespace AGOS

================
File: agos.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_AGOS_H
#define AGOS_AGOS_H

#include "engines/engine.h"

#include "common/array.h"
#include "common/error.h"
#include "common/keyboard.h"
#include "common/random.h"
#include "common/rect.h"
#include "common/stack.h"
#include "common/util.h"
#include "audio/mixer.h"

#include "backends/keymapper/action.h"
#include "backends/keymapper/keymapper.h"

#include "agos/vga.h"
#include "agos/detection.h"

/**
 * This is the namespace of the AGOS engine.
 *
 * Status of this engine: ???
 *
 * Games using this engine:
 * - Elvira: Mistress of the Dark
 * - Elvira 2: The Jaws of Cerberus
 * - The Feeble Files
 * - Simon the Sorcerer
 * - Simon the Sorcerer 2
 * - Simon the Sorcerer Puzzle Pack
 */

namespace Common {
class File;
class SeekableReadStream;
}

namespace Graphics {
struct Surface;
class FontSJIS;
}

namespace Audio {
class SeekableAudioStream;
}

namespace AGOS {

enum {
	kDebugOpcode = 1,
	kDebugVGAOpcode,
	kDebugSubroutine,
	kDebugVGAScript,
	kDebugImageDump,
};

enum AGOSAction {
	kActionNone,
	kActionWalkForward,
	kActionTurnBack,
	kActionTurnLeft,
	kActionTurnRight,
	kActionMusicDown,
	kActionMusicUp,
	kActionExitCutscene,
	kActionToggleMusic,
	kActionToggleFastMode,
	kActionToggleSwitchCharacter,
	kActionToggleSubtitle,
	kActionToggleSpeech,
	kActionToggleHitboxName,
	kActionToggleSoundEffects,
	kActionToggleBackgroundSound,
	kActionShowObjects,
	kActionTextSpeedFast,
	kActionTextSpeedMedium,
	kActionTextSpeedSlow,
	kActionSpeed_GTYPEPP,
	kActionKeyYes,
	kActionKeyNo,
	kActionPause
};

uint fileReadItemID(Common::SeekableReadStream *in);

#define CHECK_BOUNDS(x, y) assert((uint)(x) < ARRAYSIZE(y))

#ifdef ENABLE_AGOS2
class MoviePlayer;
#endif

class Sound;
class MidiPlayer;

struct Child;
struct SubObject;
struct RoomState;
struct SubRoom;
struct SubSuperRoom;

struct Item;
struct WindowBlock;
struct Subroutine;
struct SubroutineLine;
struct TimeEvent;

struct TextLocation {
	int16 x, y, width;
	TextLocation() { memset(this, 0, sizeof(*this)); }
};

struct HitArea {
	uint16 x, y;
	uint16 width, height;
	uint16 flags;
	uint16 id;
	uint16 data;
	WindowBlock *window;
	Item *itemPtr;
	uint16 verb;
	uint16 priority;

	// Personal Nightmare specific
	uint16 msg1, msg2;
	HitArea() { memset(this, 0, sizeof(*this)); }
};

struct VgaPointersEntry {
	byte *vgaFile1;
	byte *vgaFile1End;
	byte *vgaFile2;
	byte *vgaFile2End;
	byte *sfxFile;
	byte *sfxFileEnd;
	VgaPointersEntry() { memset(this, 0, sizeof(*this)); }
};

struct VgaSprite {
	uint16 id;
	int16 image;
	uint16 palette;
	int16 x, y;
	uint16 flags;
	uint16 priority;
	uint16 windowNum;
	uint16 zoneNum;
	VgaSprite() { reset(); }

	void reset() {
		id = 0;
		image = 0;
		palette = 0;
		x = y = 0;
		flags = 0;
		priority = 0;
		windowNum = 0;
		zoneNum = 0;
	}
};

struct VgaSleepStruct {
	uint16 ident;
	const byte *codePtr;
	uint16 id;
	uint16 zoneNum;
	VgaSleepStruct() { memset(this, 0, sizeof(*this)); }
};

struct VgaTimerEntry {
	int16 delay;
	const byte *codePtr;
	uint16 id;
	uint16 zoneNum;
	uint8 type;
	VgaTimerEntry() { memset(this, 0, sizeof(*this)); }
};

struct AnimTable {
	const byte *srcPtr;
	int16 x;
	int16 y;
	uint16 width;
	uint16 height;
	uint16 windowNum;
	uint16 id;
	uint16 zoneNum;
	AnimTable() { memset(this, 0, sizeof(*this)); }
};

enum EventType {
	ANIMATE_INT   = 1 << 1,
	ANIMATE_EVENT = 1 << 2,
	SCROLL_EVENT  = 1 << 3,
	PLAYER_DAMAGE_EVENT = 1 << 4,
	MONSTER_DAMAGE_EVENT = 1 << 5
};

struct GameSpecificSettings;

class Debugger;

// This is to help devices with small memory (PDA, smartphones, ...)
// to save a bit of memory used by opcode names in the AGOS engine.

#ifndef REDUCE_MEMORY_USAGE
#	define _OPCODE(ver, x)	{ &ver::x, #x }
#else
#	define _OPCODE(ver, x)	{ &ver::x, "" }
#endif

class AGOSEngine : public Engine {
protected:
	// List of Simon 1 DOS floppy SFX which use rhythm notes.
	static const byte SIMON1_RHYTHM_SFX[];

	// Music index base for Simon 2 GM data.
	static const uint16 MUSIC_INDEX_BASE_SIMON2_GM = 1128 / 4;
	// Music index base for Simon 2 MT-32 data.
	static const uint16 MUSIC_INDEX_BASE_SIMON2_MT32 = (1128 + 612) / 4;

protected:
	friend class Debugger;

	// Engine APIs
	virtual Common::Error init();
	virtual Common::Error go();
	Common::Error run() override {
		Common::Error err;
		err = init();
		if (err.getCode() != Common::kNoError)
			return err;
		return go();
	}

	bool hasFeature(EngineFeature f) const override;
	void syncSoundSettings() override;
	// Applies AGOS engine internal sound settings to ConfigManager, digital
	// sound channels and MIDI.
	void syncSoundSettingsIntern();
	void pauseEngineIntern(bool pause) override;

	virtual void setupOpcodes();
	uint16 _numOpcodes, _opcode;

	typedef void (AGOSEngine::*VgaOpcodeProc) ();

	void setupVgaOpcodes();
	VgaOpcodeProc _vga_opcode_table[100];
	uint8 _numVideoOpcodes;

	virtual void setupVideoOpcodes(VgaOpcodeProc *op);

	const AGOSGameDescription * const _gameDescription;

public:
	virtual void setupGame();

	int getGameId() const;
	int getGameType() const;
	uint32 getFeatures() const;
	const char *getExtra() const;
	Common::Language getLanguage() const;
	Common::Platform getPlatform() const;
	const char *getFileName(int type) const;

protected:
	const byte *_vcPtr;								/* video code ptr */
	uint16 _vcGetOutOfCode;


	uint32 *_gameOffsetsPtr;

	uint8 _numMusic, _numSFX;
	uint16 _numSpeech;
	uint16 _numZone;

	uint8 _numBitArray1, _numBitArray2, _numBitArray3, _numItemStore;
	uint16 _numVars;

	uint8 _vgaBaseDelay, _vgaPeriod;

	uint16 _musicIndexBase;
	uint16 _soundIndexBase;
	uint16 _tableIndexBase;
	uint16 _textIndexBase;

	uint32 _itemMemSize;
	uint32 _tableMemSize;
	uint32 _vgaMemSize;

	const GameSpecificSettings *gss;

	AGOSAction _action;
	Common::JoystickState _joyaction;
	Common::KeyState _keyPressed;

	Common::File *_gameFile;

	byte *_strippedTxtMem;
	byte *_textMem;
	uint32 _textSize;
	uint32 _stringTabNum, _stringTabPos, _stringTabSize;
	byte **_stringTabPtr;

	Item **_itemArrayPtr;
	uint32 _itemArraySize;
	uint32 _itemArrayInited;

	Common::Array<byte *> _itemHeap;

	byte *_iconFilePtr;

	const byte *_codePtr;

	byte **_localStringtable;
	uint16 _stringIdLocalMin, _stringIdLocalMax;

	RoomState *_roomStates;
	uint16 _numRoomStates;

	byte *_menuBase;
	byte *_roomsList;
	byte *_roomsListPtr;

	byte *_xtblList;
	byte *_xtablesHeapPtrOrg;
	uint32 _xtablesHeapCurPosOrg;
	Subroutine *_xsubroutineListOrg;

	byte *_tblList;
	byte *_tablesHeapPtr, *_tablesHeapPtrOrg, *_tablesheapPtrNew;
	uint32 _tablesHeapSize, _tablesHeapCurPos, _tablesHeapCurPosOrg;
	uint32 _tablesHeapCurPosNew;
	Subroutine *_subroutineListOrg;

	Subroutine *_subroutineList;

	uint8 _recursionDepth;

	uint32 _lastVgaTick;

	uint16 _marks;
	bool _scanFlag;

	bool _scriptVar2;
	bool _runScriptReturn1;
	bool _runScriptCondition[40];
	int16 _runScriptReturn[40];
	bool _skipVgaWait;
	bool _noParentNotify;
	bool _beardLoaded;
	bool _litBoxFlag;
	bool _mortalFlag;
	uint16 _displayFlag;
	bool _syncFlag2;
	bool _inCallBack;
	bool _cepeFlag;
	bool _fastMode;
	bool _backFlag;

	Common::Language _language;
	bool _copyProtection;
	bool _pause;
	bool _speech;
	bool _subtitles;
	bool _vgaVar9;
	int16 _chanceModifier;
	bool _restoreWindow6;
	int16 _scrollX, _scrollXMax;
	int16 _scrollY, _scrollYMax;
	int16 _scrollCount, _scrollFlag;
	uint16 _scrollWidth, _scrollHeight;
	const byte *_scrollImage;
	byte _boxStarHeight;
	bool _forceAscii;

	SubroutineLine *_classLine;
	int16 _classMask, _classMode1, _classMode2;
	Item *_findNextPtr;
	Subroutine *_currentTable;
	SubroutineLine *_currentLine;

	uint8 _agosMenu;
	byte _textMenu[10];
	uint16 _currentRoom, _superRoomNumber;
	uint8 _wallOn;

	uint16 _hyperLink, _newLines;
	uint16 _oracleMaxScrollY, _noOracleScroll;
	uint16 _interactY;

	int16 _scriptVerb, _scriptNoun1, _scriptNoun2;
	int16 _scriptAdj1, _scriptAdj2;

	uint16 _curWindow;
	WindowBlock *_inputWindow, *_textWindow;

	Item *_subjectItem, *_objectItem;
	Item *_currentPlayer;

	Item *_hitAreaObjectItem;
	HitArea *_lastHitArea;
	HitArea *_lastNameOn;
	HitArea *_lastHitArea3;
	Item *_hitAreaSubjectItem;
	HitArea *_currentBox, *_currentVerbBox, *_lastVerbOn;
	uint16	_currentBoxNum;
	uint16 _needHitAreaRecalc;
	uint16 _verbHitArea;
	uint16 _defaultVerb;
	bool _iOverflow;
	bool _nameLocked;

	bool _dragAccept;
	bool _dragEnd;
	bool _dragFlag;
	bool _dragMode;
	uint8 _dragCount;
	HitArea *_lastClickRem;

	uint16 _windowNum;

	int16 _printCharCurPos, _printCharMaxPos, _printCharPixelCount;
	uint16 _numLettersToPrint;

	uint8 _numTextBoxes;

	uint32 getTime() const;

	uint32 _lastMinute; // Used in processSpecialKeys()
	uint32 _lastTime;
	uint32 _clockStopped, _gameStoppedClock;
	uint32 _timeStore;

	TimeEvent *_firstTimeStruct, *_pendingDeleteTimeEvent;

	bool _initMouse;
	Common::Point _mouse;
	Common::Point _mouseOld;

	byte *_mouseData;
	bool _animatePointer;
	byte _maxCursorWidth, _maxCursorHeight;
	byte _mouseAnim, _mouseAnimMax, _mouseCursor;
	byte _currentMouseAnim, _currentMouseCursor;
	byte _oldMouseAnimMax, _oldMouseCursor;
	uint16 _mouseHideCount;
	bool _mouseToggle;

	bool _leftButtonDown, _rightButtonDown;
	byte _leftButton, _leftButtonCount, _leftButtonOld;
	byte _oneClick;
	bool _clickOnly;
	bool _leftClick, _rightClick;
	bool _noRightClick;

	Item *_dummyItem1;
	Item *_dummyItem2;
	Item *_dummyItem3;

	volatile uint16 _videoLockOut;
	uint16 _scrollUpHitArea;
	uint16 _scrollDownHitArea;

	bool _fastFadeOutFlag;
	byte _paletteFlag;
	bool _bottomPalette;
	uint16 _fastFadeCount;
	volatile uint16 _fastFadeInFlag;
	bool _neverFade;

	uint16 _screenWidth, _screenHeight;
	uint16 _internalWidth, _internalHeight;

	uint16 _noOverWrite;
	bool _rejectBlock;

	bool _exitCutscene, _picture8600;

	uint16 _soundFileId;
	int16 _lastMusicPlayed;
	int16 _nextMusicToPlay;
	bool _showPreposition;
	bool _showMessageFlag;

	bool _newDirtyClip;
	bool _wiped;
	uint16 _copyScnFlag, _vgaSpriteChanged;

	byte *_block, *_blockEnd;
	byte *_vgaMemPtr, *_vgaMemEnd, *_vgaMemBase;
	byte *_vgaFrozenBase, *_vgaRealBase;
	byte *_zoneBuffers;

	byte *_curVgaFile1;
	byte *_curVgaFile2;

	uint16 _syncCount;

	uint16 _frameCount;

	uint16 _zoneNumber;
	uint16 _vgaWaitFor, _lastVgaWaitFor;
	uint16 _vgaCurSpriteId, _vgaCurZoneNum;

	int16 _baseY;
	float _scale;
	Common::Rect _feebleRect;
	int16 _scaleX, _scaleY, _scaleWidth, _scaleHeight;

	VgaTimerEntry *_nextVgaTimerToProcess;

	uint8 _opcode177Var1, _opcode177Var2;
	uint8 _opcode178Var1, _opcode178Var2;

	Item *_objectArray[50];
	Item *_itemStore[50];

	uint16 _shortText[40];
	uint16 _shortTextX[40];
	uint16 _shortTextY[40];
	uint16 _longText[40];
	uint16 _longSound[40];

	uint16 _bitArray[128];
	uint16 _bitArrayTwo[16];
	uint16 _bitArrayThree[16];
	int16 *_variableArray;
	int16 *_variableArray2;
	int16 *_variableArrayPtr;

	WindowBlock *_dummyWindow;
	WindowBlock *_windowArray[80];

	byte _fcsData1[8];
	bool _fcsData2[8];

	TextLocation _textLocation1, _textLocation2, _textLocation3, _textLocation4;

	byte _awaitTwoByteToken;
	byte *_byteTokens;
	byte *_byteTokenStrings;
	byte *_twoByteTokens;
	byte *_twoByteTokenStrings;
	byte *_secondTwoByteTokenStrings;
	byte *_thirdTwoByteTokenStrings;
	byte _textBuffer[180];
	int _textCount;

	int _freeStringSlot;

	byte _stringReturnBuffer[2][180];

	HitArea _hitAreas[250];
	HitArea *_hitAreaList;

	AnimTable _screenAnim1[90];
	VgaPointersEntry _vgaBufferPointers[450];
	VgaSprite _vgaSprites[200];
	VgaSleepStruct _onStopTable[60];
	VgaSleepStruct _waitEndTable[60];
	VgaSleepStruct _waitSyncTable[60];

	const uint16 *_pathFindArray[100];

	uint8 _pathValues[400];
	uint16 _PVCount;
	uint16 _GPVCount;

	uint8 _pathValues1[400];
	uint16 _PVCount1;
	uint16 _GPVCount1;

	uint8 _currentPalette[768];
	uint8 _displayPalette[768];

	byte *_planarBuf;
	byte _videoBuf1[32000];
	uint16 _videoWindows[128];
	const byte *_pak98Buf;
	byte _paletteModNext;

	uint8 _window3Flag;
	uint8 _window4Flag;
	uint8 _window6Flag;

	uint16 _moveXMin, _moveYMin;
	uint16 _moveXMax, _moveYMax;

	VgaTimerEntry _vgaTimerList[205];

	WindowBlock *_windowList;

	byte _lettersToPrintBuf[80];

	MidiPlayer *_midi;
	bool _midiEnabled;

	int _vgaTickCounter;

	Audio::SoundHandle _modHandle;
	Audio::SoundHandle _digitalMusicHandle;
	Audio::SeekableAudioStream *_digitalMusicStream = nullptr;

	Sound *_sound;

	bool _effectsMuted;
	bool _ambientMuted;
	bool _musicMuted;
	// The current music volume, or the last used music volume if music is
	// currently muted.
	uint16 _musicVolume;
	// The current SFX and ambient volume, or the last used volume if SFX
	// and/or ambient sounds are currently muted.
	uint16 _effectsVolume;
	bool _useDigitalSfx;

	uint8 _saveGameNameLen;
	uint16 _saveLoadRowCurPos;
	uint16 _numSaveGameRows;
	bool _saveDialogFlag;
	bool _saveOrLoad;
	bool _saveLoadEdit;

	byte _saveLoadType, _saveLoadSlot;
	char _saveLoadName[108];
	char _saveBuf[200];

	Graphics::Surface *_backGroundBuf;
	Graphics::Surface *_backBuf;
	Graphics::Surface *_scaleBuf;
	Graphics::Surface *_window4BackScn;
	Graphics::Surface *_window6BackScn;

	Common::RandomSource _rnd;

	const byte *_vc10BasePtrOld;
	byte _hebrewCharWidths[32];

public:
	AGOSEngine(OSystem *system, const AGOSGameDescription *gd);
	~AGOSEngine() override;

	byte *_curSfxFile;
	uint32 _curSfxFileSize;
	uint16 _sampleEnd, _sampleWait;

protected:
	virtual uint16 to16Wrapper(uint value);
	virtual uint16 readUint16Wrapper(const void *src);
	virtual uint32 readUint32Wrapper(const void *src);

#ifdef ENABLE_AGOS2
	void loadArchives();
#endif

	int allocGamePcVars(Common::SeekableReadStream *in);
	void createPlayer();
	void allocateStringTable(int num);
	void setupStringTable(byte *mem, int num);
	void setupLocalStringTable(byte *mem, int num);
	void readGamePcText(Common::SeekableReadStream *in);
	virtual void readItemChildren(Common::SeekableReadStream *in, Item *item, uint tmp);
	void readItemFromGamePc(Common::SeekableReadStream *in, Item *item);
	virtual void loadGamePcFile();
	void readGamePcFile(Common::SeekableReadStream *in);
	void decompressData(const char *srcName, byte *dst, uint32 offset, uint32 srcSize, uint32 dstSize);
	void decompressPN(Common::Stack<uint32> &dataList, uint8 *&dataOut, int &dataOutSize);
	void loadOffsets(const char *filename, int number, uint32 &file, uint32 &offset, uint32 &compressedSize, uint32 &size);
	void loadSound(uint16 sound, int16 pan, int16 vol, uint16 type);
	void playSfx(uint16 sound, uint16 freq, uint16 flags, bool digitalOnly = false, bool midiOnly = false);
	void loadSound(uint16 sound, uint16 freq, uint16 flags);
	void loadMidiSfx();
	virtual void playMidiSfx(uint16 sound);
	void loadVoice(uint speechId);
	void stopAllSfx();

	void loadSoundFile(const char *filename);

	int getUserFlag(Item *item, int a);
	int getUserFlag1(Item *item, int a);
	int getUserItem(Item *item, int n);
	void setUserFlag(Item *item, int a, int b);
	void setUserItem(Item *item, int n, int m);

	void paletteFadeOut(byte *palPtr, uint num, uint size);

	void *allocateItem(uint size);
	void *allocateTable(uint size);
	void alignTableMem();

	Child *findChildOfType(Item *i, uint child);
	Child *allocateChildBlock(Item *i, uint type, uint size);

	void allocItemHeap();
	void allocTablesHeap();

	Subroutine *createSubroutine(uint16 a);
	void readSubroutine(Common::SeekableReadStream *in, Subroutine *sub);
	SubroutineLine *createSubroutineLine(Subroutine *sub, int a);
	void readSubroutineLine(Common::SeekableReadStream *in, SubroutineLine *newTable, Subroutine *sub);
	byte *readSingleOpcode(Common::SeekableReadStream *in, byte *ptr);
	void readSubroutineBlock(Common::SeekableReadStream *in);

	Subroutine *getSubroutineByID(uint subroutineId);

	/* used in debugger */
	void dumpAllSubroutines();
	void dumpAllVgaImageFiles();
	void dumpAllVgaScriptFiles();
	void dumpSubroutines();
	void dumpSubroutine(Subroutine *sub);
	void dumpSubroutineLine(SubroutineLine *sl, Subroutine *sub);
	const byte *dumpOpcode(const byte *p);

	int startSubroutine(Subroutine *sub);
	int startSubroutineEx(Subroutine *sub);

	bool checkIfToRunSubroutineLine(SubroutineLine *sl, Subroutine *sub);

	int runScript();
	virtual void executeOpcode(int opcode) = 0;

	byte getByte();
	int getNextWord();

	uint getNextVarContents();
	uint getVarWrapper();
	uint getVarOrWord();
	uint getVarOrByte();
	uint readVariable(uint16 variable);
	void writeNextVarContents(uint16 contents);
	void writeVariable(uint16 variable, uint16 contents);

	Item *derefItem(uint item);
	Item *getNextItemPtr();
	uint getNextItemID();
	uint getItem1ID() {return 1;}
	uint itemPtrToID(Item *id);
	Item *me();
	Item *actor();

	void uncompressText(byte *ptr);
	byte *uncompressToken(byte a, byte *ptr);

	void showMessageFormat(MSVC_PRINTF const char *s, ...) GCC_PRINTF(2, 3);
	const byte *getStringPtrByID(uint16 stringId, bool upperCase = false);
	const byte *getLocalStringByID(uint16 stringId);
	uint getNextStringID();

	void addTimeEvent(int32 timeout, uint16 subroutineId);
	void delTimeEvent(TimeEvent *te);

	Item *findInByClass(Item *i, int16 m);
	Item *nextInByClass(Item *i, int16 m);
	Item *findMaster(int16 a, int16 n);
	Item *nextMaster(Item *item, int16 a, int16 n);
	int wordMatch(Item *item, int16 a, int16 n);

	bool isRoom(Item *item);
	bool isObject(Item *item);
	bool isPlayer(Item *item);

	void itemChildrenChanged(Item *item);
	void unlinkItem(Item *item);
	void linkItem(Item *item, Item *parent);

	void setItemParent(Item *item, Item *parent);
	void setItemState(Item *item, int value);

	void stopAnimate(uint16 a);
	void stopAnimateSimon2(uint16 a, uint16 b);

	void enableBox(uint hitarea);
	void disableBox(uint hitarea);
	void moveBox(uint hitarea, int x, int y);
	bool isBoxDead(uint hitarea);
	void undefineBox(uint hitarea);
	void defineBox(int id, int x, int y, int width, int height, int flags, int verb, Item *itemPtr);
	void defineBox(uint16 id, uint16 x, uint16 y, uint16 width, uint16 height, uint16 msg1, uint16 msg2, uint16 flags);

	HitArea *findEmptyHitArea();

	virtual void resetVerbs();
	virtual void setVerb(HitArea * ha);
	virtual void hitarea_leave(HitArea * ha, bool state = false);
	void leaveHitAreaById(uint hitarea_id);

	void sendSync(uint a);
	void waitForSync(uint a);

	uint getOffsetOfChild2Param(SubObject *child, uint prop);
	void scriptMouseOff();
	void freezeBottom();
	void unfreezeBottom();

	TextLocation *getTextLocation(uint a);

	uint setVerbText(HitArea *ha);
	void waitForInput();
	void setup_cond_c_helper();

	uint16 getBackExit(int n);
	uint16 getDoorState(Item *item, uint16 d);
	uint16 getExitOf(Item *item, uint16 d);
	void changeDoorState(SubRoom *r, uint16 d, uint16 n);
	void setDoorState(Item *i, uint16 d, uint16 n);

	// Elvira 1 specific
	Item *getDoorOf(Item *item, uint16 d);
	Item *getExitOf_e1(Item *item, uint16 d);
	virtual void moveDirn(Item *i, uint x);

	virtual int canPlace(Item *x, Item *y);
	int contains(Item *a, Item *b);
	int sizeContents(Item *x);
	virtual int sizeOfRec(Item *o, int d);
	int sizeRec(Item *x, int d);
	int weighUp(Item *x);
	int weightRec(Item *x, int d);
	virtual int weightOf(Item *x);
	void xPlace(Item *x, Item *y);

	void restoreMenu();
	void drawMenuStrip(uint windowNum, uint menuNum);
	void lightMenuStrip(int a);
	void unlightMenuStrip();
	void lightMenuBox(uint hitarea);

	uint menuFor_e2(Item *item);
	uint menuFor_ww(Item *item, uint id);
	void clearMenuStrip();
	void doMenuStrip(uint menuNum);

	void mouseOff();
	void mouseOn();

	bool loadRoomItems(uint16 item);

	virtual bool loadTablesIntoMem(uint16 subrId);
	bool loadXTablesIntoMem(uint16 subrId);
	void loadTextIntoMem(uint16 stringId);

	uint loadTextFile(const char *filename, byte *dst);
	Common::SeekableReadStream *openTablesFile(const char *filename);
	void closeTablesFile(Common::SeekableReadStream *in);

	uint loadTextFile_simon1(const char *filename, byte *dst);
	Common::SeekableReadStream *openTablesFile_simon1(const char *filename);
	Common::SeekableReadStream *openTablesFile_pak98(const char *filename);
	Common::SeekableReadStream *createPak98FileStream(const char *filename);
	void convertPC98Image(VC10_state &state);

	uint loadTextFile_gme(const char *filename, byte *dst);
	Common::SeekableReadStream *openTablesFile_gme(const char *filename);

	void invokeTimeEvent(TimeEvent *te);
	bool kickoffTimeEvents();
	void killAllTimers();

	void endCutscene();
	virtual void runSubroutine101();

	virtual void inventoryUp(WindowBlock *window);
	virtual void inventoryDown(WindowBlock *window);

	WindowBlock *openWindow(uint x, uint y, uint w, uint h, uint flags, uint fillColor, uint textColor);
	uint getWindowNum(WindowBlock *window);
	void clearWindow(WindowBlock *window);
	void changeWindow(uint a);
	void closeWindow(uint a);
	void setTextColor(uint color);
	virtual void windowPutChar(WindowBlock *window, byte c, byte b = 0);
	void waitWindow(WindowBlock *window);

	HitArea *findBox(uint hitarea_id);
	virtual void boxController(uint x, uint y, uint mode);
	void handleVerbClicked(uint verb);
	virtual void clearName();
	void displayName(HitArea * ha);
	void resetNameWindow();
	void displayBoxStars();
	void invertBox(HitArea * ha, byte a, byte b, byte c, byte d);

	virtual void handleMouseWheelUp();
	virtual void handleMouseWheelDown();

	virtual void initMouse();
	virtual void handleMouseMoved();
	virtual void drawMousePointer();

	void drawArrow(uint16 x, uint16 y, int8 dir);
	virtual void addArrows(WindowBlock *window, uint8 num);
	virtual void removeArrows(WindowBlock *window, uint num);

	virtual void drawIcon(WindowBlock *window, uint icon, uint x, uint y);
	virtual bool hasIcon(Item *item);
	virtual uint itemGetIconNumber(Item *item);
	virtual uint setupIconHitArea(WindowBlock *window, uint num, uint x, uint y, Item *itemPtr);

	virtual void drawIconArray(uint i, Item *itemPtr, int line, int classMask);
	void removeIconArray(uint num);

	void loadIconData();
	void loadIconFile();
	void loadMenuFile();

	virtual bool processSpecialKeys();
	void hitarea_stuff_helper();

	void permitInput();

	uint getFeebleFontSize(byte chr);
	void justifyStart();
	void justifyOutPut(byte chr);

	void loadZone(uint16 zoneNum, bool useError = true);

	void animate(uint16 windowNum, uint16 zoneNum, uint16 vgaSpriteId, int16 x, int16 y, uint16 palette, bool vgaScript = false);
	void setImage(uint16 vgaSpriteId, bool vgaScript = false);
	void setWindowImage(uint16 mode, uint16 vgaSpriteId, bool specialCase = false);
	virtual void setWindowImageEx(uint16 mode, uint16 vgaSpriteId);
	void drawEdging();

	void skipSpeech();

	const char *getPixelLength(const char *string, uint16 maxWidth, uint16 &pixels);
	bool printNameOf(Item *item, uint x, uint y);
	bool printTextOf(uint a, uint x, uint y);
	void printVerbOf(uint hitarea_id);
	void showActionString(const byte *string);

	virtual void printScreenText(uint vgaSpriteId, uint color, const char *stringPtr, int16 x, int16 y, int16 width);

	void renderStringAmiga(uint vgaSpriteId, uint color, uint width, uint height, const char *txt);
	void renderString(uint vgaSpriteId, uint color, uint width, uint height, const char *txt);

	void writeChar(WindowBlock *window, int x, int y, int offs, int val);

	byte *allocBlock(uint32 size);
	void checkNoOverWrite();
	void checkRunningAnims();
	void checkAnims(uint a);
	void checkZonePtrs();
	void setZoneBuffers();

	void runVgaScript();

public:
	bool getBitFlag(uint bit);
	void setBitFlag(uint bit, bool value);

	// Video Script Opcodes, Common
	void vc1_fadeOut();
	void vc2_call();
	virtual void vc3_loadSprite();
	void vc4_fadeIn();
	void vc5_ifEqual();
	void vc6_ifObjectHere();
	void vc7_ifObjectNotHere();
	void vc8_ifObjectIsAt();
	void vc9_ifObjectStateIs();
	void vc10_draw();
	void vc12_delay();
	void vc13_addToSpriteX();
	void vc14_addToSpriteY();
	void vc15_sync();
	void vc16_waitSync();
	void vc18_jump();
	void vc19_loop();
	void vc20_setRepeat();
	void vc21_endRepeat();
	virtual void vc22_setPalette();
	void vc23_setPriority();
	void vc24_setSpriteXY();
	void vc25_halt_sprite();
	void vc26_setSubWindow();
	void vc27_resetSprite();
	void vc28_playSFX();
	void vc29_stopAllSounds();
	void vc30_setFrameRate();
	void vc31_setWindow();
	void vc33_setMouseOn();
	void vc34_setMouseOff();
	void vc35_clearWindow();
	virtual void vc36_setWindowImage();
	void vc38_ifVarNotZero();
	void vc39_setVar();
	void vc40_scrollRight();
	void vc41_scrollLeft();
	void vc42_delayIfNotEQ();

	// Video Script Opcodes, Personal Nightmare
	void vc11_onStop();
	void vc36_pause();
	void vc39_volume();
	void vc44_enableBox();
	void vc45_disableBox();
	void vc46_maxBox();
	void vc48_specialEffect();
	void vc50_setBox();
	void vc55_scanFlag();

	// Video Script Opcodes, Elvira 1
	void vc17_waitEnd();
	void vc32_saveScreen();
	void vc37_pokePalette();

	// Video Script Opcodes, Elvira 2
	void vc43_ifBitSet();
	void vc44_ifBitClear();
	void vc45_setWindowPalette();
	void vc46_setPaletteSlot1();
	void vc47_setPaletteSlot2();
	void vc48_setPaletteSlot3();
	void vc49_setBit();
	void vc50_clearBit();
	void vc51_enableBox();
	void vc52_playSound();
	void vc53_dissolveIn();
	void vc54_dissolveOut();
	void vc55_moveBox();
	void vc56_fullScreen();
	void vc57_blackPalette();
	void vc58_checkCodeWheel();
	void vc58_changePriority();
	void vc59_ifEGA();

	// Video Script Opcodes, Waxworks
	void vc60_stopAnimation();
	void vc61();
	void vc62_fastFadeOut();
	virtual void vc63_fastFadeIn();

	// Video Script Opcodes, Simon 1
	void vc11_clearPathFinder();
	void vc17_setPathfinderItem();
	void vc32_copyVar();
	void vc37_addToSpriteY();
	void vc45_setSpriteX();
	void vc46_setSpriteY();
	void vc47_addToVar();
	virtual void vc48_setPathFinder();
	void vc59_ifSpeech();
	void vc61_setMaskImage();

	// Video Script Opcodes, Simon 2
	void vc56_delayLong();
	void vc59_stopAnimations();
	void vc64_ifSpeech();
	void vc65_slowFadeIn();
	void vc66_ifEqual();
	void vc67_ifLE();
	void vc68_ifGE();
	void vc69_playSeq();
	void vc70_joinSeq();
	void vc71_ifSeqWaiting();
	void vc72_segue();
	void vc73_setMark();
	void vc74_clearMark();

	// Video Script Opcodes, Feeble Files
	void vc75_setScale();
	void vc76_setScaleXOffs();
	void vc77_setScaleYOffs();
	void vc78_computeXY();
	void vc79_computePosNum();
	void vc80_setOverlayImage();
	void vc81_setRandom();
	void vc82_getPathValue();
	void vc83_playSoundLoop();
	void vc84_stopSoundLoop();

	void setScriptCondition(bool cond);
	bool getScriptCondition();
	void setScriptReturn(int ret);
	int getScriptReturn();

	// Opcodes, common
	void o_invalid();
	void o_at();
	void o_notAt();
	void o_carried();
	void o_notCarried();
	void o_isAt();
	void o_zero();
	void o_notZero();
	void o_eq();
	void o_notEq();
	void o_gt();
	void o_lt();
	void o_eqf();
	void o_notEqf();
	void o_ltf();
	void o_gtf();
	void o_chance();
	void o_isRoom();
	void o_isObject();
	void o_state();
	void o_oflag();
	void o_destroy();
	void o_place();
	void o_copyff();
	void o_clear();
	void o_let();
	void o_add();
	void o_sub();
	void o_addf();
	void o_subf();
	void o_mul();
	void o_div();
	void o_mulf();
	void o_divf();
	void o_mod();
	void o_modf();
	void o_random();
	void o_goto();
	void o_oset();
	void o_oclear();
	void o_putBy();
	void o_inc();
	void o_dec();
	void o_setState();
	void o_print();
	void o_message();
	void o_msg();
	void o_end();
	void o_done();
	void o_process();
	void o_when();
	void o_if1();
	void o_if2();
	void o_isCalled();
	void o_is();
	void o_debug();
	void o_comment();
	void o_haltAnimation();
	void o_restartAnimation();
	void o_getParent();
	void o_getNext();
	void o_getChildren();
	void o_picture();
	void o_loadZone();
	void o_killAnimate();
	void o_defWindow();
	void o_window();
	void o_cls();
	void o_closeWindow();
	void o_addBox();
	void o_delBox();
	void o_enableBox();
	void o_disableBox();
	void o_moveBox();
	void o_doIcons();
	void o_isClass();
	void o_setClass();
	void o_unsetClass();
	void o_waitSync();
	void o_sync();
	void o_defObj();
	void o_here();
	void o_doClassIcons();
	void o_playTune();
	void o_setAdjNoun();
	void o_saveUserGame();
	void o_loadUserGame();
	void o_copysf();
	void o_restoreIcons();
	void o_freezeZones();
	void o_placeNoIcons();
	void o_clearTimers();
	void o_setDollar();
	void o_isBox();

	int16 moreText(Item *i);
	void lobjFunc(Item *i, const char *f);
	uint confirmYesOrNo(uint16 x, uint16 y);
	uint continueOrQuit();
	void printScroll();
	virtual void printStats();
	void synchChain(Item *i);

protected:
	bool drawImage_clip(VC10_state *state);

	void drawImage_init(int16 image, uint16 palette, int16 x, int16 y, uint16 flags);

	virtual void drawImage(VC10_state *state);
	void drawBackGroundImage(VC10_state *state);
	void drawVertImage(VC10_state *state);
	void drawVertImageCompressed(VC10_state *state);
	void drawVertImageUncompressed(VC10_state *state);

	void setMoveRect(uint16 x, uint16 y, uint16 width, uint16 height);

	void horizontalScroll(VC10_state *state);
	void verticalScroll(VC10_state *state);

	Graphics::Surface *getBackendSurface() const;
	void updateBackendSurface(Common::Rect *area = 0) const;
	virtual void clearHiResTextLayer() {}

	int vcReadVarOrWord();
	uint vcReadNextWord(bool forceLERead = false);
	uint vcReadNextByte();
	uint vcReadVar(uint var);
	void vcWriteVar(uint var, int16 value);
	void vcSkipNextInstruction();

	int getScale(int16 y, int16 x);
	void checkScrollX(int16 x, int16 xpos);
	void checkScrollY(int16 y, int16 ypos);
	void centerScroll();

	virtual void clearVideoWindow(uint16 windowNum, uint16 color);
	void clearVideoBackGround(uint16 windowNum, uint16 color);

	void setPaletteSlot(uint16 srcOffs, uint8 dstOffs);
	void checkOnStopTable();
	void checkWaitEndTable();

	virtual bool ifObjectHere(uint16 val);
	virtual bool ifObjectAt(uint16 a, uint16 b);
	virtual bool ifObjectState(uint16 a, int16 b);

	bool isVgaQueueEmpty();
	void haltAnimation();
	void restartAnimation();
	void addVgaEvent(uint16 num, uint8 type, const byte *codePtr, uint16 curSprite, uint16 curZoneNum);
	void deleteVgaEvent(VgaTimerEntry * vte);
	void processVgaEvents();
	void animateEvent(const byte *codePtr, uint16 curZoneNum, uint16 curSprite);
	void scrollEvent();
	void drawStuff(const byte *src, uint offs);
	void playerDamageEvent(VgaTimerEntry * vte, uint dx);
	void monsterDamageEvent(VgaTimerEntry * vte, uint dx);

	VgaSprite *findCurSprite();

	bool isSpriteLoaded(uint16 id, uint16 zoneNum);

	void resetWindow(WindowBlock *window);
	void freeBox(uint index);

	void sendWindow(uint a);

	virtual void colorWindow(WindowBlock *window);
	void colorBlock(WindowBlock *window, uint16 x, uint16 y, uint16 w, uint16 h);

	void restoreWindow(WindowBlock *window);
	void restoreBlock(uint16 left, uint16 top, uint16 right, uint16 bottom);

	byte *getBackBuf();
	byte *getBackGround();
	byte *getScaleBuf();

	byte *convertAmigaImage(VC10_state *state, bool compressed);

	bool decrunchFile(byte *src, byte *dst, uint32 size);
	void loadVGABeardFile(uint16 id);
	void loadVGAVideoFile(uint16 id, uint8 type, bool useError = true);
	bool loadVGASoundFile(uint16 id, uint8 type);

	void openGameFile();
	void readGameFile(void *dst, uint32 offs, uint32 size);

	virtual void timerProc();

	virtual void animateSprites();

	void dirtyClips();
	void dirtyClipCheck(int16 x, int16 y, int16 w, int16 h);
	void dirtyBackGround();
	void restoreBackGround();
	void saveBackGround(VgaSprite *vsp);

	void clearSurfaces();
	void displayScreen();

	void dumpVideoScript(const byte *src, bool singeOpcode);
	virtual void dumpVgaFile(const byte *vga);
	void dumpVgaScript(const byte *ptr, uint16 res, uint16 id);
	void dumpVgaScriptAlways(const byte *ptr, uint16 res, uint16 id);

	void dumpVgaBitmaps(uint16 zoneNum);

	void dumpSingleBitmap(int file, int image, const byte *offs, int w, int h, byte base);
	void dumpBitmap(const char *filename, const byte *offs, uint16 w, uint16 h, int flags, const byte *palette, byte base);
	void palLoad(byte *pal, const byte *vga1, int a, int b);

	void fillBackFromBackGround(uint16 height, uint16 width);
	void fillBackFromFront();
	void fillBackGroundFromBack();
	void fillBackGroundFromFront();

	virtual void doOutput(const byte *src, uint len);
	void clsCheck(WindowBlock *window);

	virtual void quickLoadOrSave();

	byte *vc10_uncompressFlip(const byte *src, uint16 w, uint16 h);
	byte *vc10_flip(const byte *src, uint16 w, uint16 h);

	Item *getNextItemPtrStrange();

	virtual bool loadGame(const Common::String &filename, bool restartMode = false);
	virtual bool saveGame(uint slot, const char *caption);

	void openTextWindow();
	void tidyIconArray(uint i);

	virtual void windowNewLine(WindowBlock *window);
	void windowScroll(WindowBlock *window);
	virtual void windowDrawChar(WindowBlock *window, uint x, uint y, byte chr);

	// Loads the MIDI data for the specified track. The forceSimon2GmData
	// parameter forces loading the MIDI data from the GM data set.
	// The useSimon2Remapping parameter activates GM to MT-32 instrument
	// remapping. These parameters are useful only for a specific
	// workaround (see AGOSEngine_Simon2::playMusic for more details).
	void loadMusic(uint16 track, bool forceSimon2GmData = false, bool useSimon2Remapping = false);
	void playModule(uint16 music);
	virtual void playMusic(uint16 music, uint16 track);
	void stopMusic();

	void delay(uint delay);
	void pause();

	void waitForMark(uint i);
	void scrollScreen();

	void decodeColumn(byte *dst, const byte *src, uint16 height, uint16 pitch);
	void decodeRow(byte *dst, const byte *src, uint16 width, uint16 pitch);
	void hitarea_stuff_helper_2();
	void fastFadeIn();
	void slowFadeIn();
	void fullFade();

	virtual void vcStopAnimation(uint16 zone, uint16 sprite);

	virtual bool confirmOverWrite(WindowBlock *window);
	int16 matchSaveGame(const char *name, uint16 max);
	void disableFileBoxes();
	virtual void userGame(bool load);
	void userGameBackSpace(WindowBlock *window, int x, byte b = 0);
	void fileError(WindowBlock *window, bool saveError);

	int countSaveGames();

	virtual Common::String genSaveName(int slot) const;
};

class AGOSEngine_PN : public AGOSEngine {

	Common::Error go() override;
	void demoSeq();
	void introSeq();
	void setupBoxes();
	int readfromline();
public:
	AGOSEngine_PN(OSystem *system, const AGOSGameDescription *gd);
	~AGOSEngine_PN() override;

	void setupGame() override;
	void setupOpcodes() override;
	void setupVideoOpcodes(VgaOpcodeProc *op) override;

	void executeOpcode(int opcode) override;

	int actCallD(int n);

	void opn_opcode00();
	void opn_add();
	void opn_sub();
	void opn_mul();
	void opn_div();
	void opn_opcode05();
	void opn_opcode06();
	void opn_opcode07();
	void opn_opcode08();
	void opn_opcode09();
	void opn_opcode10();
	void opn_opcode11();
	void opn_opcode12();
	void opn_opcode13();
	void opn_opcode14();
	void opn_opcode15();
	void opn_opcode16();
	void opn_lt();
	void opn_gt();
	void opn_eq();
	void opn_neq();
	void opn_opcode21();
	void opn_opcode22();
	void opn_opcode23();
	void opn_opcode24();
	void opn_opcode25();
	void opn_opcode26();
	void opn_opcode27();
	void opn_opcode28();
	void opn_opcode29();
	void opn_opcode30();
	void opn_opcode31();
	void opn_opcode32();
	void opn_opcode33();
	void opn_opcode34();
	void opn_opcode35();
	void opn_opcode36();
	void opn_opcode37();
	void opn_opcode38();
	void opn_opcode39();
	void opn_opcode40();
	void opn_opcode41();
	void opn_opcode42();
	void opn_opcode43();
	void opn_opcode44();
	void opn_opcode45();
	void opn_opcode46();
	void opn_opcode47();
	void opn_opcode48();
	void opn_opcode49();
	void opn_opcode50();
	void opn_opcode51();
	void opn_opcode52();
	void opn_opcode53();
	void opn_opcode54();
	void opn_opcode55();
	void opn_opcode56();
	void opn_opcode57();
	void opn_opcode62();
	void opn_opcode63();

protected:
	struct StackFrame {
		StackFrame *nextframe;
		int16 flag[6];
		int16 param[8];
		int16 classnum;
		uint8 *linpos;
		uint8 *lbase;
		int16 ll;
		int16 linenum;
		int16 process;
		int tagOfParentDoline;	///< tag of the doline "instance" to which this StackFrame belongs
		StackFrame() { memset(this, 0, sizeof(*this)); }
	};


	StackFrame *_stackbase;

	int _tagOfActiveDoline;	///< tag of the active doline "instance"
	int _dolineReturnVal;

	byte *_dataBase, *_textBase;
	uint32 _dataBaseSize, _textBaseSize;

	HitArea _invHitAreas[45];

	char _buffer[80];
	char _inputline[61];
	char _saveFile[20];
	char _sb[80];
	uint8 _wordcp[7];

	const char *_mouseString, *_mouseString1;
	char _objectName1[15], _objectName2[15];
	char _inMessage[20];
	char _placeMessage[15];
	bool _inputReady;
	bool _inputting;
	uint16 _intputCounter, _inputMax;
	uint16 _mousePrintFG;
	HitArea *_dragStore;
	uint8 _hitCalled;

	uint32 _quickptr[16];
	uint16 _quickshort[12];

	bool _noScanFlag;
	char _keyboardBuffer[61];

	uint16 _objects;
	int16 _objectCountS;

	int16 _bp;
	int16 _xofs;
	int16 _havinit;
	uint16 _seed;

	char *_curwrdptr;
	char *_inpp;
	int _fnst;
	int _procnum;
	int _linct;
	int _linembr;
	uint8 *_linebase;
	uint8 *_workptr;

	bool _keymapEnabled;

	uint16 getptr(uint32 pos);
	uint32 getlong(uint32 pos);

	void loadGamePcFile() override;

	int bitextract(uint32 ptr, int offs);
	int doaction();
	int doline(int needsave);
	int setposition(int process, int line);
	int varval();

	char *getMessage(char *msg, uint16 num);
	void getResponse(uint16 charNum, uint16 objNum, uint16 &msgNum1, uint16 &msgNum2);
	void getObjectName(char *v, uint16 x);

	void processor();
	void setbitf(uint32 ptr, int offs, int val);
	void setqptrs();
	void writeval(uint8 *ptr, int val);

	void addstack(int type);
	void dumpstack();
	void popstack(int type);
	void funccpy(int *store);
	void funcentry(int *storestore, int procn);

	int findentry();
	int findset();
	int gvwrd(uint8 *wptr, int mask);
	int wrdmatch(uint8 *word1, int mask1, uint8 *word2, int mask2);

	bool testContainer(uint16 a);
	bool testObvious(uint16 a);
	bool testSeen(uint16 a);

	bool ifObjectInInv(uint16 a);
	int inventoryOn(int val);
	int inventoryOff();
	void mouseHit();
	void execMouseHit(HitArea *ha);
	void hitBox1(HitArea *ha);
	void hitBox2(HitArea *ha);
	void hitBox3(HitArea *ha);
	void hitBox4(HitArea *ha);
	void hitBox5(HitArea *ha);
	void hitBox6(HitArea *ha);
	void hitBox7(HitArea *ha);
	void hitBox8(HitArea *ha);
	void hitBox9(HitArea *ha);
	void hitBox11(HitArea *ha);

	void drawIconHitBar();
	void iconPage();
	void printIcon(HitArea *ha, uint8 i, uint8 r);
	void windowPutChar(WindowBlock *window, byte c, byte b = 0) override;

	bool badload(int8 errorNum);
	int loadFile(const Common::String &name);
	int saveFile(const Common::String &name);
	void getFilename();
	void sysftodb();
	void dbtosysf();

	uint32 ftext(uint32 base, int n);
	char *unctok(char *c, int n);
	void uncomstr(char *c, uint32 x);
	void patok(int n);
	void pcf(uint8 ch);
	void pcl(const char *s);
	void pmesd(int n);
	void plocd(int n, int m);
	void pobjd(int n, int m);
	void ptext(uint32 tptr);

	void clearVideoWindow(uint16 windowNum, uint16 color) override;
	void setWindowImageEx(uint16 mode, uint16 vga_res) override;

	bool ifObjectHere(uint16 val) override;
	bool ifObjectAt(uint16 a, uint16 b) override;
	bool ifObjectState(uint16 a, int16 b) override;

	void boxController(uint x, uint y, uint mode) override;
	void timerProc() override;

	void addChar(uint8 chr);
	void clearCursor(WindowBlock *window);
	void clearInputLine();
	void handleKeyboard();
	void handleMouseMoved() override;
	void interact(char *buffer, uint8 size);

	bool processSpecialKeys() override;
protected:
	typedef void (AGOSEngine_PN::*OpcodeProcPN) ();
	struct OpcodeEntryPN {
		OpcodeProcPN proc;
		const char *desc;
	};

	const OpcodeEntryPN *_opcodesPN;
};

class AGOSEngine_Elvira1 : public AGOSEngine {
public:
	AGOSEngine_Elvira1(OSystem *system, const AGOSGameDescription *gd);
	~AGOSEngine_Elvira1() override;
	Common::Error init() override;

	void setupGame() override;
	void setupOpcodes() override;
	void setupVideoOpcodes(VgaOpcodeProc *op) override;

	void executeOpcode(int opcode) override;

	void oe1_present();
	void oe1_notPresent();
	void oe1_worn();
	void oe1_notWorn();
	void oe1_notCarried();
	void oe1_isNotAt();
	void oe1_sibling();
	void oe1_notSibling();
	void oe1_isIn();
	void oe1_isNotIn();
	void oe1_isPlayer();
	void oe1_canPut();
	void oe1_create();
	void oe1_copyof();
	void oe1_copyfo();
	void oe1_whatO();
	void oe1_weigh();
	void oe1_setFF();
	void oe1_moveDirn();
	void oe1_score();
	void oe1_look();
	void oe1_doClass();
	void oe1_pObj();
	void oe1_pName();
	void oe1_pcName();
	void oe1_isCalled();
	void oe1_cFlag();
	void oe1_rescan();
	void oe1_setUserItem();
	void oe1_getUserItem();
	void oe1_whereTo();
	void oe1_doorExit();
	void oe1_loadGame();
	void oe1_clearUserItem();
	void oe1_findMaster();
	void oe1_nextMaster();
	void oe1_animate();
	void oe1_stopAnimate();
	void oe1_menu();
	void oe1_addBox();
	void oe1_enableInput();
	void oe1_setTime();
	void oe1_ifTime();
	void oe1_playTune();
	void oe1_bitClear();
	void oe1_bitSet();
	void oe1_bitTest();
	void oe1_zoneDisk();
	void oe1_printStats();
	void oe1_stopTune();
	void oe1_printPlayerDamage();
	void oe1_printMonsterDamage();
	void oe1_pauseGame();
	void oe1_printPlayerHit();
	void oe1_printMonsterHit();

protected:
	typedef void (AGOSEngine_Elvira1::*OpcodeProcElvira1) ();
	struct OpcodeEntryElvira1 {
		OpcodeProcElvira1 proc;
		const char *desc;
	};

	const OpcodeEntryElvira1 *_opcodesElvira1;

	void drawIcon(WindowBlock *window, uint icon, uint x, uint y) override;
	void windowDrawChar(WindowBlock *window, uint x, uint y, byte chr) override;
	void addHiResTextDirtyRect(Common::Rect rect);
	void clearHiResTextLayer() override;

	Common::String genSaveName(int slot) const override;

	Graphics::FontSJIS *_sjisFont;
	Common::Array<Common::Rect> _sjisTextFields;
	uint16 _sjisCurChar;
};

class AGOSEngine_Elvira2 : public AGOSEngine_Elvira1 {
public:
	AGOSEngine_Elvira2(OSystem *system, const AGOSGameDescription *gd);
	//~AGOSEngine_Elvira2();

	void setupGame() override;
	void setupOpcodes() override;
	void setupVideoOpcodes(VgaOpcodeProc *op) override;

	void executeOpcode(int opcode) override;

	void oe2_moveDirn();
	void oe2_doClass();
	void oe2_pObj();
	void oe2_isCalled();
	void oe2_menu();
	void oe2_drawItem();
	void oe2_doTable();
	void oe2_pauseGame();
	void oe2_setDoorOpen();
	void oe2_setDoorClosed();
	void oe2_setDoorLocked();
	void oe2_ifDoorOpen();
	void oe2_ifDoorClosed();
	void oe2_ifDoorLocked();
	void oe2_storeItem();
	void oe2_getItem();
	void oe2_bSet();
	void oe2_bClear();
	void oe2_bZero();
	void oe2_bNotZero();
	void oe2_getOValue();
	void oe2_setOValue();
	void oe2_ink();
	void oe2_printStats();
	void oe2_setSuperRoom();
	void oe2_getSuperRoom();
	void oe2_setExitOpen();
	void oe2_setExitClosed();
	void oe2_setExitLocked();
	void oe2_ifExitOpen();
	void oe2_ifExitClosed();
	void oe2_ifExitLocked();
	void oe2_playEffect();
	void oe2_getDollar2();
	void oe2_setSRExit();
	void oe2_printPlayerDamage();
	void oe2_printMonsterDamage();
	void oe2_isAdjNoun();
	void oe2_b2Set();
	void oe2_b2Clear();
	void oe2_b2Zero();
	void oe2_b2NotZero();

	void printStats() override;
protected:
	typedef void (AGOSEngine_Elvira2::*OpcodeProcElvira2) ();
	struct OpcodeEntryElvira2 {
		OpcodeProcElvira2 proc;
		const char *desc;
	};

	const OpcodeEntryElvira2 *_opcodesElvira2;

	void readItemChildren(Common::SeekableReadStream *in, Item *item, uint tmp) override;

	bool loadGame(const Common::String &filename, bool restartMode = false) override;
	bool saveGame(uint slot, const char *caption) override;

	void addArrows(WindowBlock *window, uint8 num) override;
	void removeArrows(WindowBlock *window, uint num) override;

	void drawIcon(WindowBlock *window, uint icon, uint x, uint y) override;
	bool hasIcon(Item *item) override;
	uint itemGetIconNumber(Item *item) override;
	uint setupIconHitArea(WindowBlock *window, uint num, uint x, uint y, Item *itemPtr) override;

	void moveDirn(Item *i, uint x) override;
	int canPlace(Item *x, Item *y) override;
	int sizeOfRec(Item *o, int d) override;
	int weightOf(Item *x) override;

	int changeExitStates(SubSuperRoom *sr, int n, int d, uint16 s);
	uint16 getExitState(Item *item, uint16 x, uint16 d);
	void setExitState(Item *i, uint16 n, uint16 d, uint16 s);
	void setSRExit(Item *i, int n, int d, uint16 s);

	void handleMouseWheelUp() override;
	void handleMouseWheelDown() override;

	virtual void listSaveGames();
	bool confirmOverWrite(WindowBlock *window) override;
	void userGame(bool load) override;
	virtual int userGameGetKey(bool *b, uint maxChar);

	Common::String genSaveName(int slot) const override;
};

class AGOSEngine_Waxworks : public AGOSEngine_Elvira2 {
public:
	AGOSEngine_Waxworks(OSystem *system, const AGOSGameDescription *gd);
	//~AGOSEngine_Waxworks();

	void setupGame() override;
	void setupOpcodes() override;
	void setupVideoOpcodes(VgaOpcodeProc *op) override;

	void executeOpcode(int opcode) override;

	void boxTextMessage(const char *x);
	void boxTextMsg(const char *x);
	void printBox();
	uint16 getBoxSize();
	uint16 checkFit(char *Ptr, int width, int lines);

	void oww_goto();
	void oww_addTextBox();
	void oww_setShortText();
	void oww_setLongText();
	void oww_printLongText();
	void oww_whereTo();
	void oww_textMenu();
	void oww_pauseGame();
	void oww_boxMessage();
	void oww_boxMsg();
	void oww_boxLongText();
	void oww_printBox();
	void oww_boxPObj();
	void oww_lockZones();
	void oww_unlockZones();
	void startSubroutineByVerb(uint16 verb);

protected:
	typedef void (AGOSEngine_Waxworks::*OpcodeProcWaxworks) ();
	struct OpcodeEntryWaxworks {
		OpcodeProcWaxworks proc;
		const char *desc;
	};

	const OpcodeEntryWaxworks *_opcodesWaxworks;

	bool _boxCR;
	char _boxBuffer[310];
	char *_boxBufferPtr;
	int _boxLineCount;
	int _lineCounts[6];
	char *_linePtrs[6];

	void drawIcon(WindowBlock *window, uint icon, uint x, uint y) override;

	void boxController(uint x, uint y, uint mode) override;

	void addArrows(WindowBlock *window, uint8 num) override;
	void removeArrows(WindowBlock *window, uint num) override;

	uint setupIconHitArea(WindowBlock *window, uint num, uint x, uint y, Item *itemPtr) override;

	bool loadTablesIntoMem(uint16 subrId) override;

	void moveDirn(Item *i, uint x) override;

	bool confirmOverWrite(WindowBlock *window) override;

	Common::String genSaveName(int slot) const override;
};

class AGOSEngine_Simon1 : public AGOSEngine_Waxworks {
private:
	// Simon 1 DOS CD and Acorn CD GMF data sizes.
	static const int SIMON1_GMF_SIZE[];

public:
	AGOSEngine_Simon1(OSystem *system, const AGOSGameDescription *gd);
	//~AGOSEngine_Simon1();

	void setupGame() override;
	void setupOpcodes() override;
	void setupVideoOpcodes(VgaOpcodeProc *op) override;

	void executeOpcode(int opcode) override;

	void vc22_setPalette() override;

	// Opcodes, Simon 1
	void os1_animate();
	void os1_pauseGame();
	void os1_screenTextBox();
	void os1_screenTextMsg();
	void os1_playEffect();
	void os1_screenTextPObj();
	void os1_getPathPosn();
	void os1_scnTxtLongText();
	void os1_mouseOn();
	void os1_mouseOff();
	void os1_loadBeard();
	void os1_unloadBeard();
	void os1_unloadZone();
	void os1_loadStrings();
	void os1_unfreezeZones();
	void os1_specialFade();

protected:
	typedef void (AGOSEngine_Simon1::*OpcodeProcSimon1) ();
	struct OpcodeEntrySimon1 {
		OpcodeProcSimon1 proc;
		const char *desc;
	};

	const OpcodeEntrySimon1 *_opcodesSimon1;

	void drawImage(VC10_state *state) override;
	void drawMaskedImage(VC10_state *state);
	void draw32ColorImage(VC10_state *state);

	void dumpVgaFile(const byte *vga) override;

	void clearName() override;

	void handleMouseWheelUp() override;
	void handleMouseWheelDown() override;

	void drawIcon(WindowBlock *window, uint icon, uint x, uint y) override;

	void initMouse() override;
	void handleMouseMoved() override;

	void addArrows(WindowBlock *window, uint8 num) override;
	void removeArrows(WindowBlock *window, uint num) override;

	uint setupIconHitArea(WindowBlock *window, uint num, uint x, uint y, Item *itemPtr) override;

	virtual void playSpeech(uint16 speechId, uint16 vgaSpriteId);

	void listSaveGames() override;
	void userGame(bool load) override;
	int userGameGetKey(bool *b, uint maxChar) override;

	void playMusic(uint16 music, uint16 track) override;
	void playMidiSfx(uint16 sound) override;

	void vcStopAnimation(uint16 zone, uint16 sprite) override;

	Common::String genSaveName(int slot) const override;
};

class AGOSEngine_Simon2 : public AGOSEngine_Simon1 {
public:
	AGOSEngine_Simon2(OSystem *system, const AGOSGameDescription *gd);
	//~AGOSEngine_Simon2();

	void setupGame() override;
	void setupOpcodes() override;
	void setupVideoOpcodes(VgaOpcodeProc *op) override;

	void executeOpcode(int opcode) override;

	void os2_printLongText();
	void os2_rescan();
	void os2_animate();
	void os2_stopAnimate();
	void os2_playTune();
	void os2_screenTextPObj();
	void os2_mouseOn();
	void os2_mouseOff();
	void os2_isShortText();
	void os2_clearMarks();
	void os2_waitMark();

protected:
	typedef void (AGOSEngine_Simon2::*OpcodeProcSimon2) ();
	struct OpcodeEntrySimon2 {
		OpcodeProcSimon2 proc;
		const char *desc;
	};

	const OpcodeEntrySimon2 *_opcodesSimon2;

	void clearName() override;

	void drawIcon(WindowBlock *window, uint icon, uint x, uint y) override;

	void addArrows(WindowBlock *window, uint8 num) override;
	uint setupIconHitArea(WindowBlock *window, uint num, uint x, uint y, Item *itemPtr) override;

	void clearVideoWindow(uint16 windowNum, uint16 color) override;

	void playSpeech(uint16 speechId, uint16 vgaSpriteId) override;
	// This overload plays the music track specified in the second parameter.
	// The first parameter is ignored; music data must be loaded using the
	// loadMusic method before calling this method.
	void playMusic(uint16 music, uint16 track) override;

	Common::String genSaveName(int slot) const override;
};

#ifdef ENABLE_AGOS2
class AGOSEngine_Feeble : public AGOSEngine_Simon2 {
public:
	AGOSEngine_Feeble(OSystem *system, const AGOSGameDescription *gd);
	~AGOSEngine_Feeble() override;

	void setupGame() override;
	void setupOpcodes() override;
	void setupVideoOpcodes(VgaOpcodeProc *op) override;

	void executeOpcode(int opcode) override;

	void vc36_setWindowImage() override;
	void vc48_setPathFinder() override;

	void off_chance();
	void off_jumpOut();
	void off_addTextBox();
	void off_printLongText();
	void off_addBox();
	void off_oracleTextDown();
	void off_oracleTextUp();
	void off_ifTime();
	void off_setTime();
	void off_saveUserGame();
	void off_loadUserGame();
	void off_listSaveGames();
	void off_checkCD();
	void off_screenTextBox();
	void off_b2Set();
	void off_isAdjNoun();
	void off_hyperLinkOn();
	void off_hyperLinkOff();
	void off_checkPaths();
	void off_screenTextPObj();
	void off_mouseOn();
	void off_mouseOff();
	void off_loadVideo();
	void off_playVideo();
	void off_centerScroll();
	void off_resetPVCount();
	void off_setPathValues();
	void off_stopClock();
	void off_restartClock();
	void off_setColor();
	void off_b3Set();
	void off_b3Clear();
	void off_b3Zero();
	void off_b3NotZero();

protected:
	friend class MoviePlayer;
	friend class MoviePlayerDXA;
	friend class MoviePlayerSMK;

	typedef void (AGOSEngine_Feeble::*OpcodeProcFeeble) ();
	struct OpcodeEntryFeeble {
		OpcodeProcFeeble proc;
		const char *desc;
	};

	const OpcodeEntryFeeble *_opcodesFeeble;

	MoviePlayer *_moviePlayer;

	uint8 _interactiveVideo;
	uint16 _vgaCurSpritePriority;

	uint16 to16Wrapper(uint value) override;
	uint16 readUint16Wrapper(const void *src) override;
	uint32 readUint32Wrapper(const void *src) override;

	void setLoyaltyRating(byte rating);

	void playVideo(const char *filename, bool lastSceneUsed = false);
	void stopInteractiveVideo();

	void drawImage(VC10_state *state) override;
	void scaleClip(int16 h, int16 w, int16 y, int16 x, int16 scrollY);

	void handleMouseWheelUp() override;
	void handleMouseWheelDown() override;

	void drawMousePart(int image, byte x, byte y);
	void initMouse() override;
	void drawMousePointer() override;

	void animateSprites() override;
	void animateSpritesByY();

	void oracleLogo();
	void swapCharacterLogo();
	void timerProc() override;

	void addArrows(WindowBlock *window, uint8 num) override;
	uint setupIconHitArea(WindowBlock *window, uint num, uint x, uint y, Item *itemPtr) override;

	void resetVerbs() override;
	void setVerb(HitArea * ha) override;
	void hitarea_leave(HitArea * ha, bool state = false) override;
	void invertBox(HitArea *ha, bool state);

	void windowNewLine(WindowBlock *window) override;
	void windowDrawChar(WindowBlock *window, uint x, uint y, byte chr) override;

	void clearName() override;

	void drawIconArray(uint i, Item *itemPtr, int line, int classMask) override;

	void colorWindow(WindowBlock *window) override;

	void dumpVgaFile(const byte *vga) override;

	void doOutput(const byte *src, uint len) override;

	void printScreenText(uint vgaSpriteId, uint color, const char *stringPtr, int16 x, int16 y, int16 width) override;

	void printInteractText(uint16 num, const char *string);
	void sendInteractText(uint16 num, MSVC_PRINTF const char *fmt, ...) GCC_PRINTF(3, 4);

	void checkLinkBox();
	void hyperLinkOn(uint16 x);
	void hyperLinkOff();
	void linksUp();
	void linksDown();

	void runSubroutine101() override;

	void checkUp(WindowBlock *window);
	void checkDown(WindowBlock *window);
	void inventoryUp(WindowBlock *window) override;
	void inventoryDown(WindowBlock *window) override;

	void oracleTextUp();
	void oracleTextDown();
	void scrollOracle();
	void scrollOracleUp();
	void scrollOracleDown();

	void listSaveGamesFeeble();
	void saveUserGame(int slot);
	void windowBackSpace(WindowBlock *window);

	Common::String genSaveName(int slot) const override;
	void quickLoadOrSave() override;
};

class AGOSEngine_FeebleDemo : public AGOSEngine_Feeble {
public:
	AGOSEngine_FeebleDemo(OSystem *system, const AGOSGameDescription *gd);

protected:
	bool _filmMenuUsed;

	Common::Error go() override;

	void initMouse() override;
	void drawMousePointer() override;

	void exitMenu();
	void filmMenu();
	void handleText();
	void handleWobble();
	void mainMenu();
	void startInteractiveVideo(const char *filename);
	void waitForSpace();
};

class AGOSEngine_PuzzlePack : public AGOSEngine_Feeble {
public:
	AGOSEngine_PuzzlePack(OSystem *system, const AGOSGameDescription *gd);
	//~AGOSEngine_PuzzlePack();

	void setupGame() override;
	void setupOpcodes() override;

	void executeOpcode(int opcode) override;

	void vc3_loadSprite() override;
	void vc63_fastFadeIn() override;

	void opp_iconifyWindow();
	void opp_restoreOopsPosition();
	void opp_loadMouseImage();
	void opp_message();
	void opp_setShortText();
	void opp_loadHiScores();
	void opp_checkHiScores();
	void opp_sync();
	void opp_saveUserGame();
	void opp_loadUserGame();
	void opp_playTune();
	void opp_saveOopsPosition();
	void opp_resetGameTime();
	void opp_resetPVCount();
	void opp_setPathValues();
	void opp_pauseClock();

protected:
	typedef void (AGOSEngine_PuzzlePack::*OpcodeProcPuzzlePack) ();
	struct OpcodeEntryPuzzlePack {
		OpcodeProcPuzzlePack proc;
		const char *desc;
	};

	const OpcodeEntryPuzzlePack *_opcodesPuzzlePack;

	bool _oopsValid;
	uint32 _gameTime;

	void initMouse() override;
	void handleMouseMoved() override;
	void drawMousePointer() override;

	void resetVerbs() override;

	void loadMouseImage();

	void startOverlayAnims();
	void startAnOverlayAnim();

	void printInfoText(const char *itemText);

	Common::String genSaveName(int slot) const override;
};


class AGOSEngine_DIMP : public AGOSEngine_PuzzlePack {
public:
	AGOSEngine_DIMP(OSystem *system, const AGOSGameDescription *gd);
	//~AGOSEngine_DIMP();

	void setupOpcodes() override;

	void executeOpcode(int opcode) override;

protected:
	typedef void (AGOSEngine_DIMP::*OpcodeProcDIMP) ();
	struct OpcodeEntryDIMP {
		OpcodeProcDIMP proc;
		const char *desc;
	};

	const OpcodeEntryDIMP *_opcodesDIMP;

	int16 _iconToggleCount, _voiceCount;
	uint32 _lastTickCount;
	uint32 _startSecondCount, _tSecondCount;

	void odp_saveUserGame();
	void odp_loadUserGame();

	void dimpIdle();
	void timerProc() override;

};
#endif

} // End of namespace AGOS

#endif

================
File: animation.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */



#ifdef ENABLE_AGOS2

#include "common/endian.h"
#include "common/events.h"
#include "common/file.h"
#include "common/system.h"
#include "common/textconsole.h"
#include "common/translation.h"

#include "graphics/cursorman.h"
#include "graphics/paletteman.h"
#include "graphics/surface.h"

#include "agos/animation.h"
#include "agos/intern.h"
#include "agos/agos.h"

#include "audio/audiostream.h"
#include "audio/decoders/wave.h"

#include "gui/message.h"

namespace AGOS {

MoviePlayer::MoviePlayer(AGOSEngine_Feeble *vm)
	: _vm(vm) {
	_mixer = _vm->_mixer;

	_leftButtonDown = false;
	_rightButtonDown = false;
	_skipMovie = false;

	memset(baseName, 0, sizeof(baseName));

	_ticks = 0;
	_bgSoundStream = nullptr;
}

MoviePlayer::~MoviePlayer() {
}

void MoviePlayer::play() {
	if (_vm->getBitFlag(40)) {
		_vm->setBitFlag(42, false);
		startSound();
		return;
	}

	_leftButtonDown = false;
	_rightButtonDown = false;
	_skipMovie = false;

	_vm->_mixer->stopAll();

	_ticks = _vm->_system->getMillis();

	startSound();

	playVideo();
	stopVideo();

	_vm->o_killAnimate();

	if (_vm->getBitFlag(41)) {
		_vm->fillBackFromFront();
	} else {
		uint8 palette[768];
		memset(palette, 0, sizeof(palette));
		_vm->clearSurfaces();
		_vm->_system->getPaletteManager()->setPalette(palette, 0, 256);
	}

	_vm->fillBackGroundFromBack();
	_vm->_fastFadeOutFlag = true;
}

void MoviePlayer::handleNextFrame() {
	Common::Event event;
	Common::EventManager *eventMan = _vm->_system->getEventManager();
	while (eventMan->pollEvent(event)) {
		switch (event.type) {
		case Common::EVENT_CUSTOM_BACKEND_ACTION_START:
			if (event.customType == kActionExitCutscene) {
				_leftButtonDown = true;
				_rightButtonDown = true;
			} else if (event.customType == kActionPause) {
				_vm->pause();
			}
			break;
		case Common::EVENT_LBUTTONDOWN:
			_leftButtonDown = true;
			break;
		case Common::EVENT_RBUTTONDOWN:
			_rightButtonDown = true;
			break;
		case Common::EVENT_LBUTTONUP:
			_leftButtonDown = false;
			break;
		case Common::EVENT_RBUTTONUP:
			_rightButtonDown = false;
			break;
		default:
			break;
		}
	}

	if (_leftButtonDown && _rightButtonDown && !_vm->getBitFlag(41)) {
		_skipMovie = true;
		_mixer->stopHandle(_bgSound);
	}
}

///////////////////////////////////////////////////////////////////////////////
// Movie player for DXA movies
///////////////////////////////////////////////////////////////////////////////

const char *const MoviePlayerDXA::_sequenceList[90] = {
	"agent32",
	"Airlock",
	"Badluck",
	"bentalk1",
	"bentalk2",
	"bentalk3",
	"BigFight",
	"BLOWLAB",
	"breakdown",
	"bridge",
	"button2",
	"cargo",
	"COACH",
	"Colatalk",
	"cygnus2",
	"dream",
	"escape2",
	"FASALL",
	"fbikewurb",
	"feebdel",
	"Feebohno",
	"feebpump",
	"feefone1",
	"feefone2",
	"founder2",
	"founder3",
	"founder4",
	"fxmadsam",
	"fxwakeup",
	"gate",
	"Get Car",
	"getaxe",
	"getlift",
	"icetrench",
	"intomb1",
	"intomb2",
	"Jackpot",
	"knockout",
	"labocto",
	"longfeeb",
	"Mainmin",
	"maznat",
	"meetsquid",
	"mflirt",
	"mfxHappy",
	"Mix_Feeb1",
	"Mix_Feeb2",
	"Mix_Feeb3",
	"Mix_Guardscn",
	"Mlights1",
	"MLights2",
	"MProtest",
	"mudman",
	"munlock",
	"MUS5P2",
	"MUSOSP1",
	"Omenter",
	"Omnicofe",
	"OUTMIN~1",
	"Readbook",
	"Rebelhq",
	"RebelHQ2",
	"Reedin",
	"rescue1",
	"rescue2",
	"samcar",
	"Samdead",
	"scanner",
	"Sleepy",
	"spitbrai",
	"statue1",
	"statue2",
	"sva1",
	"sva2",
	"Teeter",
	"Temple2",
	"Temple3",
	"Temple4",
	"Temple5",
	"Temple6",
	"Temple7",
	"Temple8",
	"Tic-tac2",
	"torture",
	"transmit",
	"Typey",
	"ventfall",
	"ventoff",
	"wasting",
	"wurbatak"
};

MoviePlayerDXA::MoviePlayerDXA(AGOSEngine_Feeble *vm, const char *name)
	: MoviePlayer(vm) {
	debug(0, "Creating DXA cutscene player");

	memset(baseName, 0, sizeof(baseName));
	memcpy(baseName, name, strlen(name));

	_sequenceNum = 0;
}

bool MoviePlayerDXA::load() {
	if ((_vm->getPlatform() == Common::kPlatformAmiga || _vm->getPlatform() == Common::kPlatformMacintosh) &&
		_vm->_language != Common::EN_ANY) {
		_sequenceNum = 0;
		for (uint i = 0; i < 90; i++) {
			if (!scumm_stricmp(baseName, _sequenceList[i]))
				_sequenceNum = i;
		}
	}

	Common::Path videoName(Common::String::format("%s.dxa", baseName));
	Common::File *videoStream = new Common::File();
	if (!videoStream->open(videoName))
		error("Failed to load video file %s", videoName.toString(Common::Path::kNativeSeparator).c_str());
	if (!loadStream(videoStream))
		error("Failed to load video stream from file %s", videoName.toString(Common::Path::kNativeSeparator).c_str());

	debug(0, "Playing video %s", videoName.toString(Common::Path::kNativeSeparator).c_str());

	CursorMan.showMouse(false);
	return true;
}

void MoviePlayerDXA::copyFrameToBuffer(byte *dst, uint x, uint y, uint pitch) {
	uint h = getHeight();
	uint w = getWidth();

	const Graphics::Surface *surface = decodeNextFrame();

	if (!surface)
		return;

	const byte *src = (const byte *)surface->getPixels();
	dst += y * pitch + x;

	do {
		memcpy(dst, src, w);
		dst += pitch;
		src += w;
	} while (--h);

	if (hasDirtyPalette())
		g_system->getPaletteManager()->setPalette(getPalette(), 0, 256);
}

void MoviePlayerDXA::playVideo() {
	// Most of the videos included in the Amiga version, reduced the
	// resolution to 384 x 280, so require the screen to be cleared,
	// before starting playing those videos.
	if (getWidth() == 384 && getHeight() == 280) {
		_vm->clearSurfaces();
	}

	while (!endOfVideo() && !_skipMovie && !_vm->shouldQuit())
		handleNextFrame();
}

void MoviePlayerDXA::stopVideo() {
	close();
	_mixer->stopHandle(_bgSound);
}

void MoviePlayerDXA::startSound() {
	start();

	if (_bgSoundStream != NULL) {
		_vm->_mixer->stopHandle(_bgSound);
		_vm->_mixer->playStream(Audio::Mixer::kSFXSoundType, &_bgSound, _bgSoundStream, -1, getVolume(), getBalance());
	}
}

void MoviePlayerDXA::nextFrame() {
	if (_bgSoundStream && _vm->_mixer->isSoundHandleActive(_bgSound) && needsUpdate()) {
		copyFrameToBuffer(_vm->getBackBuf(), 465, 222, _vm->_screenWidth);
		return;
	}

	if (_vm->_interactiveVideo == TYPE_LOOPING && endOfVideo()) {
		rewind();
		startSound();
	}

	if (!endOfVideo()) {
		if (_vm->_interactiveVideo == TYPE_OMNITV) {
			copyFrameToBuffer(_vm->getBackBuf(), 465, 222, _vm->_screenWidth);
		} else if (_vm->_interactiveVideo == TYPE_LOOPING) {
			copyFrameToBuffer(_vm->getBackBuf(), (_vm->_screenWidth - getWidth()) / 2, (_vm->_screenHeight - getHeight()) / 2, _vm->_screenWidth);
		}
	} else if (_vm->_interactiveVideo == TYPE_OMNITV) {
		close();
		_vm->_interactiveVideo = 0;
		_vm->_variableArray[254] = 6747;
	}
}

void MoviePlayerDXA::handleNextFrame() {
	if (processFrame())
		_vm->_system->updateScreen();

	MoviePlayer::handleNextFrame();
}

bool MoviePlayerDXA::processFrame() {
	Graphics::Surface *screen = _vm->getBackendSurface();
	copyFrameToBuffer((byte *)screen->getPixels(), (_vm->_screenWidth - getWidth()) / 2, (_vm->_screenHeight - getHeight()) / 2, screen->pitch);
	_vm->updateBackendSurface();

	uint32 soundTime = _mixer->getSoundElapsedTime(_bgSound);
	uint32 nextFrameStartTime = ((Video::VideoDecoder::VideoTrack *)getTrack(0))->getNextFrameStartTime();

	if ((_bgSoundStream == NULL) || soundTime < nextFrameStartTime) {

		if (_bgSoundStream && _mixer->isSoundHandleActive(_bgSound)) {
			while (_mixer->isSoundHandleActive(_bgSound) && soundTime < nextFrameStartTime) {
				_vm->_system->delayMillis(10);
				soundTime = _mixer->getSoundElapsedTime(_bgSound);
			}
			// In case the background sound ends prematurely, update
			// _ticks so that we can still fall back on the no-sound
			// sync case for the subsequent frames.
			_ticks = _vm->_system->getMillis();
		} else {
			_ticks += getTimeToNextFrame();
			while (_vm->_system->getMillis() < _ticks)
				_vm->_system->delayMillis(10);
		}

		return true;
	}

	warning("dropped frame %i", getCurFrame());
	return false;
}

void MoviePlayerDXA::readSoundData(Common::SeekableReadStream *stream) {
	uint32 tag = stream->readUint32BE();

	if (tag == MKTAG('W','A','V','E')) {
		uint32 size = stream->readUint32BE();

		if (_sequenceNum) {
			Common::File in;

			stream->skip(size);

			in.open("audio.wav");
			if (!in.isOpen()) {
				error("Can't read offset file 'audio.wav'");
			}

			in.seek(_sequenceNum * 8, SEEK_SET);
			uint32 offset = in.readUint32LE();
			size = in.readUint32LE();

			in.seek(offset, SEEK_SET);
			_bgSoundStream = Audio::makeWAVStream(in.readStream(size), DisposeAfterUse::YES);
			in.close();
		} else {
			_bgSoundStream = Audio::makeWAVStream(stream->readStream(size), DisposeAfterUse::YES);
		}
	} else {
		_bgSoundStream = Audio::SeekableAudioStream::openStreamFile(baseName);
	}
}

///////////////////////////////////////////////////////////////////////////////
// Movie player for Smacker movies
///////////////////////////////////////////////////////////////////////////////


MoviePlayerSMK::MoviePlayerSMK(AGOSEngine_Feeble *vm, const char *name)
	: MoviePlayer(vm), SmackerDecoder() {
	debug(0, "Creating SMK cutscene player");

	memset(baseName, 0, sizeof(baseName));
	memcpy(baseName, name, strlen(name));

	int16 h = g_system->getOverlayHeight();

	_subtitles.setBBox(Common::Rect(20, h - 120, g_system->getOverlayWidth() - 20, h - 20));
	_subtitles.setColor(0xff, 0xff, 0xff);
	_subtitles.setFont("LiberationSans-Regular.ttf");
}

bool MoviePlayerSMK::load() {
	Common::Path videoName(Common::String::format("%s.smk", baseName));

	Common::File *videoStream = new Common::File();
	if (!videoStream->open(videoName))
		error("Failed to load video file %s", videoName.toString(Common::Path::kNativeSeparator).c_str());
	if (!loadStream(videoStream))
		error("Failed to load video stream from file %s", videoName.toString(Common::Path::kNativeSeparator).c_str());

	debug(0, "Playing video %s", videoName.toString(Common::Path::kNativeSeparator).c_str());

	CursorMan.showMouse(false);

	Common::String subtitlesName = Common::String::format("%s.srt", baseName);
	_subtitles.loadSRTFile(subtitlesName.c_str());

	return true;
}

void MoviePlayerSMK::copyFrameToBuffer(byte *dst, uint x, uint y, uint pitch) {
	uint h = getHeight();
	uint w = getWidth();

	const Graphics::Surface *surface = decodeNextFrame();

	if (!surface)
		return;

	const byte *src = (const byte *)surface->getPixels();
	dst += y * pitch + x;

	do {
		memcpy(dst, src, w);
		dst += pitch;
		src += w;
	} while (--h);

	if (hasDirtyPalette())
		g_system->getPaletteManager()->setPalette(getPalette(), 0, 256);
}

void MoviePlayerSMK::playVideo() {
	if (_subtitles.isLoaded()) {
		g_system->clearOverlay();
		g_system->showOverlay(false);
	}
	while (!endOfVideo() && !_skipMovie && !_vm->shouldQuit()) {
		handleNextFrame();
	}
}

void MoviePlayerSMK::stopVideo() {
	if (_subtitles.isLoaded()) {
		g_system->hideOverlay();
	}
	close();
}

void MoviePlayerSMK::startSound() {
	start();
}

void MoviePlayerSMK::handleNextFrame() {
	processFrame();

	MoviePlayer::handleNextFrame();
}

void MoviePlayerSMK::nextFrame() {
	if (_vm->_interactiveVideo == TYPE_LOOPING && endOfVideo())
		rewind();

	if (!endOfVideo()) {
		decodeNextFrame();
		if (_vm->_interactiveVideo == TYPE_OMNITV) {
			copyFrameToBuffer(_vm->getBackBuf(), 465, 222, _vm->_screenWidth);
		} else if (_vm->_interactiveVideo == TYPE_LOOPING) {
			copyFrameToBuffer(_vm->getBackBuf(), (_vm->_screenWidth - getWidth()) / 2, (_vm->_screenHeight - getHeight()) / 2, _vm->_screenWidth);
		}
	} else if (_vm->_interactiveVideo == TYPE_OMNITV) {
		close();
		_vm->_interactiveVideo = 0;
		_vm->_variableArray[254] = 6747;
	}
}

bool MoviePlayerSMK::processFrame() {
	Graphics::Surface *screen = _vm->getBackendSurface();
	copyFrameToBuffer((byte *)screen->getPixels(), (_vm->_screenWidth - getWidth()) / 2, (_vm->_screenHeight - getHeight()) / 2, screen->pitch);
	_vm->updateBackendSurface();

	uint32 waitTime = getTimeToNextFrame();

	if (!waitTime && !endOfVideoTracks()) {
		warning("dropped frame %i", getCurFrame());
		return false;
	}

	_subtitles.drawSubtitle(getTime(), false);

	_vm->_system->updateScreen();

	// Wait before showing the next frame
	_vm->_system->delayMillis(waitTime);
	return true;
}

///////////////////////////////////////////////////////////////////////////////
// Factory function for creating the appropriate cutscene player
///////////////////////////////////////////////////////////////////////////////

MoviePlayer *makeMoviePlayer(AGOSEngine_Feeble *vm, const char *name) {
	char baseName[40];
	char filename[45];

	int baseLen = strlen(name) - 4;
	memset(baseName, 0, sizeof(baseName));
	memcpy(baseName, name, baseLen);

	if (vm->getLanguage() == Common::DE_DEU && baseLen >= 8) {
		// Check short filename to work around
		// bug in a German Windows 2CD version.
		char shortName[10];
		memset(shortName, 0, sizeof(shortName));
		memcpy(shortName, baseName, 6);

		Common::sprintf_s(filename, "%s~1.dxa", shortName);
		if (Common::File::exists(filename)) {
			memset(baseName, 0, sizeof(baseName));
			memcpy(baseName, filename, 8);
		}

		Common::sprintf_s(filename, "%s~1.smk", shortName);
		if (Common::File::exists(filename)) {
			memset(baseName, 0, sizeof(baseName));
			memcpy(baseName, filename, 8);
		}
	}

	Common::sprintf_s(filename, "%s.dxa", baseName);
	if (Common::File::exists(filename)) {
		return new MoviePlayerDXA(vm, baseName);
	}

	Common::sprintf_s(filename, "%s.smk", baseName);
	if (Common::File::exists(filename)) {
		return new MoviePlayerSMK(vm, baseName);
	}

	Common::U32String buf = Common::U32String::format(_("Cutscene file '%s' not found!"), baseName);
	GUI::MessageDialog dialog(buf, _("OK"));
	dialog.runModal();

	return NULL;
}

} // End of namespace AGOS

#endif // ENABLE_AGOS2

================
File: animation.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifdef ENABLE_AGOS2

#ifndef AGOS_ANIMATION_H
#define AGOS_ANIMATION_H

#include "video/dxa_decoder.h"
#include "video/smk_decoder.h"
#include "video/subtitles.h"
#include "audio/mixer.h"

namespace AGOS {

class AGOSEngine_Feeble;

class MoviePlayer {
protected:
	AGOSEngine_Feeble *_vm;

	Audio::Mixer *_mixer;

	Audio::SoundHandle _bgSound;
	Audio::AudioStream *_bgSoundStream;

	bool _leftButtonDown;
	bool _rightButtonDown;
	bool _skipMovie;
	uint32 _ticks;

	char baseName[40];
public:
	enum VideoFlags {
		TYPE_OMNITV  = 1,
		TYPE_LOOPING = 2
	};

	MoviePlayer(AGOSEngine_Feeble *vm);
	virtual ~MoviePlayer();

	virtual bool load() = 0;
	virtual void play();
	virtual void playVideo() = 0;
	virtual void nextFrame() = 0;
	virtual void stopVideo() = 0;

protected:
	virtual void handleNextFrame();
	virtual bool processFrame() = 0;
	virtual void startSound() {}
	Video::Subtitles _subtitles;
};

class MoviePlayerDXA : public MoviePlayer, Video::DXADecoder {
	static const char *const _sequenceList[90];
	uint8 _sequenceNum;
public:
	MoviePlayerDXA(AGOSEngine_Feeble *vm, const char *name);

	bool load() override;
	void playVideo() override;
	void nextFrame() override;
	void stopVideo() override;

protected:
	void readSoundData(Common::SeekableReadStream *stream) override;

private:
	void handleNextFrame() override;
	bool processFrame() override;
	void startSound() override;
	void copyFrameToBuffer(byte *dst, uint x, uint y, uint pitch);
};

class MoviePlayerSMK : public MoviePlayer, Video::SmackerDecoder {
public:
	MoviePlayerSMK(AGOSEngine_Feeble *vm, const char *name);

	bool load() override;
	void playVideo() override;
	void nextFrame() override;
	void stopVideo() override;

private:
	void handleNextFrame() override;
	bool processFrame() override;
	void startSound() override;
	void copyFrameToBuffer(byte *dst, uint x, uint y, uint pitch);
};

MoviePlayer *makeMoviePlayer(AGOSEngine_Feeble *vm, const char *name);

} // End of namespace AGOS

#endif

#endif // ENABLE_AGOS2

================
File: charset-fontdata.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/endian.h"
#include "common/system.h"
#include "common/textconsole.h"

#include "agos/agos.h"
#include "agos/intern.h"

#include "graphics/surface.h"
#include "graphics/sjis.h"

namespace AGOS {

static const byte polish4CD_feebleFontSize[98] = {
	8, 2, 5, 8, 8, 8, 8, 2, 4, 4, 8, 8, 3, 8, 2, 9,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2, 3, 8, 8, 8, 8,
	7, 8, 8, 8, 8, 8, 8, 8, 8, 4, 8, 8, 8, 8, 8, 8,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 9,
	4, 8, 8, 8, 8, 8, 7, 8, 8, 4, 5, 7, 3, 8, 8, 8,
	8, 8, 8, 7, 7, 8, 8, 8, 8, 8, 8, 5, 2, 5, 8, 8,
	8, 8,
};

static const byte polish2CD_feebleFontSize[208] = {
	4, 2, 8, 8, 8, 8, 8, 2, 4, 4, 8, 8, 3, 8, 2, 9,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2, 8, 8, 8, 8, 8,
	7, 8, 8, 8, 8, 8, 8, 8, 8, 4, 8, 8, 8, 8, 8, 8,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 8,
	8, 8, 8, 8, 8, 8, 7, 8, 8, 4, 5, 7, 3, 8, 8, 8,
	8, 8, 8, 7, 7, 8, 8, 8, 8, 8, 8, 5, 2, 5, 8, 8,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 8, 8,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	8, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2, 8, 8,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
};

static const byte feebleFontSize[208] = {
	8, 2, 5, 7, 8, 8, 8, 2, 4, 4, 8, 8, 3, 8, 2, 9,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2, 3, 5, 8, 5, 8,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 8, 8, 8, 8, 8, 8,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 9, 4, 4, 9,
	4, 8, 8, 8, 8, 8, 7, 8, 8, 4, 5, 7, 3, 8, 8, 8,
	8, 8, 8, 7, 7, 8, 8, 8, 8, 8, 8, 5, 2, 5, 8, 8,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 8, 8,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	8, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2, 8, 8,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
};

uint AGOSEngine::getFeebleFontSize(byte chr) {
	if (getGameType() == GType_FF && (getFeatures() & GF_DEMO) && chr == 32) {
		return 4;
	} else if (_language == Common::PL_POL) {
		if (!strcmp(getExtra(), "4CD"))
			return polish4CD_feebleFontSize[chr - 32];
		else
			return polish2CD_feebleFontSize[chr - 32];
	} else {
		return feebleFontSize[chr - 32];
	}
}

#ifdef ENABLE_AGOS2
static const byte polish4CD_feeble_windowFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
	0x90, 0x90, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x86, 0x7a, 0x02, 0x04, 0x04,
	0x08, 0x10, 0x10, 0x7c, 0x82, 0x80, 0x80, 0x80, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x3e, 0x62, 0x92, 0x64, 0x08, 0x10, 0x20, 0x4c, 0x92, 0x8c, 0x00, 0x00, 0x00,
	0x00, 0x70, 0x88, 0x88, 0x50, 0x20, 0x52, 0x8a, 0x84, 0x7a, 0x00, 0x00, 0x00,
	0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x40, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x40, 0x20, 0x00, 0x00, 0x00,
	0x80, 0x40, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00,
	0x10, 0x92, 0x54, 0x38, 0x38, 0x54, 0x92, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x10, 0x10, 0x10, 0xfe, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x80, 0x00, 0x00,
	0x78, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x78, 0x00, 0x00, 0x00,
	0x10, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00,
	0x78, 0x84, 0x84, 0x04, 0x04, 0x08, 0x10, 0x20, 0x40, 0xfc, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x02, 0x02, 0x1c, 0x02, 0x02, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x04, 0x0c, 0x14, 0x24, 0x44, 0x84, 0xfe, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
	0xfe, 0x80, 0x80, 0xfc, 0x02, 0x02, 0x02, 0x02, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x3e, 0x40, 0x80, 0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0xfe, 0x02, 0x02, 0x02, 0x02, 0x04, 0x08, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,
	0x78, 0x84, 0x84, 0x84, 0x78, 0x84, 0x84, 0x84, 0x84, 0x78, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x40, 0x80, 0x00,
	0x04, 0x08, 0x08, 0x9c, 0xa2, 0xc2, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x10, 0x10, 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x3c, 0x42, 0x82, 0x02, 0x04, 0x08, 0x10, 0x10, 0x00, 0x10, 0x10, 0x00, 0x00,
	0x08, 0x10, 0x10, 0x7c, 0x80, 0x80, 0x78, 0x04, 0x04, 0xf8, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x82, 0x82, 0xfe, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0xfc, 0x82, 0x82, 0x82, 0xfc, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x80, 0x80, 0x80, 0x80, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x00, 0x00, 0x00,
	0xfe, 0x80, 0x80, 0x80, 0x80, 0xfc, 0x80, 0x80, 0x80, 0xfe, 0x00, 0x00, 0x00,
	0xfe, 0x80, 0x80, 0x80, 0x80, 0xfc, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x80, 0x80, 0x86, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x82, 0x82, 0x82, 0xfe, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0xe0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00, 0x00, 0x00,
	0x1e, 0x02, 0x02, 0x02, 0x02, 0x02, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x84, 0x88, 0x90, 0xe0, 0x90, 0x88, 0x84, 0x82, 0x00, 0x00, 0x00,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xfe, 0x00, 0x00, 0x00,
	0x82, 0xc6, 0xaa, 0x92, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x82, 0x82, 0xc2, 0xa2, 0x92, 0x8a, 0x86, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0xfc, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x00,
	0xfc, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x80, 0x80, 0x7c, 0x02, 0x02, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0xfe, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x44, 0x28, 0x10, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x92, 0xaa, 0xc6, 0x00, 0x00, 0x00,
	0x82, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x28, 0x44, 0x82, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x82, 0x82, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,
	0xfe, 0x02, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0xfe, 0x00, 0x00, 0x00,
	0x00, 0x10, 0x00, 0xfe, 0x04, 0x08, 0x10, 0x20, 0x40, 0xfe, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0x82, 0x82, 0xfe, 0x80, 0x80, 0x7e, 0x04, 0x04, 0x08,
	0x08, 0x10, 0x10, 0xfe, 0x04, 0x08, 0x10, 0x20, 0x40, 0xfe, 0x00, 0x00, 0x00,
	0xc0, 0x40, 0x40, 0x60, 0x40, 0xc0, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x86, 0x7a, 0x00, 0x00, 0x00,
	0x80, 0x80, 0x80, 0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0x82, 0x80, 0x80, 0x80, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x02, 0x02, 0x02, 0x7e, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0x82, 0x82, 0xfe, 0x80, 0x80, 0x7e, 0x00, 0x00, 0x00,
	0x1c, 0x20, 0x20, 0xf8, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x7c,
	0x80, 0x80, 0x80, 0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x40, 0xc0, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00, 0x00, 0x00,
	0x10, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xe0,
	0x80, 0x80, 0x80, 0x84, 0x88, 0x90, 0xe0, 0x90, 0x88, 0x84, 0x00, 0x00, 0x00,
	0xc0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xfc, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x9c, 0xa2, 0xc2, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x80, 0x80, 0x80,
	0x00, 0x00, 0x00, 0x7e, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x02,
	0x00, 0x00, 0x00, 0x9c, 0xa2, 0xc2, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0x80, 0x80, 0x78, 0x04, 0x04, 0xf8, 0x00, 0x00, 0x00,
	0x20, 0x20, 0x20, 0xf8, 0x20, 0x20, 0x20, 0x20, 0x20, 0x1c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x82, 0x82, 0x82, 0x82, 0x44, 0x28, 0x10, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x82, 0x44, 0x28, 0x10, 0x28, 0x44, 0x82, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x7c,
	0x00, 0x00, 0x00, 0xfe, 0x04, 0x08, 0x10, 0x20, 0x40, 0xfe, 0x00, 0x00, 0x00,
	0x30, 0x40, 0x40, 0x40, 0x40, 0x80, 0x40, 0x40, 0x40, 0x40, 0x30, 0x00, 0x00,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00,
	0xc0, 0x20, 0x20, 0x20, 0x20, 0x10, 0x20, 0x20, 0x20, 0x20, 0xc0, 0x00, 0x00,
	0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0xc8,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x88, 0x00, 0x11, 0x00, 0x00, 0x00,
	0x03, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0xc8, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x14, 0x00, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x88, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x88, 0x00, 0x11, 0x00, 0x00, 0x00, 0x03,
	0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0xc8, 0x00, 0x03, 0x00,
	0x02, 0x00, 0x0e, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x88, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0x00, 0x88, 0x00, 0x11, 0x00, 0x00, 0x00, 0x03, 0x00,
	0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0xc8, 0x00, 0x03, 0x00, 0x03,
	0x00, 0x0e, 0x00, 0x7f, 0x00, 0x45, 0x46, 0x46, 0x45, 0x43, 0x54, 0x53, 0x00,
	0x53, 0x49, 0x4d, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0xa8, 0x4d, 0xee, 0x00, 0xb0,
	0x4d, 0xee, 0x00, 0x00, 0x53, 0x49, 0x4d, 0x4f, 0x4e, 0x32, 0x00, 0xc0, 0x4d,
	0xee, 0x00, 0xc1, 0x4d, 0xee, 0x00, 0x4d, 0x55, 0x53, 0x49, 0x43, 0x00, 0x00,
	0x00, 0xc0, 0x4d, 0xee, 0x00, 0xd0, 0x4d, 0xee, 0x00, 0x44, 0x72, 0x81, 0x63,
	0x6b, 0x65, 0x6e, 0x20, 0x53, 0x69, 0x65, 0x20, 0x64, 0x69, 0x65, 0x20, 0x3c,
	0x4c, 0x65, 0x65, 0x72, 0x74, 0x61, 0x73, 0x74, 0x65, 0x3e, 0x2c, 0x20, 0x75,
	0x6d, 0x20, 0x66, 0x6f, 0x72, 0x74, 0x7a, 0x75, 0x66, 0x61, 0x68, 0x72, 0x65,
	0x6e, 0x2e, 0x2e, 0x2e, 0x00, 0x50, 0x72, 0x65, 0x73, 0x73, 0x20, 0x3c, 0x53,
	0x50, 0x41, 0x43, 0x45, 0x3e, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f, 0x6e, 0x74,
	0x69, 0x6e, 0x75, 0x65, 0x2e, 0x2e, 0x2e, 0x00, 0x65, 0x6e, 0x67, 0x69, 0x6e,
	0x65, 0x73, 0x2f, 0x61, 0x67, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x65, 0x62, 0x6c,
	0x65, 0x2e, 0x63, 0x70, 0x70, 0x00, 0x5f, 0x6d, 0x6f, 0x76, 0x69, 0x65, 0x50,
	0x6c, 0x61, 0x79, 0x65, 0x72, 0x00, 0x77, 0x6f, 0x62, 0x62, 0x6c, 0x65, 0x25,
	0x64, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x63, 0x6c, 0x69, 0x70, 0x73, 0x69,
	0x6e, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x63, 0x6c, 0x69, 0x70, 0x69, 0x6e,
	0x32, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x67, 0x6f, 0x31, 0x2e, 0x73, 0x6d,
	0x6b, 0x00, 0x6d, 0x61, 0x7a, 0x65, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x67,
	0x6f, 0x32, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x72, 0x61, 0x64, 0x69, 0x6f, 0x69,
	0x6e, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x67, 0x6f, 0x33, 0x2e, 0x73, 0x6d,
	0x6b, 0x00, 0x70, 0x61, 0x64, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x67, 0x6f,
	0x34, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x62, 0x72, 0x69, 0x64, 0x67, 0x65, 0x2e,
	0x73, 0x6d, 0x6b, 0x00, 0x66, 0x67, 0x6f, 0x35, 0x2e, 0x73, 0x6d, 0x6b, 0x00,
	0x70, 0x69, 0x6c, 0x6c, 0x64, 0x69, 0x65, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66,
	0x67, 0x6f, 0x36, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x62, 0x69, 0x6b, 0x65, 0x62,
	0x75, 0x73, 0x74, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x67, 0x6f, 0x37, 0x2e,
	0x73, 0x6d, 0x6b, 0x00, 0x73, 0x74, 0x61, 0x74, 0x75, 0x65, 0x2e, 0x73, 0x6d,
	0x6b, 0x00, 0x66, 0x67, 0x6f, 0x38, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x6a, 0x75,
	0x6e, 0x6b, 0x6f, 0x75, 0x74, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x67, 0x6f,
	0x39, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x68, 0x79, 0x70, 0x6e, 0x6f, 0x2e,
	0x73, 0x6d, 0x6b, 0x00, 0x66, 0x62, 0x79, 0x65, 0x31, 0x2e, 0x73, 0x6d, 0x6b,
	0x00, 0x66, 0x62, 0x79, 0x65, 0x32, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x6d, 0x6d,
	0x66, 0x61, 0x64, 0x65, 0x69, 0x6e, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x6d, 0x61,
	0x69, 0x6e, 0x6d, 0x65, 0x6e, 0x75, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x66,
	0x61, 0x64, 0x65, 0x35, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x74, 0x65, 0x78,
	0x74, 0x30, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x74, 0x65, 0x78, 0x74, 0x31,
	0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x74, 0x65, 0x78, 0x74, 0x32, 0x2e, 0x73,
	0x6d, 0x6b, 0x00, 0x66, 0x74, 0x65, 0x78, 0x74, 0x33, 0x2e, 0x73, 0x6d, 0x6b,
	0x00, 0x66, 0x74, 0x65, 0x78, 0x74, 0x34, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66,
	0x74, 0x65, 0x78, 0x74, 0x35, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x66, 0x61,
	0x64, 0x65, 0x31, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x6d, 0x75, 0x73, 0x6f, 0x73,
	0x70, 0x31, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x6e, 0x65, 0x77, 0x63, 0x72, 0x65,
	0x64, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x61, 0x73, 0x61, 0x6c, 0x6c, 0x2e,
	0x73, 0x6d, 0x6b, 0x00, 0x6d, 0x75, 0x73, 0x35, 0x70, 0x32, 0x2e, 0x73, 0x6d,
	0x6b, 0x00, 0x63, 0x6f, 0x61, 0x63, 0x68, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x6f,
	0x75, 0x74, 0x6d, 0x69, 0x6e, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x66, 0x61,
	0x64, 0x65, 0x33, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x69, 0x64, 0x66, 0x78, 0x34,
	0x61, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x69, 0x64, 0x66, 0x78, 0x34, 0x62, 0x2e,
	0x73, 0x6d, 0x6b, 0x00, 0x69, 0x64, 0x66, 0x78, 0x34, 0x63, 0x2e, 0x73, 0x6d,
	0x6b, 0x00, 0x69, 0x64, 0x66, 0x78, 0x34, 0x64, 0x2e, 0x73, 0x6d, 0x6b, 0x00,
	0x69, 0x64, 0x66, 0x78, 0x34, 0x65, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x69, 0x64,
	0x66, 0x78, 0x34, 0x66, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x69, 0x64, 0x66, 0x78,
	0x34, 0x67, 0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x66, 0x61, 0x64, 0x65, 0x32,
	0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x73, 0x63, 0x65, 0x6e, 0x65, 0x33, 0x62,
	0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x73, 0x63, 0x65, 0x6e, 0x65, 0x33, 0x61,
	0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x73, 0x63, 0x65, 0x6e, 0x65, 0x33, 0x63,
	0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x73, 0x63, 0x65, 0x6e, 0x65, 0x33, 0x67,
	0x2e, 0x73, 0x6d, 0x6b, 0x00, 0x66, 0x66, 0x61, 0x64, 0x65, 0x34, 0x2e, 0x73,
	0x6d, 0x6b, 0x00, 0x66, 0x66, 0x61, 0x64, 0x65, 0x36, 0x2e, 0x73, 0x6d, 0x6b,
	0x00, 0x77, 0x69, 0x6e, 0x61, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x73, 0x6d, 0x6b,
	0x00, 0x66, 0x62, 0x69, 0x67, 0x74, 0x61, 0x6c, 0x6b, 0x2e, 0x73, 0x6d, 0x6b,
	0x00, 0x65, 0x70, 0x69, 0x63, 0x2e, 0x64, 0x78, 0x61, 0x00, 0x00, 0x56, 0x4f,
	0x49, 0x43, 0x45, 0x53, 0x00, 0x00, 0x00, 0xc6, 0x50, 0xee, 0x00, 0xc7, 0x50,
	0xee, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4f, 0x75, 0x74,
	0x20, 0x6f, 0x66, 0x20, 0x69, 0x63, 0x6f, 0x6e, 0x20, 0x6d, 0x65, 0x6d, 0x6f,
	0x72, 0x79, 0x00, 0x43, 0x61, 0x6e, 0x27, 0x74, 0x20, 0x6f, 0x70, 0x65, 0x6e,
	0x20, 0x69, 0x63, 0x6f, 0x6e, 0x73, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x27,
	0x25, 0x73, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x80, 0x00,
	0x88, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0xd8,
	0x00, 0x00, 0x04, 0x48, 0x00, 0x00, 0x00, 0x20, 0x89, 0x8e, 0x00, 0xa8, 0x86,
	0x10, 0x04, 0x08, 0x21, 0x88, 0x00, 0x38, 0x50, 0x84, 0x00, 0x89, 0x49, 0x28,
	0x04, 0x08, 0x52, 0x14, 0x00, 0x20, 0x20, 0x84, 0x00, 0x89, 0x48, 0x38, 0x04,
	0x08, 0x53, 0x9c, 0x00, 0x20, 0x50, 0x84, 0x00, 0x89, 0x48, 0x20, 0x04, 0x48,
	0x50, 0x90, 0x00, 0x3c, 0x89, 0xc3, 0x00, 0x88, 0x88, 0x18, 0x03, 0x86, 0x23,
	0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b,
	0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0a, 0x0b, 0x0a, 0x0b, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0a, 0x0b, 0x0a, 0x0d, 0x0a, 0x0b, 0x0a, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b, 0x0a, 0x0d, 0x03, 0x0d, 0x0a, 0x0b, 0x0a,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b, 0x0a, 0x0d, 0x03, 0x04, 0x03,
	0x0d, 0x0a, 0x0b, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b, 0x0a, 0x0d, 0x03,
};

static const byte polish2CD_feeble_windowFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x82, 0x82, 0xfe, 0x82, 0x82, 0x82, 0x82, 0x0c, 0x08, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x86, 0x7a, 0x04, 0x06, 0x00,
	0x04, 0x08, 0x10, 0x7c, 0x82, 0x80, 0x80, 0x80, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x3e, 0x62, 0x92, 0x64, 0x08, 0x10, 0x20, 0x4c, 0x92, 0x8c, 0x00, 0x00, 0x00,
	0x7c, 0x8a, 0x92, 0x80, 0x80, 0x80, 0x80, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x40, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x40, 0x20, 0x00, 0x00, 0x00,
	0x80, 0x40, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00,
	0xfe, 0x80, 0x80, 0x80, 0x80, 0xfc, 0x80, 0x80, 0x80, 0xfe, 0x18, 0x0c, 0x00,
	0x80, 0x80, 0x90, 0xb0, 0xe0, 0xc0, 0x80, 0x80, 0x80, 0xfe, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x80, 0x00, 0x00,
	0x78, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x78, 0x00, 0x00, 0x00,
	0x10, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00,
	0x78, 0x84, 0x84, 0x04, 0x04, 0x08, 0x10, 0x20, 0x40, 0xfc, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x02, 0x02, 0x1c, 0x02, 0x02, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x04, 0x0c, 0x14, 0x24, 0x44, 0x84, 0xfe, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
	0xfe, 0x80, 0x80, 0xfc, 0x02, 0x02, 0x02, 0x02, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x3e, 0x40, 0x80, 0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0xfe, 0x02, 0x02, 0x02, 0x02, 0x04, 0x08, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,
	0x78, 0x84, 0x84, 0x84, 0x78, 0x84, 0x84, 0x84, 0x84, 0x78, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x8a, 0x92, 0xc2, 0xa2, 0x92, 0x8a, 0x86, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x04, 0x08, 0x10, 0x9c, 0xa2, 0xc2, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x7c, 0x92, 0xa2, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x04, 0x08, 0x10, 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x3c, 0x42, 0x82, 0x02, 0x04, 0x08, 0x10, 0x10, 0x00, 0x10, 0x10, 0x00, 0x00,
	0x04, 0x08, 0x10, 0x7c, 0x80, 0x80, 0x78, 0x04, 0x04, 0xf8, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x82, 0x82, 0xfe, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0xfc, 0x82, 0x82, 0x82, 0xfc, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x80, 0x80, 0x80, 0x80, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x00, 0x00, 0x00,
	0xfe, 0x80, 0x80, 0x80, 0x80, 0xfc, 0x80, 0x80, 0x80, 0xfe, 0x00, 0x00, 0x00,
	0xfe, 0x80, 0x80, 0x80, 0x80, 0xfc, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x80, 0x80, 0x86, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x82, 0x82, 0x82, 0xfe, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0xe0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00, 0x00, 0x00,
	0x1e, 0x02, 0x02, 0x02, 0x02, 0x02, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x84, 0x88, 0x90, 0xe0, 0x90, 0x88, 0x84, 0x82, 0x00, 0x00, 0x00,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xfe, 0x00, 0x00, 0x00,
	0x82, 0xc6, 0xaa, 0x92, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x82, 0x82, 0xc2, 0xa2, 0x92, 0x8a, 0x86, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0xfc, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x00,
	0xfc, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x80, 0x80, 0x7c, 0x02, 0x02, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0xfe, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x44, 0x28, 0x10, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x92, 0xaa, 0xc6, 0x00, 0x00, 0x00,
	0x82, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x28, 0x44, 0x82, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x82, 0x82, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,
	0xfe, 0x02, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0xfe, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xfe, 0x04, 0x08, 0x7c, 0x20, 0x40, 0xfe, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0x82, 0x82, 0xfe, 0x80, 0x80, 0x7e, 0x18, 0x0c, 0x00,
	0x04, 0x08, 0x10, 0xfe, 0x04, 0x08, 0x10, 0x20, 0x40, 0xfe, 0x00, 0x00, 0x00,
	0xc0, 0x40, 0x40, 0x60, 0x40, 0xc0, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00,
	0x7c, 0x8a, 0x90, 0x80, 0x7c, 0x02, 0x02, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x18, 0xfe, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0xfe, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x86, 0x7a, 0x00, 0x00, 0x00,
	0x80, 0x80, 0x80, 0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0x82, 0x80, 0x80, 0x80, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x02, 0x02, 0x02, 0x7e, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0x82, 0x82, 0xfe, 0x80, 0x80, 0x7e, 0x00, 0x00, 0x00,
	0x1c, 0x20, 0x20, 0xf8, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x7c,
	0x80, 0x80, 0x80, 0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x40, 0xc0, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00, 0x00, 0x00,
	0x10, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xe0,
	0x80, 0x80, 0x80, 0x84, 0x88, 0x90, 0xe0, 0x90, 0x88, 0x84, 0x00, 0x00, 0x00,
	0xc0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xfc, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x9c, 0xa2, 0xc2, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x80, 0x80, 0x80,
	0x00, 0x00, 0x00, 0x7e, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x02,
	0x00, 0x00, 0x00, 0x9c, 0xa2, 0xc2, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0x80, 0x80, 0x78, 0x04, 0x04, 0xf8, 0x00, 0x00, 0x00,
	0x20, 0x20, 0x20, 0xf8, 0x20, 0x20, 0x20, 0x20, 0x20, 0x1c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x82, 0x82, 0x82, 0x82, 0x44, 0x28, 0x10, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x82, 0x44, 0x28, 0x10, 0x28, 0x44, 0x82, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x7c,
	0x00, 0x00, 0x00, 0xfe, 0x04, 0x08, 0x10, 0x20, 0x40, 0xfe, 0x00, 0x00, 0x00,
	0x30, 0x40, 0x40, 0x40, 0x40, 0x80, 0x40, 0x40, 0x40, 0x40, 0x30, 0x00, 0x00,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00,
	0xc0, 0x20, 0x20, 0x20, 0x20, 0x10, 0x20, 0x20, 0x20, 0x20, 0xc0, 0x00, 0x00,
	0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x80, 0x80, 0x80, 0x80, 0x82, 0x82, 0x7c, 0x10, 0x10, 0x30,
	0x00, 0x28, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x00, 0x00, 0x00,
	0x10, 0x20, 0x00, 0x7c, 0x82, 0x82, 0xfe, 0x80, 0x80, 0x7e, 0x00, 0x00, 0x00,
	0x10, 0x28, 0x00, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x86, 0x7a, 0x00, 0x00, 0x00,
	0x00, 0x28, 0x00, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x86, 0x7a, 0x00, 0x00, 0x00,
	0x10, 0x08, 0x00, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x86, 0x7a, 0x00, 0x00, 0x00,
	0x08, 0x14, 0x08, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x86, 0x7a, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0x82, 0x80, 0x80, 0x80, 0x82, 0x7c, 0x10, 0x10, 0x30,
	0x10, 0x28, 0x00, 0x7c, 0x82, 0x82, 0xfe, 0x80, 0x80, 0x7e, 0x00, 0x00, 0x00,
	0x00, 0x28, 0x00, 0x7c, 0x82, 0x82, 0xfe, 0x80, 0x80, 0x7e, 0x00, 0x00, 0x00,
	0x10, 0x08, 0x00, 0x7c, 0x82, 0x82, 0xfe, 0x80, 0x80, 0x7e, 0x00, 0x00, 0x00,
	0x00, 0xa0, 0x00, 0x40, 0xc0, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00, 0x00, 0x00,
	0x40, 0xa0, 0x00, 0x40, 0xc0, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00, 0x00, 0x00,
	0x80, 0x40, 0x00, 0x40, 0xc0, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00, 0x00, 0x00,
	0x28, 0x00, 0x7c, 0x82, 0x82, 0x82, 0xfe, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x10, 0x28, 0x7c, 0x82, 0x82, 0x82, 0xfe, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x10, 0x20, 0xfe, 0x80, 0x80, 0xfc, 0x80, 0x80, 0x80, 0xfe, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0x28, 0x00, 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x28, 0x00, 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x20, 0x10, 0x00, 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x10, 0x28, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x00, 0x00, 0x00,
	0x10, 0x08, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x00, 0x00, 0x00,
	0x00, 0x28, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x7c,
	0x28, 0x00, 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x28, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x10, 0x00, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x86, 0x7a, 0x00, 0x00, 0x00,
	0x40, 0x80, 0x00, 0x40, 0xc0, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00, 0x00, 0x00,
	0x10, 0x20, 0x00, 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x08, 0x10, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x00, 0x00, 0x00,
	0x14, 0x28, 0x00, 0x9c, 0xa2, 0xc2, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x14, 0x28, 0x82, 0xc2, 0xa2, 0x92, 0x8a, 0x86, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0x10, 0x00, 0x10, 0x10, 0x20, 0x40, 0x80, 0x82, 0x84, 0x78, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3c, 0x42, 0x82, 0x82, 0x82, 0x84, 0x84, 0x82, 0x82, 0x82, 0x9c, 0x80, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const byte feeble_windowFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
	0x90, 0x90, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x48, 0xfc, 0x48, 0x48, 0xfc, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7c, 0x92, 0x90, 0x90, 0x7c, 0x12, 0x12, 0x12, 0x92, 0x7c, 0x10, 0x10, 0x00,
	0x3e, 0x62, 0x92, 0x64, 0x08, 0x10, 0x20, 0x4c, 0x92, 0x8c, 0x00, 0x00, 0x00,
	0x00, 0x70, 0x88, 0x88, 0x50, 0x20, 0x52, 0x8a, 0x84, 0x7a, 0x00, 0x00, 0x00,
	0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x40, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x40, 0x20, 0x00, 0x00, 0x00,
	0x80, 0x40, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00,
	0x10, 0x92, 0x54, 0x38, 0x38, 0x54, 0x92, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x10, 0x10, 0x10, 0xfe, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x80, 0x00, 0x00,
	0x78, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x78, 0x00, 0x00, 0x00,
	0x10, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00,
	0x78, 0x84, 0x84, 0x04, 0x04, 0x08, 0x10, 0x20, 0x40, 0xfc, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x02, 0x02, 0x1c, 0x02, 0x02, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x04, 0x0c, 0x14, 0x24, 0x44, 0x84, 0xfe, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
	0xfe, 0x80, 0x80, 0xfc, 0x02, 0x02, 0x02, 0x02, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x3e, 0x40, 0x80, 0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0xfe, 0x02, 0x02, 0x02, 0x02, 0x04, 0x08, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,
	0x78, 0x84, 0x84, 0x84, 0x78, 0x84, 0x84, 0x84, 0x84, 0x78, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x40, 0x80, 0x00,
	0x00, 0x00, 0x10, 0x20, 0x40, 0x80, 0x40, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x3c, 0x42, 0x82, 0x02, 0x04, 0x08, 0x10, 0x10, 0x00, 0x10, 0x10, 0x00, 0x00,
	0x3c, 0x42, 0x82, 0x9a, 0xa6, 0xa6, 0x9c, 0x80, 0x80, 0x7e, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x82, 0x82, 0xfe, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0xfc, 0x82, 0x82, 0x82, 0xfc, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x80, 0x80, 0x80, 0x80, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x00, 0x00, 0x00,
	0xfe, 0x80, 0x80, 0x80, 0x80, 0xfc, 0x80, 0x80, 0x80, 0xfe, 0x00, 0x00, 0x00,
	0xfe, 0x80, 0x80, 0x80, 0x80, 0xfc, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x80, 0x80, 0x86, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x82, 0x82, 0x82, 0xfe, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0xe0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00, 0x00, 0x00,
	0x1e, 0x02, 0x02, 0x02, 0x02, 0x02, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x84, 0x88, 0x90, 0xe0, 0x90, 0x88, 0x84, 0x82, 0x00, 0x00, 0x00,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xfe, 0x00, 0x00, 0x00,
	0x82, 0xc6, 0xaa, 0x92, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x82, 0x82, 0xc2, 0xa2, 0x92, 0x8a, 0x86, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0xfc, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x00,
	0xfc, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x7c, 0x82, 0x80, 0x80, 0x7c, 0x02, 0x02, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0xfe, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x44, 0x28, 0x10, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x92, 0xaa, 0xc6, 0x00, 0x00, 0x00,
	0x82, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x28, 0x44, 0x82, 0x00, 0x00, 0x00,
	0x82, 0x82, 0x82, 0x82, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,
	0xfe, 0x02, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0xfe, 0x00, 0x00, 0x00,
	0xe0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xe0, 0x00, 0x00, 0x00,
	0x80, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00,
	0xe0, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xe0, 0x00, 0x00, 0x00,
	0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x86, 0x7a, 0x00, 0x00, 0x00,
	0x80, 0x80, 0x80, 0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0x82, 0x80, 0x80, 0x80, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x02, 0x02, 0x02, 0x7e, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0x82, 0x82, 0xfe, 0x80, 0x80, 0x7e, 0x00, 0x00, 0x00,
	0x1c, 0x20, 0x20, 0xf8, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x7c,
	0x80, 0x80, 0x80, 0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x40, 0xc0, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00, 0x00, 0x00,
	0x10, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xe0,
	0x80, 0x80, 0x80, 0x84, 0x88, 0x90, 0xe0, 0x90, 0x88, 0x84, 0x00, 0x00, 0x00,
	0xc0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xfc, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x9c, 0xa2, 0xc2, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xfc, 0x82, 0x82, 0x82, 0x82, 0x82, 0xfc, 0x80, 0x80, 0x80,
	0x00, 0x00, 0x00, 0x7e, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x02,
	0x00, 0x00, 0x00, 0x9c, 0xa2, 0xc2, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0x80, 0x80, 0x78, 0x04, 0x04, 0xf8, 0x00, 0x00, 0x00,
	0x20, 0x20, 0x20, 0xf8, 0x20, 0x20, 0x20, 0x20, 0x20, 0x1c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x82, 0x82, 0x82, 0x82, 0x44, 0x28, 0x10, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x82, 0x44, 0x28, 0x10, 0x28, 0x44, 0x82, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x7c,
	0x00, 0x00, 0x00, 0xfe, 0x04, 0x08, 0x10, 0x20, 0x40, 0xfe, 0x00, 0x00, 0x00,
	0x30, 0x40, 0x40, 0x40, 0x40, 0x80, 0x40, 0x40, 0x40, 0x40, 0x30, 0x00, 0x00,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00,
	0xc0, 0x20, 0x20, 0x20, 0x20, 0x10, 0x20, 0x20, 0x20, 0x20, 0xc0, 0x00, 0x00,
	0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00,
	0x7c, 0x82, 0x82, 0x80, 0x80, 0x80, 0x80, 0x82, 0x82, 0x7c, 0x10, 0x10, 0x30,
	0x00, 0x28, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x00, 0x00, 0x00,
	0x10, 0x20, 0x00, 0x7c, 0x82, 0x82, 0xfe, 0x80, 0x80, 0x7e, 0x00, 0x00, 0x00,
	0x10, 0x28, 0x00, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x86, 0x7a, 0x00, 0x00, 0x00,
	0x00, 0x28, 0x00, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x86, 0x7a, 0x00, 0x00, 0x00,
	0x10, 0x08, 0x00, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x86, 0x7a, 0x00, 0x00, 0x00,
	0x08, 0x14, 0x08, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x86, 0x7a, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0x82, 0x80, 0x80, 0x80, 0x82, 0x7c, 0x10, 0x10, 0x30,
	0x10, 0x28, 0x00, 0x7c, 0x82, 0x82, 0xfe, 0x80, 0x80, 0x7e, 0x00, 0x00, 0x00,
	0x00, 0x28, 0x00, 0x7c, 0x82, 0x82, 0xfe, 0x80, 0x80, 0x7e, 0x00, 0x00, 0x00,
	0x10, 0x08, 0x00, 0x7c, 0x82, 0x82, 0xfe, 0x80, 0x80, 0x7e, 0x00, 0x00, 0x00,
	0x00, 0xa0, 0x00, 0x40, 0xc0, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00, 0x00, 0x00,
	0x40, 0xa0, 0x00, 0x40, 0xc0, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00, 0x00, 0x00,
	0x80, 0x40, 0x00, 0x40, 0xc0, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00, 0x00, 0x00,
	0x28, 0x00, 0x7c, 0x82, 0x82, 0x82, 0xfe, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x10, 0x28, 0x7c, 0x82, 0x82, 0x82, 0xfe, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x28, 0x00, 0xfe, 0x80, 0x80, 0xfc, 0x80, 0x80, 0x80, 0xfe, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0x28, 0x00, 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x28, 0x00, 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x20, 0x10, 0x00, 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x10, 0x28, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x00, 0x00, 0x00,
	0x10, 0x08, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x00, 0x00, 0x00,
	0x00, 0x28, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x02, 0x02, 0x7c,
	0x28, 0x00, 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x28, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x10, 0x00, 0x3e, 0x42, 0x82, 0x82, 0x82, 0x86, 0x7a, 0x00, 0x00, 0x00,
	0x40, 0x80, 0x00, 0x40, 0xc0, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00, 0x00, 0x00,
	0x10, 0x20, 0x00, 0x7c, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7c, 0x00, 0x00, 0x00,
	0x08, 0x10, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x7e, 0x00, 0x00, 0x00,
	0x14, 0x28, 0x00, 0x9c, 0xa2, 0xc2, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x14, 0x28, 0x82, 0xc2, 0xa2, 0x92, 0x8a, 0x86, 0x82, 0x82, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0x10, 0x00, 0x10, 0x10, 0x20, 0x40, 0x80, 0x82, 0x84, 0x78, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3c, 0x42, 0x82, 0x82, 0x82, 0x84, 0x84, 0x82, 0x82, 0x82, 0x9c, 0x80, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

void AGOSEngine_Feeble::windowDrawChar(WindowBlock *window, uint x, uint y, byte chr) {
	const byte *src;
	byte color, *dst;
	uint dstPitch, h, w, i;

	if (_noOracleScroll)
		return;

	_videoLockOut |= 0x8000;

	dst = getBackGround();
	dstPitch = _backGroundBuf->pitch;
	h = 13;
	w = getFeebleFontSize(chr);

	if (_language == Common::PL_POL) {
		if (!strcmp(getExtra(), "4CD"))
			src = polish4CD_feeble_windowFont + (chr - 32) * 13;
		else
			src = polish2CD_feeble_windowFont + (chr - 32) * 13;
	} else {
		src = feeble_windowFont + (chr - 32) * 13;
	}
	dst += y * dstPitch + x + window->textColumnOffset;

	color = window->textColor;

	do {
		int8 b = *src++;
		i = 0;
		do {
			if (b < 0) {
				if (dst[i] == 0)
					dst[i] = color;
			}

			b <<= 1;
		} while (++i != w);
		dst += dstPitch;
	} while (--h);

	_videoLockOut &= ~0x8000;
}
#endif

static const byte english_simon1AGAFontData[] = {
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x20,0x10,0x40,0x88,0x30,0x40,0x00,0x88,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x30,0x00,0x10,0x20,0x48,0x10,0x20,0x00,0x48,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x28,0x00,0x54,0x1C,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x1C,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x10,0x00,0x00,0x10,0x28,0x08,0x10,0x20,0x44,0x00,0x40,0x00,0xB8,0x30,0x00,0x00,0x48,0x08,0x00,0x00,0x74,0x30,0x00,0x40,0x88,0x20,0x00,0x00,0x50,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xB4,0x00,0x48,0x00,0xB4,0x10,0x00,0x00,0x68,0x00,0x20,0x00,0x58,0x00,0x08,0x40,0xB4,0x08,0x40,0x00,0xB4,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x00,0x06,
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x10,0x00,0x40,0xA8,0x18,0x20,0x00,0x44,0x10,0x00,0x00,0x28,0x18,0x20,0x00,0x44,0x10,0x00,0x40,0xAC,0x0C,0x20,0x00,0x52,0x00,0x00,0x00,0x2C,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x30,0x00,0x10,0x20,0x48,0x10,0x20,0x00,0x48,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x28,0x00,0x54,0x1C,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x1C,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x28,0x00,0x54,0x1C,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x1C,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x28,0x00,0x54,0x1C,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x1C,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x10,0x20,0x48,0x10,0x20,0x00,0x48,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x05,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x10,0x20,0x48,0x10,0x20,0x00,0x48,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x05,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x18,0x20,0x40,0x84,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x04,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x04,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xBA,0x0C,0x00,0x40,0xB2,0x04,0x50,0x00,0xAA,0x44,0x20,0x00,0x9A,0x44,0x00,0x00,0xBA,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x00,0x20,0x40,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xBA,0x04,0x00,0x00,0x5A,0x08,0x10,0x00,0x24,0x00,0x20,0x00,0x5C,0x00,0x04,0x40,0xBA,0x3C,0x40,0x00,0x82,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xBA,0x04,0x00,0x00,0x5A,0x00,0x08,0x10,0x24,0x04,0x00,0x00,0x5A,0x04,0x00,0x40,0xBA,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x08,0x00,0x08,0x00,0x14,0x08,0x00,0x10,0x24,0x08,0x00,0x20,0x54,0x08,0x40,0x00,0xB4,0x3C,0x40,0x00,0x82,0x08,0x00,0x00,0x74,0x04,0x08,0x10,0x22,0x00,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7C,0x04,0x18,0x60,0x82,0x00,0x40,0x00,0xBC,0x78,0x00,0x00,0x84,0x04,0x00,0x00,0x7A,0x04,0x00,0x00,0x4A,0x04,0x00,0x40,0xBA,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x18,0x08,0x10,0x00,0x24,0x00,0x00,0x20,0x58,0x00,0x40,0x00,0xB8,0x38,0x40,0x00,0x84,0x44,0x00,0x00,0xBA,0x44,0x00,0x00,0xBA,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7C,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xBA,0x00,0x04,0x00,0x4A,0x00,0x00,0x08,0x14,0x00,0x10,0x00,0x28,0x00,0x10,0x00,0x28,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xBA,0x04,0x40,0x00,0xBA,0x18,0x20,0x00,0x44,0x04,0x00,0x40,0xBA,0x04,0x40,0x00,0xBA,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xBA,0x04,0x40,0x00,0xBA,0x1C,0x20,0x00,0x42,0x04,0x00,0x00,0x3A,0x00,0x08,0x00,0x34,0x00,0x10,0x20,0x48,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x04,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x10,0x20,0x48,0x10,0x20,0x00,0x48,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x30,0x00,0x10,0x20,0x48,0x10,0x20,0x00,0x48,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x05,
	0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x40,0x00,0xBA,0x04,0x00,0x00,0x4A,0x08,0x00,0x00,0x14,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x40,0x00,0xBA,0x04,0x00,0x00,0x4A,0x08,0x00,0x00,0x14,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x40,0x00,0xBA,0x04,0x00,0x00,0x4A,0x08,0x00,0x00,0x14,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x40,0x00,0xBA,0x04,0x00,0x00,0x4A,0x08,0x00,0x00,0x14,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xBA,0x04,0x40,0x10,0xAA,0x0C,0x50,0x00,0xA2,0x1C,0x40,0x00,0xA2,0x40,0x00,0x00,0xBC,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xBA,0x04,0x00,0x40,0xBA,0x0C,0x70,0x00,0x82,0x04,0x40,0x00,0xBA,0x44,0x00,0x00,0xAA,0x44,0x00,0x00,0xAA,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x78,0x08,0x10,0x60,0x84,0x04,0x00,0x20,0x5A,0x04,0x20,0x00,0x5A,0x28,0x10,0x00,0x44,0x24,0x00,0x00,0x5A,0x24,0x00,0x00,0x5A,0x18,0x20,0x40,0x84,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x24,0x04,0x00,0x20,0x5A,0x00,0x00,0x40,0xA4,0x00,0x00,0x40,0xA0,0x00,0x40,0x00,0xA4,0x24,0x00,0x00,0x5A,0x18,0x00,0x00,0x24,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x70,0x10,0x20,0x40,0x88,0x08,0x20,0x00,0x54,0x04,0x20,0x00,0x5A,0x04,0x20,0x00,0x5A,0x24,0x00,0x00,0x5A,0x28,0x00,0x00,0x54,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7C,0x04,0x18,0x60,0x82,0x04,0x20,0x00,0x5A,0x00,0x20,0x00,0x5C,0x28,0x10,0x00,0x44,0x20,0x00,0x00,0x5C,0x20,0x04,0x00,0x5A,0x0C,0x30,0x40,0x82,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7C,0x04,0x18,0x60,0x82,0x04,0x20,0x00,0x5A,0x00,0x20,0x00,0x5C,0x28,0x10,0x00,0x44,0x20,0x00,0x00,0x58,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x24,0x04,0x00,0x20,0x5A,0x00,0x40,0x00,0xAC,0x00,0x44,0x08,0xB2,0x44,0x00,0x00,0xAA,0x24,0x00,0x00,0x5A,0x1C,0x00,0x00,0x22,0x00,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xAA,0x00,0x44,0x00,0xAA,0x04,0x40,0x00,0xBA,0x4C,0x30,0x00,0x82,0x44,0x00,0x00,0xBA,0x44,0x00,0x00,0xAA,0x44,0x00,0x00,0xAA,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7C,0x04,0x38,0x40,0x82,0x00,0x10,0x00,0x6C,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x6C,0x1C,0x20,0x40,0x82,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x0C,0x00,0x04,0x08,0x12,0x00,0x04,0x00,0x0A,0x04,0x00,0x00,0x0A,0x04,0x00,0x00,0x4A,0x04,0x00,0x40,0xAA,0x04,0x40,0x00,0xBA,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x64,0x00,0x24,0x40,0x9A,0x00,0x24,0x00,0x5A,0x20,0x08,0x00,0x54,0x20,0x10,0x00,0x48,0x28,0x00,0x00,0x54,0x24,0x00,0x00,0x5A,0x04,0x20,0x40,0x9A,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x70,0x00,0x30,0x40,0x88,0x00,0x20,0x00,0x50,0x00,0x20,0x00,0x50,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x54,0x24,0x00,0x00,0x5A,0x1C,0x20,0x40,0x82,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x04,0x40,0xAA,0x24,0x40,0x08,0x92,0x04,0x50,0x00,0xAA,0x14,0x40,0x00,0xAA,0x44,0x00,0x00,0xBA,0x44,0x00,0x00,0xAA,0x44,0x00,0x00,0xAA,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xAA,0x20,0x44,0x00,0x9A,0x14,0x40,0x00,0xAA,0x0C,0x40,0x00,0xB2,0x44,0x00,0x00,0xAA,0x44,0x00,0x00,0xAA,0x44,0x00,0x00,0xAA,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xBA,0x04,0x00,0x40,0xAA,0x04,0x40,0x00,0xAA,0x04,0x40,0x00,0xAA,0x04,0x40,0x00,0xBA,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x78,0x08,0x30,0x40,0x84,0x04,0x20,0x00,0x5A,0x04,0x20,0x00,0x5A,0x28,0x10,0x00,0x44,0x20,0x00,0x00,0x58,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xBA,0x04,0x00,0x40,0xAA,0x04,0x40,0x00,0xAA,0x04,0x40,0x00,0xBA,0x44,0x00,0x10,0xAA,0x30,0x08,0x00,0x44,0x04,0x00,0x00,0x3A,0x00,0x00,0x00,0x04,0x07,
	0x00,0x00,0x00,0x78,0x00,0x18,0x60,0x84,0x04,0x20,0x00,0x5A,0x24,0x00,0x00,0x5A,0x28,0x10,0x00,0x44,0x24,0x00,0x00,0x5A,0x24,0x00,0x00,0x5A,0x04,0x20,0x40,0x9A,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xBA,0x00,0x40,0x00,0xBC,0x08,0x30,0x00,0x44,0x04,0x00,0x00,0x7A,0x04,0x00,0x40,0xBA,0x08,0x30,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7C,0x04,0x18,0x60,0x82,0x14,0x40,0x00,0xAA,0x10,0x00,0x00,0x6C,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x08,0x10,0x20,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xAA,0x00,0x44,0x00,0xAA,0x04,0x40,0x00,0xAA,0x04,0x40,0x00,0xAA,0x44,0x00,0x00,0xAA,0x44,0x00,0x00,0xBA,0x3C,0x00,0x00,0x42,0x00,0x00,0x00,0x3C,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x04,0x40,0xAA,0x00,0x44,0x00,0xAA,0x04,0x40,0x00,0xAA,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xAA,0x00,0x04,0x40,0xAA,0x04,0x40,0x00,0xAA,0x04,0x40,0x00,0xBA,0x54,0x00,0x00,0xAA,0x6C,0x00,0x00,0x92,0x44,0x00,0x00,0xAA,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xAA,0x04,0x40,0x00,0xAA,0x28,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x08,0x20,0x00,0x54,0x04,0x00,0x40,0xAA,0x04,0x40,0x00,0xAA,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x04,0x00,0x40,0xAA,0x04,0x40,0x00,0xAA,0x04,0x40,0x00,0xBA,0x38,0x00,0x00,0x44,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x08,0x10,0x20,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7C,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xBA,0x08,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x20,0x00,0x54,0x04,0x00,0x40,0xBA,0x3C,0x40,0x00,0x82,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7C,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xBA,0x08,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x20,0x00,0x54,0x04,0x00,0x40,0xBA,0x3C,0x40,0x00,0x82,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7C,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xBA,0x08,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x20,0x00,0x54,0x04,0x00,0x40,0xBA,0x3C,0x40,0x00,0x82,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7C,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xBA,0x08,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x20,0x00,0x54,0x04,0x00,0x40,0xBA,0x3C,0x40,0x00,0x82,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7C,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xBA,0x08,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x20,0x00,0x54,0x04,0x00,0x40,0xBA,0x3C,0x40,0x00,0x82,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7C,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xBA,0x08,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x20,0x00,0x54,0x04,0x00,0x40,0xBA,0x3C,0x40,0x00,0x82,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7C,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xBA,0x08,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x20,0x00,0x54,0x04,0x00,0x40,0xBA,0x3C,0x40,0x00,0x82,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x28,0x10,0x44,0x04,0x00,0x00,0x3A,0x04,0x08,0x30,0x42,0x04,0x40,0x00,0xBA,0x3C,0x00,0x00,0x42,0x00,0x00,0x00,0x3C,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x00,0x20,0x00,0x58,0x00,0x28,0x00,0x54,0x04,0x20,0x10,0x4A,0x04,0x20,0x00,0x5A,0x04,0x20,0x00,0x5A,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xBA,0x00,0x40,0x00,0xA4,0x04,0x40,0x00,0xBA,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x0C,0x00,0x04,0x08,0x12,0x08,0x00,0x00,0x34,0x08,0x20,0x00,0x54,0x18,0x40,0x00,0xA4,0x08,0x40,0x00,0xB4,0x08,0x40,0x00,0xB4,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xBA,0x3C,0x40,0x00,0x82,0x00,0x40,0x00,0xBC,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x18,0x00,0x08,0x10,0x24,0x04,0x00,0x20,0x5A,0x00,0x20,0x00,0x54,0x10,0x20,0x40,0x88,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x30,0x40,0x00,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x34,0x04,0x10,0x20,0x4A,0x08,0x00,0x40,0xB4,0x08,0x40,0x00,0xB4,0x38,0x00,0x00,0x44,0x04,0x00,0x40,0xBA,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x07,
	0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x00,0x20,0x00,0x58,0x20,0x08,0x00,0x54,0x24,0x00,0x10,0x4A,0x24,0x00,0x00,0x5A,0x24,0x00,0x00,0x5A,0x04,0x20,0x40,0x9A,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x00,0x00,0x00,0x60,0x00,0x40,0x20,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x04,0x00,0x00,0x04,0x0A,0x00,0x00,0x00,0x04,0x00,0x00,0x04,0x0A,0x00,0x04,0x00,0x0A,0x04,0x00,0x00,0x0A,0x04,0x00,0x00,0x4A,0x04,0x00,0x40,0xBA,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x07,
	0x00,0x00,0x00,0x60,0x00,0x00,0x60,0x90,0x00,0x20,0x00,0x54,0x20,0x04,0x00,0x5A,0x20,0x00,0x08,0x54,0x20,0x10,0x00,0x48,0x28,0x00,0x00,0x54,0x04,0x20,0x40,0x9A,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xB4,0x24,0x48,0x00,0x92,0x44,0x10,0x00,0xAA,0x44,0x00,0x00,0xBA,0x44,0x00,0x00,0xAA,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x08,0x10,0x60,0x84,0x04,0x00,0x40,0xBA,0x04,0x40,0x00,0xAA,0x44,0x00,0x00,0xAA,0x44,0x00,0x00,0xAA,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xBA,0x04,0x40,0x00,0xAA,0x44,0x00,0x00,0xBA,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x00,0x08,0x50,0xA4,0x04,0x20,0x00,0x5A,0x24,0x00,0x00,0x5A,0x38,0x00,0x00,0x44,0x20,0x00,0x00,0x58,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x34,0x00,0x14,0x20,0x4A,0x08,0x40,0x00,0xB4,0x48,0x00,0x00,0xB4,0x38,0x00,0x00,0x44,0x08,0x00,0x00,0x34,0x04,0x08,0x10,0x22,0x00,0x00,0x00,0x1C,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x00,0x08,0x50,0xA4,0x04,0x20,0x00,0x5A,0x24,0x00,0x00,0x5A,0x20,0x00,0x00,0x54,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x04,0x18,0x20,0x42,0x00,0x40,0x00,0xBC,0x38,0x00,0x00,0x44,0x04,0x00,0x00,0x7A,0x38,0x00,0x40,0x84,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x00,0x20,0x00,0x58,0x08,0x30,0x40,0x84,0x20,0x00,0x00,0x58,0x20,0x00,0x00,0x54,0x04,0x20,0x00,0x5A,0x08,0x10,0x00,0x24,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xB4,0x00,0x48,0x00,0xB4,0x08,0x40,0x00,0xB4,0x48,0x00,0x00,0xB4,0x34,0x00,0x00,0x4A,0x00,0x00,0x00,0x34,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xAA,0x00,0x44,0x00,0xAA,0x04,0x40,0x00,0xAA,0x28,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xAA,0x00,0x44,0x00,0xBA,0x14,0x40,0x00,0xAA,0x2C,0x40,0x00,0x92,0x48,0x00,0x00,0xB4,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xAA,0x00,0x28,0x00,0x54,0x10,0x00,0x00,0x28,0x08,0x20,0x00,0x54,0x04,0x40,0x00,0xAA,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xAA,0x00,0x44,0x00,0xAA,0x04,0x40,0x00,0xBA,0x38,0x00,0x00,0x44,0x00,0x10,0x00,0x68,0x00,0x20,0x40,0x90,0x00,0x00,0x00,0x60,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x04,0x38,0x40,0x82,0x08,0x40,0x00,0xB4,0x00,0x10,0x00,0x6C,0x04,0x20,0x00,0x5A,0x3C,0x00,0x40,0x82,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x07
};

static const byte german_simon1AGAFontData[] = {
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x20,0x10,0x40,0x88,0x30,0x40,0x00,0x88,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x30,0x00,0x10,0x20,0x48,0x10,0x20,0x00,0x48,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x00,0x00,0x38,0x00,0x28,0x10,0x44,0x04,0x00,0x00,0x3a,0x04,0x08,0x30,0x42,0x04,0x40,0x00,0xba,0x3c,0x00,0x00,0x42,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xaa,0x44,0x00,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x50,0x00,0x00,0x50,0xa8,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xb4,0x00,0x48,0x00,0xb4,0x08,0x40,0x00,0xb4,0x48,0x00,0x00,0xb4,0x34,0x00,0x00,0x4a,0x00,0x00,0x00,0x34,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x10,0x00,0x40,0xa8,0x18,0x20,0x00,0x44,0x10,0x00,0x00,0x28,0x18,0x20,0x00,0x44,0x10,0x00,0x40,0xac,0x0c,0x20,0x00,0x52,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x30,0x00,0x10,0x20,0x48,0x10,0x20,0x00,0x48,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x28,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x28,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x28,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x30,0x10,0x20,0x00,0x48,0x08,0x00,0x40,0xb4,0x08,0x40,0x00,0xb4,0x50,0x00,0x00,0xa8,0x48,0x00,0x00,0xb4,0x48,0x00,0x00,0xb4,0x50,0x00,0x00,0xa8,0x40,0x00,0x00,0xa0,0x00,0x00,0x00,0x00,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x10,0x20,0x48,0x10,0x20,0x00,0x48,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x05,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x18,0x20,0x40,0x84,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x04,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x0c,0x70,0x00,0x82,0x04,0x40,0x00,0xba,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xba,0x0c,0x00,0x40,0xb2,0x04,0x50,0x00,0xaa,0x44,0x20,0x00,0x9a,0x44,0x00,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x00,0x20,0x40,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x04,0x00,0x00,0x5a,0x08,0x10,0x00,0x24,0x00,0x20,0x00,0x5c,0x00,0x04,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x00,0x00,0x5a,0x00,0x08,0x10,0x24,0x04,0x00,0x00,0x5a,0x04,0x00,0x40,0xba,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x08,0x00,0x08,0x00,0x14,0x08,0x00,0x10,0x24,0x08,0x00,0x20,0x54,0x08,0x40,0x00,0xb4,0x3c,0x40,0x00,0x82,0x08,0x00,0x00,0x74,0x04,0x08,0x10,0x22,0x00,0x00,0x00,0x1c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x18,0x60,0x82,0x00,0x40,0x00,0xbc,0x78,0x00,0x00,0x84,0x04,0x00,0x00,0x7a,0x04,0x00,0x00,0x4a,0x04,0x00,0x40,0xba,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x18,0x08,0x10,0x00,0x24,0x00,0x00,0x20,0x58,0x00,0x40,0x00,0xb8,0x38,0x40,0x00,0x84,0x44,0x00,0x00,0xba,0x44,0x00,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xba,0x00,0x04,0x00,0x4a,0x00,0x00,0x08,0x14,0x00,0x10,0x00,0x28,0x00,0x10,0x00,0x28,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xba,0x18,0x20,0x00,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xba,0x1c,0x20,0x00,0x42,0x04,0x00,0x00,0x3a,0x00,0x08,0x00,0x34,0x00,0x10,0x20,0x48,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x04,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x00,0x00,0x6c,0x00,0x00,0x44,0xaa,0x00,0x44,0x00,0xaa,0x04,0x40,0x00,0xaa,0x44,0x00,0x00,0xaa,0x3c,0x00,0x00,0x42,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x50,0x00,0x00,0x50,0xa8,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xb4,0x00,0x48,0x00,0xb4,0x08,0x40,0x00,0xb4,0x48,0x00,0x00,0xb4,0x34,0x00,0x00,0x4a,0x00,0x00,0x00,0x34,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x10,0x28,0x00,0x08,0x20,0x54,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x40,0x00,0xbc,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x40,0x00,0xba,0x04,0x00,0x00,0x4a,0x08,0x00,0x00,0x14,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x20,0x50,0x00,0x10,0x40,0xa8,0x00,0x00,0x00,0x60,0x00,0x40,0x20,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x00,0x40,0xba,0x0c,0x70,0x00,0x82,0x04,0x40,0x00,0xba,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x78,0x08,0x10,0x60,0x84,0x04,0x00,0x20,0x5a,0x04,0x20,0x00,0x5a,0x28,0x10,0x00,0x44,0x24,0x00,0x00,0x5a,0x24,0x00,0x00,0x5a,0x18,0x20,0x40,0x84,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x24,0x04,0x00,0x20,0x5a,0x00,0x00,0x40,0xa4,0x00,0x00,0x40,0xa0,0x00,0x40,0x00,0xa4,0x24,0x00,0x00,0x5a,0x18,0x00,0x00,0x24,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x70,0x10,0x20,0x40,0x88,0x08,0x20,0x00,0x54,0x04,0x20,0x00,0x5a,0x04,0x20,0x00,0x5a,0x24,0x00,0x00,0x5a,0x28,0x00,0x00,0x54,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x18,0x60,0x82,0x04,0x20,0x00,0x5a,0x00,0x20,0x00,0x5c,0x28,0x10,0x00,0x44,0x20,0x00,0x00,0x5c,0x20,0x04,0x00,0x5a,0x0c,0x30,0x40,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x18,0x60,0x82,0x04,0x20,0x00,0x5a,0x00,0x20,0x00,0x5c,0x28,0x10,0x00,0x44,0x20,0x00,0x00,0x58,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x24,0x04,0x00,0x20,0x5a,0x00,0x40,0x00,0xac,0x00,0x44,0x08,0xb2,0x44,0x00,0x00,0xaa,0x24,0x00,0x00,0x5a,0x1c,0x00,0x00,0x22,0x00,0x00,0x00,0x1c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x44,0x00,0xaa,0x04,0x40,0x00,0xba,0x4c,0x30,0x00,0x82,0x44,0x00,0x00,0xba,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x00,0x10,0x00,0x6c,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x6c,0x1c,0x20,0x40,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x0c,0x00,0x04,0x08,0x12,0x00,0x04,0x00,0x0a,0x04,0x00,0x00,0x0a,0x04,0x00,0x00,0x4a,0x04,0x00,0x40,0xaa,0x04,0x40,0x00,0xba,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x64,0x00,0x24,0x40,0x9a,0x00,0x24,0x00,0x5a,0x20,0x08,0x00,0x54,0x20,0x10,0x00,0x48,0x28,0x00,0x00,0x54,0x24,0x00,0x00,0x5a,0x04,0x20,0x40,0x9a,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x70,0x00,0x30,0x40,0x88,0x00,0x20,0x00,0x50,0x00,0x20,0x00,0x50,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x54,0x24,0x00,0x00,0x5a,0x1c,0x20,0x40,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x04,0x40,0xaa,0x24,0x40,0x08,0x92,0x04,0x50,0x00,0xaa,0x14,0x40,0x00,0xaa,0x44,0x00,0x00,0xba,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x20,0x44,0x00,0x9a,0x14,0x40,0x00,0xaa,0x0c,0x40,0x00,0xb2,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x00,0x40,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x78,0x08,0x30,0x40,0x84,0x04,0x20,0x00,0x5a,0x04,0x20,0x00,0x5a,0x28,0x10,0x00,0x44,0x20,0x00,0x00,0x58,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x00,0x40,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xba,0x44,0x00,0x10,0xaa,0x30,0x08,0x00,0x44,0x04,0x00,0x00,0x3a,0x00,0x00,0x00,0x04,0x07,
	0x00,0x00,0x00,0x78,0x00,0x18,0x60,0x84,0x04,0x20,0x00,0x5a,0x24,0x00,0x00,0x5a,0x28,0x10,0x00,0x44,0x24,0x00,0x00,0x5a,0x24,0x00,0x00,0x5a,0x04,0x20,0x40,0x9a,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xba,0x00,0x40,0x00,0xbc,0x08,0x30,0x00,0x44,0x04,0x00,0x00,0x7a,0x04,0x00,0x40,0xba,0x08,0x30,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x18,0x60,0x82,0x14,0x40,0x00,0xaa,0x10,0x00,0x00,0x6c,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x08,0x10,0x20,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x44,0x00,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xaa,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xba,0x3c,0x00,0x00,0x42,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x04,0x40,0xaa,0x00,0x44,0x00,0xaa,0x04,0x40,0x00,0xaa,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x04,0x40,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xba,0x54,0x00,0x00,0xaa,0x6c,0x00,0x00,0x92,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x04,0x40,0x00,0xaa,0x28,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x08,0x20,0x00,0x54,0x04,0x00,0x40,0xaa,0x04,0x40,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x04,0x00,0x40,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x08,0x10,0x20,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xba,0x08,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x20,0x00,0x54,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xba,0x08,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x20,0x00,0x54,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xba,0x08,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x20,0x00,0x54,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xb4,0x00,0x48,0x00,0xb4,0x10,0x00,0x00,0x68,0x00,0x20,0x00,0x58,0x00,0x08,0x40,0xb4,0x08,0x40,0x00,0xb4,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x00,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xa0,0x00,0x40,0x00,0xb8,0x38,0x00,0x00,0x44,0x10,0x00,0x00,0x28,0x00,0x10,0x20,0x48,0x00,0x00,0x00,0x30,0x06,
	0x00,0x00,0x00,0x50,0x00,0x00,0x50,0xa8,0x00,0x00,0x00,0x50,0x00,0x40,0x20,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x20,0x50,0x00,0x10,0x00,0x28,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xb4,0x00,0x48,0x00,0xb4,0x08,0x40,0x00,0xb4,0x48,0x00,0x00,0xb4,0x34,0x00,0x00,0x4a,0x00,0x00,0x00,0x34,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x28,0x10,0x44,0x04,0x00,0x00,0x3a,0x04,0x08,0x30,0x42,0x04,0x40,0x00,0xba,0x3c,0x00,0x00,0x42,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x00,0x20,0x00,0x58,0x00,0x28,0x00,0x54,0x04,0x20,0x10,0x4a,0x04,0x20,0x00,0x5a,0x04,0x20,0x00,0x5a,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x00,0x40,0x00,0xa4,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x0c,0x00,0x04,0x08,0x12,0x08,0x00,0x00,0x34,0x08,0x20,0x00,0x54,0x18,0x40,0x00,0xa4,0x08,0x40,0x00,0xb4,0x08,0x40,0x00,0xb4,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x40,0x00,0xbc,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x18,0x00,0x08,0x10,0x24,0x04,0x00,0x20,0x5a,0x00,0x20,0x00,0x54,0x10,0x20,0x40,0x88,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x30,0x40,0x00,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x34,0x04,0x10,0x20,0x4a,0x08,0x00,0x40,0xb4,0x08,0x40,0x00,0xb4,0x38,0x00,0x00,0x44,0x04,0x00,0x40,0xba,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x07,
	0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x00,0x20,0x00,0x58,0x20,0x08,0x00,0x54,0x24,0x00,0x10,0x4a,0x24,0x00,0x00,0x5a,0x24,0x00,0x00,0x5a,0x04,0x20,0x40,0x9a,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x00,0x00,0x00,0x60,0x00,0x40,0x20,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x04,0x00,0x00,0x04,0x0a,0x00,0x00,0x00,0x04,0x00,0x00,0x04,0x0a,0x00,0x04,0x00,0x0a,0x04,0x00,0x00,0x0a,0x04,0x00,0x00,0x4a,0x04,0x00,0x40,0xba,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x07,
	0x00,0x00,0x00,0x60,0x00,0x00,0x60,0x90,0x00,0x20,0x00,0x54,0x20,0x04,0x00,0x5a,0x20,0x00,0x08,0x54,0x20,0x10,0x00,0x48,0x28,0x00,0x00,0x54,0x04,0x20,0x40,0x9a,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xb4,0x24,0x48,0x00,0x92,0x44,0x10,0x00,0xaa,0x44,0x00,0x00,0xba,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x08,0x10,0x60,0x84,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xaa,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xaa,0x44,0x00,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x00,0x08,0x50,0xa4,0x04,0x20,0x00,0x5a,0x24,0x00,0x00,0x5a,0x38,0x00,0x00,0x44,0x20,0x00,0x00,0x58,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x34,0x00,0x14,0x20,0x4a,0x08,0x40,0x00,0xb4,0x48,0x00,0x00,0xb4,0x38,0x00,0x00,0x44,0x08,0x00,0x00,0x34,0x04,0x08,0x10,0x22,0x00,0x00,0x00,0x1c,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x00,0x08,0x50,0xa4,0x04,0x20,0x00,0x5a,0x24,0x00,0x00,0x5a,0x20,0x00,0x00,0x54,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3c,0x04,0x18,0x20,0x42,0x00,0x40,0x00,0xbc,0x38,0x00,0x00,0x44,0x04,0x00,0x00,0x7a,0x38,0x00,0x40,0x84,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x00,0x20,0x00,0x58,0x08,0x30,0x40,0x84,0x20,0x00,0x00,0x58,0x20,0x00,0x00,0x54,0x04,0x20,0x00,0x5a,0x08,0x10,0x00,0x24,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xb4,0x00,0x48,0x00,0xb4,0x08,0x40,0x00,0xb4,0x48,0x00,0x00,0xb4,0x34,0x00,0x00,0x4a,0x00,0x00,0x00,0x34,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x44,0x00,0xaa,0x04,0x40,0x00,0xaa,0x28,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x44,0x00,0xba,0x14,0x40,0x00,0xaa,0x2c,0x40,0x00,0x92,0x48,0x00,0x00,0xb4,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x28,0x00,0x54,0x10,0x00,0x00,0x28,0x08,0x20,0x00,0x54,0x04,0x40,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x44,0x00,0xaa,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x10,0x00,0x68,0x00,0x20,0x40,0x90,0x00,0x00,0x00,0x60,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x08,0x40,0x00,0xb4,0x00,0x10,0x00,0x6c,0x04,0x20,0x00,0x5a,0x3c,0x00,0x40,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07
};

static const byte french_simon1AGAFontData[] = {
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x20,0x10,0x40,0x88,0x30,0x40,0x00,0x88,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x30,0x00,0x10,0x20,0x48,0x10,0x20,0x00,0x48,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x10,0x28,0x00,0x08,0x20,0x54,0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xaa,0x44,0x00,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x10,0x28,0x00,0x08,0x20,0x54,0x00,0x00,0x00,0x38,0x00,0x28,0x10,0x44,0x04,0x00,0x00,0x3a,0x04,0x08,0x30,0x42,0x04,0x40,0x00,0xba,0x3c,0x00,0x00,0x42,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x00,0x40,0x00,0xa4,0x00,0x40,0x00,0xa0,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x10,0x00,0x00,0x28,0x00,0x10,0x20,0x48,0x00,0x00,0x00,0x30,0x07,
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x10,0x00,0x40,0xa8,0x18,0x20,0x00,0x44,0x10,0x00,0x00,0x28,0x18,0x20,0x00,0x44,0x10,0x00,0x40,0xac,0x0c,0x20,0x00,0x52,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x30,0x00,0x10,0x20,0x48,0x10,0x20,0x00,0x48,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x28,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x28,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x28,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x00,0x40,0x00,0xa4,0x00,0x40,0x00,0xa0,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x10,0x00,0x00,0x28,0x00,0x10,0x20,0x48,0x00,0x00,0x00,0x30,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x10,0x20,0x48,0x10,0x20,0x00,0x48,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x05,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x18,0x20,0x40,0x84,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x04,
	0x00,0x00,0x10,0x28,0x00,0x00,0x20,0x50,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x40,0x00,0xbc,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xba,0x0c,0x00,0x40,0xb2,0x04,0x50,0x00,0xaa,0x44,0x20,0x00,0x9a,0x44,0x00,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x00,0x20,0x40,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x04,0x00,0x00,0x5a,0x08,0x10,0x00,0x24,0x00,0x20,0x00,0x5c,0x00,0x04,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x00,0x00,0x5a,0x00,0x08,0x10,0x24,0x04,0x00,0x00,0x5a,0x04,0x00,0x40,0xba,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x08,0x00,0x08,0x00,0x14,0x08,0x00,0x10,0x24,0x08,0x00,0x20,0x54,0x08,0x40,0x00,0xb4,0x3c,0x40,0x00,0x82,0x08,0x00,0x00,0x74,0x04,0x08,0x10,0x22,0x00,0x00,0x00,0x1c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x18,0x60,0x82,0x00,0x40,0x00,0xbc,0x78,0x00,0x00,0x84,0x04,0x00,0x00,0x7a,0x04,0x00,0x00,0x4a,0x04,0x00,0x40,0xba,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x18,0x08,0x10,0x00,0x24,0x00,0x00,0x20,0x58,0x00,0x40,0x00,0xb8,0x38,0x40,0x00,0x84,0x44,0x00,0x00,0xba,0x44,0x00,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xba,0x00,0x04,0x00,0x4a,0x00,0x00,0x08,0x14,0x00,0x10,0x00,0x28,0x00,0x10,0x00,0x28,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xba,0x18,0x20,0x00,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xba,0x1c,0x20,0x00,0x42,0x04,0x00,0x00,0x3a,0x00,0x08,0x00,0x34,0x00,0x10,0x20,0x48,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x04,
	0x00,0x00,0x10,0x28,0x00,0x08,0x00,0x14,0x00,0x00,0x00,0x38,0x00,0x28,0x10,0x44,0x04,0x00,0x00,0x3a,0x04,0x08,0x30,0x42,0x04,0x40,0x00,0xba,0x3c,0x00,0x00,0x42,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x20,0x50,0x00,0x10,0x40,0xa8,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xb4,0x00,0x48,0x00,0xb4,0x08,0x40,0x00,0xb4,0x48,0x00,0x00,0xb4,0x34,0x00,0x00,0x4a,0x00,0x00,0x00,0x34,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x10,0x28,0x00,0x08,0x00,0x14,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x40,0x00,0xbc,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x10,0x28,0x00,0x08,0x20,0x54,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x40,0x00,0xbc,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x40,0x00,0xba,0x04,0x00,0x00,0x4a,0x08,0x00,0x00,0x14,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x20,0x50,0x00,0x10,0x40,0xa8,0x00,0x00,0x00,0x60,0x00,0x40,0x20,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x00,0x40,0xba,0x0c,0x70,0x00,0x82,0x04,0x40,0x00,0xba,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x78,0x08,0x10,0x60,0x84,0x04,0x00,0x20,0x5a,0x04,0x20,0x00,0x5a,0x28,0x10,0x00,0x44,0x24,0x00,0x00,0x5a,0x24,0x00,0x00,0x5a,0x18,0x20,0x40,0x84,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x24,0x04,0x00,0x20,0x5a,0x00,0x00,0x40,0xa4,0x00,0x00,0x40,0xa0,0x00,0x40,0x00,0xa4,0x24,0x00,0x00,0x5a,0x18,0x00,0x00,0x24,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x70,0x10,0x20,0x40,0x88,0x08,0x20,0x00,0x54,0x04,0x20,0x00,0x5a,0x04,0x20,0x00,0x5a,0x24,0x00,0x00,0x5a,0x28,0x00,0x00,0x54,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x18,0x60,0x82,0x04,0x20,0x00,0x5a,0x00,0x20,0x00,0x5c,0x28,0x10,0x00,0x44,0x20,0x00,0x00,0x5c,0x20,0x04,0x00,0x5a,0x0c,0x30,0x40,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x18,0x60,0x82,0x04,0x20,0x00,0x5a,0x00,0x20,0x00,0x5c,0x28,0x10,0x00,0x44,0x20,0x00,0x00,0x58,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x24,0x04,0x00,0x20,0x5a,0x00,0x40,0x00,0xac,0x00,0x44,0x08,0xb2,0x44,0x00,0x00,0xaa,0x24,0x00,0x00,0x5a,0x1c,0x00,0x00,0x22,0x00,0x00,0x00,0x1c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x44,0x00,0xaa,0x04,0x40,0x00,0xba,0x4c,0x30,0x00,0x82,0x44,0x00,0x00,0xba,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x00,0x10,0x00,0x6c,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x6c,0x1c,0x20,0x40,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x0c,0x00,0x04,0x08,0x12,0x00,0x04,0x00,0x0a,0x04,0x00,0x00,0x0a,0x04,0x00,0x00,0x4a,0x04,0x00,0x40,0xaa,0x04,0x40,0x00,0xba,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x64,0x00,0x24,0x40,0x9a,0x00,0x24,0x00,0x5a,0x20,0x08,0x00,0x54,0x20,0x10,0x00,0x48,0x28,0x00,0x00,0x54,0x24,0x00,0x00,0x5a,0x04,0x20,0x40,0x9a,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x70,0x00,0x30,0x40,0x88,0x00,0x20,0x00,0x50,0x00,0x20,0x00,0x50,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x54,0x24,0x00,0x00,0x5a,0x1c,0x20,0x40,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x04,0x40,0xaa,0x24,0x40,0x08,0x92,0x04,0x50,0x00,0xaa,0x14,0x40,0x00,0xaa,0x44,0x00,0x00,0xba,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x20,0x44,0x00,0x9a,0x14,0x40,0x00,0xaa,0x0c,0x40,0x00,0xb2,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x00,0x40,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x78,0x08,0x30,0x40,0x84,0x04,0x20,0x00,0x5a,0x04,0x20,0x00,0x5a,0x28,0x10,0x00,0x44,0x20,0x00,0x00,0x58,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x00,0x40,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xba,0x44,0x00,0x10,0xaa,0x30,0x08,0x00,0x44,0x04,0x00,0x00,0x3a,0x00,0x00,0x00,0x04,0x07,
	0x00,0x00,0x00,0x78,0x00,0x18,0x60,0x84,0x04,0x20,0x00,0x5a,0x24,0x00,0x00,0x5a,0x28,0x10,0x00,0x44,0x24,0x00,0x00,0x5a,0x24,0x00,0x00,0x5a,0x04,0x20,0x40,0x9a,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xba,0x00,0x40,0x00,0xbc,0x08,0x30,0x00,0x44,0x04,0x00,0x00,0x7a,0x04,0x00,0x40,0xba,0x08,0x30,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x18,0x60,0x82,0x14,0x40,0x00,0xaa,0x10,0x00,0x00,0x6c,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x08,0x10,0x20,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x44,0x00,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xaa,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xba,0x3c,0x00,0x00,0x42,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x04,0x40,0xaa,0x00,0x44,0x00,0xaa,0x04,0x40,0x00,0xaa,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x04,0x40,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xba,0x54,0x00,0x00,0xaa,0x6c,0x00,0x00,0x92,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x04,0x40,0x00,0xaa,0x28,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x08,0x20,0x00,0x54,0x04,0x00,0x40,0xaa,0x04,0x40,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x04,0x00,0x40,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x08,0x10,0x20,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xba,0x08,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x20,0x00,0x54,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xba,0x08,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x20,0x00,0x54,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xba,0x08,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x20,0x00,0x54,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xb4,0x00,0x48,0x00,0xb4,0x10,0x00,0x00,0x68,0x00,0x20,0x00,0x58,0x00,0x08,0x40,0xb4,0x08,0x40,0x00,0xb4,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x00,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xa0,0x00,0x40,0x00,0xb8,0x38,0x00,0x00,0x44,0x10,0x00,0x00,0x28,0x00,0x10,0x20,0x48,0x00,0x00,0x00,0x30,0x06,
	0x00,0x00,0x00,0x50,0x00,0x00,0x50,0xa8,0x00,0x00,0x00,0x50,0x00,0x40,0x20,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x20,0x50,0x00,0x10,0x00,0x28,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xb4,0x00,0x48,0x00,0xb4,0x08,0x40,0x00,0xb4,0x48,0x00,0x00,0xb4,0x34,0x00,0x00,0x4a,0x00,0x00,0x00,0x34,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x28,0x10,0x44,0x04,0x00,0x00,0x3a,0x04,0x08,0x30,0x42,0x04,0x40,0x00,0xba,0x3c,0x00,0x00,0x42,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x00,0x20,0x00,0x58,0x00,0x28,0x00,0x54,0x04,0x20,0x10,0x4a,0x04,0x20,0x00,0x5a,0x04,0x20,0x00,0x5a,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x00,0x40,0x00,0xa4,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x0c,0x00,0x04,0x08,0x12,0x08,0x00,0x00,0x34,0x08,0x20,0x00,0x54,0x18,0x40,0x00,0xa4,0x08,0x40,0x00,0xb4,0x08,0x40,0x00,0xb4,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x40,0x00,0xbc,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x18,0x00,0x08,0x10,0x24,0x04,0x00,0x20,0x5a,0x00,0x20,0x00,0x54,0x10,0x20,0x40,0x88,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x30,0x40,0x00,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x34,0x04,0x10,0x20,0x4a,0x08,0x00,0x40,0xb4,0x08,0x40,0x00,0xb4,0x38,0x00,0x00,0x44,0x04,0x00,0x40,0xba,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x07,
	0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x00,0x20,0x00,0x58,0x20,0x08,0x00,0x54,0x24,0x00,0x10,0x4a,0x24,0x00,0x00,0x5a,0x24,0x00,0x00,0x5a,0x04,0x20,0x40,0x9a,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x00,0x00,0x00,0x60,0x00,0x40,0x20,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x04,0x00,0x00,0x04,0x0a,0x00,0x00,0x00,0x04,0x00,0x00,0x04,0x0a,0x00,0x04,0x00,0x0a,0x04,0x00,0x00,0x0a,0x04,0x00,0x00,0x4a,0x04,0x00,0x40,0xba,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x07,
	0x00,0x00,0x00,0x60,0x00,0x00,0x60,0x90,0x00,0x20,0x00,0x54,0x20,0x04,0x00,0x5a,0x20,0x00,0x08,0x54,0x20,0x10,0x00,0x48,0x28,0x00,0x00,0x54,0x04,0x20,0x40,0x9a,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xb4,0x24,0x48,0x00,0x92,0x44,0x10,0x00,0xaa,0x44,0x00,0x00,0xba,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x08,0x10,0x60,0x84,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xaa,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xaa,0x44,0x00,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x00,0x08,0x50,0xa4,0x04,0x20,0x00,0x5a,0x24,0x00,0x00,0x5a,0x38,0x00,0x00,0x44,0x20,0x00,0x00,0x58,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x34,0x00,0x14,0x20,0x4a,0x08,0x40,0x00,0xb4,0x48,0x00,0x00,0xb4,0x38,0x00,0x00,0x44,0x08,0x00,0x00,0x34,0x04,0x08,0x10,0x22,0x00,0x00,0x00,0x1c,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x00,0x08,0x50,0xa4,0x04,0x20,0x00,0x5a,0x24,0x00,0x00,0x5a,0x20,0x00,0x00,0x54,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3c,0x04,0x18,0x20,0x42,0x00,0x40,0x00,0xbc,0x38,0x00,0x00,0x44,0x04,0x00,0x00,0x7a,0x38,0x00,0x40,0x84,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x00,0x20,0x00,0x58,0x08,0x30,0x40,0x84,0x20,0x00,0x00,0x58,0x20,0x00,0x00,0x54,0x04,0x20,0x00,0x5a,0x08,0x10,0x00,0x24,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xb4,0x00,0x48,0x00,0xb4,0x08,0x40,0x00,0xb4,0x48,0x00,0x00,0xb4,0x34,0x00,0x00,0x4a,0x00,0x00,0x00,0x34,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x44,0x00,0xaa,0x04,0x40,0x00,0xaa,0x28,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x44,0x00,0xba,0x14,0x40,0x00,0xaa,0x2c,0x40,0x00,0x92,0x48,0x00,0x00,0xb4,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x28,0x00,0x54,0x10,0x00,0x00,0x28,0x08,0x20,0x00,0x54,0x04,0x40,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x44,0x00,0xaa,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x10,0x00,0x68,0x00,0x20,0x40,0x90,0x00,0x00,0x00,0x60,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x08,0x40,0x00,0xb4,0x00,0x10,0x00,0x6c,0x04,0x20,0x00,0x5a,0x3c,0x00,0x40,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07
};

static const byte italian_simon1AGAFontData[] = {
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x20,0x10,0x40,0x88,0x30,0x40,0x00,0x88,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x30,0x00,0x10,0x20,0x48,0x10,0x20,0x00,0x48,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x00,0x00,0x38,0x00,0x28,0x10,0x44,0x04,0x00,0x00,0x3a,0x04,0x08,0x30,0x42,0x04,0x40,0x00,0xba,0x3c,0x00,0x00,0x42,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xaa,0x44,0x00,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x10,0x28,0x00,0x08,0x00,0x14,0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xaa,0x44,0x00,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x10,0x00,0x40,0xa8,0x18,0x20,0x00,0x44,0x10,0x00,0x00,0x28,0x18,0x20,0x00,0x44,0x10,0x00,0x40,0xac,0x0c,0x20,0x00,0x52,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x30,0x00,0x10,0x20,0x48,0x10,0x20,0x00,0x48,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x28,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x28,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x28,0x00,0x00,0x28,0x54,0x00,0x28,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x1c,0x20,0x40,0x82,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x20,0x50,0x00,0x10,0x00,0x28,0x00,0x00,0x00,0x60,0x00,0x40,0x20,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x10,0x20,0x48,0x10,0x20,0x00,0x48,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x05,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x18,0x20,0x40,0x84,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x04,
	0x00,0x00,0x10,0x28,0x00,0x00,0x20,0x50,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x40,0x00,0xbc,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xba,0x0c,0x00,0x40,0xb2,0x04,0x50,0x00,0xaa,0x44,0x20,0x00,0x9a,0x44,0x00,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x00,0x20,0x40,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x04,0x00,0x00,0x5a,0x08,0x10,0x00,0x24,0x00,0x20,0x00,0x5c,0x00,0x04,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x00,0x00,0x5a,0x00,0x08,0x10,0x24,0x04,0x00,0x00,0x5a,0x04,0x00,0x40,0xba,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x08,0x00,0x08,0x00,0x14,0x08,0x00,0x10,0x24,0x08,0x00,0x20,0x54,0x08,0x40,0x00,0xb4,0x3c,0x40,0x00,0x82,0x08,0x00,0x00,0x74,0x04,0x08,0x10,0x22,0x00,0x00,0x00,0x1c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x18,0x60,0x82,0x00,0x40,0x00,0xbc,0x78,0x00,0x00,0x84,0x04,0x00,0x00,0x7a,0x04,0x00,0x00,0x4a,0x04,0x00,0x40,0xba,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x18,0x08,0x10,0x00,0x24,0x00,0x00,0x20,0x58,0x00,0x40,0x00,0xb8,0x38,0x40,0x00,0x84,0x44,0x00,0x00,0xba,0x44,0x00,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xba,0x00,0x04,0x00,0x4a,0x00,0x00,0x08,0x14,0x00,0x10,0x00,0x28,0x00,0x10,0x00,0x28,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xba,0x18,0x20,0x00,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xba,0x1c,0x20,0x00,0x42,0x04,0x00,0x00,0x3a,0x00,0x08,0x00,0x34,0x00,0x10,0x20,0x48,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x20,0x40,0x00,0x90,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x04,
	0x00,0x00,0x10,0x28,0x00,0x08,0x00,0x14,0x00,0x00,0x00,0x38,0x00,0x28,0x10,0x44,0x04,0x00,0x00,0x3a,0x04,0x08,0x30,0x42,0x04,0x40,0x00,0xba,0x3c,0x00,0x00,0x42,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x10,0x28,0x00,0x08,0x00,0x14,0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xaa,0x44,0x00,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x10,0x28,0x00,0x08,0x00,0x14,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x40,0x00,0xbc,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x10,0x28,0x00,0x08,0x20,0x54,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x40,0x00,0xbc,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x40,0x00,0xba,0x04,0x00,0x00,0x4a,0x08,0x00,0x00,0x14,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x20,0x50,0x00,0x10,0x40,0xa8,0x00,0x00,0x00,0x60,0x00,0x40,0x20,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x00,0x40,0xba,0x0c,0x70,0x00,0x82,0x04,0x40,0x00,0xba,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x78,0x08,0x10,0x60,0x84,0x04,0x00,0x20,0x5a,0x04,0x20,0x00,0x5a,0x28,0x10,0x00,0x44,0x24,0x00,0x00,0x5a,0x24,0x00,0x00,0x5a,0x18,0x20,0x40,0x84,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x24,0x04,0x00,0x20,0x5a,0x00,0x00,0x40,0xa4,0x00,0x00,0x40,0xa0,0x00,0x40,0x00,0xa4,0x24,0x00,0x00,0x5a,0x18,0x00,0x00,0x24,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x70,0x10,0x20,0x40,0x88,0x08,0x20,0x00,0x54,0x04,0x20,0x00,0x5a,0x04,0x20,0x00,0x5a,0x24,0x00,0x00,0x5a,0x28,0x00,0x00,0x54,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x18,0x60,0x82,0x04,0x20,0x00,0x5a,0x00,0x20,0x00,0x5c,0x28,0x10,0x00,0x44,0x20,0x00,0x00,0x5c,0x20,0x04,0x00,0x5a,0x0c,0x30,0x40,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x18,0x60,0x82,0x04,0x20,0x00,0x5a,0x00,0x20,0x00,0x5c,0x28,0x10,0x00,0x44,0x20,0x00,0x00,0x58,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x24,0x04,0x00,0x20,0x5a,0x00,0x40,0x00,0xac,0x00,0x44,0x08,0xb2,0x44,0x00,0x00,0xaa,0x24,0x00,0x00,0x5a,0x1c,0x00,0x00,0x22,0x00,0x00,0x00,0x1c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x44,0x00,0xaa,0x04,0x40,0x00,0xba,0x4c,0x30,0x00,0x82,0x44,0x00,0x00,0xba,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x00,0x10,0x00,0x6c,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x6c,0x1c,0x20,0x40,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x0c,0x00,0x04,0x08,0x12,0x00,0x04,0x00,0x0a,0x04,0x00,0x00,0x0a,0x04,0x00,0x00,0x4a,0x04,0x00,0x40,0xaa,0x04,0x40,0x00,0xba,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x64,0x00,0x24,0x40,0x9a,0x00,0x24,0x00,0x5a,0x20,0x08,0x00,0x54,0x20,0x10,0x00,0x48,0x28,0x00,0x00,0x54,0x24,0x00,0x00,0x5a,0x04,0x20,0x40,0x9a,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x70,0x00,0x30,0x40,0x88,0x00,0x20,0x00,0x50,0x00,0x20,0x00,0x50,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x54,0x24,0x00,0x00,0x5a,0x1c,0x20,0x40,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x04,0x40,0xaa,0x24,0x40,0x08,0x92,0x04,0x50,0x00,0xaa,0x14,0x40,0x00,0xaa,0x44,0x00,0x00,0xba,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x20,0x44,0x00,0x9a,0x14,0x40,0x00,0xaa,0x0c,0x40,0x00,0xb2,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x00,0x40,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x78,0x08,0x30,0x40,0x84,0x04,0x20,0x00,0x5a,0x04,0x20,0x00,0x5a,0x28,0x10,0x00,0x44,0x20,0x00,0x00,0x58,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x00,0x40,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xba,0x44,0x00,0x10,0xaa,0x30,0x08,0x00,0x44,0x04,0x00,0x00,0x3a,0x00,0x00,0x00,0x04,0x07,
	0x00,0x00,0x00,0x78,0x00,0x18,0x60,0x84,0x04,0x20,0x00,0x5a,0x24,0x00,0x00,0x5a,0x28,0x10,0x00,0x44,0x24,0x00,0x00,0x5a,0x24,0x00,0x00,0x5a,0x04,0x20,0x40,0x9a,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x38,0x00,0x18,0x20,0x44,0x04,0x00,0x40,0xba,0x00,0x40,0x00,0xbc,0x08,0x30,0x00,0x44,0x04,0x00,0x00,0x7a,0x04,0x00,0x40,0xba,0x08,0x30,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x18,0x60,0x82,0x14,0x40,0x00,0xaa,0x10,0x00,0x00,0x6c,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x08,0x10,0x20,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x44,0x00,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xaa,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xba,0x3c,0x00,0x00,0x42,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x04,0x40,0xaa,0x00,0x44,0x00,0xaa,0x04,0x40,0x00,0xaa,0x28,0x00,0x00,0x54,0x28,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x04,0x40,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xba,0x54,0x00,0x00,0xaa,0x6c,0x00,0x00,0x92,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x04,0x40,0x00,0xaa,0x28,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x08,0x20,0x00,0x54,0x04,0x00,0x40,0xaa,0x04,0x40,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x44,0x04,0x00,0x40,0xaa,0x04,0x40,0x00,0xaa,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x10,0x00,0x00,0x28,0x10,0x00,0x00,0x28,0x08,0x10,0x20,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xba,0x08,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x20,0x00,0x54,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xba,0x08,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x20,0x00,0x54,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x04,0x40,0x00,0xba,0x08,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x20,0x00,0x54,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xb4,0x00,0x48,0x00,0xb4,0x10,0x00,0x00,0x68,0x00,0x20,0x00,0x58,0x00,0x08,0x40,0xb4,0x08,0x40,0x00,0xb4,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x00,0x06,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xa0,0x00,0x40,0x00,0xb8,0x38,0x00,0x00,0x44,0x10,0x00,0x00,0x28,0x00,0x10,0x20,0x48,0x00,0x00,0x00,0x30,0x06,
	0x00,0x00,0x00,0x50,0x00,0x00,0x50,0xa8,0x00,0x00,0x00,0x50,0x00,0x40,0x20,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x20,0x50,0x00,0x10,0x00,0x28,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xb4,0x00,0x48,0x00,0xb4,0x08,0x40,0x00,0xb4,0x48,0x00,0x00,0xb4,0x34,0x00,0x00,0x4a,0x00,0x00,0x00,0x34,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x28,0x10,0x44,0x04,0x00,0x00,0x3a,0x04,0x08,0x30,0x42,0x04,0x40,0x00,0xba,0x3c,0x00,0x00,0x42,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x00,0x20,0x00,0x58,0x00,0x28,0x00,0x54,0x04,0x20,0x10,0x4a,0x04,0x20,0x00,0x5a,0x04,0x20,0x00,0x5a,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x00,0x40,0x00,0xa4,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x0c,0x00,0x04,0x08,0x12,0x08,0x00,0x00,0x34,0x08,0x20,0x00,0x54,0x18,0x40,0x00,0xa4,0x08,0x40,0x00,0xb4,0x08,0x40,0x00,0xb4,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x08,0x30,0x44,0x04,0x00,0x40,0xba,0x3c,0x40,0x00,0x82,0x00,0x40,0x00,0xbc,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x18,0x00,0x08,0x10,0x24,0x04,0x00,0x20,0x5a,0x00,0x20,0x00,0x54,0x10,0x20,0x40,0x88,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x30,0x40,0x00,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x34,0x04,0x10,0x20,0x4a,0x08,0x00,0x40,0xb4,0x08,0x40,0x00,0xb4,0x38,0x00,0x00,0x44,0x04,0x00,0x40,0xba,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x07,
	0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x00,0x20,0x00,0x58,0x20,0x08,0x00,0x54,0x24,0x00,0x10,0x4a,0x24,0x00,0x00,0x5a,0x24,0x00,0x00,0x5a,0x04,0x20,0x40,0x9a,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x00,0x00,0x00,0x60,0x00,0x40,0x20,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x04,0x00,0x00,0x04,0x0a,0x00,0x00,0x00,0x04,0x00,0x00,0x04,0x0a,0x00,0x04,0x00,0x0a,0x04,0x00,0x00,0x0a,0x04,0x00,0x00,0x4a,0x04,0x00,0x40,0xba,0x18,0x20,0x00,0x44,0x00,0x00,0x00,0x38,0x07,
	0x00,0x00,0x00,0x60,0x00,0x00,0x60,0x90,0x00,0x20,0x00,0x54,0x20,0x04,0x00,0x5a,0x20,0x00,0x08,0x54,0x20,0x10,0x00,0x48,0x28,0x00,0x00,0x54,0x04,0x20,0x40,0x9a,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x60,0x00,0x20,0x40,0x90,0x00,0x20,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x20,0x00,0x00,0x50,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x05,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xb4,0x24,0x48,0x00,0x92,0x44,0x10,0x00,0xaa,0x44,0x00,0x00,0xba,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x08,0x10,0x60,0x84,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xaa,0x44,0x00,0x00,0xaa,0x44,0x00,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x08,0x10,0x20,0x44,0x04,0x00,0x40,0xba,0x04,0x40,0x00,0xaa,0x44,0x00,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x00,0x08,0x50,0xa4,0x04,0x20,0x00,0x5a,0x24,0x00,0x00,0x5a,0x38,0x00,0x00,0x44,0x20,0x00,0x00,0x58,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x34,0x00,0x14,0x20,0x4a,0x08,0x40,0x00,0xb4,0x48,0x00,0x00,0xb4,0x38,0x00,0x00,0x44,0x08,0x00,0x00,0x34,0x04,0x08,0x10,0x22,0x00,0x00,0x00,0x1c,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x00,0x08,0x50,0xa4,0x04,0x20,0x00,0x5a,0x24,0x00,0x00,0x5a,0x20,0x00,0x00,0x54,0x10,0x20,0x40,0x88,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3c,0x04,0x18,0x20,0x42,0x00,0x40,0x00,0xbc,0x38,0x00,0x00,0x44,0x04,0x00,0x00,0x7a,0x38,0x00,0x40,0x84,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x50,0x00,0x20,0x00,0x58,0x08,0x30,0x40,0x84,0x20,0x00,0x00,0x58,0x20,0x00,0x00,0x54,0x04,0x20,0x00,0x5a,0x08,0x10,0x00,0x24,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x00,0x00,0x48,0xb4,0x00,0x48,0x00,0xb4,0x08,0x40,0x00,0xb4,0x48,0x00,0x00,0xb4,0x34,0x00,0x00,0x4a,0x00,0x00,0x00,0x34,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x44,0x00,0xaa,0x04,0x40,0x00,0xaa,0x28,0x00,0x00,0x54,0x10,0x00,0x00,0x28,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x44,0x00,0xba,0x14,0x40,0x00,0xaa,0x2c,0x40,0x00,0x92,0x48,0x00,0x00,0xb4,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x28,0x00,0x54,0x10,0x00,0x00,0x28,0x08,0x20,0x00,0x54,0x04,0x40,0x00,0xaa,0x00,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x44,0xaa,0x00,0x44,0x00,0xaa,0x04,0x40,0x00,0xba,0x38,0x00,0x00,0x44,0x00,0x10,0x00,0x68,0x00,0x20,0x40,0x90,0x00,0x00,0x00,0x60,0x07,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7c,0x04,0x38,0x40,0x82,0x08,0x40,0x00,0xb4,0x00,0x10,0x00,0x6c,0x04,0x20,0x00,0x5a,0x3c,0x00,0x40,0x82,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x07
};

void AGOSEngine::renderStringAmiga(uint vgaSpriteId, uint color, uint width, uint height, const char *txt) {
	VgaPointersEntry *vpe = &_vgaBufferPointers[2];
	byte *p, *dst, *dst_org, chr;
	uint count;

	if (vgaSpriteId >= 100) {
		vgaSpriteId -= 100;
		vpe++;
	}

	dst = vpe->vgaFile2;

	count = 2000;
	if (vgaSpriteId == 1)
		count *= 2;

	p = dst + vgaSpriteId * 8;
	WRITE_BE_UINT16(p + 4, height);
	WRITE_BE_UINT16(p + 6, width);
	dst += READ_BE_UINT32(p);

	width /= 8;	// convert width from pixels to bytes

	const byte *imgSrc = nullptr;
	switch (_language) {
	case Common::IT_ITA:
		imgSrc = italian_simon1AGAFontData;
		break;
	case Common::FR_FRA:
		imgSrc = french_simon1AGAFontData;
		break;
	case Common::DE_DEU:
		imgSrc = german_simon1AGAFontData;
		break;
	case Common::EN_ANY:
		imgSrc = english_simon1AGAFontData;
		break;
	default:
		error("renderStringAmiga: Unknown language %d", _language);
	}


	uint charsize = width * height;
	memset(dst, 0, count);
	dst_org = dst;
	int delta = 0;
	while ((chr = *txt++) != 0) {
		int img_width = 1;
		if (chr == 10) {
			dst += width * 10;
			dst_org = dst;
			delta = 0;
		} else if ((signed char)(chr -= '!') < 0) {
			img_width = 7;
		} else {
			const byte *img = imgSrc + chr * 41;
			img_width = img[40];
			byte *cur_dst = dst_org;
			for (int row = 0; row < 10; row++) {
				int col = color;
				for (int plane = 0; plane < 3; plane++) {
					chr = img[plane] >> delta;
					if (chr) {
						if (col & 1) cur_dst[charsize * 0] |= chr;
						if (col & 2) cur_dst[charsize * 1] |= chr;
						if (col & 4) cur_dst[charsize * 2] |= chr;
						if (col & 8) cur_dst[charsize * 3] |= chr;
					}
					chr = img[plane] << (8 - delta);
					if (((8 - delta) < img_width) && (chr)) {
						if (col & 1) cur_dst[charsize * 0 + 1] |= chr;
						if (col & 2) cur_dst[charsize * 1 + 1] |= chr;
						if (col & 4) cur_dst[charsize * 2 + 1] |= chr;
						if (col & 8) cur_dst[charsize * 3 + 1] |= chr;
					}
					col++;
				}
				chr = img[3] >> delta;
				if (chr) {
					cur_dst[charsize * 0] |= chr;
					cur_dst[charsize * 1] |= chr;
					cur_dst[charsize * 2] |= chr;
					cur_dst[charsize * 3] |= chr;
				}
				chr = img[3] << (8 - delta);
				if (((8 - delta) < img_width) && (chr)) {
					cur_dst[charsize * 0 + 1] |= chr;
					cur_dst[charsize * 1 + 1] |= chr;
					cur_dst[charsize * 2 + 1] |= chr;
					cur_dst[charsize * 3 + 1] |= chr;
				}
				cur_dst += width;
				img += 4;
			}
		}
		delta += img_width - 1;
		if (delta >= 8) {
			delta -= 8;
			dst_org++;
		}
	}
}

void AGOSEngine::renderString(uint vgaSpriteId, uint color, uint width, uint height, const char *txt) {
	VgaPointersEntry *vpe = &_vgaBufferPointers[2];
	byte *src, *dst, *p, *dst_org, chr;
	const int textHeight = (getGameType() == GType_FF || getGameType() == GType_PP) ? 15: 10;
	uint count = 0;

	if (vgaSpriteId >= 100) {
		vgaSpriteId -= 100;
		vpe++;
	}

	src = dst = vpe->vgaFile2;

	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		if (vgaSpriteId == 1)
			count = 45000;
	} else {
		count = 4000;
		if (vgaSpriteId == 1)
			count *= 2;
	}

	p = dst + vgaSpriteId * 8;

	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		if (vgaSpriteId != 1)
			WRITE_LE_UINT32(p, READ_LE_UINT32(p - 8) + READ_LE_UINT16(p - 4) * READ_LE_UINT16(p - 2));

		WRITE_LE_UINT16(p + 4, height);
		WRITE_LE_UINT16(p + 6, width);
	} else {
		WRITE_BE_UINT16(p + 4, height);
		WRITE_BE_UINT16(p + 6, width);
	}
	dst += readUint32Wrapper(p);

	if (count != 0)
		memset(dst, 0, count);

	if (_language == Common::HE_ISR)
		dst += width - 1; // For Hebrew, start at the right edge, not the left.

	dst_org = dst;
	while ((chr = *txt++) != 0) {
		if (chr == 10) {
			dst_org += width * textHeight;
			dst = dst_org;
		} else if ((chr -= ' ') == 0) {
			dst += (_language == Common::HE_ISR ? -6 : 6); // Hebrew moves to the left, all others to the right
		} else {
			byte *img_hdr, *img;
			uint i, img_width, img_height;

			if (getGameType() == GType_FF || getGameType() == GType_PP) {
				img_hdr = src + 96 + chr * 8;
				img_height = READ_LE_UINT16(img_hdr + 4);
				img_width = READ_LE_UINT16(img_hdr + 6);
				img = src + READ_LE_UINT32(img_hdr);
			} else {
				img_hdr = src + 48 + chr * 4;
				img_height = img_hdr[2];
				img_width = img_hdr[3];
				img = src + READ_LE_UINT16(img_hdr);
			}

			if (_language == Common::HE_ISR)
				dst -= img_width - 1; // For Hebrew, move from right edge to left edge of image.
			byte *cur_dst = dst;

			// Occurs in Amiga and Macintosh ports of The Feeble Files, when
			// special characters are used by French/German/Spanish versions.
			// Due to the English image data, been used by all languages.
			if (img_width == 0 || img_height == 0)
				continue;

			assert(img_width < 50 && img_height < 50);

			do {
				for (i = 0; i != img_width; i++) {
					chr = *img++;
					if (chr) {
						if (chr == 0xF)
							chr = 207;
						else
							chr += color;
						cur_dst[i] = chr;
					}
				}
				cur_dst += width;
			} while (--img_height);

			if (_language != Common::HE_ISR) // Hebrew character movement is done higher up
				dst += img_width - 1;
		}
	}
}

static const byte czech_simonFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x70, 0x70, 0x20, 0x20, 0x00, 0x20, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x50, 0x20, 0x78, 0x80, 0x70, 0x08, 0xf0, 0x00,
	0x10, 0x20, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x50, 0x20, 0xb0, 0x48, 0x48, 0x40, 0xe0, 0x00,
	0x00, 0x10, 0x28, 0x10, 0x2a, 0x44, 0x3a, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
	0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x3e, 0x08, 0x14, 0x00,
	0x00, 0x70, 0x88, 0xf0, 0x88, 0x88, 0xf0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
	0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
	0x50, 0x20, 0xf8, 0x90, 0x20, 0x48, 0xf8, 0x00,
	0x70, 0x88, 0x98, 0xa8, 0xc8, 0x88, 0x70, 0x00,
	0x20, 0x60, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x40, 0x88, 0xf8, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x08, 0x88, 0x70, 0x00,
	0x10, 0x30, 0x50, 0x90, 0xf8, 0x10, 0x38, 0x00,
	0xf8, 0x80, 0xf0, 0x08, 0x08, 0x88, 0x70, 0x00,
	0x30, 0x40, 0x80, 0xf0, 0x88, 0x88, 0x70, 0x00,
	0xf8, 0x88, 0x08, 0x10, 0x20, 0x20, 0x20, 0x00,
	0x70, 0x88, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x70, 0x88, 0x88, 0x78, 0x08, 0x10, 0x60, 0x00,
	0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00,
	0x08, 0x10, 0x70, 0x08, 0x78, 0x88, 0x78, 0x00,
	0x20, 0x50, 0x20, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x10, 0x20, 0x70, 0x88, 0xf8, 0x80, 0x70, 0x00,
	0x50, 0x20, 0x70, 0x88, 0xf8, 0x80, 0x70, 0x00,
	0x70, 0x88, 0x08, 0x10, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x40, 0xc0, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x70, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x00,
	0xf0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xf0, 0x00,
	0x30, 0x48, 0x80, 0x80, 0x80, 0x48, 0x30, 0x00,
	0xe0, 0x50, 0x48, 0x48, 0x48, 0x50, 0xe0, 0x00,
	0xf8, 0x48, 0x40, 0x70, 0x40, 0x48, 0xf8, 0x00,
	0xf8, 0x48, 0x40, 0x70, 0x40, 0x40, 0xe0, 0x00,
	0x30, 0x48, 0x80, 0x98, 0x88, 0x48, 0x38, 0x00,
	0x88, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x00,
	0xf8, 0x20, 0x20, 0x20, 0x20, 0x20, 0xf8, 0x00,
	0x18, 0x08, 0x08, 0x08, 0x88, 0x88, 0x70, 0x00,
	0xc8, 0x48, 0x50, 0x60, 0x50, 0x48, 0xc8, 0x00,
	0xe0, 0x40, 0x40, 0x40, 0x40, 0x48, 0xf8, 0x00,
	0x88, 0xd8, 0xa8, 0xa8, 0x88, 0x88, 0x88, 0x00,
	0x88, 0xc8, 0xa8, 0x98, 0x88, 0x88, 0x88, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0xf0, 0x48, 0x48, 0x70, 0x40, 0x40, 0xe0, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0xa8, 0x70, 0x08,
	0xf0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xc8, 0x00,
	0x70, 0x88, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00,
	0xf8, 0xa8, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x78, 0x00,
	0x88, 0x88, 0x88, 0x50, 0x50, 0x20, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x88, 0xa8, 0xd8, 0x88, 0x00,
	0x88, 0x88, 0x50, 0x20, 0x50, 0x88, 0x88, 0x00,
	0x88, 0x88, 0x88, 0x70, 0x20, 0x20, 0x70, 0x00,
	0xf8, 0x88, 0x10, 0x20, 0x40, 0x88, 0xf8, 0x00,
	0x00, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00,
	0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
	0x50, 0x20, 0x70, 0x88, 0x80, 0x88, 0x70, 0x00,
	0x10, 0x20, 0x88, 0x88, 0x88, 0x70, 0x20, 0xc0,
	0x10, 0x20, 0x90, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x70, 0x08, 0x78, 0x88, 0x78, 0x00,
	0xc0, 0x40, 0x50, 0x68, 0x48, 0x48, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x80, 0x88, 0x70, 0x00,
	0x18, 0x10, 0x50, 0xb0, 0x90, 0x90, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0xf8, 0x80, 0x70, 0x00,
	0x30, 0x48, 0x40, 0xe0, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x68, 0x90, 0x90, 0x70, 0x88, 0x70,
	0xc0, 0x40, 0x50, 0x68, 0x48, 0x48, 0xc8, 0x00,
	0x40, 0x00, 0xc0, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x08, 0x00, 0x08, 0x08, 0x08, 0x08, 0x88, 0x70,
	0xc0, 0x40, 0x48, 0x50, 0x60, 0x50, 0xc8, 0x00,
	0xc0, 0x40, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x90, 0xd8, 0xa8, 0x88, 0x88, 0x00,
	0x00, 0x00, 0xf0, 0x88, 0x88, 0x88, 0x88, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x00, 0xb0, 0x48, 0x48, 0x70, 0x40, 0xe0,
	0x00, 0x00, 0x68, 0x90, 0x90, 0x70, 0x10, 0x38,
	0x00, 0x00, 0xb0, 0x48, 0x48, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x78, 0x80, 0x70, 0x08, 0xf0, 0x00,
	0x40, 0x40, 0xf0, 0x40, 0x40, 0x48, 0x30, 0x00,
	0x00, 0x00, 0x90, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x88, 0x50, 0x20, 0x00,
	0x00, 0x00, 0x88, 0x88, 0xa8, 0xd8, 0x90, 0x00,
	0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x88, 0x70, 0x20, 0xc0,
	0x00, 0x00, 0xf8, 0x90, 0x20, 0x48, 0xf8, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x0e, 0x08, 0x30, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
	0x00, 0x70, 0x10, 0x0c, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00,
	0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc,
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
};

static const byte english_simonFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x70, 0x70, 0x20, 0x20, 0x00, 0x20, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x90, 0x00, 0x60, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x90, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x90, 0x00, 0x90, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x10, 0x28, 0x10, 0x2a, 0x44, 0x3a, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
	0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x3e, 0x08, 0x14, 0x00,
	0x00, 0x70, 0x88, 0xf0, 0x88, 0x88, 0xf0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
	0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
	0x10, 0x20, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x70, 0x88, 0x98, 0xa8, 0xc8, 0x88, 0x70, 0x00,
	0x20, 0x60, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x40, 0x88, 0xf8, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x08, 0x88, 0x70, 0x00,
	0x10, 0x30, 0x50, 0x90, 0xf8, 0x10, 0x38, 0x00,
	0xf8, 0x80, 0xf0, 0x08, 0x08, 0x88, 0x70, 0x00,
	0x30, 0x40, 0x80, 0xf0, 0x88, 0x88, 0x70, 0x00,
	0xf8, 0x88, 0x08, 0x10, 0x20, 0x20, 0x20, 0x00,
	0x70, 0x88, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x70, 0x88, 0x88, 0x78, 0x08, 0x10, 0x60, 0x00,
	0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00,
	0x20, 0x10, 0x00, 0x70, 0x08, 0xf8, 0x78, 0x00,
	0x20, 0x50, 0x00, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x50, 0x00, 0x90, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x20, 0x50, 0x00, 0x70, 0xf8, 0x80, 0x70, 0x00,
	0x70, 0x88, 0x08, 0x10, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x50, 0x00, 0xc0, 0x40, 0x40, 0xe0, 0x00,
	0x70, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x00,
	0xf0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xf0, 0x00,
	0x30, 0x48, 0x80, 0x80, 0x80, 0x48, 0x30, 0x00,
	0xe0, 0x50, 0x48, 0x48, 0x48, 0x50, 0xe0, 0x00,
	0xf8, 0x48, 0x40, 0x70, 0x40, 0x48, 0xf8, 0x00,
	0xf8, 0x48, 0x40, 0x70, 0x40, 0x40, 0xe0, 0x00,
	0x30, 0x48, 0x80, 0x98, 0x88, 0x48, 0x38, 0x00,
	0x88, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x00,
	0xf8, 0x20, 0x20, 0x20, 0x20, 0x20, 0xf8, 0x00,
	0x18, 0x08, 0x08, 0x08, 0x88, 0x88, 0x70, 0x00,
	0xc8, 0x48, 0x50, 0x60, 0x50, 0x48, 0xc8, 0x00,
	0xe0, 0x40, 0x40, 0x40, 0x40, 0x48, 0xf8, 0x00,
	0x88, 0xd8, 0xa8, 0xa8, 0x88, 0x88, 0x88, 0x00,
	0x88, 0xc8, 0xa8, 0x98, 0x88, 0x88, 0x88, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0xf0, 0x48, 0x48, 0x70, 0x40, 0x40, 0xe0, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0xa8, 0x70, 0x08,
	0xf0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xc8, 0x00,
	0x70, 0x88, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00,
	0xf8, 0xa8, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x78, 0x00,
	0x88, 0x88, 0x88, 0x50, 0x50, 0x20, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x88, 0xa8, 0xd8, 0x88, 0x00,
	0x88, 0x88, 0x50, 0x20, 0x50, 0x88, 0x88, 0x00,
	0x88, 0x88, 0x88, 0x70, 0x20, 0x20, 0x70, 0x00,
	0xf8, 0x88, 0x10, 0x20, 0x40, 0x88, 0xf8, 0x00,
	0x00, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00,
	0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x30, 0x48, 0x40, 0x48, 0x30, 0x10, 0x30,
	0x00, 0x50, 0x00, 0x60, 0x20, 0x28, 0x30, 0x00,
	0x20, 0x10, 0x00, 0x98, 0x90, 0x90, 0xe8, 0x00,
	0x00, 0x00, 0x70, 0x08, 0x78, 0x88, 0x78, 0x00,
	0xc0, 0x40, 0x50, 0x68, 0x48, 0x48, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x80, 0x88, 0x70, 0x00,
	0x18, 0x10, 0x50, 0xb0, 0x90, 0x90, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0xf8, 0x80, 0x70, 0x00,
	0x30, 0x48, 0x40, 0xe0, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x68, 0x90, 0x90, 0x70, 0x88, 0x70,
	0xc0, 0x40, 0x50, 0x68, 0x48, 0x48, 0xc8, 0x00,
	0x40, 0x00, 0xc0, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x08, 0x00, 0x08, 0x08, 0x08, 0x08, 0x88, 0x70,
	0xc0, 0x40, 0x48, 0x50, 0x60, 0x50, 0xc8, 0x00,
	0xc0, 0x40, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x90, 0xd8, 0xa8, 0x88, 0x88, 0x00,
	0x00, 0x00, 0xf0, 0x88, 0x88, 0x88, 0x88, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x00, 0xb0, 0x48, 0x48, 0x70, 0x40, 0xe0,
	0x00, 0x00, 0x68, 0x90, 0x90, 0x70, 0x10, 0x38,
	0x00, 0x00, 0xb0, 0x48, 0x48, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x78, 0x80, 0x70, 0x08, 0xf0, 0x00,
	0x40, 0x40, 0xf0, 0x40, 0x40, 0x48, 0x30, 0x00,
	0x00, 0x00, 0x90, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x88, 0x50, 0x20, 0x00,
	0x00, 0x00, 0x88, 0x88, 0xa8, 0xd8, 0x90, 0x00,
	0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x88, 0x70, 0x20, 0xc0,
	0x00, 0x00, 0xf8, 0x90, 0x20, 0x48, 0xf8, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x0e, 0x08, 0x30, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
	0x00, 0x70, 0x10, 0x0c, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00,
	0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc,
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
};

static const byte french_simonFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x70, 0x70, 0x20, 0x20, 0x00, 0x20, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x50, 0x00, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x20, 0x50, 0x00, 0x70, 0x08, 0xf8, 0x78, 0x00,
	0x70, 0x88, 0x80, 0x80, 0x88, 0x70, 0x20, 0x60,
	0x00, 0x10, 0x28, 0x10, 0x2a, 0x44, 0x3a, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
	0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x3e, 0x08, 0x14, 0x00,
	0x70, 0x88, 0x80, 0x80, 0x88, 0x70, 0x20, 0x60,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
	0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
	0x20, 0x40, 0x00, 0x70, 0xf8, 0x80, 0x70, 0x00,
	0x70, 0x88, 0x98, 0xa8, 0xc8, 0x88, 0x70, 0x00,
	0x20, 0x60, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x40, 0x88, 0xf8, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x08, 0x88, 0x70, 0x00,
	0x10, 0x30, 0x50, 0x90, 0xf8, 0x10, 0x38, 0x00,
	0xf8, 0x80, 0xf0, 0x08, 0x08, 0x88, 0x70, 0x00,
	0x30, 0x40, 0x80, 0xf0, 0x88, 0x88, 0x70, 0x00,
	0xf8, 0x88, 0x08, 0x10, 0x20, 0x20, 0x20, 0x00,
	0x70, 0x88, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x70, 0x88, 0x88, 0x78, 0x08, 0x10, 0x60, 0x00,
	0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00,
	0x20, 0x10, 0x00, 0x70, 0x08, 0xf8, 0x78, 0x00,
	0x20, 0x50, 0x00, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x20, 0x10, 0x00, 0x70, 0xf8, 0x80, 0x70, 0x00,
	0x20, 0x50, 0x00, 0x70, 0xf8, 0x80, 0x70, 0x00,
	0x70, 0x88, 0x08, 0x10, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x50, 0x00, 0xc0, 0x40, 0x40, 0xe0, 0x00,
	0x70, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x00,
	0xf0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xf0, 0x00,
	0x30, 0x48, 0x80, 0x80, 0x80, 0x48, 0x30, 0x00,
	0xe0, 0x50, 0x48, 0x48, 0x48, 0x50, 0xe0, 0x00,
	0xf8, 0x48, 0x40, 0x70, 0x40, 0x48, 0xf8, 0x00,
	0xf8, 0x48, 0x40, 0x70, 0x40, 0x40, 0xe0, 0x00,
	0x30, 0x48, 0x80, 0x98, 0x88, 0x48, 0x38, 0x00,
	0x88, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x00,
	0xf8, 0x20, 0x20, 0x20, 0x20, 0x20, 0xf8, 0x00,
	0x18, 0x08, 0x08, 0x08, 0x88, 0x88, 0x70, 0x00,
	0xc8, 0x48, 0x50, 0x60, 0x50, 0x48, 0xc8, 0x00,
	0xe0, 0x40, 0x40, 0x40, 0x40, 0x48, 0xf8, 0x00,
	0x88, 0xd8, 0xa8, 0xa8, 0x88, 0x88, 0x88, 0x00,
	0x88, 0xc8, 0xa8, 0x98, 0x88, 0x88, 0x88, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0xf0, 0x48, 0x48, 0x70, 0x40, 0x40, 0xe0, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0xa8, 0x70, 0x08,
	0xf0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xc8, 0x00,
	0x70, 0x88, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00,
	0xf8, 0xa8, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x78, 0x00,
	0x88, 0x88, 0x88, 0x50, 0x50, 0x20, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x88, 0xa8, 0xd8, 0x88, 0x00,
	0x88, 0x88, 0x50, 0x20, 0x50, 0x88, 0x88, 0x00,
	0x88, 0x88, 0x88, 0x70, 0x20, 0x20, 0x70, 0x00,
	0xf8, 0x88, 0x10, 0x20, 0x40, 0x88, 0xf8, 0x00,
	0x00, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00,
	0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x80, 0x70, 0x20, 0x60,
	0xa0, 0x00, 0xc0, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x20, 0x10, 0x00, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x70, 0x08, 0x78, 0x88, 0x78, 0x00,
	0xc0, 0x40, 0x50, 0x68, 0x48, 0x48, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x80, 0x88, 0x70, 0x00,
	0x18, 0x10, 0x50, 0xb0, 0x90, 0x90, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0xf8, 0x80, 0x70, 0x00,
	0x30, 0x48, 0x40, 0xe0, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x68, 0x90, 0x90, 0x70, 0x88, 0x70,
	0xc0, 0x40, 0x50, 0x68, 0x48, 0x48, 0xc8, 0x00,
	0x40, 0x00, 0xc0, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x08, 0x00, 0x08, 0x08, 0x08, 0x08, 0x88, 0x70,
	0xc0, 0x40, 0x48, 0x50, 0x60, 0x50, 0xc8, 0x00,
	0xc0, 0x40, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x90, 0xd8, 0xa8, 0x88, 0x88, 0x00,
	0x00, 0x00, 0xf0, 0x88, 0x88, 0x88, 0x88, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x00, 0xb0, 0x48, 0x48, 0x70, 0x40, 0xe0,
	0x00, 0x00, 0x68, 0x90, 0x90, 0x70, 0x10, 0x38,
	0x00, 0x00, 0xb0, 0x48, 0x48, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x78, 0x80, 0x70, 0x08, 0xf0, 0x00,
	0x40, 0x40, 0xf0, 0x40, 0x40, 0x48, 0x30, 0x00,
	0x00, 0x00, 0x90, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x88, 0x50, 0x20, 0x00,
	0x00, 0x00, 0x88, 0x88, 0xa8, 0xd8, 0x90, 0x00,
	0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x88, 0x70, 0x20, 0xc0,
	0x00, 0x00, 0xf8, 0x90, 0x20, 0x48, 0xf8, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x0e, 0x08, 0x30, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
	0x00, 0x70, 0x10, 0x0c, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00,
	0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc,
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
};

static const byte german_simonFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x70, 0x70, 0x20, 0x20, 0x00, 0x20, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x50, 0x00, 0x70, 0x08, 0x78, 0x88, 0x78, 0x00,
	0x50, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x50, 0x00, 0x90, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x10, 0x28, 0x10, 0x2a, 0x44, 0x3a, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
	0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x3e, 0x08, 0x14, 0x00,
	0x60, 0x90, 0x90, 0xa0, 0x90, 0x90, 0xa0, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
	0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
	0x50, 0x00, 0x70, 0x88, 0xf8, 0x88, 0x88, 0x00,
	0x70, 0x88, 0x98, 0xa8, 0xc8, 0x88, 0x70, 0x00,
	0x20, 0x60, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x40, 0x88, 0xf8, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x08, 0x88, 0x70, 0x00,
	0x10, 0x30, 0x50, 0x90, 0xf8, 0x10, 0x38, 0x00,
	0xf8, 0x80, 0xf0, 0x08, 0x08, 0x88, 0x70, 0x00,
	0x30, 0x40, 0x80, 0xf0, 0x88, 0x88, 0x70, 0x00,
	0xf8, 0x88, 0x08, 0x10, 0x20, 0x20, 0x20, 0x00,
	0x70, 0x88, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x70, 0x88, 0x88, 0x78, 0x08, 0x10, 0x60, 0x00,
	0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00,
	0x88, 0x70, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x50, 0x00, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x50, 0x00, 0x90, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x20, 0x40, 0x00, 0x70, 0xf8, 0x80, 0x70, 0x00,
	0x70, 0x88, 0x08, 0x10, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x50, 0x00, 0xc0, 0x40, 0x40, 0xe0, 0x00,
	0x70, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x00,
	0xf0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xf0, 0x00,
	0x30, 0x48, 0x80, 0x80, 0x80, 0x48, 0x30, 0x00,
	0xe0, 0x50, 0x48, 0x48, 0x48, 0x50, 0xe0, 0x00,
	0xf8, 0x48, 0x40, 0x70, 0x40, 0x48, 0xf8, 0x00,
	0xf8, 0x48, 0x40, 0x70, 0x40, 0x40, 0xe0, 0x00,
	0x30, 0x48, 0x80, 0x98, 0x88, 0x48, 0x38, 0x00,
	0x88, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x00,
	0xf8, 0x20, 0x20, 0x20, 0x20, 0x20, 0xf8, 0x00,
	0x18, 0x08, 0x08, 0x08, 0x88, 0x88, 0x70, 0x00,
	0xc8, 0x48, 0x50, 0x60, 0x50, 0x48, 0xc8, 0x00,
	0xe0, 0x40, 0x40, 0x40, 0x40, 0x48, 0xf8, 0x00,
	0x88, 0xd8, 0xa8, 0xa8, 0x88, 0x88, 0x88, 0x00,
	0x88, 0xc8, 0xa8, 0x98, 0x88, 0x88, 0x88, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0xf0, 0x48, 0x48, 0x70, 0x40, 0x40, 0xe0, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0xa8, 0x70, 0x08,
	0xf0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xc8, 0x00,
	0x70, 0x88, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00,
	0xf8, 0xa8, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x78, 0x00,
	0x88, 0x88, 0x88, 0x50, 0x50, 0x20, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x88, 0xa8, 0xd8, 0x88, 0x00,
	0x88, 0x88, 0x50, 0x20, 0x50, 0x88, 0x88, 0x00,
	0x88, 0x88, 0x88, 0x70, 0x20, 0x20, 0x70, 0x00,
	0xf8, 0x88, 0x10, 0x20, 0x40, 0x88, 0xf8, 0x00,
	0x00, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00,
	0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x30, 0x48, 0x40, 0x48, 0x30, 0x10, 0x30,
	0x00, 0x50, 0x00, 0x60, 0x20, 0x28, 0x30, 0x00,
	0x20, 0x10, 0x00, 0x98, 0x90, 0x90, 0xe8, 0x00,
	0x00, 0x00, 0x70, 0x08, 0x78, 0x88, 0x78, 0x00,
	0xc0, 0x40, 0x50, 0x68, 0x48, 0x48, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x80, 0x88, 0x70, 0x00,
	0x18, 0x10, 0x50, 0xb0, 0x90, 0x90, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0xf8, 0x80, 0x70, 0x00,
	0x30, 0x48, 0x40, 0xe0, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x68, 0x90, 0x90, 0x70, 0x88, 0x70,
	0xc0, 0x40, 0x50, 0x68, 0x48, 0x48, 0xc8, 0x00,
	0x40, 0x00, 0xc0, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x08, 0x00, 0x08, 0x08, 0x08, 0x08, 0x88, 0x70,
	0xc0, 0x40, 0x48, 0x50, 0x60, 0x50, 0xc8, 0x00,
	0xc0, 0x40, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x90, 0xd8, 0xa8, 0x88, 0x88, 0x00,
	0x00, 0x00, 0xf0, 0x88, 0x88, 0x88, 0x88, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x00, 0xb0, 0x48, 0x48, 0x70, 0x40, 0xe0,
	0x00, 0x00, 0x68, 0x90, 0x90, 0x70, 0x10, 0x38,
	0x00, 0x00, 0xb0, 0x48, 0x48, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x78, 0x80, 0x70, 0x08, 0xf0, 0x00,
	0x40, 0x40, 0xf0, 0x40, 0x40, 0x48, 0x30, 0x00,
	0x00, 0x00, 0x90, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x88, 0x50, 0x20, 0x00,
	0x00, 0x00, 0x88, 0x88, 0xa8, 0xd8, 0x90, 0x00,
	0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x88, 0x70, 0x20, 0xc0,
	0x00, 0x00, 0xf8, 0x90, 0x20, 0x48, 0xf8, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x0e, 0x08, 0x30, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
	0x00, 0x70, 0x10, 0x0c, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00,
	0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc,
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
};

static const byte hebrew_simonFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x70, 0x70, 0x20, 0x20, 0x00, 0x20, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x90, 0x00, 0x60, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x90, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x90, 0x00, 0x90, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x10, 0x28, 0x10, 0x2a, 0x44, 0x3a, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
	0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x3e, 0x08, 0x14, 0x00,
	0x00, 0x70, 0x88, 0xf0, 0x88, 0x88, 0xf0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
	0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
	0x10, 0x20, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x70, 0x88, 0x98, 0xa8, 0xc8, 0x88, 0x70, 0x00,
	0x20, 0x60, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x40, 0x88, 0xf8, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x08, 0x88, 0x70, 0x00,
	0x10, 0x30, 0x50, 0x90, 0xf8, 0x10, 0x38, 0x00,
	0xf8, 0x80, 0xf0, 0x08, 0x08, 0x88, 0x70, 0x00,
	0x30, 0x40, 0x80, 0xf0, 0x88, 0x88, 0x70, 0x00,
	0xf8, 0x88, 0x08, 0x10, 0x20, 0x20, 0x20, 0x00,
	0x70, 0x88, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x70, 0x88, 0x88, 0x78, 0x08, 0x10, 0x60, 0x00,
	0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00,
	0x05, 0x05, 0x04, 0x06, 0x05, 0x03, 0x04, 0x05,
	0x06, 0x03, 0x05, 0x05, 0x04, 0x06, 0x05, 0x03,
	0x04, 0x06, 0x05, 0x06, 0x06, 0x06, 0x05, 0x05,
	0x05, 0x06, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x70, 0x88, 0x08, 0x10, 0x20, 0x00, 0x20, 0x00,
	0x00, 0x00, 0x90, 0x50, 0xa0, 0x90, 0x90, 0x00,
	0x00, 0x00, 0xe0, 0x20, 0x20, 0x20, 0xf0, 0x00,
	0x00, 0x00, 0xe0, 0x20, 0x60, 0xa0, 0xa0, 0x00,
	0x00, 0x00, 0xf8, 0x10, 0x10, 0x10, 0x10, 0x00,
	0x00, 0x00, 0xf0, 0x10, 0x10, 0x90, 0x90, 0x00,
	0x00, 0x00, 0xc0, 0x40, 0x40, 0x40, 0x40, 0x00,
	0x00, 0x00, 0xe0, 0x40, 0x20, 0x40, 0x40, 0x00,
	0x00, 0x00, 0xf0, 0x90, 0x90, 0x90, 0x90, 0x00,
	0x00, 0x00, 0xb8, 0xa8, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x00, 0xc0, 0x40, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xf0, 0x10, 0x10, 0x10, 0x10, 0x10,
	0x00, 0x00, 0xe0, 0x10, 0x10, 0x10, 0xe0, 0x00,
	0x80, 0x80, 0xe0, 0x20, 0x20, 0x20, 0xc0, 0x00,
	0x00, 0x00, 0xf8, 0x48, 0x48, 0x48, 0x78, 0x00,
	0x00, 0x00, 0xb0, 0xd0, 0x90, 0x90, 0xb0, 0x00,
	0x00, 0x00, 0xc0, 0x40, 0x40, 0x40, 0x40, 0x40,
	0x00, 0x00, 0x60, 0x20, 0x20, 0x20, 0xe0, 0x00,
	0x00, 0x00, 0xf8, 0x48, 0x48, 0x48, 0x30, 0x00,
	0x00, 0x00, 0x50, 0x50, 0x50, 0x50, 0xe0, 0x00,
	0x00, 0x00, 0xf8, 0x48, 0x68, 0x08, 0x08, 0x08,
	0x00, 0x00, 0xf8, 0x48, 0x68, 0x08, 0xf8, 0x00,
	0x00, 0x00, 0xd8, 0x48, 0x30, 0x10, 0x10, 0x10,
	0x00, 0x00, 0x90, 0x50, 0x20, 0x10, 0xf0, 0x00,
	0x00, 0x00, 0xf0, 0x10, 0x90, 0xa0, 0x80, 0x80,
	0x00, 0x00, 0xf0, 0x10, 0x10, 0x10, 0x10, 0x00,
	0x00, 0x00, 0xa8, 0xa8, 0xc8, 0x88, 0x70, 0x00,
	0x00, 0x00, 0xf0, 0x50, 0x50, 0x50, 0xd0, 0x00,
	0x00, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00,
	0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x30, 0x48, 0x40, 0x48, 0x30, 0x10, 0x30,
	0x00, 0x50, 0x00, 0x60, 0x20, 0x28, 0x30, 0x00,
	0x20, 0x10, 0x00, 0x98, 0x90, 0x90, 0xe8, 0x00,
	0x00, 0x00, 0x70, 0x08, 0x78, 0x88, 0x78, 0x00,
	0xc0, 0x40, 0x50, 0x68, 0x48, 0x48, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x80, 0x88, 0x70, 0x00,
	0x18, 0x10, 0x50, 0xb0, 0x90, 0x90, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0xf8, 0x80, 0x70, 0x00,
	0x30, 0x48, 0x40, 0xe0, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x68, 0x90, 0x90, 0x70, 0x88, 0x70,
	0xc0, 0x40, 0x50, 0x68, 0x48, 0x48, 0xc8, 0x00,
	0x40, 0x00, 0xc0, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x08, 0x00, 0x08, 0x08, 0x08, 0x08, 0x88, 0x70,
	0xc0, 0x40, 0x48, 0x50, 0x60, 0x50, 0xc8, 0x00,
	0xc0, 0x40, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x90, 0xd8, 0xa8, 0x88, 0x88, 0x00,
	0x00, 0x00, 0xf0, 0x88, 0x88, 0x88, 0x88, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x00, 0xb0, 0x48, 0x48, 0x70, 0x40, 0xe0,
	0x00, 0x00, 0x68, 0x90, 0x90, 0x70, 0x10, 0x38,
	0x00, 0x00, 0xb0, 0x48, 0x48, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x78, 0x80, 0x70, 0x08, 0xf0, 0x00,
	0x40, 0x40, 0xf0, 0x40, 0x40, 0x48, 0x30, 0x00,
	0x00, 0x00, 0x90, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x88, 0x50, 0x20, 0x00,
	0x00, 0x00, 0x88, 0x88, 0xa8, 0xd8, 0x90, 0x00,
	0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x88, 0x70, 0x20, 0xc0,
	0x00, 0x00, 0xf8, 0x90, 0x20, 0x48, 0xf8, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x0e, 0x08, 0x30, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
	0x00, 0x70, 0x10, 0x0c, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00,
	0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc,
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
};

static const byte italian_simonFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x70, 0x70, 0x20, 0x20, 0x00, 0x20, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x50, 0x00, 0x70, 0x08, 0x78, 0x88, 0x78, 0x00,
	0x50, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x20, 0x10, 0x00, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x10, 0x28, 0x10, 0x2a, 0x44, 0x3a, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
	0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x3e, 0x08, 0x14, 0x00,
	0x20, 0x10, 0x00, 0xc0, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
	0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
	0x20, 0x40, 0x00, 0x70, 0xf8, 0x80, 0x70, 0x00,
	0x70, 0x88, 0x98, 0xa8, 0xc8, 0x88, 0x70, 0x00,
	0x20, 0x60, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x40, 0x88, 0xf8, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x08, 0x88, 0x70, 0x00,
	0x10, 0x30, 0x50, 0x90, 0xf8, 0x10, 0x38, 0x00,
	0xf8, 0x80, 0xf0, 0x08, 0x08, 0x88, 0x70, 0x00,
	0x30, 0x40, 0x80, 0xf0, 0x88, 0x88, 0x70, 0x00,
	0xf8, 0x88, 0x08, 0x10, 0x20, 0x20, 0x20, 0x00,
	0x70, 0x88, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x70, 0x88, 0x88, 0x78, 0x08, 0x10, 0x60, 0x00,
	0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00,
	0x20, 0x10, 0x00, 0x70, 0x08, 0xf8, 0x78, 0x00,
	0x20, 0x10, 0x00, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x20, 0x10, 0x00, 0x70, 0xf8, 0x80, 0x70, 0x00,
	0x20, 0x50, 0x00, 0x70, 0xf8, 0x80, 0x70, 0x00,
	0x70, 0x88, 0x08, 0x10, 0x20, 0x00, 0x20, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x20, 0x28, 0x30, 0x00,
	0x70, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x00,
	0xf0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xf0, 0x00,
	0x30, 0x48, 0x80, 0x80, 0x80, 0x48, 0x30, 0x00,
	0xe0, 0x50, 0x48, 0x48, 0x48, 0x50, 0xe0, 0x00,
	0xf8, 0x48, 0x40, 0x70, 0x40, 0x48, 0xf8, 0x00,
	0xf8, 0x48, 0x40, 0x70, 0x40, 0x40, 0xe0, 0x00,
	0x30, 0x48, 0x80, 0x98, 0x88, 0x48, 0x38, 0x00,
	0x88, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x00,
	0xf8, 0x20, 0x20, 0x20, 0x20, 0x20, 0xf8, 0x00,
	0x18, 0x08, 0x08, 0x08, 0x88, 0x88, 0x70, 0x00,
	0xc8, 0x48, 0x50, 0x60, 0x50, 0x48, 0xc8, 0x00,
	0xe0, 0x40, 0x40, 0x40, 0x40, 0x48, 0xf8, 0x00,
	0x88, 0xd8, 0xa8, 0xa8, 0x88, 0x88, 0x88, 0x00,
	0x88, 0xc8, 0xa8, 0x98, 0x88, 0x88, 0x88, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0xf0, 0x48, 0x48, 0x70, 0x40, 0x40, 0xe0, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0xa8, 0x70, 0x08,
	0xf0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xc8, 0x00,
	0x70, 0x88, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00,
	0xf8, 0xa8, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x78, 0x00,
	0x88, 0x88, 0x88, 0x50, 0x50, 0x20, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x88, 0xa8, 0xd8, 0x88, 0x00,
	0x88, 0x88, 0x50, 0x20, 0x50, 0x88, 0x88, 0x00,
	0x88, 0x88, 0x88, 0x70, 0x20, 0x20, 0x70, 0x00,
	0xf8, 0x88, 0x10, 0x20, 0x40, 0x88, 0xf8, 0x00,
	0x00, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00,
	0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x80, 0x70, 0x20, 0x60,
	0xa0, 0x00, 0xc0, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x20, 0x10, 0x00, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x70, 0x08, 0x78, 0x88, 0x78, 0x00,
	0xc0, 0x40, 0x50, 0x68, 0x48, 0x48, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x80, 0x88, 0x70, 0x00,
	0x18, 0x10, 0x50, 0xb0, 0x90, 0x90, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0xf8, 0x80, 0x70, 0x00,
	0x30, 0x48, 0x40, 0xe0, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x68, 0x90, 0x90, 0x70, 0x88, 0x70,
	0xc0, 0x40, 0x50, 0x68, 0x48, 0x48, 0xc8, 0x00,
	0x40, 0x00, 0xc0, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x08, 0x00, 0x08, 0x08, 0x08, 0x08, 0x88, 0x70,
	0xc0, 0x40, 0x48, 0x50, 0x60, 0x50, 0xc8, 0x00,
	0xc0, 0x40, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x90, 0xd8, 0xa8, 0x88, 0x88, 0x00,
	0x00, 0x00, 0xf0, 0x88, 0x88, 0x88, 0x88, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x00, 0xb0, 0x48, 0x48, 0x70, 0x40, 0xe0,
	0x00, 0x00, 0x68, 0x90, 0x90, 0x70, 0x10, 0x38,
	0x00, 0x00, 0xb0, 0x48, 0x48, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x78, 0x80, 0x70, 0x08, 0xf0, 0x00,
	0x40, 0x40, 0xf0, 0x40, 0x40, 0x48, 0x30, 0x00,
	0x00, 0x00, 0x90, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x88, 0x50, 0x20, 0x00,
	0x00, 0x00, 0x88, 0x88, 0xa8, 0xd8, 0x90, 0x00,
	0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x88, 0x70, 0x20, 0xc0,
	0x00, 0x00, 0xf8, 0x90, 0x20, 0x48, 0xf8, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x0e, 0x08, 0x30, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
	0x00, 0x70, 0x10, 0x0c, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00,
	0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc,
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
};

static const byte polish_simonFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x70, 0x70, 0x20, 0x20, 0x00, 0x20, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x70, 0x88, 0xf8, 0x80, 0x70, 0x08,
	0x00, 0x10, 0x78, 0x80, 0x70, 0x08, 0xf0, 0x00,
	0xc0, 0x40, 0x40, 0x60, 0xc0, 0x40, 0xe0, 0x00,
	0x00, 0x10, 0x28, 0x10, 0x2a, 0x44, 0x3a, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
	0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x3e, 0x08, 0x14, 0x00,
	0x00, 0x20, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
	0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
	0x00, 0x20, 0x70, 0x88, 0x80, 0x88, 0x70, 0x00,
	0x70, 0x88, 0x98, 0xa8, 0xc8, 0x88, 0x70, 0x00,
	0x20, 0x60, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x40, 0x88, 0xf8, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x08, 0x88, 0x70, 0x00,
	0x10, 0x30, 0x50, 0x90, 0xf8, 0x10, 0x38, 0x00,
	0xf8, 0x80, 0xf0, 0x08, 0x08, 0x88, 0x70, 0x00,
	0x30, 0x40, 0x80, 0xf0, 0x88, 0x88, 0x70, 0x00,
	0xf8, 0x88, 0x08, 0x10, 0x20, 0x20, 0x20, 0x00,
	0x70, 0x88, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x70, 0x88, 0x88, 0x78, 0x08, 0x10, 0x60, 0x00,
	0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00,
	0x00, 0x20, 0xf0, 0x88, 0x88, 0x88, 0x88, 0x00,
	0x50, 0x00, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x20, 0xf8, 0x90, 0x20, 0x48, 0xf8, 0x00,
	0x08, 0x20, 0xf8, 0x90, 0x20, 0x48, 0xf8, 0x00,
	0x70, 0x88, 0x08, 0x10, 0x20, 0x00, 0x20, 0x00,
	0x00, 0x00, 0x70, 0x08, 0x78, 0x88, 0x78, 0x04,
	0x70, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x00,
	0xf0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xf0, 0x00,
	0x30, 0x48, 0x80, 0x80, 0x80, 0x48, 0x30, 0x00,
	0xe0, 0x50, 0x48, 0x48, 0x48, 0x50, 0xe0, 0x00,
	0xf8, 0x48, 0x40, 0x70, 0x40, 0x48, 0xf8, 0x00,
	0xf8, 0x48, 0x40, 0x70, 0x40, 0x40, 0xe0, 0x00,
	0x30, 0x48, 0x80, 0x98, 0x88, 0x48, 0x38, 0x00,
	0x88, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x00,
	0xf8, 0x20, 0x20, 0x20, 0x20, 0x20, 0xf8, 0x00,
	0x18, 0x08, 0x08, 0x08, 0x88, 0x88, 0x70, 0x00,
	0xc8, 0x48, 0x50, 0x60, 0x50, 0x48, 0xc8, 0x00,
	0xe0, 0x40, 0x40, 0x40, 0x40, 0x48, 0xf8, 0x00,
	0x88, 0xd8, 0xa8, 0xa8, 0x88, 0x88, 0x88, 0x00,
	0x88, 0xc8, 0xa8, 0x98, 0x88, 0x88, 0x88, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0xf0, 0x48, 0x48, 0x70, 0x40, 0x40, 0xe0, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0xa8, 0x70, 0x08,
	0xf0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xc8, 0x00,
	0x70, 0x88, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00,
	0xf8, 0xa8, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x78, 0x00,
	0x88, 0x88, 0x88, 0x50, 0x50, 0x20, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x88, 0xa8, 0xd8, 0x88, 0x00,
	0x88, 0x88, 0x50, 0x20, 0x50, 0x88, 0x88, 0x00,
	0x88, 0x88, 0x88, 0x70, 0x20, 0x20, 0x70, 0x00,
	0xf8, 0x88, 0x10, 0x20, 0x40, 0x88, 0xf8, 0x00,
	0x00, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00,
	0xe0, 0x40, 0x40, 0x60, 0xc0, 0x48, 0xf8, 0x00,
	0x10, 0x78, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00,
	0xf8, 0x48, 0x40, 0x70, 0x40, 0x48, 0xf8, 0x10,
	0x20, 0xf8, 0x10, 0x20, 0x40, 0x88, 0xf8, 0x00,
	0x00, 0x00, 0x70, 0x08, 0x78, 0x88, 0x78, 0x00,
	0xc0, 0x40, 0x50, 0x68, 0x48, 0x48, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x80, 0x88, 0x70, 0x00,
	0x18, 0x10, 0x50, 0xb0, 0x90, 0x90, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0xf8, 0x80, 0x70, 0x00,
	0x30, 0x48, 0x40, 0xe0, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x68, 0x90, 0x90, 0x70, 0x88, 0x70,
	0xc0, 0x40, 0x50, 0x68, 0x48, 0x48, 0xc8, 0x00,
	0x40, 0x00, 0xc0, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x08, 0x00, 0x08, 0x08, 0x08, 0x08, 0x88, 0x70,
	0xc0, 0x40, 0x48, 0x50, 0x60, 0x50, 0xc8, 0x00,
	0xc0, 0x40, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x90, 0xd8, 0xa8, 0x88, 0x88, 0x00,
	0x00, 0x00, 0xf0, 0x88, 0x88, 0x88, 0x88, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x00, 0xb0, 0x48, 0x48, 0x70, 0x40, 0xe0,
	0x00, 0x00, 0x68, 0x90, 0x90, 0x70, 0x10, 0x38,
	0x00, 0x00, 0xb0, 0x48, 0x48, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x78, 0x80, 0x70, 0x08, 0xf0, 0x00,
	0x40, 0x40, 0xf0, 0x40, 0x40, 0x48, 0x30, 0x00,
	0x00, 0x00, 0x90, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x88, 0x50, 0x20, 0x00,
	0x00, 0x00, 0x88, 0x88, 0xa8, 0xd8, 0x90, 0x00,
	0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x88, 0x70, 0x20, 0xc0,
	0x00, 0x00, 0xf8, 0x90, 0x20, 0x48, 0xf8, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x0e, 0x08, 0x30, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
	0x00, 0x70, 0x10, 0x0c, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00,
	0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc,
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
};

static const byte russian_simonFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x70, 0x70, 0x20, 0x20, 0x00, 0x20, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x64, 0x28, 0x30, 0x28, 0x64, 0x00,
	0x00, 0x00, 0x60, 0x30, 0x28, 0x28, 0x70, 0x00,
	0x3c, 0x44, 0x44, 0x3c, 0x24, 0x44, 0x44, 0x00,
	0x00, 0x10, 0x28, 0x10, 0x2a, 0x44, 0x3a, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
	0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x48, 0x54, 0x54, 0x74, 0x54, 0x54, 0x48, 0x00,
	0x00, 0x00, 0x3c, 0x44, 0x3c, 0x24, 0x64, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
	0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
	0x10, 0x20, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x70, 0x88, 0x98, 0xa8, 0xc8, 0x88, 0x70, 0x00,
	0x20, 0x60, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x40, 0x88, 0xf8, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x08, 0x88, 0x70, 0x00,
	0x10, 0x30, 0x50, 0x90, 0xf8, 0x10, 0x38, 0x00,
	0xf8, 0x80, 0xf0, 0x08, 0x08, 0x88, 0x70, 0x00,
	0x30, 0x40, 0x80, 0xf0, 0x88, 0x88, 0x70, 0x00,
	0xf8, 0x88, 0x08, 0x10, 0x20, 0x20, 0x20, 0x00,
	0x70, 0x88, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x70, 0x88, 0x88, 0x78, 0x08, 0x10, 0x60, 0x00,
	0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00,
	0x20, 0x10, 0x00, 0x70, 0x08, 0xf8, 0x78, 0x00,
	0x00, 0x00, 0x60, 0x30, 0x28, 0x28, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x58, 0x14, 0x14, 0x38, 0x00,
	0x00, 0x00, 0x78, 0x04, 0x1c, 0x04, 0x78, 0x00,
	0x70, 0x88, 0x08, 0x10, 0x20, 0x00, 0x20, 0x00,
	0x00, 0x00, 0x54, 0x54, 0x54, 0x54, 0x38, 0x04,
	0x38, 0x44, 0x44, 0x7c, 0x44, 0x44, 0x44, 0x00,
	0x7c, 0x24, 0x20, 0x38, 0x24, 0x24, 0x78, 0x00,
	0x78, 0x24, 0x24, 0x38, 0x24, 0x24, 0x78, 0x00,
	0x7c, 0x24, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x38, 0x28, 0x28, 0x28, 0x28, 0x28, 0x7c, 0x44,
	0x7c, 0x24, 0x20, 0x38, 0x20, 0x24, 0x7c, 0x00,
	0x54, 0x54, 0x54, 0x38, 0x54, 0x54, 0x54, 0x00,
	0x38, 0x44, 0x04, 0x18, 0x04, 0x44, 0x38, 0x00,
	0x44, 0x44, 0x4c, 0x54, 0x64, 0x44, 0x44, 0x00,
	0x64, 0x28, 0x28, 0x30, 0x28, 0x24, 0x64, 0x00,
	0x1c, 0x24, 0x24, 0x24, 0x24, 0x24, 0x64, 0x00,
	0x44, 0x6c, 0x54, 0x44, 0x44, 0x44, 0x44, 0x00,
	0x44, 0x44, 0x44, 0x7c, 0x44, 0x44, 0x44, 0x00,
	0x38, 0x44, 0x44, 0x44, 0x44, 0x44, 0x38, 0x00,
	0x7c, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x00,
	0x78, 0x24, 0x24, 0x38, 0x20, 0x20, 0x70, 0x00,
	0x38, 0x44, 0x40, 0x40, 0x40, 0x44, 0x38, 0x00,
	0x7c, 0x54, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00,
	0x64, 0x24, 0x24, 0x1c, 0x04, 0x04, 0x38, 0x00,
	0x38, 0x54, 0x54, 0x54, 0x38, 0x10, 0x38, 0x00,
	0x6c, 0x28, 0x10, 0x10, 0x28, 0x28, 0x6c, 0x00,
	0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x3c, 0x04,
	0x4c, 0x48, 0x48, 0x38, 0x08, 0x08, 0x1c, 0x00,
	0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x3c, 0x00,
	0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0x38, 0x04,
	0x38, 0x44, 0x04, 0x1c, 0x04, 0x44, 0x38, 0x00,
	0x00, 0x00, 0x44, 0x64, 0x54, 0x54, 0x64, 0x00,
	0x00, 0x00, 0x48, 0x54, 0x74, 0x54, 0x48, 0x00,
	0x00, 0x00, 0x3c, 0x44, 0x3c, 0x24, 0x64, 0x00,
	0x00, 0x00, 0x78, 0x04, 0x18, 0x04, 0x78, 0x00,
	0x00, 0x00, 0x64, 0x28, 0x30, 0x28, 0x64, 0x00,
	0x3c, 0x44, 0x44, 0x3c, 0x24, 0x44, 0x44, 0x00,
	0x00, 0x00, 0x38, 0x04, 0x3c, 0x44, 0x3c, 0x00,
	0x3c, 0x40, 0x20, 0x38, 0x44, 0x44, 0x38, 0x00,
	0x30, 0x48, 0x50, 0x78, 0x44, 0x44, 0x38, 0x00,
	0x00, 0x00, 0x78, 0x04, 0x38, 0x40, 0x3c, 0x00,
	0x38, 0x04, 0x04, 0x3c, 0x44, 0x44, 0x38, 0x00,
	0x00, 0x00, 0x38, 0x44, 0x78, 0x40, 0x38, 0x00,
	0x28, 0x00, 0x38, 0x44, 0x78, 0x40, 0x38, 0x00,
	0x00, 0x00, 0x54, 0x54, 0x38, 0x54, 0x54, 0x00,
	0x40, 0x00, 0xc0, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x44, 0x44, 0x44, 0x44, 0x3c, 0x00,
	0x38, 0x00, 0x44, 0x44, 0x44, 0x44, 0x3c, 0x00,
	0xc0, 0x40, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x1c, 0x24, 0x24, 0x24, 0x64, 0x00,
	0x00, 0x00, 0x44, 0x6c, 0x54, 0x44, 0x44, 0x00,
	0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00,
	0x00, 0x00, 0x44, 0x44, 0x7c, 0x44, 0x44, 0x00,
	0x00, 0x00, 0x7c, 0x44, 0x44, 0x44, 0x44, 0x00,
	0x00, 0x00, 0x78, 0x24, 0x24, 0x38, 0x20, 0x70,
	0x00, 0x00, 0x3c, 0x40, 0x40, 0x40, 0x3c, 0x00,
	0x00, 0x00, 0x7c, 0x54, 0x10, 0x10, 0x38, 0x00,
	0x00, 0x00, 0x44, 0x44, 0x3c, 0x04, 0x38, 0x00,
	0x30, 0x10, 0x38, 0x54, 0x54, 0x38, 0x10, 0x38,
	0x00, 0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00,
	0x00, 0x00, 0x48, 0x48, 0x48, 0x48, 0x3c, 0x04,
	0x00, 0x00, 0x4c, 0x48, 0x48, 0x38, 0x08, 0x1c,
	0x00, 0x00, 0x54, 0x54, 0x54, 0x54, 0x3c, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x0e, 0x08, 0x30, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
	0x00, 0x70, 0x10, 0x0c, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00,
	0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc,
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
};

static const byte spanish_simonFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x70, 0x70, 0x20, 0x20, 0x00, 0x20, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x50, 0x00, 0x70, 0x08, 0x78, 0x88, 0x78, 0x00,
	0x50, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x50, 0x00, 0x90, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x10, 0x28, 0x10, 0x2a, 0x44, 0x3a, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
	0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x3e, 0x08, 0x14, 0x00,
	0x60, 0x90, 0x90, 0xa0, 0x90, 0x90, 0xa0, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
	0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
	0x20, 0x40, 0x00, 0x70, 0xf8, 0x80, 0x70, 0x00,
	0x70, 0x88, 0x98, 0xa8, 0xc8, 0x88, 0x70, 0x00,
	0x20, 0x60, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x40, 0x88, 0xf8, 0x00,
	0x70, 0x88, 0x08, 0x30, 0x08, 0x88, 0x70, 0x00,
	0x10, 0x30, 0x50, 0x90, 0xf8, 0x10, 0x38, 0x00,
	0xf8, 0x80, 0xf0, 0x08, 0x08, 0x88, 0x70, 0x00,
	0x30, 0x40, 0x80, 0xf0, 0x88, 0x88, 0x70, 0x00,
	0xf8, 0x88, 0x08, 0x10, 0x20, 0x20, 0x20, 0x00,
	0x70, 0x88, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x70, 0x88, 0x88, 0x78, 0x08, 0x10, 0x60, 0x00,
	0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00,
	0x20, 0x40, 0x00, 0x70, 0x08, 0xf8, 0x78, 0x00,
	0x20, 0x40, 0x00, 0xc0, 0x40, 0x40, 0xe0, 0x00,
	0x20, 0x40, 0x00, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x20, 0x40, 0x00, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x70, 0x88, 0x08, 0x10, 0x20, 0x00, 0x20, 0x00,
	0x50, 0xa0, 0x00, 0xf0, 0x88, 0x88, 0x88, 0x00,
	0x70, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x00,
	0xf0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xf0, 0x00,
	0x30, 0x48, 0x80, 0x80, 0x80, 0x48, 0x30, 0x00,
	0xe0, 0x50, 0x48, 0x48, 0x48, 0x50, 0xe0, 0x00,
	0xf8, 0x48, 0x40, 0x70, 0x40, 0x48, 0xf8, 0x00,
	0xf8, 0x48, 0x40, 0x70, 0x40, 0x40, 0xe0, 0x00,
	0x30, 0x48, 0x80, 0x98, 0x88, 0x48, 0x38, 0x00,
	0x88, 0x88, 0x88, 0xf8, 0x88, 0x88, 0x88, 0x00,
	0xf8, 0x20, 0x20, 0x20, 0x20, 0x20, 0xf8, 0x00,
	0x18, 0x08, 0x08, 0x08, 0x88, 0x88, 0x70, 0x00,
	0xc8, 0x48, 0x50, 0x60, 0x50, 0x48, 0xc8, 0x00,
	0xe0, 0x40, 0x40, 0x40, 0x40, 0x48, 0xf8, 0x00,
	0x88, 0xd8, 0xa8, 0xa8, 0x88, 0x88, 0x88, 0x00,
	0x88, 0xc8, 0xa8, 0x98, 0x88, 0x88, 0x88, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0xf0, 0x48, 0x48, 0x70, 0x40, 0x40, 0xe0, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0xa8, 0x70, 0x08,
	0xf0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xc8, 0x00,
	0x70, 0x88, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00,
	0xf8, 0xa8, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x78, 0x00,
	0x88, 0x88, 0x88, 0x50, 0x50, 0x20, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x88, 0xa8, 0xd8, 0x88, 0x00,
	0x88, 0x88, 0x50, 0x20, 0x50, 0x88, 0x88, 0x00,
	0x88, 0x88, 0x88, 0x70, 0x20, 0x20, 0x70, 0x00,
	0xf8, 0x88, 0x10, 0x20, 0x40, 0x88, 0xf8, 0x00,
	0x00, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00,
	0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
	0x20, 0x00, 0x20, 0x40, 0x80, 0x88, 0x70, 0x00,
	0x20, 0x00, 0x20, 0x20, 0x70, 0x70, 0x20, 0x00,
	0x50, 0x00, 0x90, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x70, 0x08, 0x78, 0x88, 0x78, 0x00,
	0xc0, 0x40, 0x50, 0x68, 0x48, 0x48, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x80, 0x88, 0x70, 0x00,
	0x18, 0x10, 0x50, 0xb0, 0x90, 0x90, 0x70, 0x00,
	0x00, 0x00, 0x70, 0x88, 0xf8, 0x80, 0x70, 0x00,
	0x30, 0x48, 0x40, 0xe0, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x68, 0x90, 0x90, 0x70, 0x88, 0x70,
	0xc0, 0x40, 0x50, 0x68, 0x48, 0x48, 0xc8, 0x00,
	0x40, 0x00, 0xc0, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x08, 0x00, 0x08, 0x08, 0x08, 0x08, 0x88, 0x70,
	0xc0, 0x40, 0x48, 0x50, 0x60, 0x50, 0xc8, 0x00,
	0xc0, 0x40, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x90, 0xd8, 0xa8, 0x88, 0x88, 0x00,
	0x00, 0x00, 0xf0, 0x88, 0x88, 0x88, 0x88, 0x00,
	0x00, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x00, 0xb0, 0x48, 0x48, 0x70, 0x40, 0xe0,
	0x00, 0x00, 0x68, 0x90, 0x90, 0x70, 0x10, 0x38,
	0x00, 0x00, 0xb0, 0x48, 0x48, 0x40, 0xe0, 0x00,
	0x00, 0x00, 0x78, 0x80, 0x70, 0x08, 0xf0, 0x00,
	0x40, 0x40, 0xf0, 0x40, 0x40, 0x48, 0x30, 0x00,
	0x00, 0x00, 0x90, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x88, 0x50, 0x20, 0x00,
	0x00, 0x00, 0x88, 0x88, 0xa8, 0xd8, 0x90, 0x00,
	0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x88, 0x70, 0x20, 0xc0,
	0x00, 0x00, 0xf8, 0x90, 0x20, 0x48, 0xf8, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x0e, 0x08, 0x30, 0x08, 0x08, 0x0e, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
	0x00, 0x70, 0x10, 0x0c, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00,
	0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc,
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
};

static const byte english_waxworksFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20,
	0x00, 0x50, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x90, 0x00, 0x60, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x90, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x90, 0x00, 0x90, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x10, 0x28, 0x10, 0x2A, 0x44, 0x3A, 0x00,
	0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
	0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x3E, 0x08, 0x14, 0x00,
	0x00, 0x70, 0x88, 0xF0, 0x88, 0x88, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10,
	0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
	0x10, 0x20, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x00, 0x70, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x20, 0x60, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x10, 0x20, 0x48, 0xF8, 0x00,
	0x00, 0x70, 0x88, 0x30, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x10, 0x20, 0x40, 0x90, 0xF8, 0x10, 0x00,
	0x00, 0xF8, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x80, 0xF0, 0x88, 0x70, 0x00,
	0x00, 0xF8, 0x08, 0x10, 0x20, 0x40, 0x40, 0x00,
	0x00, 0x70, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x78, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00,
	0x40, 0x20, 0x00, 0x60, 0x90, 0x90, 0x68, 0x00,
	0x20, 0x50, 0x00, 0x98, 0x90, 0x90, 0xE8, 0x00,
	0x20, 0x10, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x20, 0x50, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x00, 0x3C, 0x42, 0x04, 0x08, 0x00, 0x08, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x20, 0x28, 0x30, 0x00,
	0x20, 0x50, 0x50, 0x70, 0x50, 0x50, 0x88, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xF0, 0x00,
	0x30, 0x48, 0x80, 0x80, 0x80, 0x48, 0x30, 0x00,
	0xF0, 0x48, 0x48, 0x48, 0x48, 0x48, 0xF0, 0x00,
	0xF8, 0x40, 0x40, 0x70, 0x40, 0x40, 0xF8, 0x00,
	0xF8, 0x40, 0x40, 0x70, 0x40, 0x40, 0xE0, 0x00,
	0x38, 0x40, 0x80, 0x98, 0x88, 0x48, 0x30, 0x00,
	0xC8, 0x48, 0x48, 0x78, 0x48, 0x48, 0xC8, 0x00,
	0x70, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x78, 0x10, 0x10, 0x10, 0x90, 0x90, 0x60, 0x00,
	0xC8, 0x50, 0x60, 0x40, 0x60, 0x50, 0xC8, 0x00,
	0xE0, 0x40, 0x40, 0x40, 0x40, 0x48, 0xF8, 0x00,
	0x88, 0xD8, 0xA8, 0x88, 0x88, 0x88, 0x88, 0x00,
	0xC8, 0x48, 0x68, 0x58, 0x58, 0x48, 0xC8, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x40, 0x40, 0xC0, 0x00,
	0x60, 0x90, 0x90, 0x90, 0xB0, 0x90, 0x68, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x50, 0x48, 0xC8, 0x00,
	0x70, 0x88, 0x80, 0x60, 0x10, 0x88, 0x70, 0x00,
	0xF8, 0xA8, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x88, 0x50, 0x50, 0x50, 0x50, 0x50, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x50, 0x50, 0x50, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x88, 0xA8, 0xD8, 0x88, 0x00,
	0x88, 0x50, 0x70, 0x20, 0x70, 0x50, 0x88, 0x00,
	0x88, 0x48, 0x30, 0x20, 0x40, 0x80, 0xC0, 0x00,
	0xF8, 0x88, 0x10, 0x20, 0x40, 0x80, 0xF8, 0x00,
	0x00, 0x0E, 0x08, 0x08, 0x08, 0x08, 0x0E, 0x00,
	0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00,
	0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x30, 0x48, 0x40, 0x48, 0x30, 0x10, 0x30,
	0x00, 0x50, 0x00, 0x60, 0x20, 0x28, 0x30, 0x00,
	0x20, 0x10, 0x00, 0x98, 0x90, 0x90, 0xE8, 0x00,
	0x00, 0x00, 0x60, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x40, 0x40, 0x50, 0x68, 0x48, 0x48, 0xF0, 0x00,
	0x00, 0x00, 0x30, 0x48, 0x40, 0x48, 0x30, 0x00,
	0x10, 0x10, 0x70, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x70, 0x48, 0x70, 0x40, 0x38, 0x00,
	0x10, 0x38, 0x20, 0x70, 0x20, 0x20, 0x20, 0x40,
	0x00, 0x00, 0x78, 0x90, 0x90, 0x90, 0x70, 0x10,
	0xC0, 0x40, 0x58, 0x68, 0x48, 0x48, 0xC8, 0x00,
	0x20, 0x00, 0x60, 0x20, 0x20, 0x28, 0x30, 0x00,
	0x10, 0x18, 0x10, 0x10, 0x10, 0x10, 0x10, 0x60,
	0x40, 0x40, 0x70, 0x48, 0x70, 0x50, 0xC8, 0x00,
	0x40, 0x40, 0x40, 0x40, 0x40, 0x50, 0x60, 0x00,
	0x00, 0x00, 0xA8, 0xF8, 0xA8, 0xA8, 0xA8, 0x00,
	0x00, 0x00, 0xD8, 0x68, 0x48, 0x48, 0x48, 0x00,
	0x00, 0x00, 0x30, 0x48, 0x48, 0x48, 0x30, 0x00,
	0x00, 0x00, 0xF0, 0x48, 0x48, 0x70, 0x40, 0xC0,
	0x00, 0x00, 0x70, 0x90, 0x90, 0x70, 0x18, 0x10,
	0x00, 0x00, 0xD8, 0x68, 0x40, 0x40, 0xE0, 0x00,
	0x00, 0x00, 0x38, 0x40, 0x30, 0x08, 0x70, 0x00,
	0x20, 0x20, 0x70, 0x20, 0x20, 0x28, 0x30, 0x00,
	0x00, 0x00, 0x98, 0x90, 0x90, 0x90, 0xE8, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x50, 0x50, 0x20, 0x00,
	0x00, 0x00, 0xA8, 0xA8, 0xA8, 0xF8, 0xA8, 0x00,
	0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00,
	0x00, 0x00, 0x98, 0x90, 0x90, 0x70, 0x10, 0x60,
	0x00, 0x00, 0x78, 0x10, 0x20, 0x40, 0x78, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x0E, 0x08, 0x30, 0x08, 0x08, 0x0E, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
	0x00, 0x70, 0x10, 0x0C, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x14, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
	0x00, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0x00,
};

static const byte french_waxworksFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20,
	0x00, 0x50, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x68, 0x00,
	0x30, 0x48, 0x80, 0x80, 0x48, 0x30, 0x10, 0x30,
	0x00, 0x10, 0x28, 0x10, 0x2A, 0x44, 0x3A, 0x00,
	0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
	0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x3E, 0x08, 0x14, 0x00,
	0x00, 0x70, 0x88, 0xF0, 0x88, 0x88, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10,
	0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
	0x10, 0x20, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x00, 0x70, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x20, 0x60, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x10, 0x20, 0x48, 0xF8, 0x00,
	0x00, 0x70, 0x88, 0x30, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x10, 0x20, 0x40, 0x90, 0xF8, 0x10, 0x00,
	0x00, 0xF8, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x80, 0xF0, 0x88, 0x70, 0x00,
	0x00, 0xF8, 0x08, 0x10, 0x20, 0x40, 0x40, 0x00,
	0x00, 0x70, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x78, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00,
	0x40, 0x20, 0x00, 0x60, 0x90, 0x90, 0x68, 0x00,
	0x20, 0x50, 0x00, 0x98, 0x90, 0x90, 0xE8, 0x00,
	0x20, 0x10, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x20, 0x50, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x00, 0x3C, 0x42, 0x04, 0x08, 0x00, 0x08, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x20, 0x28, 0x30, 0x00,
	0x20, 0x50, 0x50, 0x70, 0x50, 0x50, 0x88, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xF0, 0x00,
	0x30, 0x48, 0x80, 0x80, 0x80, 0x48, 0x30, 0x00,
	0xF0, 0x48, 0x48, 0x48, 0x48, 0x48, 0xF0, 0x00,
	0xF8, 0x40, 0x40, 0x70, 0x40, 0x40, 0xF8, 0x00,
	0xF8, 0x40, 0x40, 0x70, 0x40, 0x40, 0xE0, 0x00,
	0x38, 0x40, 0x80, 0x98, 0x88, 0x48, 0x30, 0x00,
	0xC8, 0x48, 0x48, 0x78, 0x48, 0x48, 0xC8, 0x00,
	0x70, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x78, 0x10, 0x10, 0x10, 0x90, 0x90, 0x60, 0x00,
	0xC8, 0x50, 0x60, 0x40, 0x60, 0x50, 0xC8, 0x00,
	0xE0, 0x40, 0x40, 0x40, 0x40, 0x48, 0xF8, 0x00,
	0x88, 0xD8, 0xA8, 0x88, 0x88, 0x88, 0x88, 0x00,
	0xC8, 0x48, 0x68, 0x58, 0x58, 0x48, 0xC8, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x40, 0x40, 0xC0, 0x00,
	0x60, 0x90, 0x90, 0x90, 0xB0, 0x90, 0x68, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x50, 0x48, 0xC8, 0x00,
	0x70, 0x88, 0x80, 0x60, 0x10, 0x88, 0x70, 0x00,
	0xF8, 0xA8, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x88, 0x50, 0x50, 0x50, 0x50, 0x50, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x50, 0x50, 0x50, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x88, 0xA8, 0xD8, 0x88, 0x00,
	0x88, 0x50, 0x70, 0x20, 0x70, 0x50, 0x88, 0x00,
	0x88, 0x48, 0x30, 0x20, 0x40, 0x80, 0xC0, 0x00,
	0xF8, 0x88, 0x10, 0x20, 0x40, 0x80, 0xF8, 0x00,
	0x00, 0x0E, 0x08, 0x08, 0x08, 0x08, 0x0E, 0x00,
	0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00,
	0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x30, 0x48, 0x40, 0x48, 0x30, 0x10, 0x30,
	0x00, 0x50, 0x00, 0x60, 0x20, 0x28, 0x30, 0x00,
	0x20, 0x10, 0x00, 0x98, 0x90, 0x90, 0xE8, 0x00,
	0x00, 0x00, 0x60, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x40, 0x40, 0x50, 0x68, 0x48, 0x48, 0xF0, 0x00,
	0x00, 0x00, 0x30, 0x48, 0x40, 0x48, 0x30, 0x00,
	0x10, 0x10, 0x70, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x70, 0x48, 0x70, 0x40, 0x38, 0x00,
	0x10, 0x38, 0x20, 0x70, 0x20, 0x20, 0x20, 0x40,
	0x00, 0x00, 0x78, 0x90, 0x90, 0x90, 0x70, 0x10,
	0xC0, 0x40, 0x58, 0x68, 0x48, 0x48, 0xC8, 0x00,
	0x20, 0x00, 0x60, 0x20, 0x20, 0x28, 0x30, 0x00,
	0x10, 0x18, 0x10, 0x10, 0x10, 0x10, 0x10, 0x60,
	0x40, 0x40, 0x70, 0x48, 0x70, 0x50, 0xC8, 0x00,
	0x40, 0x40, 0x40, 0x40, 0x40, 0x50, 0x60, 0x00,
	0x00, 0x00, 0xA8, 0xF8, 0xA8, 0xA8, 0xA8, 0x00,
	0x00, 0x00, 0xD8, 0x68, 0x48, 0x48, 0x48, 0x00,
	0x00, 0x00, 0x30, 0x48, 0x48, 0x48, 0x30, 0x00,
	0x00, 0x00, 0xF0, 0x48, 0x48, 0x70, 0x40, 0xC0,
	0x00, 0x00, 0x70, 0x90, 0x90, 0x70, 0x18, 0x10,
	0x00, 0x00, 0xD8, 0x68, 0x40, 0x40, 0xE0, 0x00,
	0x00, 0x00, 0x38, 0x40, 0x30, 0x08, 0x70, 0x00,
	0x20, 0x20, 0x70, 0x20, 0x20, 0x28, 0x30, 0x00,
	0x00, 0x00, 0x98, 0x90, 0x90, 0x90, 0xE8, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x50, 0x50, 0x20, 0x00,
	0x00, 0x00, 0xA8, 0xA8, 0xA8, 0xF8, 0xA8, 0x00,
	0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00,
	0x00, 0x00, 0x98, 0x90, 0x90, 0x70, 0x10, 0x60,
	0x00, 0x00, 0x78, 0x10, 0x20, 0x40, 0x78, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x0E, 0x08, 0x30, 0x08, 0x08, 0x0E, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
	0x00, 0x70, 0x10, 0x0C, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x14, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
	0x00, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0x00,
};

static const byte german_waxworksFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20,
	0x00, 0x50, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x90, 0x00, 0x60, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x90, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x90, 0x00, 0x90, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x10, 0x28, 0x10, 0x2A, 0x44, 0x3A, 0x00,
	0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
	0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x3E, 0x08, 0x14, 0x00,
	0x00, 0x70, 0x88, 0xF0, 0x88, 0x88, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10,
	0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
	0x50, 0x00, 0x20, 0x50, 0x50, 0x70, 0x50, 0x00,
	0x00, 0x70, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x20, 0x60, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x10, 0x20, 0x48, 0xF8, 0x00,
	0x00, 0x70, 0x88, 0x30, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x10, 0x20, 0x40, 0x90, 0xF8, 0x10, 0x00,
	0x00, 0xF8, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x80, 0xF0, 0x88, 0x70, 0x00,
	0x00, 0xF8, 0x08, 0x10, 0x20, 0x40, 0x40, 0x00,
	0x00, 0x70, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x78, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00,
	0x50, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x50, 0x00, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x90, 0x00, 0x90, 0x90, 0x90, 0x60, 0x00,
	0x20, 0x50, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x00, 0x3C, 0x42, 0x04, 0x08, 0x00, 0x08, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x20, 0x28, 0x30, 0x00,
	0x20, 0x50, 0x50, 0x70, 0x50, 0x50, 0x88, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xF0, 0x00,
	0x30, 0x48, 0x80, 0x80, 0x80, 0x48, 0x30, 0x00,
	0xF0, 0x48, 0x48, 0x48, 0x48, 0x48, 0xF0, 0x00,
	0xF8, 0x40, 0x40, 0x70, 0x40, 0x40, 0xF8, 0x00,
	0xF8, 0x40, 0x40, 0x70, 0x40, 0x40, 0xE0, 0x00,
	0x38, 0x40, 0x80, 0x98, 0x88, 0x48, 0x30, 0x00,
	0xC8, 0x48, 0x48, 0x78, 0x48, 0x48, 0xC8, 0x00,
	0x70, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x78, 0x10, 0x10, 0x10, 0x90, 0x90, 0x60, 0x00,
	0xC8, 0x50, 0x60, 0x40, 0x60, 0x50, 0xC8, 0x00,
	0xE0, 0x40, 0x40, 0x40, 0x40, 0x48, 0xF8, 0x00,
	0x88, 0xD8, 0xA8, 0x88, 0x88, 0x88, 0x88, 0x00,
	0xC8, 0x48, 0x68, 0x58, 0x58, 0x48, 0xC8, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x40, 0x40, 0xC0, 0x00,
	0x60, 0x90, 0x90, 0x90, 0xB0, 0x90, 0x68, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x50, 0x48, 0xC8, 0x00,
	0x70, 0x88, 0x80, 0x60, 0x10, 0x88, 0x70, 0x00,
	0xF8, 0xA8, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x88, 0x50, 0x50, 0x50, 0x50, 0x50, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x50, 0x50, 0x50, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x88, 0xA8, 0xD8, 0x88, 0x00,
	0x88, 0x50, 0x70, 0x20, 0x70, 0x50, 0x88, 0x00,
	0x88, 0x48, 0x30, 0x20, 0x40, 0x80, 0xC0, 0x00,
	0xF8, 0x88, 0x10, 0x20, 0x40, 0x80, 0xF8, 0x00,
	0x00, 0x0E, 0x08, 0x08, 0x08, 0x08, 0x0E, 0x00,
	0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00,
	0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x30, 0x48, 0x40, 0x48, 0x30, 0x10, 0x30,
	0x00, 0x50, 0x00, 0x60, 0x20, 0x28, 0x30, 0x00,
	0x20, 0x10, 0x00, 0x98, 0x90, 0x90, 0xE8, 0x00,
	0x00, 0x00, 0x60, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x40, 0x40, 0x50, 0x68, 0x48, 0x48, 0xF0, 0x00,
	0x00, 0x00, 0x30, 0x48, 0x40, 0x48, 0x30, 0x00,
	0x10, 0x10, 0x70, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x70, 0x48, 0x70, 0x40, 0x38, 0x00,
	0x10, 0x38, 0x20, 0x70, 0x20, 0x20, 0x20, 0x40,
	0x00, 0x00, 0x78, 0x90, 0x90, 0x90, 0x70, 0x10,
	0xC0, 0x40, 0x58, 0x68, 0x48, 0x48, 0xC8, 0x00,
	0x20, 0x00, 0x60, 0x20, 0x20, 0x28, 0x30, 0x00,
	0x10, 0x18, 0x10, 0x10, 0x10, 0x10, 0x10, 0x60,
	0x40, 0x40, 0x70, 0x48, 0x70, 0x50, 0xC8, 0x00,
	0x40, 0x40, 0x40, 0x40, 0x40, 0x50, 0x60, 0x00,
	0x00, 0x00, 0xA8, 0xF8, 0xA8, 0xA8, 0xA8, 0x00,
	0x00, 0x00, 0xD8, 0x68, 0x48, 0x48, 0x48, 0x00,
	0x00, 0x00, 0x30, 0x48, 0x48, 0x48, 0x30, 0x00,
	0x00, 0x00, 0xF0, 0x48, 0x48, 0x70, 0x40, 0xC0,
	0x00, 0x00, 0x70, 0x90, 0x90, 0x70, 0x18, 0x10,
	0x00, 0x00, 0xD8, 0x68, 0x40, 0x40, 0xE0, 0x00,
	0x00, 0x00, 0x38, 0x40, 0x30, 0x08, 0x70, 0x00,
	0x20, 0x20, 0x70, 0x20, 0x20, 0x28, 0x30, 0x00,
	0x00, 0x00, 0x98, 0x90, 0x90, 0x90, 0xE8, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x50, 0x50, 0x20, 0x00,
	0x00, 0x00, 0xA8, 0xA8, 0xA8, 0xF8, 0xA8, 0x00,
	0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00,
	0x00, 0x00, 0x98, 0x90, 0x90, 0x70, 0x10, 0x60,
	0x00, 0x00, 0x78, 0x10, 0x20, 0x40, 0x78, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x0E, 0x08, 0x30, 0x08, 0x08, 0x0E, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
	0x00, 0x70, 0x10, 0x0C, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x14, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
	0x00, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0x00,
};

static const byte italian_waxworksFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20,
	0x00, 0x50, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x90, 0x00, 0x60, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x90, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x40, 0x20, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x10, 0x28, 0x10, 0x2A, 0x44, 0x3A, 0x00,
	0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
	0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x3E, 0x08, 0x14, 0x00,
	0x40, 0x20, 0x00, 0x60, 0x20, 0x28, 0x30, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10,
	0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
	0x10, 0x20, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x00, 0x70, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x20, 0x60, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x10, 0x20, 0x48, 0xF8, 0x00,
	0x00, 0x70, 0x88, 0x30, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x10, 0x20, 0x40, 0x90, 0xF8, 0x10, 0x00,
	0x00, 0xF8, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x80, 0xF0, 0x88, 0x70, 0x00,
	0x00, 0xF8, 0x08, 0x10, 0x20, 0x40, 0x40, 0x00,
	0x00, 0x70, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x78, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00,
	0x40, 0x20, 0x00, 0x60, 0x90, 0x90, 0x68, 0x00,
	0x40, 0x20, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x20, 0x10, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x20, 0x50, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x00, 0x3C, 0x42, 0x04, 0x08, 0x00, 0x08, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x20, 0x28, 0x30, 0x00,
	0x20, 0x50, 0x50, 0x70, 0x50, 0x50, 0x88, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xF0, 0x00,
	0x30, 0x48, 0x80, 0x80, 0x80, 0x48, 0x30, 0x00,
	0xF0, 0x48, 0x48, 0x48, 0x48, 0x48, 0xF0, 0x00,
	0xF8, 0x40, 0x40, 0x70, 0x40, 0x40, 0xF8, 0x00,
	0xF8, 0x40, 0x40, 0x70, 0x40, 0x40, 0xE0, 0x00,
	0x38, 0x40, 0x80, 0x98, 0x88, 0x48, 0x30, 0x00,
	0xC8, 0x48, 0x48, 0x78, 0x48, 0x48, 0xC8, 0x00,
	0x70, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x78, 0x10, 0x10, 0x10, 0x90, 0x90, 0x60, 0x00,
	0xC8, 0x50, 0x60, 0x40, 0x60, 0x50, 0xC8, 0x00,
	0xE0, 0x40, 0x40, 0x40, 0x40, 0x48, 0xF8, 0x00,
	0x88, 0xD8, 0xA8, 0x88, 0x88, 0x88, 0x88, 0x00,
	0xC8, 0x48, 0x68, 0x58, 0x58, 0x48, 0xC8, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x40, 0x40, 0xC0, 0x00,
	0x60, 0x90, 0x90, 0x90, 0xB0, 0x90, 0x68, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x50, 0x48, 0xC8, 0x00,
	0x70, 0x88, 0x80, 0x60, 0x10, 0x88, 0x70, 0x00,
	0xF8, 0xA8, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x88, 0x50, 0x50, 0x50, 0x50, 0x50, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x50, 0x50, 0x50, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x88, 0xA8, 0xD8, 0x88, 0x00,
	0x88, 0x50, 0x70, 0x20, 0x70, 0x50, 0x88, 0x00,
	0x88, 0x48, 0x30, 0x20, 0x40, 0x80, 0xC0, 0x00,
	0xF8, 0x88, 0x10, 0x20, 0x40, 0x80, 0xF8, 0x00,
	0x00, 0x0E, 0x08, 0x08, 0x08, 0x08, 0x0E, 0x00,
	0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00,
	0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x30, 0x48, 0x40, 0x48, 0x30, 0x10, 0x30,
	0x00, 0x50, 0x00, 0x60, 0x20, 0x28, 0x30, 0x00,
	0x20, 0x10, 0x00, 0x98, 0x90, 0x90, 0xE8, 0x00,
	0x00, 0x00, 0x60, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x40, 0x40, 0x50, 0x68, 0x48, 0x48, 0xF0, 0x00,
	0x00, 0x00, 0x30, 0x48, 0x40, 0x48, 0x30, 0x00,
	0x10, 0x10, 0x70, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x70, 0x48, 0x70, 0x40, 0x38, 0x00,
	0x10, 0x38, 0x20, 0x70, 0x20, 0x20, 0x20, 0x40,
	0x00, 0x00, 0x78, 0x90, 0x90, 0x90, 0x70, 0x10,
	0xC0, 0x40, 0x58, 0x68, 0x48, 0x48, 0xC8, 0x00,
	0x20, 0x00, 0x60, 0x20, 0x20, 0x28, 0x30, 0x00,
	0x10, 0x18, 0x10, 0x10, 0x10, 0x10, 0x10, 0x60,
	0x40, 0x40, 0x70, 0x48, 0x70, 0x50, 0xC8, 0x00,
	0x40, 0x40, 0x40, 0x40, 0x40, 0x50, 0x60, 0x00,
	0x00, 0x00, 0xA8, 0xF8, 0xA8, 0xA8, 0xA8, 0x00,
	0x00, 0x00, 0xD8, 0x68, 0x48, 0x48, 0x48, 0x00,
	0x00, 0x00, 0x30, 0x48, 0x48, 0x48, 0x30, 0x00,
	0x00, 0x00, 0xF0, 0x48, 0x48, 0x70, 0x40, 0xC0,
	0x00, 0x00, 0x70, 0x90, 0x90, 0x70, 0x18, 0x10,
	0x00, 0x00, 0xD8, 0x68, 0x40, 0x40, 0xE0, 0x00,
	0x00, 0x00, 0x38, 0x40, 0x30, 0x08, 0x70, 0x00,
	0x20, 0x20, 0x70, 0x20, 0x20, 0x28, 0x30, 0x00,
	0x00, 0x00, 0x98, 0x90, 0x90, 0x90, 0xE8, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x50, 0x50, 0x20, 0x00,
	0x00, 0x00, 0xA8, 0xA8, 0xA8, 0xF8, 0xA8, 0x00,
	0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00,
	0x00, 0x00, 0x98, 0x90, 0x90, 0x70, 0x10, 0x60,
	0x00, 0x00, 0x78, 0x10, 0x20, 0x40, 0x78, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x0E, 0x08, 0x30, 0x08, 0x08, 0x0E, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
	0x00, 0x70, 0x10, 0x0C, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x14, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
	0x00, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0x00,
};

static const byte spanish_waxworksFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20,
	0x00, 0x50, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x90, 0x00, 0x60, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x90, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x90, 0x00, 0x90, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x10, 0x28, 0x10, 0x2A, 0x44, 0x3A, 0x00,
	0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
	0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x3E, 0x08, 0x14, 0x00,
	0x00, 0x70, 0x88, 0xF0, 0x88, 0x88, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10,
	0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
	0x10, 0x20, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x00, 0x70, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x20, 0x60, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x10, 0x20, 0x48, 0xF8, 0x00,
	0x00, 0x70, 0x88, 0x30, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x10, 0x20, 0x40, 0x90, 0xF8, 0x10, 0x00,
	0x00, 0xF8, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x80, 0xF0, 0x88, 0x70, 0x00,
	0x00, 0xF8, 0x08, 0x10, 0x20, 0x40, 0x40, 0x00,
	0x00, 0x70, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x78, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00,
	0x20, 0x40, 0x00, 0x60, 0x90, 0x90, 0x68, 0x00,
	0x20, 0x40, 0x00, 0x60, 0x20, 0x28, 0x30, 0x00,
	0x20, 0x40, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x20, 0x40, 0x00, 0x98, 0x90, 0x90, 0xE8, 0x00,
	0x00, 0x3C, 0x42, 0x04, 0x08, 0x00, 0x08, 0x00,
	0x28, 0x50, 0x00, 0xD8, 0x68, 0x48, 0x48, 0x00,
	0x20, 0x50, 0x50, 0x70, 0x50, 0x50, 0x88, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xF0, 0x00,
	0x30, 0x48, 0x80, 0x80, 0x80, 0x48, 0x30, 0x00,
	0xF0, 0x48, 0x48, 0x48, 0x48, 0x48, 0xF0, 0x00,
	0xF8, 0x40, 0x40, 0x70, 0x40, 0x40, 0xF8, 0x00,
	0xF8, 0x40, 0x40, 0x70, 0x40, 0x40, 0xE0, 0x00,
	0x38, 0x40, 0x80, 0x98, 0x88, 0x48, 0x30, 0x00,
	0xC8, 0x48, 0x48, 0x78, 0x48, 0x48, 0xC8, 0x00,
	0x70, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x78, 0x10, 0x10, 0x10, 0x90, 0x90, 0x60, 0x00,
	0xC8, 0x50, 0x60, 0x40, 0x60, 0x50, 0xC8, 0x00,
	0xE0, 0x40, 0x40, 0x40, 0x40, 0x48, 0xF8, 0x00,
	0x88, 0xD8, 0xA8, 0x88, 0x88, 0x88, 0x88, 0x00,
	0xC8, 0x48, 0x68, 0x58, 0x58, 0x48, 0xC8, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x40, 0x40, 0xC0, 0x00,
	0x60, 0x90, 0x90, 0x90, 0xB0, 0x90, 0x68, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x50, 0x48, 0xC8, 0x00,
	0x70, 0x88, 0x80, 0x60, 0x10, 0x88, 0x70, 0x00,
	0xF8, 0xA8, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x88, 0x50, 0x50, 0x50, 0x50, 0x50, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x50, 0x50, 0x50, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x88, 0xA8, 0xD8, 0x88, 0x00,
	0x88, 0x50, 0x70, 0x20, 0x70, 0x50, 0x88, 0x00,
	0x88, 0x48, 0x30, 0x20, 0x40, 0x80, 0xC0, 0x00,
	0xF8, 0x88, 0x10, 0x20, 0x40, 0x80, 0xF8, 0x00,
	0x00, 0x0E, 0x08, 0x08, 0x08, 0x08, 0x0E, 0x00,
	0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00,
	0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x20, 0x00, 0x20, 0x40, 0x88, 0x70, 0x00,
	0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
	0x00, 0x90, 0x00, 0x90, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x00, 0x60, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x40, 0x40, 0x50, 0x68, 0x48, 0x48, 0xF0, 0x00,
	0x00, 0x00, 0x30, 0x48, 0x40, 0x48, 0x30, 0x00,
	0x10, 0x10, 0x70, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x70, 0x48, 0x70, 0x40, 0x38, 0x00,
	0x10, 0x38, 0x20, 0x70, 0x20, 0x20, 0x20, 0x40,
	0x00, 0x00, 0x78, 0x90, 0x90, 0x90, 0x70, 0x10,
	0xC0, 0x40, 0x58, 0x68, 0x48, 0x48, 0xC8, 0x00,
	0x20, 0x00, 0x60, 0x20, 0x20, 0x28, 0x30, 0x00,
	0x10, 0x18, 0x10, 0x10, 0x10, 0x10, 0x10, 0x60,
	0x40, 0x40, 0x70, 0x48, 0x70, 0x50, 0xC8, 0x00,
	0x40, 0x40, 0x40, 0x40, 0x40, 0x50, 0x60, 0x00,
	0x00, 0x00, 0xA8, 0xF8, 0xA8, 0xA8, 0xA8, 0x00,
	0x00, 0x00, 0xD8, 0x68, 0x48, 0x48, 0x48, 0x00,
	0x00, 0x00, 0x30, 0x48, 0x48, 0x48, 0x30, 0x00,
	0x00, 0x00, 0xF0, 0x48, 0x48, 0x70, 0x40, 0xC0,
	0x00, 0x00, 0x70, 0x90, 0x90, 0x70, 0x18, 0x10,
	0x00, 0x00, 0xD8, 0x68, 0x40, 0x40, 0xE0, 0x00,
	0x00, 0x00, 0x38, 0x40, 0x30, 0x08, 0x70, 0x00,
	0x20, 0x20, 0x70, 0x20, 0x20, 0x28, 0x30, 0x00,
	0x00, 0x00, 0x98, 0x90, 0x90, 0x90, 0xE8, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x50, 0x50, 0x20, 0x00,
	0x00, 0x00, 0xA8, 0xA8, 0xA8, 0xF8, 0xA8, 0x00,
	0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00,
	0x00, 0x00, 0x98, 0x90, 0x90, 0x70, 0x10, 0x60,
	0x00, 0x00, 0x78, 0x10, 0x20, 0x40, 0x78, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x0E, 0x08, 0x30, 0x08, 0x08, 0x0E, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
	0x00, 0x70, 0x10, 0x0C, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x14, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
	0x00, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0x00,
};

static const byte english_elvira1Font[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20,
	0x00, 0x50, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x90, 0x00, 0x60, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x90, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x90, 0x00, 0x90, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x10, 0x28, 0x10, 0x2A, 0x44, 0x3A, 0x00,
	0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
	0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x3E, 0x08, 0x14, 0x00,
	0x00, 0x70, 0x88, 0xF0, 0x88, 0x88, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10,
	0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
	0x10, 0x20, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x00, 0x70, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x20, 0x60, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x10, 0x20, 0x48, 0xF8, 0x00,
	0x00, 0x70, 0x88, 0x30, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x10, 0x20, 0x40, 0x90, 0xF8, 0x10, 0x00,
	0x00, 0xF8, 0x80, 0x70, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x80, 0xF0, 0x88, 0x70, 0x00,
	0x00, 0xF8, 0x08, 0x10, 0x20, 0x40, 0x40, 0x00,
	0x00, 0x70, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,
	0x00, 0x70, 0x88, 0x78, 0x08, 0x88, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00,
	0x40, 0x20, 0x00, 0x60, 0x90, 0x90, 0x68, 0x00,
	0x20, 0x50, 0x00, 0x98, 0x90, 0x90, 0xE8, 0x00,
	0x20, 0x10, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x20, 0x50, 0x00, 0x78, 0x70, 0x40, 0x38, 0x00,
	0x00, 0x3C, 0x42, 0x04, 0x08, 0x00, 0x08, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x20, 0x28, 0x30, 0x00,
	0x20, 0x50, 0x50, 0x70, 0x50, 0x50, 0x88, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x48, 0x48, 0xF0, 0x00,
	0x30, 0x48, 0x80, 0x80, 0x80, 0x48, 0x30, 0x00,
	0xF0, 0x48, 0x48, 0x48, 0x48, 0x48, 0xF0, 0x00,
	0xF8, 0x40, 0x40, 0x70, 0x40, 0x40, 0xF8, 0x00,
	0xF8, 0x40, 0x40, 0x70, 0x40, 0x40, 0xE0, 0x00,
	0x38, 0x40, 0x80, 0x98, 0x88, 0x48, 0x30, 0x00,
	0xC8, 0x48, 0x48, 0x78, 0x48, 0x48, 0xC8, 0x00,
	0x70, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x78, 0x10, 0x10, 0x10, 0x90, 0x90, 0x60, 0x00,
	0xC8, 0x50, 0x60, 0x40, 0x60, 0x50, 0xC8, 0x00,
	0xE0, 0x40, 0x40, 0x40, 0x40, 0x48, 0xF8, 0x00,
	0x88, 0xD8, 0xA8, 0x88, 0x88, 0x88, 0x88, 0x00,
	0xC8, 0x48, 0x68, 0x58, 0x58, 0x48, 0xC8, 0x00,
	0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x40, 0x40, 0xC0, 0x00,
	0x60, 0x90, 0x90, 0x90, 0xB0, 0x90, 0x68, 0x00,
	0xF0, 0x48, 0x48, 0x70, 0x50, 0x48, 0xC8, 0x00,
	0x70, 0x88, 0x80, 0x60, 0x10, 0x88, 0x70, 0x00,
	0xF8, 0xA8, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
	0x88, 0x50, 0x50, 0x50, 0x50, 0x50, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x50, 0x50, 0x50, 0x20, 0x00,
	0x88, 0x88, 0x88, 0x88, 0xA8, 0xD8, 0x88, 0x00,
	0x88, 0x50, 0x70, 0x20, 0x70, 0x50, 0x88, 0x00,
	0x88, 0x48, 0x30, 0x20, 0x40, 0x80, 0xC0, 0x00,
	0xF8, 0x88, 0x10, 0x20, 0x40, 0x80, 0xF8, 0x00,
	0x00, 0x0E, 0x08, 0x08, 0x08, 0x08, 0x0E, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x30, 0x48, 0x40, 0x48, 0x30, 0x10, 0x30,
	0x00, 0x50, 0x00, 0x60, 0x20, 0x28, 0x30, 0x00,
	0x20, 0x10, 0x00, 0x98, 0x90, 0x90, 0xE8, 0x00,
	0x00, 0x00, 0x60, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x40, 0x40, 0x50, 0x68, 0x48, 0x48, 0xF0, 0x00,
	0x00, 0x00, 0x30, 0x48, 0x40, 0x48, 0x30, 0x00,
	0x10, 0x10, 0x70, 0x90, 0x90, 0x90, 0x68, 0x00,
	0x00, 0x00, 0x70, 0x48, 0x70, 0x40, 0x38, 0x00,
	0x10, 0x38, 0x20, 0x70, 0x20, 0x20, 0x20, 0x40,
	0x00, 0x00, 0x78, 0x90, 0x90, 0x90, 0x70, 0x10,
	0xC0, 0x40, 0x58, 0x68, 0x48, 0x48, 0xC8, 0x00,
	0x20, 0x00, 0x60, 0x20, 0x20, 0x28, 0x30, 0x00,
	0x10, 0x18, 0x10, 0x10, 0x10, 0x10, 0x10, 0x60,
	0x40, 0x40, 0x70, 0x48, 0x70, 0x50, 0xC8, 0x00,
	0x40, 0x40, 0x40, 0x40, 0x40, 0x50, 0x60, 0x00,
	0x00, 0x00, 0xA8, 0xF8, 0xA8, 0xA8, 0xA8, 0x00,
	0x00, 0x00, 0xD8, 0x68, 0x48, 0x48, 0x48, 0x00,
	0x00, 0x00, 0x30, 0x48, 0x48, 0x48, 0x30, 0x00,
	0x00, 0x00, 0xF0, 0x48, 0x48, 0x70, 0x40, 0xC0,
	0x00, 0x00, 0x70, 0x90, 0x90, 0x70, 0x18, 0x10,
	0x00, 0x00, 0xD8, 0x68, 0x40, 0x40, 0xE0, 0x00,
	0x00, 0x00, 0x38, 0x40, 0x30, 0x08, 0x70, 0x00,
	0x20, 0x20, 0x70, 0x20, 0x20, 0x28, 0x30, 0x00,
	0x00, 0x00, 0x98, 0x90, 0x90, 0x90, 0xE8, 0x00,
	0x00, 0x00, 0x88, 0x88, 0x50, 0x50, 0x20, 0x00,
	0x00, 0x00, 0xA8, 0xA8, 0xA8, 0xF8, 0xA8, 0x00,
	0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00,
	0x00, 0x00, 0x98, 0x90, 0x90, 0x70, 0x10, 0x60,
	0x00, 0x00, 0x78, 0x10, 0x20, 0x40, 0x78, 0x00,
	0x20, 0x50, 0x00, 0x60, 0x90, 0x90, 0x60, 0x00,
	0x00, 0x0E, 0x08, 0x30, 0x08, 0x08, 0x0E, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
	0x00, 0x70, 0x10, 0x0C, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x14, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
	0x00, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0x00,
};

static const byte english_pnFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x00,
	0x00, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x24, 0x7E, 0x24, 0x24, 0x7E, 0x24, 0x00,
	0x00, 0x08, 0x3E, 0x28, 0x3E, 0x0A, 0x3E, 0x08,
	0x00, 0x62, 0x64, 0x08, 0x10, 0x26, 0x46, 0x00,
	0x00, 0x10, 0x28, 0x10, 0x2A, 0x44, 0x3A, 0x00,
	0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x00,
	0x00, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x3E, 0x08, 0x14, 0x00,
	0x00, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10,
	0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
	0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00,
	0x00, 0x3C, 0x46, 0x4A, 0x52, 0x62, 0x3C, 0x00,
	0x00, 0x18, 0x28, 0x08, 0x08, 0x08, 0x3E, 0x00,
	0x00, 0x3C, 0x42, 0x02, 0x3C, 0x40, 0x7E, 0x00,
	0x00, 0x3C, 0x42, 0x0C, 0x02, 0x42, 0x3C, 0x00,
	0x00, 0x08, 0x18, 0x28, 0x48, 0x7E, 0x08, 0x00,
	0x00, 0x7E, 0x40, 0x7C, 0x02, 0x42, 0x3C, 0x00,
	0x00, 0x3C, 0x40, 0x7C, 0x42, 0x42, 0x3C, 0x00,
	0x00, 0x7E, 0x02, 0x04, 0x08, 0x10, 0x10, 0x00,
	0x00, 0x3C, 0x42, 0x3C, 0x42, 0x42, 0x3C, 0x00,
	0x00, 0x3C, 0x42, 0x42, 0x3E, 0x02, 0x3C, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00,
	0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x10, 0x20,
	0x00, 0x00, 0x04, 0x08, 0x10, 0x08, 0x04, 0x00,
	0x00, 0x00, 0x00, 0x3E, 0x00, 0x3E, 0x00, 0x00,
	0x00, 0x00, 0x10, 0x08, 0x04, 0x08, 0x10, 0x00,
	0x00, 0x3C, 0x42, 0x04, 0x08, 0x00, 0x08, 0x00,
	0x00, 0x3C, 0x4A, 0x56, 0x5E, 0x40, 0x3C, 0x00,
	0x00, 0x3C, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x00,
	0x00, 0x7C, 0x42, 0x7C, 0x42, 0x42, 0x7C, 0x00,
	0x00, 0x3C, 0x42, 0x40, 0x40, 0x42, 0x3C, 0x00,
	0x00, 0x78, 0x44, 0x42, 0x42, 0x44, 0x78, 0x00,
	0x00, 0x7E, 0x40, 0x7C, 0x40, 0x40, 0x7E, 0x00,
	0x00, 0x7E, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x00,
	0x00, 0x3C, 0x42, 0x40, 0x4E, 0x42, 0x3C, 0x00,
	0x00, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x00,
	0x00, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00,
	0x00, 0x02, 0x02, 0x02, 0x42, 0x42, 0x3C, 0x00,
	0x00, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00,
	0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x00,
	0x00, 0x42, 0x66, 0x5A, 0x42, 0x42, 0x42, 0x00,
	0x00, 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x00,
	0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00,
	0x00, 0x7C, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x00,
	0x00, 0x3C, 0x42, 0x42, 0x52, 0x4A, 0x3C, 0x00,
	0x00, 0x7C, 0x42, 0x42, 0x7C, 0x44, 0x42, 0x00,
	0x00, 0x3C, 0x40, 0x3C, 0x02, 0x42, 0x3C, 0x00,
	0x00, 0xFE, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00,
	0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00,
	0x00, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18, 0x00,
	0x00, 0x42, 0x42, 0x42, 0x42, 0x5A, 0x24, 0x00,
	0x00, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x00,
	0x00, 0x82, 0x44, 0x28, 0x10, 0x10, 0x10, 0x00,
	0x00, 0x7E, 0x04, 0x08, 0x10, 0x20, 0x7E, 0x00,
	0x00, 0x0E, 0x08, 0x08, 0x08, 0x08, 0x0E, 0x00,
	0x00, 0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00,
	0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x10, 0x38, 0x54, 0x10, 0x10, 0x10, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
	0x00, 0x1C, 0x22, 0x78, 0x20, 0x20, 0x7E, 0x00,
	0x00, 0x00, 0x38, 0x04, 0x3C, 0x44, 0x3C, 0x00,
	0x00, 0x20, 0x20, 0x3C, 0x22, 0x22, 0x3C, 0x00,
	0x00, 0x00, 0x1C, 0x20, 0x20, 0x20, 0x1C, 0x00,
	0x00, 0x04, 0x04, 0x3C, 0x44, 0x44, 0x3C, 0x00,
	0x00, 0x00, 0x38, 0x44, 0x78, 0x40, 0x3C, 0x00,
	0x00, 0x0C, 0x10, 0x18, 0x10, 0x10, 0x10, 0x00,
	0x00, 0x00, 0x3C, 0x44, 0x44, 0x3C, 0x04, 0x38,
	0x00, 0x40, 0x40, 0x78, 0x44, 0x44, 0x44, 0x00,
	0x00, 0x10, 0x00, 0x30, 0x10, 0x10, 0x38, 0x00,
	0x00, 0x04, 0x00, 0x04, 0x04, 0x04, 0x24, 0x18,
	0x00, 0x20, 0x28, 0x30, 0x30, 0x28, 0x24, 0x00,
	0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x0C, 0x00,
	0x00, 0x00, 0x68, 0x54, 0x54, 0x54, 0x54, 0x00,
	0x00, 0x00, 0x78, 0x44, 0x44, 0x44, 0x44, 0x00,
	0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00,
	0x00, 0x00, 0x78, 0x44, 0x44, 0x78, 0x40, 0x40,
	0x00, 0x00, 0x3C, 0x44, 0x44, 0x3C, 0x04, 0x06,
	0x00, 0x00, 0x1C, 0x20, 0x20, 0x20, 0x20, 0x00,
	0x00, 0x00, 0x38, 0x40, 0x38, 0x04, 0x78, 0x00,
	0x00, 0x10, 0x38, 0x10, 0x10, 0x10, 0x0C, 0x00,
	0x00, 0x00, 0x44, 0x44, 0x44, 0x44, 0x38, 0x00,
	0x00, 0x00, 0x44, 0x44, 0x28, 0x28, 0x10, 0x00,
	0x00, 0x00, 0x44, 0x54, 0x54, 0x54, 0x28, 0x00,
	0x00, 0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00,
	0x00, 0x00, 0x44, 0x44, 0x44, 0x3C, 0x04, 0x38,
	0x00, 0x00, 0x7C, 0x08, 0x10, 0x20, 0x7C, 0x00,
	0x00, 0x0E, 0x08, 0x30, 0x08, 0x08, 0x0E, 0x00,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
	0x00, 0x70, 0x10, 0x0C, 0x10, 0x10, 0x70, 0x00,
	0x00, 0x14, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3C, 0x42, 0x99, 0xA1, 0xA1, 0x99, 0x42, 0x3C,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

void AGOSEngine::windowDrawChar(WindowBlock *window, uint x, uint y, byte chr) {
	const byte *src;
	byte color, *dst;
	uint dstPitch, h, w, i;

	_videoLockOut |= 0x8000;

	Graphics::Surface *screen = getBackendSurface();

	if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
		dst = (byte *)screen->getPixels();
		dstPitch = screen->pitch;
		h = 8;
		w = 6;

		switch (_language) {
		case Common::CS_CZE:
			src = czech_simonFont + (chr - 32) * 8;
			break;
		case Common::RU_RUS:
			src = russian_simonFont + (chr - 32) * 8;
			break;
		case Common::PL_POL:
			src = polish_simonFont + (chr - 32) * 8;
			break;
		case Common::HE_ISR:
			src = hebrew_simonFont + (chr - 32) * 8;
			break;
		case Common::ES_ESP:
			src = spanish_simonFont + (chr - 32) * 8;
			break;
		case Common::IT_ITA:
			src = italian_simonFont + (chr - 32) * 8;
			break;
		case Common::FR_FRA:
			src = french_simonFont + (chr - 32) * 8;
			break;
		case Common::DE_DEU:
			src = german_simonFont + (chr - 32) * 8;
			break;
		case Common::EN_ANY:
			src = english_simonFont + (chr - 32) * 8;
			break;
		default:
			error("windowDrawChar: Unknown language %d", _language);
		}
	} else if (getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) {
		dst = (byte *)screen->getPixels();
		dstPitch = screen->pitch;
		h = 8;
		w = 6;

		switch (_language) {
		case Common::ES_ESP:
			src = spanish_waxworksFont + (chr - 32) * 8;
			break;
		case Common::IT_ITA:
			src = italian_waxworksFont + (chr - 32) * 8;
			break;
		case Common::FR_FRA:
			src = french_waxworksFont + (chr - 32) * 8;
			break;
		case Common::DE_DEU:
			src = german_waxworksFont + (chr - 32) * 8;
			break;
		case Common::EN_ANY:
			src = english_waxworksFont + (chr - 32) * 8;
			break;
		default:
			error("windowDrawChar: Unknown language %d", _language);
		}
	} else if (getGameType() == GType_ELVIRA1) {
		dst = (byte *)screen->getPixels();
		dstPitch = screen->pitch;
		h = 8;
		w = 6;

		src = english_elvira1Font + (chr - 32) * 8;
	} else {
		dst = (byte *)screen->getPixels();
		dstPitch = screen->pitch;
		h = 8;
		w = 8;

		src = english_pnFont + (chr - 32) * 8;
	}
	dst += y * dstPitch + x + window->textColumnOffset;

	color = window->textColor;
	if (getGameType() == GType_ELVIRA2 || getGameType() == GType_WW)
		color += dst[0] & 0xF0;

	do {
		int8 b = *src++;
		i = 0;
		do {
			if (b < 0) {
				dst[i] = color;
			}

			b <<= 1;
		} while (++i != w);
		dst += dstPitch;
	} while (--h);

	Common::Rect dirtyRect(x + window->textColumnOffset, y, x + window->textColumnOffset + 6, y + 8);
	updateBackendSurface(&dirtyRect);

	_videoLockOut &= ~0x8000;
}

void AGOSEngine_Elvira1::windowDrawChar(WindowBlock *window, uint x, uint y, byte chr) {
	if (_language != Common::JA_JPN || _forceAscii) {
		AGOSEngine::windowDrawChar(window, x, y, chr);
		return;
	}

	if (_sjisCurChar) {
		_sjisCurChar |= (chr << 8);
	} else {
		_sjisCurChar = chr;
		if ((chr >= 0x80 && chr < 0xA0) || chr >= 0xE0)
			return;
	}

	_videoLockOut |= 0x8000;

	x = x & ~7;
	y = (y + 4) & ~3;
	// PC-98 uses text mode black (hardware colors, not related to the graphics mode palette
	// colors) for font drawing, so I just set one of the unused black colors (color 33) here.
	_sjisFont->drawChar(*_scaleBuf, _sjisCurChar, x << 1, y << 1, 33, 0);
	Common::Rect dirtyRect(x, y, x + (_sjisFont->getCharWidth(_sjisCurChar) >> 1), y + (_sjisFont->getFontHeight() >> 1));
	addHiResTextDirtyRect(dirtyRect);
	updateBackendSurface(&dirtyRect);
	_sjisCurChar = 0;

	_videoLockOut &= ~0x8000;
}

void AGOSEngine_Elvira1::addHiResTextDirtyRect(Common::Rect rect) {
	rect.left >>= 1;
	rect.top <<= 1;
	rect.right >>= 1;
	rect.bottom <<= 1;

	for (Common::Array<Common::Rect>::iterator i = _sjisTextFields.begin(); i != _sjisTextFields.end(); ++i) {
		// Merge rects if it makes sense, but only once.
		if (rect.left <= i->right && rect.right >= i->left && rect.top <= i->bottom && rect.bottom >= i->top) {
			i->left = MIN<int16>(i->left, rect.left);
			i->top = MIN<int16>(i->top, rect.top);
			i->right = MAX<int16>(i->right, rect.right);
			i->bottom = MAX<int16>(i->bottom, rect.bottom);
			return;
		}
	}

	_sjisTextFields.push_back(rect);
}

void AGOSEngine_Elvira1::clearHiResTextLayer() {
	if (getPlatform() != Common::kPlatformPC98)
		return;

	void *p = _scaleBuf->getPixels();
	assert(p);

	if (_sjisTextFields.size() < 10) {
		for (Common::Array<Common::Rect>::iterator i = _sjisTextFields.begin(); i != _sjisTextFields.end(); ++i) {
			uint16 w = i->width();
			uint16 ptch = _scaleBuf->pitch >> 2;
			uint32 *dst = (uint32*)p + i->top * ptch + i->left;
			for (uint32 *end = dst + i->height() * ptch; dst < end; dst += ptch)
				Common::fill<uint32*, uint32>(dst, &dst[w], 0);
			i->left <<= 1;
			i->top >>= 1;
			i->right <<= 1;
			i->bottom >>= 1;
			updateBackendSurface(i);
		}
	} else {
		memset(p, 0, _scaleBuf->w * _scaleBuf->h);
		updateBackendSurface();
	}
	_sjisTextFields.clear();
}

} // End of namespace AGOS

================
File: charset.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/system.h"

#include "agos/agos.h"
#include "agos/intern.h"

#include "graphics/surface.h"

namespace AGOS {

#ifdef ENABLE_AGOS2
void AGOSEngine_Feeble::doOutput(const byte *src, uint len) {
	if (_textWindow == NULL)
		return;

	while (len-- != 0 && !shouldQuit()) {
		if (getBitFlag(93)) {
			if (_curWindow == 3) {
				if ((_newLines >= _textWindow->scrollY) && (_newLines < (_textWindow->scrollY + 3)))
					sendWindow(*src);
				if (*src == '\n')		// Do two top lines of text only
					_newLines++;
				src++;
			}
		} else {
			if (getBitFlag(94)) {
				if (_curWindow == 3) {
					if (_newLines == (_textWindow->scrollY + 7))
						sendWindow(*src);
					if (*src == '\n')	// Do two top lines of text only
						_newLines++;
					src++;
				}
			} else {
				if (getBitFlag(92))
					delay(50);
				sendWindow(*src++);
			}
		}
	}
}
#endif

void AGOSEngine::doOutput(const byte *src, uint len) {
	uint idx;

	if (_textWindow == nullptr)
		return;

	while (len-- != 0) {
		if (*src != 12 && _textWindow->iconPtr != nullptr &&
				_fcsData1[idx = getWindowNum(_textWindow)] != 2) {

			_fcsData1[idx] = 2;
			_fcsData2[idx] = 1;
		}

		sendWindow(*src++);
	}
}

void AGOSEngine::clsCheck(WindowBlock *window) {
	uint index = getWindowNum(window);
	tidyIconArray(index);
	_fcsData1[index] = 0;
}

void AGOSEngine::tidyIconArray(uint i) {
	WindowBlock *window;

	if (_fcsData2[i]) {
		mouseOff();
		window = _windowArray[i];
		drawIconArray(i, window->iconPtr->itemRef, window->iconPtr->line, window->iconPtr->classMask);
		_fcsData2[i] = 0;
		mouseOn();
	}
}

void AGOSEngine::showMessageFormat(const char *s, ...) {
	char buf[STRINGBUFLEN];
	char *str;
	va_list va;

	va_start(va, s);
	vsnprintf(buf, STRINGBUFLEN, s, va);
	va_end(va);

	if (!_fcsData1[_curWindow]) {
		if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) {
			if (_showMessageFlag) {
				if (_windowArray[_curWindow]->flags & 128) {
					haltAnimation();
				}
			}
		}
		openTextWindow();
		if (!_showMessageFlag) {
			_windowArray[0] = _textWindow;
			justifyStart();
		}
		_showMessageFlag = true;
		_fcsData1[_curWindow] = 1;
	}

	for (str = buf; *str; str++)
		justifyOutPut(*str);
}

void AGOSEngine::justifyStart() {
	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		_printCharCurPos = _textWindow->textColumn;
		_printCharMaxPos = _textWindow->width;
	} else {
		_printCharCurPos = _textWindow->textLength;
		_printCharMaxPos = _textWindow->textMaxLength;
	}
	_printCharPixelCount = 0;
	_numLettersToPrint = 0;
	_newLines = 0;
}

void AGOSEngine::justifyOutPut(byte chr) {
	if (chr == 12) {
		_numLettersToPrint = 0;
		_printCharCurPos = 0;
		_printCharPixelCount = 0;
		doOutput(&chr, 1);
		clsCheck(_textWindow);
	} else if (getLanguage() == Common::JA_JPN && !_forceAscii) {
		// Japanese has no word wrapping
		_lettersToPrintBuf[0] = chr;
		_lettersToPrintBuf[1] = '\0';
		doOutput(_lettersToPrintBuf, 1);
	} else if (chr == 0 || chr == ' ' || chr == 10) {
		bool fit;

		if (getGameType() == GType_FF || getGameType() == GType_PP) {
			fit = _printCharMaxPos - _printCharCurPos > _printCharPixelCount;
		} else {
			fit = _printCharMaxPos - _printCharCurPos >= _printCharPixelCount;
		}

		if (fit) {
			_printCharCurPos += _printCharPixelCount;
			doOutput(_lettersToPrintBuf, _numLettersToPrint);

			if (_printCharCurPos == _printCharMaxPos) {
				_printCharCurPos = 0;
			} else {
				if (chr)
					doOutput(&chr, 1);
				if (chr == 10)
					_printCharCurPos = 0;
				else if (chr != 0)
					_printCharCurPos += (getGameType() == GType_FF || getGameType() == GType_PP) ? getFeebleFontSize(chr) : 1;
			}
		} else {
			const byte newline_character = 10;
			_printCharCurPos = _printCharPixelCount;
			doOutput(&newline_character, 1);
			doOutput(_lettersToPrintBuf, _numLettersToPrint);
			if (chr == ' ') {
				doOutput(&chr, 1);
				_printCharCurPos += (getGameType() == GType_FF || getGameType() == GType_PP) ? getFeebleFontSize(chr) : 1;
			} else {
				doOutput(&chr, 1);
				_printCharCurPos = 0;
			}
		}
		_numLettersToPrint = 0;
		_printCharPixelCount = 0;
	} else {
		_lettersToPrintBuf[_numLettersToPrint++] = chr;
		_printCharPixelCount += (getGameType() == GType_FF || getGameType() == GType_PP) ? getFeebleFontSize(chr) : 1;
	}
}

void AGOSEngine::openTextWindow() {
	if (_textWindow) {
		if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) {
			if (_textWindow->flags & 0x80)
				clearWindow(_textWindow);
		}
		return;
	}

	if (getGameType() == GType_FF || getGameType() == GType_PP)
		_textWindow = openWindow(64, 96, 384, 172, 1, 0, 15);
	else
		_textWindow = openWindow(8, 144, 24, 6, 1, 0, 15);
}

void AGOSEngine_PN::windowPutChar(WindowBlock *window, byte c, byte b) {
	if (_mousePrintFG || _wiped)
		return;
	AGOSEngine::windowPutChar(window, c, b);
}

void AGOSEngine::windowPutChar(WindowBlock *window, byte c, byte b) {
	byte width = 6;
	byte textColumnWidth = 8;

	if (c == 12) {
		clearWindow(window);
	} else if (c == 13 || c == 10) {
		windowNewLine(window);
	} else if ((c == 1 && _language != Common::HE_ISR) || (c == 8)) {
		if (_language == Common::HE_ISR) {
			if (b >= 64 && b < 91)
				width = _hebrewCharWidths [b - 64];

			if (window->textLength != 0) {
				window->textLength--;
				window->textColumnOffset += width;
				if (window->textColumnOffset >= 8) {
					window->textColumnOffset -= 8;
					window->textColumn--;
				}
			}
		} else {
			int8 val = (c == 8) ? 6 : 4;

			if (window->textLength != 0) {
				window->textLength--;
				window->textColumnOffset -= val;
				if ((int8)window->textColumnOffset < val) {
					window->textColumnOffset += 8;
					window->textColumn--;
				}
			}
		}
	} else if (c >= 32) {
		if (getGameType() == GType_FF || getGameType() == GType_PP) {
			// Ignore invalid characters
			if (c - 32 > 195)
				return;

			windowDrawChar(window, window->textColumn + window->x, window->textRow + window->y, c);
			window->textColumn += getFeebleFontSize(c);
			return;
		}

		if (_language == Common::JA_JPN && !_forceAscii)
			textColumnWidth = width = 4;
		else if (c - 32 > 98) // Ignore invalid characters
			return;

		if (window->textLength == window->textMaxLength) {
			windowNewLine(window);
		} else if (window->textRow == window->height) {
			windowNewLine(window);
			window->textRow--;
		}

		if (_language == Common::HE_ISR) {
			if (c >= 64 && c < 91)
				width = _hebrewCharWidths [c - 64];
			window->textColumnOffset -= width;
			if (window->textColumnOffset >= width) {
				window->textColumnOffset += 8;
				window->textColumn++;
			}
			windowDrawChar(window, (window->width + window->x - window->textColumn) * 8, window->textRow * 8 + window->y, c);
			window->textLength++;
		} else {
			windowDrawChar(window, window->x * 8 + window->textColumn * textColumnWidth, window->textRow * 8 + window->y, c);
			window->textLength++;
			window->textColumnOffset += width;
			if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
				if (c == 'i' || c == 'l')
					window->textColumnOffset -= 2;
			}
			if (window->textColumnOffset >= textColumnWidth) {
				window->textColumnOffset -= textColumnWidth;
				window->textColumn++;
			}
		}
	}
}

#ifdef ENABLE_AGOS2
void AGOSEngine_Feeble::windowNewLine(WindowBlock *window) {
	if (_noOracleScroll == 0) {
		if (window->height < window->textRow + 30) {
			if (!getBitFlag(94)) {
				_noOracleScroll = 1;
				if (getBitFlag(92)) {
					_noOracleScroll = 0;
					checkLinkBox();
					scrollOracle();
					linksUp();
					window->scrollY++;
					_oracleMaxScrollY++;
				} else {
					_oracleMaxScrollY++;
					checkLinkBox();
				}
			}
		} else {
			window->textRow += 15;
			checkLinkBox();
		}
	} else {
		_oracleMaxScrollY++;
		checkLinkBox();
	}

	window->textColumn = 0;
	window->textColumnOffset = 0;
	window->textLength = 0;
}
#endif

void AGOSEngine::windowNewLine(WindowBlock *window) {
	window->textColumn = 0;
	window->textColumnOffset = (getGameType() == GType_ELVIRA2) ? 4 : 0;
	window->textLength = 0;

	if (getGameType() == GType_PN) {
		window->textRow++;
		if (window->textRow == window->height) {
			windowScroll(window);
			window->textRow--;
		}
	} else {
		if (window->textRow == window->height) {
			if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2 ||
				getGameType() == GType_WW) {
				windowScroll(window);
			}
		} else {
			window->textRow++;
		}
	}
}

void AGOSEngine::windowScroll(WindowBlock *window) {
	_videoLockOut |= 0x8000;

	if (window->height != 1) {
		Graphics::Surface *screen = getBackendSurface();

		byte *src, *dst;
		uint16 w1, h1, w2, h2;

		w1 = w2 = window->width * 8;
		h1 = h2 = (window->height -1) * 8;

		dst = (byte *)screen->getBasePtr(window->x * 8, window->y);
		src = dst + 8 * screen->pitch;

		do {
			memcpy(dst, src, w1);
			src += screen->pitch;
			dst += screen->pitch;
		} while (--h1);

		if (getGameId() == GID_ELVIRA1 && getPlatform() == Common::kPlatformPC98) {
			w1 = w2 << 1;
			h1 = h2 << 1;
			dst = (byte *)_scaleBuf->getBasePtr(window->x * 16, window->y * 2);
			src = dst + 16 * screen->pitch;
			do {
				memcpy(dst, src, w1);
				src += screen->pitch;
				dst += screen->pitch;
			} while (--h1);
		}

		Common::Rect dirtyRect(window->x * 8, window->y, window->x * 8 + w2, window->y + h2);
		updateBackendSurface(&dirtyRect);
	}

	colorBlock(window, window->x * 8, (window->height - 1) * 8 + window->y, window->width * 8, 8);

	_videoLockOut &= ~0x8000;
}
} // End of namespace AGOS

================
File: configure.engine
================
# This file is included from the main "configure" script
# add_engine [name] [desc] [build-by-default] [subengines] [base games] [deps] [components]
add_engine agos "AGOS" yes "agos2" "AGOS 1 games" "" "midi fmtowns_pc98_audio"
add_engine agos2 "AGOS 2 games" yes "" "" "highres"

================
File: contain.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "agos/agos.h"
#include "agos/intern.h"

namespace AGOS {

int AGOSEngine_Elvira2::canPlace(Item *x, Item *y) {
	Item *z = derefItem(x->parent);

	SubObject *o = (SubObject *)findChildOfType(y, kObjectType);
	int ct;
	int cap = 0;

	if (o == nullptr)
		return 0;	/* Fits Fine */

	xPlace(x,nullptr);		/* Avoid disturbing figures */
	if (o)
		cap = sizeContents(y);

	xPlace(x, z);
	if ((o) && (o->objectFlags & kOFVolume)) {
		ct = getOffsetOfChild2Param(o, kOFVolume);
		cap = o->objectFlagValue[ct] - cap;
		cap -= sizeOfRec(x, 0);	/* - size of item going in */
		if (cap < 0)
			return -1;	/* Too big to fit */
	}

	return 0;
}

int AGOSEngine::canPlace(Item *x, Item *y) {
	Item *z = derefItem(x->parent);

	SubPlayer *p = (SubPlayer *)findChildOfType(y, kPlayerType);
	SubContainer *c = (SubContainer *)findChildOfType(y, kContainerType);
	int cap = 0;
	int wt;

	if ((c == nullptr) && (p == nullptr))
		return 0;		/* Fits Fine */

	xPlace(x, nullptr);		/* Avoid disturbing figures */
	if (c)
		cap = sizeContents(y);

	wt = weightOf(y);
	xPlace(x, z);
	if (c) {
		cap = c->volume - cap;
		cap -= sizeOfRec(x, 0);	/* - size of item going in */
		if (cap < 0)
			return -1;	/* Too big to fit */
	}
	if (p) {
		if (wt + weightOf(x) > p->strength * 10)
			return -2;	/* Too heavy */
	}

	return 0;
}

void AGOSEngine::xPlace(Item *x, Item *y) {
	if (derefItem(x->parent))
		unlinkItem(x);

	linkItem(x, y);
}

int AGOSEngine::contains(Item *a, Item *b) {
	while (derefItem(b->parent)) {
		if (derefItem(b->parent) == a)
			return 1;
		b = derefItem(b->parent);
	}

	return 0;
}

int AGOSEngine::sizeContents(Item *x) {
	return sizeRec(x, 0);
}

int AGOSEngine::sizeRec(Item *x, int d) {
	Item *o;
	int n = 0;

	o = derefItem(x->child);

	if (d > 32)
		return(0);
	while (o) {
		n += sizeOfRec(o,d);
		o = derefItem(o->child);
	}

	return n;
}

int AGOSEngine_Elvira2::sizeOfRec(Item *i, int d) {
	SubObject *o = (SubObject *)findChildOfType(i, kObjectType);

	int ct;
	if ((o) && (o->objectFlags & kOFSoft)) {
		if (o->objectFlags & kOFSize) {
			ct = getOffsetOfChild2Param(o, kOFSize);
			return o->objectFlagValue[ct] + sizeRec(i, d + 1);
		}
		return sizeRec(i, d + 1);
	}
	if ((o) && (o->objectFlags & kOFSize)) {
		ct = getOffsetOfChild2Param(o, kOFSize);
		return o->objectFlagValue[ct];
	}

	return 0;
}

int AGOSEngine::sizeOfRec(Item *i, int d) {
	SubObject *o = (SubObject *)findChildOfType(i, kObjectType);

	SubPlayer *p = (SubPlayer *)findChildOfType(i, kPlayerType);
	SubContainer *c = (SubContainer *)findChildOfType(i, kContainerType);

	if ((c) && (c->flags & 1)) {
		if (o)
			return (o->objectSize + sizeRec(i, d + 1));
		if (p)
			return (p->size + sizeRec(i, d + 1));
		return (sizeRec(i, d + 1));
	}
	if (o)
		return (o->objectWeight);
	if (p)
		return (p->weight);

	return 0;
}

int AGOSEngine::weighUp(Item *x) {
	return weightRec(x, 0);
}

int AGOSEngine::weightRec(Item *x, int d) {
	int n = weightOf(x);
	Item *o;

	if (d > 32)
		return 0;
	o = derefItem(x->child);
	while (o) {
		n += weightRec(o, d + 1);
		o = derefItem(o->next);
	}

	return n;
}

int AGOSEngine_Elvira2::weightOf(Item *x) {
	SubObject *o = (SubObject *)findChildOfType(x, kObjectType);

	if ((o) && (o->objectFlags & kOFWeight)) {
		int ct = getOffsetOfChild2Param(o, kOFWeight);
		return (o->objectFlagValue[ct]);
	}

	return 0;
}

int AGOSEngine::weightOf(Item *x) {
	SubObject *o = (SubObject *)findChildOfType(x, kObjectType);

	SubPlayer *p = (SubPlayer *)findChildOfType(x, kPlayerType);
	if (o)
		return o->objectWeight;
	if (p)
		return p->weight;

	return 0;
}

} // End of namespace AGOS

================
File: credits.pl
================
begin_section("AGOS");
	add_person("Torbj&ouml;rn Andersson", "eriktorbjorn", "");
	add_person("Paul Gilbert", "dreammaster", "");
	add_person("Travis Howell", "Kirben", "");
	add_person("Oliver Kiehl", "olki", "(retired)");
	add_person("Ludvig Strigeus", "ludde", "(retired)");
end_section();

================
File: cursor.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/endian.h"
#include "common/events.h"

#include "graphics/cursorman.h"

#include "agos/agos.h"
#include "agos/intern.h"

namespace AGOS {

static const uint16 _common_mouseInfo[32] = {
	0xC000, 0x8000, 0xE000, 0xC000, 0xF000, 0xE000, 0xF800, 0xF000,
	0xFC00, 0xF800, 0xFE00, 0xFC00, 0xFC00, 0xF000, 0x9800, 0x9000,
	0x0C00, 0x0800, 0x0C00, 0x0800, 0x0600, 0x0400, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};

static const uint16 _common_handInfo[32] = {
	0x01C0, 0x01C0, 0x07F0, 0x0770, 0x07F0, 0x0550, 0x07FC, 0x055C,
	0x07FC, 0x0554, 0x3FFC, 0x3D54, 0x3FFC, 0x2554, 0x3FFE, 0x2402,
	0x1FFC, 0x1204, 0x1FFC, 0x1004, 0x0FF8, 0x0808, 0x07F8, 0x0408,
	0x03F8, 0x03F8, 0x03F8, 0x0208, 0x03F8, 0x03F8, 0x0000, 0x0000
};

static const uint16 _common_shieldInfo1[32] = {
	0x0000, 0x0000, 0x2184, 0x2004, 0x33CC, 0x300C, 0x3FFC, 0x3E7C,
	0x3FFC, 0x3E7C, 0x3FFC, 0x3E7C, 0x3FFC, 0x0000, 0x3FFC, 0x3E7C,
	0x3FFC, 0x3E7C, 0x1FF8, 0x1E78, 0x1FF8, 0x1E78, 0x0FF0, 0x0E70,
	0x07E0, 0x0660, 0x03C0, 0x0240, 0x0180, 0x0000, 0x0000, 0x0000
};

static const uint16 _common_shieldInfo2[32] = {
	0x0000, 0x0000, 0x2184, 0x2004, 0x33CC, 0x300C, 0x3FFC, 0x3E7C,
	0x3FFC, 0x2004, 0x3FFC, 0x2004, 0x3FFC, 0x0000, 0x3FFC, 0x2000,
	0x3FFC, 0x2004, 0x1FF8, 0x1008, 0x1FF8, 0x1008, 0x0FF0, 0x0810,
	0x07E0, 0x0420, 0x03C0, 0x0240, 0x0180, 0x0000, 0x0000, 0x0000,
};

static const uint16 _common_swordInfo1[32] = {
	0x0000, 0x0000, 0xC000, 0x4000, 0xF000, 0x7000, 0x7800, 0x3800,
	0x3C00, 0x1C00, 0x1E00, 0x0E00, 0x0F00, 0x0700, 0x0780, 0x0380,
	0x03C6, 0x01C0, 0x01FF, 0x00E6, 0x00FE, 0x007C, 0x007C, 0x0038,
	0x00FC, 0x0078, 0x01FE, 0x00CC, 0x01CF, 0x0086, 0x0086, 0x0000
};

static const uint16 _common_swordInfo2[32] = {
	0x0000, 0x0000, 0x4000, 0x0000, 0x7000, 0x0000, 0x3800, 0x0000,
	0x1C00, 0x0000, 0x0E00, 0x0000, 0x0700, 0x0000, 0x0380, 0x0000,
	0x01C0, 0x0000, 0x00E6, 0x0000, 0x007C, 0x0000, 0x0038, 0x0000,
	0x0078, 0x0000, 0x00CC, 0x0000, 0x0086, 0x0000, 0x0000, 0x0000,
};

static const uint16 _common_lightningInfo1[32] = {
	0x0000, 0x0000, 0xC000, 0x4000, 0xE000, 0x6000, 0xF020, 0x7000,
	0x7860, 0x3820, 0x7CE0, 0x3C60, 0x3FF0, 0x1EF0, 0x3FF0, 0x1FF0,
	0x1FF8, 0x0FF8, 0x1FF8, 0x0FF8, 0x0F7C, 0x073C, 0x0E3C, 0x061C,
	0x061E, 0x020E, 0x040E, 0x0006, 0x0006, 0x0002, 0x0002, 0x0000,
};

static const uint16 _common_lightningInfo2[32] = {
	0x0000, 0x0000, 0xC000, 0x0000, 0xE000, 0x0000, 0xF020, 0x0000,
	0x7860, 0x0000, 0x7CE0, 0x0000, 0x3FF0, 0x0000, 0x3FF0, 0x0000,
	0x1FF8, 0x0000, 0x1FF8, 0x0000, 0x0F7C, 0x0000, 0x0E3C, 0x0000,
	0x061E, 0x0000, 0x040E, 0x0000, 0x0006, 0x0000, 0x0002, 0x0000,
};

static const uint16 _common_crossbowInfo1[32] = {
	0x0000, 0x0000, 0x03E0, 0x07C0, 0x1FF8, 0x1FF0, 0x3FFC, 0x3FF8,
	0x7FFE, 0x7FFC, 0x7FFE, 0x7FFC, 0xF39E, 0xF39E, 0xE38E, 0xE38E,
	0xC386, 0xC386, 0xC386, 0xC386, 0xC386, 0xC386, 0xC386, 0xC386,
	0x8002, 0x8002, 0x8002, 0x8002, 0x0000, 0x0000, 0x0000, 0x0000,
};

static const uint16 _common_crossbowInfo2[32] = {
	0x0000, 0x0000, 0x03E0, 0x0000, 0x1FF8, 0x0000, 0x3FFC, 0x0000,
	0x7FFE, 0x0000, 0x7FFE, 0x0000, 0xF39E, 0x0000, 0xE38E, 0x0000,
	0xC386, 0x0000, 0xC386, 0x0000, 0xC386, 0x0000, 0xC386, 0x0000,
	0x8002, 0x0000, 0x8002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
};

static const uint16 _common_moveForward[32] = {
	0x0180, 0x0100, 0x03C0, 0x0380, 0x07E0, 0x07C0, 0x0FF0, 0x0FE0,
	0x1FF8, 0x1FF0, 0x03C0, 0x0380, 0x03C0, 0x0380, 0x03C0, 0x0380,
	0x03C0, 0x0380, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};

static const uint16 _common_moveRight[32] = {
	0x00C0, 0x0080, 0x00E0, 0x00C0, 0x00F0, 0x00E0, 0x1FF8, 0x1FF0,
	0x3FFC, 0x3FF8, 0x3FF8, 0x3FF0, 0x3CF0, 0x38E0, 0x3CE0, 0x38C0,
	0x3CC0, 0x3880, 0x3C00, 0x3800, 0x3C00, 0x3800, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};

static const uint16 _common_moveBack[32] = {
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x03C0, 0x0380, 0x03C0, 0x0380, 0x03C0, 0x0380, 0x03C0, 0x0380,
	0x1FF8, 0x1FF0, 0x0FF0, 0x0FE0, 0x07E0, 0x07C0, 0x03C0, 0x0380,
	0x0180, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};

static const uint16 _common_moveLeft[32] = {
	0x0C00, 0x0800, 0x1C00, 0x1800, 0x3C00, 0x3800, 0x7FE0, 0x7FC0,
	0xFFF0, 0xFFE0, 0x7FF0, 0x7FE0, 0x3CF0, 0x38E0, 0x1CF0, 0x18E0,
	0x0CF0, 0x08E0, 0x00F0, 0x00E0, 0x00F0, 0x00E0, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};

static const byte _simon2_cursors[10][256] = {
	// cross hair
	{ 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xec,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xec,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xec,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xec,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xec,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xef,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xec,0xec,0xec,0xec,0xec,0xef,0xff,0xea,0xff,0xef,0xec,0xec,0xec,0xec,0xec,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xef,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xec,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xec,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xec,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xec,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xec,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff },
	// examine
	{ 0xff,0xff,0xef,0xef,0xef,0xef,0xef,0xef,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xef,0xee,0xeb,0xe4,0xe4,0xe4,0xee,0xef,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xef,0xee,0xeb,0xee,0xef,0xef,0xee,0xec,0xee,0xef,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xef,0xeb,0xee,0xef,0xee,0xee,0xef,0xee,0xe4,0xef,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xef,0xeb,0xef,0xef,0xef,0xec,0xee,0xef,0xe4,0xef,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xef,0xeb,0xef,0xef,0xee,0xef,0xef,0xef,0xe4,0xef,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xef,0xeb,0xee,0xef,0xef,0xef,0xef,0xee,0xe4,0xef,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xef,0xee,0xeb,0xee,0xef,0xef,0xee,0xe4,0xee,0xef,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xef,0xee,0xeb,0xeb,0xeb,0xeb,0xee,0xe4,0xec,0xef,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xef,0xef,0xef,0xef,0xef,0xef,0xeb,0xe4,0xee,0xef,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xef,0xee,0xe4,0xeb,0xef,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xef,0xeb,0xe4,0xeb,0xef,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xef,0xeb,0xec,0xeb,0xef,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xef,0xeb,0xe4,0xef,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xef,0xef,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff },
	// pick up
	{ 0xff,0xff,0xff,0xff,0xff,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xe5,0xe6,0xe6,0xe7,0xe7,0xe6,0xe6,0xe5,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xe5,0xe7,0xe7,0xe7,0xe7,0xe8,0xe8,0xe8,0xe8,0xe5,0xff,0xff,0xff,
	  0xff,0xff,0xe5,0xe6,0xe7,0xe7,0xe7,0xe7,0xe7,0xe7,0xe8,0xe9,0xe7,0xe5,0xff,0xff,
	  0xff,0xe5,0xe6,0xe7,0xe6,0xe5,0xff,0xff,0xff,0xff,0xe5,0xe6,0xe8,0xe6,0xe5,0xff,
	  0xff,0xe5,0xe7,0xe7,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xe5,0xe8,0xe7,0xe5,0xff,
	  0xff,0xe5,0xe7,0xe7,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xe5,0xe7,0xe7,0xe5,0xff,
	  0xff,0xef,0xeb,0xeb,0xef,0xff,0xff,0xff,0xff,0xff,0xff,0xef,0xeb,0xeb,0xef,0xff,
	  0xff,0xef,0xee,0xeb,0xee,0xef,0xff,0xff,0xff,0xff,0xef,0xee,0xeb,0xee,0xef,0xff,
	  0xff,0xff,0xef,0xeb,0xeb,0xef,0xff,0xff,0xff,0xff,0xef,0xeb,0xeb,0xef,0xff,0xff,
	  0xff,0xff,0xef,0xee,0xe4,0xee,0xef,0xff,0xff,0xef,0xee,0xe4,0xee,0xef,0xff,0xff,
	  0xff,0xff,0xff,0xef,0xe4,0xeb,0xef,0xff,0xff,0xef,0xeb,0xe4,0xef,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xeb,0xeb,0xeb,0xef,0xef,0xeb,0xeb,0xeb,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xef,0xee,0xee,0xee,0xee,0xe1,0xe1,0xef,0xff,0xff,0xff,0xe4,
	  0xef,0xee,0xeb,0xeb,0xeb,0xeb,0xeb,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xeb,0xec,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe4 },
	// give
	{ 0xff,0xff,0xff,0xff,0xff,0xe5,0xe7,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xe5,0xe7,0xe8,0xe7,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xe9,0xe7,0xe8,0xe8,0xe8,0xe7,0xe9,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xe5,0xe7,0xea,0xe8,0xe8,0xe8,0xea,0xe7,0xe5,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xe5,0xe7,0xe8,0xe8,0xea,0xe9,0xea,0xe8,0xe8,0xe7,0xe5,0xff,0xff,0xff,0xff,
	  0xe5,0xe7,0xe9,0xe8,0xe8,0xe9,0xec,0xe9,0xe8,0xe8,0xe8,0xe7,0xe5,0xff,0xff,0xff,
	  0xe5,0xe7,0xe7,0xe9,0xe8,0xec,0xe9,0xec,0xe8,0xe9,0xe7,0xe6,0xe5,0xff,0xff,0xff,
	  0xe5,0xe7,0xe7,0xe8,0xec,0xe9,0xe9,0xe9,0xec,0xe7,0xe6,0xe6,0xe5,0xff,0xff,0xff,
	  0xe5,0xe7,0xe7,0xea,0xe8,0xe9,0xe9,0xe9,0xe7,0xec,0xec,0xe4,0xe5,0xff,0xff,0xff,
	  0xe5,0xe7,0xe7,0xe9,0xe7,0xe8,0xe9,0xe7,0xe6,0xec,0xe4,0xec,0xe4,0xef,0xff,0xff,
	  0xe5,0xe6,0xe7,0xe9,0xe7,0xe7,0xe8,0xe6,0xe6,0xe4,0xec,0xe4,0xec,0xe4,0xef,0xff,
	  0xff,0xe5,0xe6,0xe9,0xe7,0xe7,0xe8,0xe6,0xe6,0xe8,0xe4,0xec,0xe4,0xec,0xeb,0xff,
	  0xff,0xff,0xe5,0xe9,0xe7,0xe7,0xe8,0xe6,0xe6,0xe8,0xe6,0xe4,0xec,0xeb,0xef,0xff,
	  0xff,0xff,0xff,0xe8,0xe7,0xe7,0xe8,0xe6,0xe6,0xe7,0xff,0xef,0xeb,0xef,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xe5,0xe7,0xe8,0xe6,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xe5,0xe6,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff },
	// talk
	{ 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xe5,0xe7,0xe8,0xe8,0xe8,0xe7,0xe6,0xe5,0xe5,0xe5,0xff,0xff,0xff,0xff,
	  0xff,0xe5,0xe6,0xe9,0xea,0xe6,0xea,0xe9,0xe8,0xe9,0xe8,0xe7,0xe5,0xff,0xff,0xff,
	  0xff,0xe5,0xe7,0xe5,0xef,0xe5,0xec,0xea,0xe5,0xea,0xec,0xe5,0xe9,0xe6,0xff,0xff,
	  0xff,0xe5,0xe6,0xe5,0xef,0xef,0xef,0xe5,0xef,0xef,0xe5,0xef,0xef,0xe8,0xe5,0xff,
	  0xff,0xe5,0xe9,0xea,0xe5,0xe8,0xe7,0xe6,0xe6,0xe8,0xe7,0xe5,0xec,0xe9,0xe5,0xff,
	  0xff,0xe5,0xe9,0xe8,0xe5,0xe7,0xe8,0xe8,0xe9,0xe9,0xe8,0xe5,0xe9,0xe9,0xe5,0xff,
	  0xff,0xe5,0xe6,0xec,0xea,0xe5,0xe6,0xe6,0xe7,0xe7,0xe6,0xe5,0xec,0xe8,0xe5,0xff,
	  0xff,0xff,0xe5,0xe9,0xe8,0xe9,0xe5,0xe8,0xe5,0xe8,0xe5,0xe9,0xe9,0xe7,0xe5,0xff,
	  0xff,0xff,0xe5,0xe7,0xe9,0xec,0xe8,0xec,0xe8,0xec,0xe8,0xec,0xe8,0xe5,0xff,0xff,
	  0xff,0xff,0xff,0xe5,0xe6,0xe8,0xe9,0xe9,0xe9,0xe9,0xe9,0xe8,0xe5,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff },
	// use
	{ 0xff,0xff,0xff,0xff,0xff,0xee,0xe1,0xeb,0xee,0xef,0xef,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xef,0xef,0xef,0xe4,0xeb,0xee,0xe5,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xeb,0xe4,0xe4,0xeb,0xe5,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xeb,0xe4,0xec,0xe4,0xef,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xeb,0xeb,0xe4,0xe4,0xee,0xef,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xee,0xeb,0xeb,0xeb,0xe1,0xef,0xee,0xef,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe5,0xe6,0xef,0xef,0xee,0xeb,0xeb,0xe4,0xee,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xe5,0xe6,0xff,0xff,0xff,0xef,0xeb,0xec,0xeb,0xef,
	  0xff,0xff,0xff,0xff,0xff,0xe5,0xe6,0xe5,0xff,0xff,0xff,0xee,0xe4,0xeb,0xef,0xff,
	  0xff,0xff,0xff,0xe5,0xe5,0xe6,0xe5,0xff,0xff,0xff,0xff,0xef,0xee,0xef,0xff,0xff,
	  0xff,0xff,0xe5,0xe6,0xe8,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xef,0xff,0xff,0xff,
	  0xff,0xe5,0xe6,0xe8,0xe6,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xe5,0xe6,0xe8,0xe6,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xe5,0xe6,0xe6,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xe5,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff },
	// wear
	{ 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xef,0xef,0xef,0xef,0xef,0xef,0xef,0xef,0xef,0xef,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xef,0xeb,0xed,0xe4,0xe2,0xeb,0xee,0xee,0xee,0xef,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xef,0xe2,0xec,0xe2,0xe1,0xee,0xef,0xef,0xee,0xef,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xef,0xeb,0xed,0xeb,0xee,0xef,0xef,0xef,0xee,0xef,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xef,0xee,0xe4,0xeb,0xee,0xef,0xef,0xee,0xef,0xef,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xef,0xe4,0xeb,0xee,0xef,0xef,0xee,0xef,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xef,0xe2,0xeb,0xee,0xef,0xef,0xee,0xef,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xef,0xeb,0xe1,0xee,0xef,0xef,0xee,0xef,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xef,0xeb,0xe1,0xee,0xef,0xef,0xef,0xef,0xff,0xff,0xff,0xff,
	  0xff,0xef,0xef,0xef,0xe1,0xe4,0xe4,0xe4,0xe1,0xeb,0xee,0xef,0xef,0xef,0xff,0xff,
	  0xef,0xee,0xee,0xef,0xee,0xee,0xee,0xee,0xee,0xef,0xef,0xef,0xee,0xee,0xef,0xff,
	  0xff,0xef,0xef,0xee,0xe1,0xe2,0xe4,0xe4,0xe4,0xeb,0xe1,0xee,0xef,0xef,0xff,0xff,
	  0xff,0xff,0xff,0xef,0xef,0xef,0xef,0xef,0xef,0xef,0xef,0xef,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff },
	// move
	{ 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xff,
	  0xff,0xe1,0xe2,0xe2,0xe2,0xe2,0xe2,0xe2,0xe2,0xe2,0xe2,0xe2,0xe2,0xe2,0xe1,0xff,
	  0xff,0xe1,0xe3,0xe3,0xe3,0xed,0xe3,0xe3,0xe3,0xe3,0xed,0xe3,0xe3,0xe3,0xe1,0xff,
	  0xff,0xe1,0xe3,0xe3,0xed,0xec,0xe3,0xe3,0xe3,0xe3,0xec,0xed,0xe3,0xe3,0xe1,0xff,
	  0xff,0xe1,0xe3,0xed,0xec,0xec,0xec,0xec,0xec,0xec,0xec,0xec,0xed,0xe3,0xe1,0xff,
	  0xff,0xe1,0xed,0xec,0xec,0xec,0xec,0xec,0xec,0xec,0xec,0xec,0xec,0xed,0xe1,0xff,
	  0xff,0xe1,0xe3,0xed,0xec,0xec,0xec,0xec,0xec,0xec,0xec,0xec,0xed,0xe3,0xe1,0xff,
	  0xff,0xe1,0xe3,0xe3,0xed,0xec,0xe3,0xe3,0xe3,0xe3,0xec,0xed,0xe3,0xe3,0xe1,0xff,
	  0xff,0xe1,0xe3,0xe3,0xe3,0xed,0xe3,0xe3,0xe3,0xe3,0xed,0xe3,0xe3,0xe3,0xe1,0xff,
	  0xff,0xe1,0xe2,0xe2,0xe2,0xe2,0xe2,0xe2,0xe2,0xe2,0xe2,0xe2,0xe2,0xe2,0xe1,0xff,
	  0xff,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff },
	// open
	{ 0xff,0xff,0xe5,0xe8,0xe8,0xe7,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xe5,0xe8,0xe7,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xe5,0xe7,0xe5,0xe7,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xe5,0xff,0xe5,0xe7,0xe6,0xe9,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xe6,0xea,0xe6,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xe6,0xea,0xe6,0xe7,0xe5,0xff,0xe5,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xe6,0xea,0xe6,0xff,0xe5,0xe7,0xe5,0xe7,0xe5,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xe6,0xea,0xe6,0xff,0xff,0xff,0xe5,0xe7,0xe8,0xe5,0xff,0xff,0xff,
	  0xff,0xe5,0xe6,0xea,0xe6,0xff,0xff,0xff,0xe5,0xe7,0xe8,0xe8,0xe5,0xff,0xff,0xff,
	  0xff,0xe5,0xe9,0xea,0xea,0xea,0xea,0xea,0xea,0xea,0xea,0xe5,0xff,0xff,0xff,0xff,
	  0xff,0xe5,0xe9,0xe7,0xe7,0xe7,0xe7,0xe7,0xe7,0xe7,0xea,0xe5,0xff,0xff,0xff,0xff,
	  0xff,0xe5,0xe9,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe9,0xe5,0xff,0xff,0xff,0xff,
	  0xff,0xe5,0xe9,0xe8,0xe8,0xe8,0xe8,0xe8,0xe7,0xe7,0xe9,0xe5,0xff,0xff,0xff,0xff,
	  0xff,0xe5,0xe9,0xe6,0xe6,0xe6,0xe6,0xe6,0xe6,0xe5,0xe9,0xe5,0xff,0xff,0xff,0xff,
	  0xff,0xe5,0xe9,0xe8,0xe8,0xe8,0xe8,0xe8,0xe8,0xe7,0xe9,0xe5,0xff,0xff,0xff,0xff,
	  0xff,0xe5,0xe9,0xe9,0xe9,0xe9,0xe9,0xe9,0xe9,0xe9,0xe9,0xe5,0xff,0xff,0xff,0xff },
	// question mark
	{ 0xff,0xff,0xff,0xff,0xff,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xe5,0xe7,0xea,0xec,0xec,0xec,0xe9,0xe5,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xe5,0xe7,0xea,0xec,0xea,0xe9,0xea,0xec,0xe9,0xe5,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xe5,0xe9,0xec,0xe9,0xe8,0xe7,0xe8,0xea,0xec,0xe5,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xe5,0xe8,0xe9,0xe8,0xe5,0xe5,0xe8,0xe9,0xec,0xe5,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xe5,0xe5,0xe5,0xe5,0xe8,0xe9,0xec,0xe9,0xe5,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xe5,0xe9,0xec,0xec,0xe9,0xe5,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xe5,0xe8,0xec,0xea,0xe8,0xe5,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xe5,0xe9,0xec,0xe9,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xe5,0xe9,0xea,0xe9,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xe5,0xe7,0xe9,0xe7,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xe5,0xe5,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xe5,0xe8,0xe9,0xe8,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xe5,0xe9,0xec,0xe9,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xe5,0xe8,0xe9,0xe8,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,
	  0xff,0xff,0xff,0xff,0xff,0xff,0xe5,0xe5,0xe5,0xff,0xff,0xff,0xff,0xff,0xff,0xff },
};

// Feeble Files specific
#ifdef ENABLE_AGOS2
static const byte _mouseOffs[29 * 32] = {
	6,0,15,21,16,21,14,21,15,21,16,21,16,21,16,21,15,21,15,21,15,21,14,21,12,21,12,21,12,21,12,21,
	6,2,10,12,9,12,8,11,7,10,6,9,4,8,3,7,1,7,0,6,3,7,4,8,6,9,7,10,8,11,9,12,
	0,0,0,0,0,0,0,0,0,1,0,3,0,3,0,4,1,4,1,3,2,3,2,2,1,3,0,4,0,3,0,0,

	0,0,5,16,4,19,2,21,1,21,1,21,1,21,1,18,3,9,6,2,6,0,3,6,4,12,4,13,4,13,4,14,
	0,0,6,13,5,15,4,16,3,19,2,19,2,19,2,18,1,16,4,10,7,3,7,0,4,2,4,6,0,0,0,0,

	0,0,7,0,7,1,8,1,11,1,13,1,9,1,6,1,6,0,6,0,6,0,7,0,11,0,13,0,9,0,7,0,

	0,0,7,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

// SAM icons
	0,0,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,
	0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
	0,0,5,5,5,5,5,5,5,5,5,4,1,1,2,2,3,3,5,5,7,6,9,8,11,10,14,13,16,16,0,0,
	0,0,4,3,5,2,4,2,4,3,5,3,5,2,4,2,4,3,5,3,5,2,4,3,4,3,5,3,5,2,4,2,

// Asteroid Map icons
	0,0,3,0,4,1,5,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,3,0,4,1,5,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,8,0,7,0,8,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
// Other icons
	0,0,9,9,9,10,8,11,7,11,7,11,8,11,9,10,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,10,7,10,6,10,5,10,4,10,3,10,4,10,5,10,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,7,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,7,3,4,3,2,4,0,5,0,7,0,7,0,5,2,4,4,3,7,3,0,0,0,0,0,0,0,0,0,0,
	0,0,12,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
// Vent icons
	0,0,8,3,7,3,6,3,5,3,4,3,3,3,2,3,1,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,2,3,3,3,4,3,8,3,10,3,12,3,14,3,17,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,3,14,4,12,5,10,6,9,7,8,7,7,8,6,9,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,2,3,3,2,3,4,3,4,3,5,3,4,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

	0,0,7,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,9,9,9,10,8,11,7,11,7,11,8,11,9,10,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,10,7,10,6,10,5,10,4,10,3,10,4,10,5,10,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};

void AGOSEngine_PuzzlePack::handleMouseMoved() {
	uint x;

	if (getGameId() != GID_DIMP && _mouseHideCount) {
		CursorMan.showMouse(false);
		return;
	}

	CursorMan.showMouse(true);
	_mouse = _eventMan->getMousePos();

	x = 0;
	if (_lastHitArea3 == 0 && _leftButtonDown) {
		_verbHitArea = 300;
		_leftButtonDown = false;
		x = 1;
	}

	if (_rightButtonDown) {
		_verbHitArea = (getGameId() == GID_DIMP) ? 301 : 300;
		_rightButtonDown = false;
		x = 1;
	}

	boxController(_mouse.x, _mouse.y, x);
	_lastHitArea3 = _lastHitArea;
	if (x == 1 && _lastHitArea == NULL)
		_lastHitArea3 = (HitArea *) -1;

	drawMousePointer();
}
#endif

void AGOSEngine_Simon1::handleMouseMoved() {
	uint x;

	if (_mouseHideCount) {
		CursorMan.showMouse(false);
		return;
	}

	CursorMan.showMouse(true);
	_mouse = _eventMan->getMousePos();

	if (_defaultVerb) {
		uint id = 101;
		if (_mouse.y >= 136)
			id = 102;
		if (_defaultVerb != id)
			resetVerbs();
	}

	if (getGameType() == GType_FF) {
		if (getBitFlag(99)) { // Oracle
			if (_mouse.x >= 10 && _mouse.x <= 635 && _mouse.y >= 5 && _mouse.y <= 475) {
				setBitFlag(98, true);
			} else {
				if (getBitFlag(98)) {
					_variableArray[254] = 63;
				}
			}
		} else if (getBitFlag(88)) { // Close Up
			if (_mouse.x >= 10 && _mouse.x <= 635 && _mouse.y >= 5 && _mouse.y <= 475) {
				setBitFlag(87, true);
			} else {
				if (getBitFlag(87)) {
					_variableArray[254] = 75;
				}
			}
		}

		if (_rightButtonDown) {
			_rightButtonDown = false;
			setVerb(nullptr);
		}
	} else if (getGameType() == GType_SIMON2) {
		if (getBitFlag(79)) {
			if (!_vgaVar9) {
				if (_mouse.x >= 315 || _mouse.x < 9)
					goto get_out2;
				_vgaVar9 = 1;
			}
			if (_scrollCount == 0) {
				if (_mouse.x >= 315) {
					if (_scrollX != _scrollXMax)
						_scrollFlag = 1;
				} else if (_mouse.x < 8) {
					if (_scrollX != 0)
						_scrollFlag = -1;
				}
			}
		} else {
		get_out2:;
			_vgaVar9 = 0;
		}
	}

	if (_mouse != _mouseOld)
		_needHitAreaRecalc++;

	if (_leftButtonOld == 0 && _leftButtonCount != 0) {
		boxController(_mouse.x, _mouse.y, 3);
	}
	_leftButtonOld = _leftButton;

	x = 0;
	if (_lastHitArea3 == nullptr && _leftButtonDown) {
		_leftButtonDown = false;
		x = 1;
	} else {
		if (!_litBoxFlag && _needHitAreaRecalc == 0)
			goto get_out;
	}

	boxController(_mouse.x, _mouse.y, x);
	_lastHitArea3 = _lastHitArea;
	if (x == 1 && _lastHitArea == nullptr)
		_lastHitArea3 = (HitArea *) -1;

get_out:
	_mouseOld = _mouse;
	drawMousePointer();

	_needHitAreaRecalc = 0;
	_litBoxFlag = false;
}

void AGOSEngine_PN::handleMouseMoved() {
	if (_mouseHideCount) {
		CursorMan.showMouse(false);
		return;
	}

	CursorMan.showMouse(true);
	_mouse = _eventMan->getMousePos();

	if (_leftClick == true) {
		_leftClick = false;
		if (_dragFlag) {
			_hitCalled = 4;
		} else if (_videoLockOut & 0x10) {
			if (_oneClick != 0) {
				_hitCalled = 2;
				_oneClick = 0;
			} else {
				_oneClick++;
			}
		} else {
			_hitCalled = 1;
		}
		_dragCount = 0;
	}

	if (_rightClick == true) {
		_rightClick = false;
		if (_hitCalled == 0)
			_hitCalled = 5;
	}

	if (_mouse != _mouseOld)
		_needHitAreaRecalc++;

	if (_leftButton != 0) {
		if (_dragCount <= 20) {
			_dragCount++;
			if (_dragCount > 20) {
				if (_videoLockOut & 0x10) {
					if (_oneClick == 0)
						_hitCalled = 3;
				} else {
					_hitCalled = 3;
				}
			}
		}
	} else if ((_videoLockOut & 0x10) && _oneClick != 0) {
		_oneClick++;
		if (_oneClick > 10) {
			_hitCalled = 1;
			_oneClick = 0;
		}
	}

	if (!_wiped)
		boxController(_mouse.x, _mouse.y, 0);

	_mouseOld = _mouse;
	drawMousePointer();

	_needHitAreaRecalc = 0;
	_litBoxFlag = false;
}

void AGOSEngine::handleMouseMoved() {
	uint x;

	if (_mouseHideCount) {
		CursorMan.showMouse(false);
		return;
	}

	CursorMan.showMouse(true);
	_mouse = _eventMan->getMousePos();

	if (getGameType() == GType_WW) {
		if (_variableArray[51] != 0 && _mouseCursor != _variableArray[51]) {
			_mouseCursor = _variableArray[51];
			_needHitAreaRecalc++;
		}
	} else if (getGameType() == GType_ELVIRA2) {
		if (_mouseCursor != _variableArray[72]) {
			_mouseCursor = _variableArray[72];
			_needHitAreaRecalc++;
		}
	} else if (getGameType() == GType_ELVIRA1) {
		if (getPlatform() == Common::kPlatformPC98) {
			_mouse.x >>= 1;
			_mouse.y >>= 1;
		}
		if (_mouseCursor != _variableArray[438]) {
			_mouseCursor = _variableArray[438];
			_needHitAreaRecalc++;
		}
	}

	if (_leftClick == true) {
		_leftClick = false;
		if (_dragMode) {
			_dragEnd = true;
		} else {
			_oneClick = 1;
		}
		_dragCount = 0;
	}

	if (_mouse != _mouseOld)
		_needHitAreaRecalc++;

	if (_leftButtonOld == 0 && _leftButton != 0) {
		_lastClickRem = nullptr;
		boxController(_mouse.x, _mouse.y, 3);
	}
	_leftButtonOld = _leftButton;

	if (_dragMode || _lastHitArea3) {
		x = 0;
		if (_needHitAreaRecalc == 0)
			goto get_out;
		else
			goto boxstuff;
	}

	if (_leftButton != 0 && _dragAccept && _lastClickRem != nullptr) {
		_dragCount++;
		if (_dragCount == 20) {
			_dragMode = true;
			_dragFlag = true;
			_needHitAreaRecalc++;
		}
	}

	x = 0;
	if (_oneClick > 0) {
		_oneClick = 0;
		x = 1;
	} else {
		if (!_litBoxFlag && _needHitAreaRecalc == 0)
			goto get_out;
	}

boxstuff:
	boxController(_mouse.x, _mouse.y, x);
	_lastHitArea3 = _lastHitArea;
get_out:
	_mouseOld = _mouse;
	drawMousePointer();

	_needHitAreaRecalc = 0;
	_litBoxFlag = false;
}

void AGOSEngine::mouseOff() {
	_mouseHideCount++;
}

void AGOSEngine::mouseOn() {
	_videoLockOut |= 1;

	if (_mouseHideCount != 0)
		_mouseHideCount--;

	_videoLockOut &= ~1;
}

#ifdef ENABLE_AGOS2
void AGOSEngine_PuzzlePack::initMouse() {
	if (getGameId() == GID_DIMP) {
		AGOSEngine_Simon1::initMouse();
	} else {
		_maxCursorWidth = 75;
		_maxCursorHeight = 97;
		_mouseData = (byte *)calloc(_maxCursorWidth * _maxCursorHeight, 1);
	}
}

void AGOSEngine_FeebleDemo::initMouse() {
	// TODO: Add larger cursor
	AGOSEngine_Simon1::initMouse();
}
void AGOSEngine_Feeble::initMouse() {
	_maxCursorWidth = 40;
	_maxCursorHeight = 40;
	_mouseData = (byte *)calloc(_maxCursorWidth * _maxCursorHeight, 1);
}

void AGOSEngine_PuzzlePack::loadMouseImage() {
	loadZone(_variableArray[500]);
	VgaPointersEntry *vpe = &_vgaBufferPointers[_variableArray[500]];

	byte *src = vpe->vgaFile2 + READ_LE_UINT32(vpe->vgaFile2 + _variableArray[501] * 8);
	memcpy(_mouseData, src, _maxCursorWidth * _maxCursorHeight);
}

void AGOSEngine_PuzzlePack::drawMousePointer() {
	if (getGameId() != GID_DIMP) {
		CursorMan.replaceCursor(_mouseData, _maxCursorWidth, _maxCursorHeight, 37, 48, 0);
	}
}

void AGOSEngine_Feeble::drawMousePart(int image, byte x, byte y) {
	VgaPointersEntry *vpe = &_vgaBufferPointers[7];
	byte *src;
	int width, height;

	byte *dst = _mouseData + y * _maxCursorWidth + x;

	src = vpe->vgaFile2 + image * 8;
	width = READ_LE_UINT16(src + 6);
	height = READ_LE_UINT16(src + 4);

	src = vpe->vgaFile2 + READ_LE_UINT32(src);

	assert(width + x <= _maxCursorWidth);
	assert(height + y <= _maxCursorWidth);

	for (int h = 0; h < height; h++) {
		for (int w = 0; w < width; w++) {
			if (src[w] != 0)
				dst[w] = src[w];
		}
		src += width;
		dst += _maxCursorWidth;
	}
}

void AGOSEngine_FeebleDemo::drawMousePointer() {
}

void AGOSEngine_Feeble::drawMousePointer() {
	uint cursor;
	int image, offs;

	if (_animatePointer) {
		if (getBitFlag(99)) {
			_mouseToggle = !_mouseToggle;
			if (_mouseToggle)
				_mouseAnim++;
		} else {
			_mouseAnim++;
		}
		if (_mouseAnim == _mouseAnimMax)
			_mouseAnim = 1;
	}

	cursor = _mouseCursor;

	if (!_animatePointer && getBitFlag(99)) {
		_mouseAnim = 1;
		cursor = 6;
	} else if (_mouseCursor != 5 && getBitFlag(72)) {
		cursor += 7;
	}

	if (cursor != _currentMouseCursor || _mouseAnim != _currentMouseAnim) {
		_currentMouseCursor = cursor;
		_currentMouseAnim = _mouseAnim;

		memset(_mouseData, 0, _maxCursorWidth * _maxCursorHeight);

		image = cursor * 16 + 1;
		offs = cursor * 32;
		drawMousePart(image, _mouseOffs[offs], _mouseOffs[offs + 1]);

		image = cursor * 16 + 1 + _mouseAnim;
		offs = cursor * 32 + _mouseAnim * 2;
		drawMousePart(image, _mouseOffs[offs], _mouseOffs[offs + 1]);

		int hotspotX = 19;
		int hotspotY = 19;

		if (_mouseCursor == 14) {
			// Finger pointing away from screen. Not sure where
			// this is used.
			hotspotX += 4;
			hotspotY -= 6;
		} else if (_mouseCursor == 15) {
			// Finger pointing down. Used for the oh-so-annoying
			// Cygnus Alpha tile puzzle.
			hotspotY += 18;
		}

		CursorMan.replaceCursor(_mouseData, _maxCursorWidth, _maxCursorHeight, hotspotX, hotspotY, 0);
	}
}
#endif

void AGOSEngine_Simon1::initMouse() {
	AGOSEngine::initMouse();

	const uint16 *src = _common_mouseInfo;
	for (int i = 0; i < 16; i++) {
		for (int j = 0; j < 16; j++) {
			if (src[0] & (1 << (15 - (j % 16)))) {
				if (src[1] & (1 << (15 - (j % 16)))) {
					_mouseData[16 * i + j] = 1;
				} else {
					_mouseData[16 * i + j] = 0;
				}
			}
		}
		src += 2;
	}

	CursorMan.replaceCursor(_mouseData, 16, 16, 0, 0, 0xFF);
}

static const byte mouseCursorPalette[] = {
	0x00, 0x00, 0x00, // Black
	0xFF, 0xFF, 0xFF  // White
};

void AGOSEngine::initMouse() {
	_maxCursorWidth = 16;
	_maxCursorHeight = 16;

	if (getGameId() == GID_ELVIRA1 && getPlatform() == Common::kPlatformPC98) {
		_maxCursorWidth <<= 1;
		_maxCursorHeight <<= 1;
	}

	_mouseData = (byte *)calloc(_maxCursorWidth * _maxCursorHeight, 1);

	memset(_mouseData, 0xFF, _maxCursorWidth * _maxCursorHeight);

	CursorMan.replaceCursorPalette(mouseCursorPalette, 0, ARRAYSIZE(mouseCursorPalette) / 3);
}

void AGOSEngine::drawMousePointer() {
	if (getGameType() == GType_SIMON2) {
		CursorMan.replaceCursor(_simon2_cursors[_mouseCursor], 16, 16, 7, 7, 0xFF);
	} else if (getGameType() != GType_SIMON1) {
		const uint16 *src;
		int i, j;

		memset(_mouseData, 0xFF, _maxCursorWidth * _maxCursorHeight);

		if (getGameType() == GType_WW) {
			if (_mouseCursor == 0) {
				src = _common_mouseInfo;
			} else if (_mouseCursor == 2) {
				src = _common_handInfo;
			} else if (_mouseCursor == 3) {
				src = _common_swordInfo1;
			} else if (_mouseCursor == 4) {
				src = _common_moveForward;
			} else if (_mouseCursor == 5) {
				src = _common_moveRight;
			} else if (_mouseCursor == 6) {
				src = _common_moveBack;
			} else if (_mouseCursor == 7) {
				src = _common_moveLeft;
			} else {
				src = _common_mouseInfo;
			}
		} else if (getGameType() == GType_ELVIRA2) {
			if (_mouseCursor == 0) {
				src = _common_mouseInfo;
			} else if (_mouseCursor == 1) {
				src = _common_shieldInfo1;
			} else if (_mouseCursor == 2) {
				src = _common_shieldInfo2;
			} else if (_mouseCursor == 3) {
				src = _common_swordInfo1;
			} else if (_mouseCursor == 4) {
				src = _common_swordInfo2;
			} else if (_mouseCursor == 5) {
				src = _common_lightningInfo1;
			} else if (_mouseCursor == 6) {
				src = _common_lightningInfo2;
			} else if (_mouseCursor == 7) {
				src = _common_crossbowInfo1;
			} else {
				src = _common_crossbowInfo2;
			}
		} else {
			if (_mouseCursor == 0) {
				src = _common_mouseInfo;
			} else if (_mouseCursor == 1) {
				src = _common_shieldInfo1;
			} else {
				src = _common_swordInfo1;
			}
		}

		if (_dragFlag)
			src = _common_handInfo;

		for (i = 0; i < 16; i++) {
			for (j = 0; j < 16; j++) {
				if (src[0] & (1 << (15 - (j % 16)))) {
					if (src[1] & (1 << (15 - (j % 16)))) {
						_mouseData[16 * i + j] = 1;
					} else {
						_mouseData[16 * i + j] = 0;
					}
				}
			}
			src += 2;
		}

		if (getGameId() == GID_ELVIRA1 && getPlatform() == Common::kPlatformPC98) {
			// Simple 2x upscaling for the cursor in dual layer hi-res mode.
			uint8 ptch = 16;
			uint16 *dst1 = &((uint16*)_mouseData)[16 * 16 * 2 - 1];
			uint16 *dst2 = dst1 - ptch;
			for (const byte *pos = &_mouseData[16 * 16 - 1]; pos >= _mouseData; --pos) {
				*dst1-- = *dst2-- = (*pos << 8) | *pos;
				if (!(ptch = (ptch - 1) % 16)) {
					dst1 -= 16;
					dst2 -= 16;
				}
			}
		}

		CursorMan.replaceCursor(_mouseData, _maxCursorWidth, _maxCursorHeight, 0, 0, 0xFF);
	}
}

} // End of namespace AGOS

================
File: debug.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// AGOS debug functions

#include "common/file.h"
#include "common/textconsole.h"

#include "agos/debug.h"
#include "agos/agos.h"
#include "agos/intern.h"
#include "agos/vga.h"

namespace AGOS {

const byte *AGOSEngine::dumpOpcode(const byte *p) {
	uint16 opcode;
	const char *s, *st;

	if (getGameType() == GType_ELVIRA1) {
		opcode = READ_BE_UINT16(p);
		p += 2;
		if (opcode == 10000)
			return nullptr;
	} else {
		opcode = *p++;
		if (opcode == 255)
			return nullptr;
	}

	if (getGameType() == GType_PP) {
		st = s = puzzlepack_opcodeNameTable[opcode];
	} else if (getGameType() == GType_FF) {
		st = s = feeblefiles_opcodeNameTable[opcode];
	} else if (getGameType() == GType_SIMON2 && getFeatures() & GF_TALKIE) {
		st = s = simon2talkie_opcodeNameTable[opcode];
	} else if (getGameType() == GType_SIMON2) {
		st = s = simon2dos_opcodeNameTable[opcode];
	} else if (getFeatures() & GF_TALKIE) {
		st = s = simon1talkie_opcodeNameTable[opcode];
	} else if (getGameType() == GType_SIMON1) {
		st = s = simon1dos_opcodeNameTable[opcode];
	} else if (getGameType() == GType_WW) {
		st = s = waxworks_opcodeNameTable[opcode];
	} else if (getGameType() == GType_ELVIRA2) {
		st = s = elvira2_opcodeNameTable[opcode];
	} else {
		st = s = elvira1_opcodeNameTable[opcode];
	}

	if (s == nullptr) {
		error("dumpOpcode: INVALID OPCODE %d", opcode);
	}

	while (*st != '|')
		st++;
	debugN("%s ", st + 1);

	for (;;) {
		switch (*s++) {
		case 'x':
			debugN("\n");
			return nullptr;
		case '|':
			debugN("\n");
			return p;
		case 'B':{
				byte b = *p++;
				if (b == 255)
					debugN("[%d] ", *p++);
				else
					debugN("%d ", b);
				break;
			}
		case 'V':{
				byte b = *p++;
				if (b == 255)
					debugN("[[%d]] ", *p++);
				else
					debugN("[%d] ", b);
				break;
			}

		case 'W':{
				uint16 n = READ_BE_UINT16(p);
				p += 2;
				if (getGameType() == GType_PP) {
					if (n >= 60000 && n < 62048)
						debugN("[%d] ", n - 60000);
					else
						debugN("%d ", n);

				} else {
					if (n >= 30000 && n < 30512)
						debugN("[%d] ", n - 30000);
					else
						debugN("%d ", n);
				}
				break;
			}

		case 'w':{
				int n = (int16)READ_BE_UINT16(p);
				p += 2;
				debugN("%d ", n);
				break;
			}

		case 'I':{
				int n = (int16)READ_BE_UINT16(p);
				p += 2;
				if (n == -1)
					debugN("SUBJECT_ITEM ");
				else if (n == -3)
					debugN("OBJECT_ITEM ");
				else if (n == -5)
					debugN("ME_ITEM ");
				else if (n == -7)
					debugN("ACTOR_ITEM ");
				else if (n == -9)
					debugN("ITEM_A_PARENT ");
				else
					debugN("<%d> ", n);
				break;
			}

		case 'J':{
				debugN("-> ");
			}
			break;

		case 'T':{
				uint n = READ_BE_UINT16(p);
				p += 2;
				if (n != 0xFFFF)
					debugN("\"%s\"(%d) ", getStringPtrByID(n), n);
				else
					debugN("NULL_STRING ");
			}
			break;

		default:
			break;
		}
	}
}

void AGOSEngine::dumpSubroutineLine(SubroutineLine *sl, Subroutine *sub) {
	const byte *p;

	debugN("; ****\n");

	p = (byte *)sl + SUBROUTINE_LINE_SMALL_SIZE;
	if (sub->id == 0) {
		debugN("; verb=%d, noun1=%d, noun2=%d\n", sl->verb, sl->noun1, sl->noun2);
		p = (byte *)sl + SUBROUTINE_LINE_BIG_SIZE;
	}

	for (;;) {
		p = dumpOpcode(p);
		if (p == nullptr)
			break;
	}
}

void AGOSEngine::dumpSubroutine(Subroutine *sub) {
	SubroutineLine *sl;

	debugN("\n******************************************\n;Subroutine, ID=%d:\nSUB_%d:\n", sub->id, sub->id);
	sl = (SubroutineLine *)((byte *)sub + sub->first);
	for (; (byte *)sl != (byte *)sub; sl = (SubroutineLine *)((byte *)sub + sl->next)) {
		dumpSubroutineLine(sl, sub);
	}
	debugN("\nEND ******************************************\n");
}

void AGOSEngine::dumpSubroutines() {
	Subroutine *sub = _subroutineList;
	for (; sub; sub = sub->next) {
		dumpSubroutine(sub);
	}
}

void AGOSEngine::dumpAllSubroutines() {
	for (int i = 0; i < 65536; i++) {
		Subroutine *sub = getSubroutineByID(i);
		if (sub != nullptr) {
			dumpSubroutine(sub);
		}
	}
}

void AGOSEngine::dumpVideoScript(const byte *src, bool singeOpcode) {
	uint16 opcode;
	const char *str, *strn;

	do {
		if (getGameType() == GType_SIMON2 || getGameType() == GType_FF || getGameType() == GType_PP) {
			opcode = *src++;
		} else {
			opcode = READ_BE_UINT16(src);
			src += 2;
		}

		if (opcode >= _numVideoOpcodes) {
			error("dumpVideoScript: Opcode %d out of range (%d)", opcode, _numVideoOpcodes);
		}

		if (getGameType() == GType_PP) {
			strn = str = puzzlepack_videoOpcodeNameTable[opcode];
		} else if (getGameType() == GType_FF) {
			strn = str = feeblefiles_videoOpcodeNameTable[opcode];
		} else if (getGameType() == GType_SIMON2) {
			strn = str = simon2_videoOpcodeNameTable[opcode];
		} else if (getGameType() == GType_SIMON1) {
			strn = str = simon1_videoOpcodeNameTable[opcode];
		} else if (getGameType() == GType_WW) {
			strn = str = ww_videoOpcodeNameTable[opcode];
		} else if (getGameType() == GType_ELVIRA2) {
			strn = str = elvira2_videoOpcodeNameTable[opcode];
		} else if (getGameType() == GType_ELVIRA1) {
			strn = str = elvira1_videoOpcodeNameTable[opcode];
		} else {
			strn = str = pn_videoOpcodeNameTable[opcode];
		}

		if (strn == nullptr) {
			error("dumpVideoScript: Invalid Opcode %d", opcode);
		}

		while (*strn != '|')
			strn++;
		debugN("%.2d: %s ", opcode, strn + 1);

		int end = (getGameType() == GType_FF || getGameType() == GType_PP) ? 9999 : 999;
		for (; *str != '|'; str++) {
			switch (*str) {
			case 'x':
				debugN("\n");
				return;
			case 'b': {
				debugN("%d ", *src++);
				break;
				}
			case 'w': {
				int16 v = (int16)readUint16Wrapper(src);
				src += 2;
				if (v < 0)
					debugN("[%d] ", -v);
				else
					debugN("%d ", v);
				break;
				}
			case 'd': {
				debugN("%d ", (int16)readUint16Wrapper(src));
				src += 2;
				break;
				}
			case 'v': {
				debugN("[%d] ", readUint16Wrapper(src));
				src += 2;
				break;
				}
			case 'i': {
				debugN("%d ", (int16)readUint16Wrapper(src));
				src += 2;
				break;
				}
			case 'j': {
				debugN("-> ");
				break;
				}
			case 'q': {
				while (readUint16Wrapper(src) != end) {
					debugN("(%d,%d) ", readUint16Wrapper(src),
									readUint16Wrapper(src + 2));
					src += 4;
				}
				src += 2;
				break;
				}
			default:
				error("dumpVideoScript: Invalid fmt string '%c' in decompile VGA", *str);
			}
		}

		debugN("\n");
	} while (!singeOpcode);
}

void AGOSEngine::dumpVgaScript(const byte *ptr, uint16 res, uint16 id) {
	dumpVgaScriptAlways(ptr, res, id);
}

void AGOSEngine::dumpVgaScriptAlways(const byte *ptr, uint16 res, uint16 id) {
	debugN("; address=%x, vgafile=%d  vgasprite=%d\n",
					(unsigned int)(ptr - _vgaBufferPointers[res].vgaFile1), res, id);
	dumpVideoScript(ptr, false);
	debugN("; end\n");
}

void AGOSEngine::dumpAllVgaImageFiles() {
	const uint8 start = (getGameType() == GType_PN) ? 0 : 2;

	for (int z = start; z < _numZone; z++) {
		loadZone(z, false);
		dumpVgaBitmaps(z);
	}
}

void AGOSEngine::dumpAllVgaScriptFiles() {
	const uint8 start = (getGameType() == GType_PN) ? 0 : 2;

	for (int z = start; z < _numZone; z++) {
		uint16 zoneNum = (getGameType() == GType_PN) ? 0 : z;
		loadZone(z, false);

		VgaPointersEntry *vpe = &_vgaBufferPointers[zoneNum];
		if (vpe->vgaFile1 != nullptr) {
			_curVgaFile1 = vpe->vgaFile1;
			dumpVgaFile(_curVgaFile1);
		}
	}
}

#ifdef ENABLE_AGOS2
void AGOSEngine_Feeble::dumpVgaFile(const byte *vga) {
	const byte *pp;
	const byte *p;
	int16 count;

	pp = vga;
	p = pp + READ_LE_UINT16(pp + 2);
	count = READ_LE_UINT16(&((const VgaFile1Header_Feeble *) p)->animationCount);
	p = pp + READ_LE_UINT16(&((const VgaFile1Header_Feeble *) p)->animationTable);

	while (--count >= 0) {
		uint16 id = READ_LE_UINT16(&((const AnimationHeader_Feeble *) p)->id);

		dumpVgaScriptAlways(vga + READ_LE_UINT16(&((const AnimationHeader_Feeble *) p)->scriptOffs), id / 100, id);
		p += sizeof(AnimationHeader_Feeble);
	}

	pp = vga;
	p = pp + READ_LE_UINT16(pp + 2);
	count = READ_LE_UINT16(&((const VgaFile1Header_Feeble *) p)->imageCount);
	p = pp + READ_LE_UINT16(&((const VgaFile1Header_Feeble *) p)->imageTable);

	while (--count >= 0) {
		uint16 id = READ_LE_UINT16(&((const ImageHeader_Feeble *) p)->id);

		dumpVgaScriptAlways(vga + READ_LE_UINT16(&((const ImageHeader_Feeble *) p)->scriptOffs), id / 100, id);
		p += sizeof(ImageHeader_Feeble);
	}
}
#endif

void AGOSEngine_Simon1::dumpVgaFile(const byte *vga) {
	const byte *pp;
	const byte *p;
	int16 count;

	pp = vga;
	p = pp + READ_BE_UINT16(pp + 4);
	count = READ_BE_UINT16(&((const VgaFile1Header_Common *) p)->animationCount);
	p = pp + READ_BE_UINT16(&((const VgaFile1Header_Common *) p)->animationTable);

	while (--count >= 0) {
		uint16 id = READ_BE_UINT16(&((const AnimationHeader_Simon *) p)->id);

		dumpVgaScriptAlways(vga + READ_BE_UINT16(&((const AnimationHeader_Simon *) p)->scriptOffs), id / 100, id);
		p += sizeof(AnimationHeader_Simon);
	}

	pp = vga;
	p = pp + READ_BE_UINT16(pp + 4);
	count = READ_BE_UINT16(&((const VgaFile1Header_Common *) p)->imageCount);
	p = pp + READ_BE_UINT16(&((const VgaFile1Header_Common *) p)->imageTable);

	while (--count >= 0) {
		uint16 id = READ_BE_UINT16(&((const ImageHeader_Simon *) p)->id);

		dumpVgaScriptAlways(vga + READ_BE_UINT16(&((const ImageHeader_Simon *) p)->scriptOffs), id / 100, id);
		p += sizeof(ImageHeader_Simon);
	}
}

void AGOSEngine::dumpVgaFile(const byte *vga) {
	const byte *pp;
	const byte *p;
	int16 count;

	pp = vga;
	p = pp + READ_BE_UINT16(pp + 10) + 20;
	count = READ_BE_UINT16(&((const VgaFile1Header_Common *) p)->animationCount);
	p = pp + READ_BE_UINT16(&((const VgaFile1Header_Common *) p)->animationTable);

	while (--count >= 0) {
		uint16 id = READ_BE_UINT16(&((const AnimationHeader_WW *) p)->id);

		dumpVgaScriptAlways(vga + READ_BE_UINT16(&((const AnimationHeader_WW *) p)->scriptOffs), id / 100, id);
		p += sizeof(AnimationHeader_WW);
	}

	pp = vga;
	p = pp + READ_BE_UINT16(pp + 10) + 20;
	count = READ_BE_UINT16(&((const VgaFile1Header_Common *) p)->imageCount);
	p = pp + READ_BE_UINT16(&((const VgaFile1Header_Common *) p)->imageTable);

	while (--count >= 0) {
		uint16 id = READ_BE_UINT16(&((const ImageHeader_WW *) p)->id);

		dumpVgaScriptAlways(vga + READ_BE_UINT16(&((const ImageHeader_WW *) p)->scriptOffs), id / 100, id);
		p += sizeof(ImageHeader_WW);
	}
}

static const byte bmp_hdr[] = {
	0x42, 0x4D,
	0x9E, 0x14, 0x00, 0x00,				/* offset 2, file size */
	0x00, 0x00, 0x00, 0x00,
	0x36, 0x04, 0x00, 0x00,
	0x28, 0x00, 0x00, 0x00,

	0x3C, 0x00, 0x00, 0x00,				/* image width */
	0x46, 0x00, 0x00, 0x00,				/* image height */
	0x01, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,

	0x00, 0x01, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00,
};

void dumpBMP(const char *filename, int16 w, int16 h, const byte *bytes, const byte *palette) {
	Common::DumpFile out;
	byte my_hdr[sizeof(bmp_hdr)];
	int i;

	out.open(filename);
	if (!out.isOpen())
		return;

	memcpy(my_hdr, bmp_hdr, sizeof(bmp_hdr));

	*(uint32 *)(my_hdr + 2) = w * h + 1024 + sizeof(bmp_hdr);
	*(uint32 *)(my_hdr + 18) = w;
	*(uint32 *)(my_hdr + 22) = h;


	out.write(my_hdr, sizeof(my_hdr));

	for (i = 0; i != 256; i++, palette += 3) {
		byte color[4];
		color[0] = palette[2];
		color[1] = palette[1];
		color[2] = palette[0];
		color[3] = 0;
		out.write(color, 4);
	}

	while (--h >= 0) {
		out.write(bytes + h * ((w + 3) & ~3), ((w + 3) & ~3));
	}
}

void AGOSEngine::dumpBitmap(const char *filename, const byte *offs, uint16 w, uint16 h, int flags, const byte *palette,
								 byte base) {

	byte *imageBuffer = (byte *)malloc(w * h);
	assert(imageBuffer);

	VC10_state state;
	state.depack_cont = -0x80;
	state.srcPtr = offs;
	state.dh = h;
	state.height = h;
	state.width = w / 16;

	if (getFeatures() & GF_PLANAR) {
		state.srcPtr = convertAmigaImage(&state, (getGameType() == GType_PN || (flags & 0x80) != 0));
		flags &= ~0x80;
	}

	const byte *src = state.srcPtr;
	byte *dst = imageBuffer;
	int i, j;

	if (w > _screenWidth) {
		for (i = 0; i < w; i += 8) {
			decodeColumn(dst, src + readUint32Wrapper(src), h, w);
			dst += 8;
			src += 4;
		}
	} else if (h > _screenHeight) {
		for (i = 0; i < h; i += 8) {
			decodeRow(dst, src + readUint32Wrapper(src), w, w);
			dst += 8 * w;
			src += 4;
		}
	} else if (getGameType() == GType_FF || getGameType() == GType_PP) {
		if ((flags & 0x80)) {
			for (i = 0; i != w; i++) {
				byte *c = vc10_depackColumn(&state);
				for (j = 0; j != h; j++) {
					dst[j * w + i] = c[j];
				}
			}
		} else {
			for (j = 0; j != h; j++) {
				for (i = 0; i != w; i++) {
					dst[i] = src[i];
				}
			}
			dst += w;
			src += w;
		}
	} else if ((getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) && w == 320 && (h == 134 || h == 135 || h == 200)) {
		for (j = 0; j != h; j++) {
			uint16 count = w / 8;

			byte *dstPtr = dst;
			do {
				uint32 bits = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | (src[3]);

				dstPtr[0] = (byte)((bits >> (32 - 5)) & 31);
				dstPtr[1] = (byte)((bits >> (32 - 10)) & 31);
				dstPtr[2] = (byte)((bits >> (32 - 15)) & 31);
				dstPtr[3] = (byte)((bits >> (32 - 20)) & 31);
				dstPtr[4] = (byte)((bits >> (32 - 25)) & 31);
				dstPtr[5] = (byte)((bits >> (32 - 30)) & 31);

				bits = (bits << 8) | src[4];

				dstPtr[6] = (byte)((bits >> (40 - 35)) & 31);
				dstPtr[7] = (byte)((bits) & 31);

				dstPtr += 8;
				src += 5;
			} while (--count);
			dst += w;
		}
	} else if (flags & 0x80) {
		for (i = 0; i != w; i += 2) {
			byte *c = vc10_depackColumn(&state);
			for (j = 0; j != h; j++) {
				byte col = c[j];
				dst[j * w + i] = (col >> 4) | base;
				dst[j * w + i + 1] = (col & 0xF) | base;
			}
		}
	} else {
		for (j = 0; j != h; j++) {
			for (i = 0; i != w / 2; i ++) {
				byte col = src[i];
				dst[i * 2] = (col >> 4) | base;
				dst[i * 2 + 1] = (col & 0xF) | base;
			}
			dst += w;
			src += w / 2;
		}
	}

	dumpBMP(filename, w, h, imageBuffer, palette);
	free(imageBuffer);
}

void AGOSEngine::dumpSingleBitmap(int file, int image, const byte *offs, int w, int h, byte base) {
	char buf[40];

	Common::sprintf_s(buf, "dumps/File%d_Image%d.bmp", file, image);

	if (Common::File::exists(buf))
		return;

	dumpBitmap(buf, offs, w, h, 0, _displayPalette, base);
}

void AGOSEngine::palLoad(byte *pal, const byte *vga1, int a, int b) {
	const byte *src;
	uint16 num, palSize;
	byte *palptr = (byte *)&pal[0];

	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		num = 256;
		palSize = 768;
	} else {
		num = 32;
		palSize = 96;
	}

	if (getGameType() == GType_PN && (getFeatures() & GF_EGA)) {
		memcpy(palptr, _displayPalette, 3 * 16);
	} else if (getGameType() == GType_PN || getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) {
		src = vga1 + READ_BE_UINT16(vga1 + 6) + b * 32;

		do {
			uint16 color = READ_BE_UINT16(src);
			palptr[0] = ((color & 0xf00) >> 8) * 32;
			palptr[1] = ((color & 0x0f0) >> 4) * 32;
			palptr[2] = ((color & 0x00f) >> 0) * 32;

			palptr += 3;
			src += 2;
		} while (--num);
	} else {
		src = vga1 + 6 + b * palSize;

		do {
			palptr[0] = src[0] << 2;
			palptr[1] = src[1] << 2;
			palptr[2] = src[2] << 2;

			palptr += 3;
			src += 3;
		} while (--num);
	}
}

void AGOSEngine::dumpVgaBitmaps(uint16 zoneNum) {
	uint16 width, height, flags;
	uint32 offs, offsEnd;
	const byte *p2;
	byte pal[768];

	uint16 zone = (getGameType() == GType_PN) ? 0 : zoneNum;
	VgaPointersEntry *vpe = &_vgaBufferPointers[zone];
	if (vpe->vgaFile1 == nullptr || vpe->vgaFile2 == nullptr)
		return;

	const byte *vga1 = vpe->vgaFile1;
	const byte *vga2 = vpe->vgaFile2;
	uint32 imageBlockSize = vpe->vgaFile2End - vpe->vgaFile2;

	memset(pal, 0, sizeof(pal));
	palLoad(pal, vga1, 0, 0);

	offsEnd = readUint32Wrapper(vga2 + 8);
	for (uint i = 1; ; i++) {
		if ((i * 8) >= offsEnd)
			break;

		p2 = vga2 + i * 8;
		offs = readUint32Wrapper(p2);

		width = readUint16Wrapper(p2 + 6);
		if (getGameType() == GType_FF || getGameType() == GType_PP) {
			height = READ_LE_UINT16(p2 + 4) & 0x7FFF;
			flags = p2[5];
		} else {
			height = p2[5];
			flags = p2[4];
		}

		debug(1, "Zone %d: Image %d. Offs= %d Width=%d, Height=%d, Flags=0x%X", zoneNum, i, offs, width, height, flags);
		if (offs >= imageBlockSize || width == 0 || height == 0)
			break;

		/* dump bitmap */
		char buf[40];
		Common::sprintf_s(buf, "dumps/Res%d_Image%d.bmp", zoneNum, i);

		dumpBitmap(buf, vga2 + offs, width, height, flags, pal, 0);
	}
}

} // End of namespace AGOS

================
File: debug.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_DEBUG_H
#define AGOS_DEBUG_H

#include "common/scummsys.h"

namespace AGOS {

static const char *const elvira1_opcodeNameTable[300] = {
	/* 0 */
	"IJ|AT",
	"IJ|NOT_AT",
	"IJ|PRESENT",
	"IJ|NOT_PRESENT",
	/* 4 */
	"IJ|WORN",
	"IJ|NOT_WORN",
	"IJ|CARRIED",
	"IJ|NOT_CARRIED",
	/* 8 */
	"IIJ|IS_AT",
	"IIJ|IS_NOT_AT",
	"IIJ|IS_SIBLING",
	"IIJ|IS_NOT_SIBLING",
	/* 12 */
	"WJ|IS_ZERO",
	"WJ|ISNOT_ZERO",
	"WWJ|IS_EQ",
	"WWJ|IS_NEQ",
	/* 16 */
	"WWJ|IS_LE",
	"WWJ|IS_GE",
	"WWJ|IS_EQF",
	"WWJ|IS_NEQF",
	/* 20 */
	"WWJ|IS_LEF",
	"WWJ|IS_GEF",
	"IIJ|IS_IN",
	"IIJ|IS_NOT_IN",
	/* 24 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 28 */
	"WJ|PREP",
	"WJ|CHANCE",
	"IJ|IS_PLAYER",
	NULL,
	/* 32 */
	"IJ|IS_ROOM",
	"IJ|IS_OBJECT",
	"IWJ|ITEM_STATE_IS",
	NULL,
	/* 36 */
	"IWJ|OBJECT_HAS_FLAG",
	"IIJ|CAN_PUT",
	NULL,
	NULL,
	/* 40 */
	NULL,
	NULL,
	NULL,
	"IW|GET",
	/* 44 */
	"I|DROP",
	NULL,
	NULL,
	"I|CREATE",
	/* 48 */
	"I|SET_NO_PARENT",
	NULL,
	NULL,
	"II|SET_PARENT",
	/* 52 */
	NULL,
	NULL,
	"IWW|COPY_OF",
	"WIW|COPY_FO",
	/* 56 */
	"WW|MOVE",
	"W|WHAT_O",
	NULL,
	"IW|WEIGH",
	/* 60 */
	"W|SET_FF",
	"W|ZERO",
	NULL,
	NULL,
	/* 64 */
	"WW|SET",
	"WW|ADD",
	"WW|SUB",
	"WW|ADDF",
	/* 68 */
	"WW|SUBF",
	"WW|MUL",
	"WW|DIV",
	"WW|MULF",
	/* 72 */
	"WW|DIVF",
	"WW|MOD",
	"WW|MODF",
	"WW|RANDOM",
	/* 76 */
	"W|MOVE_DIRN",
	"I|SET_A_PARENT",
	NULL,
	NULL,
	/* 80 */
	"IW|SET_CHILD2_BIT",
	"IW|CLEAR_CHILD2_BIT",
	NULL,
	NULL,
	/* 84 */
	"II|MAKE_SIBLING",
	"I|INC_STATE",
	"I|DEC_STATE",
	"IW|SET_STATE",
	/* 88 */
	NULL,
	"W|SHOW_INT",
	"|SHOW_SCORE",
	"T|SHOW_STRING_NL",
	/* 92 */
	"T|SHOW_STRING",
	"I|LISTOBJ",
	NULL,
	"|INVEN",
	/* 96 */
	"|LOOK",
	"x|END",
	"x|DONE",
	NULL,
	/* 100 */
	"x|OK",
	NULL,
	NULL,
	NULL,
	/* 104 */
	NULL,
	"W|START_SUB",
	"IWW|DO_CLASS",
	NULL,
	/* 108 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 112 */
	"IW|PRINT_OBJ",
	NULL,
	"I|PRINT_NAME",
	"I|PRINT_CNAME",
	/* 116 */
	NULL,
	NULL,
	NULL,
	"WW|ADD_TIMEOUT",
	/* 120 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 124 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 128 */
	"J|IS_SUBJECT_ITEM_EMPTY",
	"J|IS_OBJECT_ITEM_EMPTY",
	NULL,
	NULL,
	/* 132 */
	NULL,
	NULL,
	NULL,
	"ITJ|CHILD_FR2_IS",
	/* 136 */
	"IIJ|IS_ITEM_EQ",
	NULL,
	NULL,
	NULL,
	/* 140 */
	"I|EXITS",
	NULL,
	NULL,
	NULL,
	/* 144 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 148 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 152 */
	"W|DEBUG",
	NULL,
	NULL,
	NULL,
	/* 156 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 160 */
	NULL,
	NULL,
	"IWJ|IS_CFLAG",
	NULL,
	/* 164 */
	"|RESCAN",
	"wwwW|MEANS",
	NULL,
	NULL,
	/* 168 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 172 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 176 */
	"IWI|SET_USER_ITEM",
	"IWW|GET_USER_ITEM",
	"IW|CLEAR_USER_ITEM",
	NULL,
	/* 180 */
	"IWW|WHERE_TO",
	"IIW|DOOR_EXIT",
	NULL,
	NULL,
	/* 184 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 188 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 192 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 196 */
	NULL,
	NULL,
	"W|COMMENT",
	NULL,
	/* 200 */
	NULL,
	"T|SAVE_GAME",
	"T|LOAD_GAME",
	"|NOT",
	/* 204 */
	NULL,
	NULL,
	"IW|GET_PARENT",
	"IW|GET_NEXT",
	/* 208 */
	"IW|GET_CHILDREN",
	NULL,
	NULL,
	NULL,
	/* 212 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 216 */
	NULL,
	NULL,
	NULL,
	"WW|FIND_MASTER",
	/* 220 */
	"IWW|NEXT_MASTER",
	NULL,
	NULL,
	NULL,
	/* 224 */
	"WW|PICTURE",
	"W|LOAD_ZONE",
	"WWWWW|ANIMATE",
	"W|STOP_ANIMATE",
	/* 228 */
	"|KILL_ANIMATE",
	"WWWWWWW|DEFINE_WINDOW",
	"W|CHANGE_WINDOW",
	"|CLS",
	/* 232 */
	"W|CLOSE_WINDOW",
	"WW|AGOS_MENU",
	NULL,
	"WWWWWIW|ADD_BOX",
	/* 236 */
	"W|DEL_BOX",
	"W|ENABLE_BOX",
	"W|DISABLE_BOX",
	"WWW|MOVE_BOX",
	/* 240 */
	NULL,
	NULL,
	"IW|DO_ICONS",
	"IWJ|IS_CLASS",
	/* 244 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 248 */
	NULL,
	"IW|SET_CLASS",
	"IW|UNSET_CLASS",
	"WW|CLEAR_BIT",
	/* 252 */
	"WW|SET_BIT",
	"WWJ|BIT_TEST",
	NULL,
	"W|WAIT_SYNC",
	/* 256 */
	"W|SYNC",
	"WI|DEF_OBJ",
	"|ENABLE_INPUT",
	"|SET_TIME",
	/* 260 */
	"WJ|IF_TIME",
	"IJ|IS_SIBLING_WITH_A",
	"IWW|DO_CLASS_ICONS",
	"WW|PLAY_TUNE",
	/* 264 */
	NULL,
	"W|IF_END_TUNE",
	"Www|SET_ADJ_NOUN",
	"WW|ZONE_DISK",
	/* 268 */
	"|SAVE_USER_GAME",
	"|LOAD_USER_GAME",
	"|PRINT_STATS",
	"|STOP_TUNE",
	/* 272 */
	"|PRINT_PLAYER_DAMAGE",
	"|PRINT_MONSTER_DAMAGE",
	"|PAUSE",
	"IW|COPY_SF",
	/* 276 */
	"W|RESTORE_ICONS",
	"|PRINT_PLAYER_HIT",
	"|PRINT_MONSTER_HIT",
	"|FREEZE_ZONES",
	/* 280 */
	"II|SET_PARENT_SPECIAL",
	"|CLEAR_TIMERS",
	"IW|SET_STORE",
	"WJ|IS_BOX",
};

static const char *const elvira2_opcodeNameTable[256] = {
	/* 0 */
	"|NOT",
	"IJ|AT",
	"IJ|NOT_AT",
	NULL,
	/* 4 */
	NULL,
	"IJ|CARRIED",
	"IJ|NOT_CARRIED",
	"IIJ|IS_AT",
	/* 8 */
	"IIJ|IS_NOT_AT",
	"IIJ|IS_SIBLING",
	"IIJ|IS_NOT_SIBLING",
	"VJ|IS_ZERO",
	/* 12 */
	"VJ|ISNOT_ZERO",
	"VWJ|IS_EQ",
	"VWJ|IS_NEQ",
	"VWJ|IS_LE",
	/* 16 */
	"VWJ|IS_GE",
	"VVJ|IS_EQF",
	"VVJ|IS_NEQF",
	"VVJ|IS_LEF",
	/* 20 */
	"VVJ|IS_GEF",
	"IIJ|IS_IN",
	"IIJ|IS_NOT_IN",
	"WJ|CHANCE",
	/* 24 */
	"IJ|IS_PLAYER",
	"IJ|IS_ROOM",
	"IJ|IS_OBJECT",
	"IWJ|ITEM_STATE_IS",
	/* 28 */
	"IBJ|OBJECT_HAS_FLAG",
	"IIJ|CAN_PUT",
	NULL,
	"I|SET_NO_PARENT",
	/* 32 */
	NULL,
	"II|SET_PARENT",
	"IBV|COPY_OF",
	"VIB|COPY_FO",
	/* 36 */
	"VV|MOVE",
	"W|WHAT_O",
	NULL,
	"IW|WEIGH",
	/* 40 */
	NULL,
	"V|ZERO",
	"VW|SET",
	"VW|ADD",
	/* 44 */
	"VW|SUB",
	"VV|ADDF",
	"VV|SUBF",
	"VW|MUL",
	/* 48 */
	"VW|DIV",
	"VV|MULF",
	"VV|DIVF",
	"VW|MOD",
	/* 52 */
	"VV|MODF",
	"VW|RANDOM",
	"B|MOVE_DIRN",
	"I|SET_A_PARENT",
	/* 56 */
	"IB|SET_CHILD2_BIT",
	"IB|CLEAR_CHILD2_BIT",
	"II|MAKE_SIBLING",
	"I|INC_STATE",
	/* 60 */
	"I|DEC_STATE",
	"IW|SET_STATE",
	"V|SHOW_INT",
	"T|SHOW_STRING_NL",
	/* 64 */
	"T|SHOW_STRING",
	NULL,
	NULL,
	NULL,
	/* 68 */
	"x|END",
	"x|DONE",
	NULL,
	"W|START_SUB",
	/* 72 */
	"IBW|DO_CLASS",
	"I|PRINT_OBJ",
	"I|PRINT_NAME",
	"I|PRINT_CNAME",
	/* 76 */
	"WW|ADD_TIMEOUT",
	"J|IS_SUBJECT_ITEM_EMPTY",
	"J|IS_OBJECT_ITEM_EMPTY",
	"ITJ|CHILD_FR2_IS",
	/* 80 */
	"IIJ|IS_ITEM_EQ",
	NULL,
	"B|DEBUG",
	"|RESCAN",
	/* 84 */
	NULL,
	"IBB|WHERE_TO",
	NULL,
	"W|COMMENT",
	/* 88 */
	"|STOP_ANIMATION",
	"T|LOAD_GAME",
	"IB|GET_PARENT",
	"IB|GET_NEXT",
	/* 92 */
	"IB|GET_CHILDREN",
	NULL,
	"BB|FIND_MASTER",
	"IBB|NEXT_MASTER",
	/* 96 */
	"WB|PICTURE",
	"W|LOAD_ZONE",
	"WBWWW|ANIMATE",
	"W|STOP_ANIMATE",
	/* 100 */
	"|KILL_ANIMATE",
	"BWWWWWW|DEFINE_WINDOW",
	"B|CHANGE_WINDOW",
	"|CLS",
	/* 104 */
	"B|CLOSE_WINDOW",
	"B|SET_AGOS_MENU",
	NULL,
	"WWWWWIW|ADD_BOX",
	/* 108 */
	"W|DEL_BOX",
	"W|ENABLE_BOX",
	"W|DISABLE_BOX",
	"WWW|MOVE_BOX",
	/* 112 */
	NULL,
	"IBWW|DRAW_ITEM",
	"IB|DO_ICONS",
	"IBJ|IS_CLASS",
	/* 116 */
	"IB|SET_CLASS",
	"IB|UNSET_CLASS",
	NULL,
	"W|WAIT_SYNC",
	/* 120 */
	"W|SYNC",
	"BI|DEF_OBJ",
	NULL,
	"|SET_TIME",
	/* 124 */
	"WJ|IF_TIME",
	"IJ|IS_SIBLING_WITH_A",
	"IBB|DO_CLASS_ICONS",
	"WW|PLAY_TUNE",
	/* 128 */
	NULL,
	NULL,
	"Bww|SET_ADJ_NOUN",
	NULL,
	/* 132 */
	"|SAVE_USER_GAME",
	"|LOAD_USER_GAME",
	"|STOP_TUNE",
	"|PAUSE",
	/* 136 */
	"IV|COPY_SF",
	"B|RESTORE_ICONS",
	"|FREEZE_ZONES",
	"II|SET_PARENT_SPECIAL",
	/* 140 */
	"|CLEAR_TIMERS",
	"BI|SET_M1_OR_M3",
	"WJ|IS_BOX",
	"I|START_ITEM_SUB",
	/* 144 */
	"IB|SET_DOOR_OPEN",
	"IB|SET_DOOR_CLOSED",
	"IB|SET_DOOR_LOCKED",
	"IB|SET_DOOR_OPEN",
	/* 148 */
	"IBJ|IF_DOOR_OPEN",
	"IBJ|IF_DOOR_CLOSED",
	"IBJ|IF_DOOR_LOCKED",
	"BI|STORE_ITEM",
	/* 152 */
	"BB|GET_ITEM",
	"B|SET_BIT",
	"B|CLEAR_BIT",
	"BJ|IS_BIT_CLEAR",
	/* 156 */
	"BJ|IS_BIT_SET",
	"IBB|GET_ITEM_PROP",
	"IBW|SET_ITEM_PROP",
	NULL,
	/* 160 */
	"B|SET_INK",
	"|PRINT_STATS",
	NULL,
	NULL,
	/* 164 */
	NULL,
	"W|SET_SUPER_ROOM",
	"V|GET_SUPER_ROOM",
	"IWB|SET_EXIT_OPEN",
	/* 168 */
	"IWB|SET_EXIT_CLOSED",
	"IWB|SET_EXIT_LOCKED",
	"IWB|SET_EXIT_CLOSED",
	"IWBJ|IF_EXIT_OPEN",
	/* 172 */
	"IWBJ|IF_EXIT_CLOSED",
	"IWBJ|IF_EXIT_LOCKED",
	"W|PLAY_EFFECT",
	"|getDollar2",
	/* 176 */
	"IWBB|SET_SUPER_ROOM_EXIT",
	"B|UNK_177",
	"B|UNK_178",
	"IWWJ|IS_ADJ_NOUN",
	/* 180 */
	"B|SET_BIT2",
	"B|CLEAR_BIT2",
	"BJ|IS_BIT2_CLEAR",
	"BJ|IS_BIT2_SET",
};

static const char *const waxworks_opcodeNameTable[256] = {
	/* 0 */
	"|NOT",
	"IJ|AT",
	"IJ|NOT_AT",
	NULL,
	/* 4 */
	NULL,
	"IJ|CARRIED",
	"IJ|NOT_CARRIED",
	"IIJ|IS_AT",
	/* 8 */
	"IIJ|IS_NOT_AT",
	"IIJ|IS_SIBLING",
	"IIJ|IS_NOT_SIBLING",
	"VJ|IS_ZERO",
	/* 12 */
	"VJ|ISNOT_ZERO",
	"VWJ|IS_EQ",
	"VWJ|IS_NEQ",
	"VWJ|IS_LE",
	/* 16 */
	"VWJ|IS_GE",
	"VVJ|IS_EQF",
	"VVJ|IS_NEQF",
	"VVJ|IS_LEF",
	/* 20 */
	"VVJ|IS_GEF",
	"IIJ|IS_IN",
	"IIJ|IS_NOT_IN",
	"WJ|CHANCE",
	/* 24 */
	"IJ|IS_PLAYER",
	"IJ|IS_ROOM",
	"IJ|IS_OBJECT",
	"IWJ|ITEM_STATE_IS",
	/* 28 */
	"IBJ|OBJECT_HAS_FLAG",
	"IIJ|CAN_PUT",
	NULL,
	"I|SET_NO_PARENT",
	/* 32 */
	NULL,
	"II|SET_PARENT",
	"IBV|COPY_OF",
	"VIB|COPY_FO",
	/* 36 */
	"VV|MOVE",
	"W|WHAT_O",
	NULL,
	"IW|WEIGH",
	/* 40 */
	NULL,
	"V|ZERO",
	"VW|SET",
	"VW|ADD",
	/* 44 */
	"VW|SUB",
	"VV|ADDF",
	"VV|SUBF",
	"VW|MUL",
	/* 48 */
	"VW|DIV",
	"VV|MULF",
	"VV|DIVF",
	"VW|MOD",
	/* 52 */
	"VV|MODF",
	"VW|RANDOM",
	"B|MOVE_DIRN",
	"I|SET_A_PARENT",
	/* 56 */
	"IB|SET_CHILD2_BIT",
	"IB|CLEAR_CHILD2_BIT",
	"II|MAKE_SIBLING",
	"I|INC_STATE",
	/* 60 */
	"I|DEC_STATE",
	"IW|SET_STATE",
	"V|SHOW_INT",
	"T|SHOW_STRING_NL",
	/* 64 */
	"T|SHOW_STRING",
	"WWWWWB|ADD_TEXT_BOX",
	"BT|SET_SHORT_TEXT",
	"BT|SET_LONG_TEXT",
	/* 68 */
	"x|END",
	"x|DONE",
	"V|SHOW_STRING_AR3",
	"W|START_SUB",
	/* 72 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 76 */
	"WW|ADD_TIMEOUT",
	"J|IS_SUBJECT_ITEM_EMPTY",
	"J|IS_OBJECT_ITEM_EMPTY",
	"ITJ|CHILD_FR2_IS",
	/* 80 */
	"IIJ|IS_ITEM_EQ",
	NULL,
	"B|DEBUG",
	"|RESCAN",
	/* 84 */
	NULL,
	"IBB|WHERE_TO",
	NULL,
	"W|COMMENT",
	/* 88 */
	"|STOP_ANIMATION",
	"T|LOAD_GAME",
	"IB|GET_PARENT",
	"IB|GET_NEXT",
	/* 92 */
	"IB|GET_CHILDREN",
	NULL,
	"BB|FIND_MASTER",
	"IBB|NEXT_MASTER",
	/* 96 */
	"WB|PICTURE",
	"W|LOAD_ZONE",
	"WBWWW|ANIMATE",
	"W|STOP_ANIMATE",
	/* 100 */
	"|KILL_ANIMATE",
	"BWWWWWW|DEFINE_WINDOW",
	"B|CHANGE_WINDOW",
	"|CLS",
	/* 104 */
	"B|CLOSE_WINDOW",
	"B|SET_AGOS_MENU",
	"BB|SET_TEXT_MENU",
	"WWWWWIW|ADD_BOX",
	/* 108 */
	"W|DEL_BOX",
	"W|ENABLE_BOX",
	"W|DISABLE_BOX",
	"WWW|MOVE_BOX",
	/* 112 */
	NULL,
	NULL,
	"IB|DO_ICONS",
	"IBJ|IS_CLASS",
	/* 116 */
	"IB|SET_CLASS",
	"IB|UNSET_CLASS",
	NULL,
	"W|WAIT_SYNC",
	/* 120 */
	"W|SYNC",
	"BI|DEF_OBJ",
	NULL,
	NULL,
	/* 124 */
	NULL,
	"IJ|IS_SIBLING_WITH_A",
	"IBB|DO_CLASS_ICONS",
	"WW|PLAY_TUNE",
	/* 128 */
	NULL,
	NULL,
	"Bww|SET_ADJ_NOUN",
	NULL,
	/* 132 */
	"|SAVE_USER_GAME",
	"|LOAD_USER_GAME",
	"|STOP_TUNE",
	"|PAUSE",
	/* 136 */
	"IV|COPY_SF",
	"B|RESTORE_ICONS",
	"|FREEZE_ZONES",
	"II|SET_PARENT_SPECIAL",
	/* 140 */
	"|CLEAR_TIMERS",
	"BI|SET_M1_OR_M3",
	"WJ|IS_BOX",
	"I|START_ITEM_SUB",
	/* 144 */
	"IB|SET_DOOR_OPEN",
	"IB|SET_DOOR_CLOSED",
	"IB|SET_DOOR_LOCKED",
	"IB|SET_DOOR_OPEN",
	/* 148 */
	"IBJ|IF_DOOR_OPEN",
	"IBJ|IF_DOOR_CLOSED",
	"IBJ|IF_DOOR_LOCKED",
	"BI|STORE_ITEM",
	/* 152 */
	"BB|GET_ITEM",
	"B|SET_BIT",
	"B|CLEAR_BIT",
	"BJ|IS_BIT_CLEAR",
	/* 156 */
	"BJ|IS_BIT_SET",
	"IBB|GET_ITEM_PROP",
	"IBW|SET_ITEM_PROP",
	NULL,
	/* 160 */
	"B|SET_INK",
	NULL,
	NULL,
	NULL,
	/* 164 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 168 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 172 */
	NULL,
	NULL,
	NULL,
	"|getDollar2",
	/* 176 */
	NULL,
	NULL,
	NULL,
	"IWWJ|IS_ADJ_NOUN",
	/* 180 */
	"B|SET_BIT2",
	"B|CLEAR_BIT2",
	"BJ|IS_BIT2_CLEAR",
	"BJ|IS_BIT2_SET",
	/* 184 */
	"T|BOX_MESSAGE",
	"T|BOX_MSG",
	"B|BOX_LONG_TEXT",
	"|PRINT_BOX",
	/* 188 */
	"I|BOX_POBJ",
	"|LOCK_ZONES",
	"|UNLOCK_ZONES",
};

static const char *const simon1dos_opcodeNameTable[256] = {
	/* 0 */
	"|NOT",
	"IJ|AT",
	"IJ|NOT_AT",
	NULL,
	/* 4 */
	NULL,
	"IJ|CARRIED",
	"IJ|NOT_CARRIED",
	"IIJ|IS_AT",
	/* 8 */
	NULL,
	NULL,
	NULL,
	"VJ|IS_ZERO",
	/* 12 */
	"VJ|ISNOT_ZERO",
	"VWJ|IS_EQ",
	"VWJ|IS_NEQ",
	"VWJ|IS_LE",
	/* 16 */
	"VWJ|IS_GE",
	"VVJ|IS_EQF",
	"VVJ|IS_NEQF",
	"VVJ|IS_LEF",
	/* 20 */
	"VVJ|IS_GEF",
	NULL,
	NULL,
	"WJ|CHANCE",
	/* 24 */
	NULL,
	"IJ|IS_ROOM",
	"IJ|IS_OBJECT",
	"IWJ|ITEM_STATE_IS",
	/* 28 */
	"IBJ|OBJECT_HAS_FLAG",
	NULL,
	NULL,
	"I|SET_NO_PARENT",
	/* 32 */
	NULL,
	"II|SET_PARENT",
	NULL,
	NULL,
	/* 36 */
	"VV|MOVE",
	NULL,
	NULL,
	NULL,
	/* 40 */
	NULL,
	"V|ZERO",
	"VW|SET",
	"VW|ADD",
	/* 44 */
	"VW|SUB",
	"VV|ADDF",
	"VV|SUBF",
	"VW|MUL",
	/* 48 */
	"VW|DIV",
	"VV|MULF",
	"VV|DIVF",
	"VW|MOD",
	/* 52 */
	"VV|MODF",
	"VW|RANDOM",
	NULL,
	"I|SET_A_PARENT",
	/* 56 */
	"IB|SET_CHILD2_BIT",
	"IB|CLEAR_CHILD2_BIT",
	"II|MAKE_SIBLING",
	"I|INC_STATE",
	/* 60 */
	"I|DEC_STATE",
	"IW|SET_STATE",
	"V|SHOW_INT",
	"T|SHOW_STRING_NL",
	/* 64 */
	"T|SHOW_STRING",
	"WWWWWB|ADD_TEXT_BOX",
	"BT|SET_SHORT_TEXT",
	"BT|SET_LONG_TEXT",
	/* 68 */
	"x|END",
	"x|DONE",
	"V|SHOW_STRING_AR3",
	"W|START_SUB",
	/* 72 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 76 */
	"WW|ADD_TIMEOUT",
	"J|IS_SUBJECT_ITEM_EMPTY",
	"J|IS_OBJECT_ITEM_EMPTY",
	"ITJ|CHILD_FR2_IS",
	/* 80 */
	"IIJ|IS_ITEM_EQ",
	NULL,
	"B|DEBUG",
	"|RESCAN",
	/* 84 */
	NULL,
	NULL,
	NULL,
	"W|COMMENT",
	/* 88 */
	"|STOP_ANIMATION",
	"|RESTART_ANIMATION",
	"IB|GET_PARENT",
	"IB|GET_NEXT",
	/* 92 */
	"IB|GET_CHILDREN",
	NULL,
	NULL,
	NULL,
	/* 96 */
	"WB|PICTURE",
	"W|LOAD_ZONE",
	"WBWWW|ANIMATE",
	"W|STOP_ANIMATE",
	/* 100 */
	"|KILL_ANIMATE",
	"BWWWWWW|DEFINE_WINDOW",
	"B|CHANGE_WINDOW",
	"|CLS",
	/* 104 */
	"B|CLOSE_WINDOW",
	NULL,
	NULL,
	"WWWWWIW|ADD_BOX",
	/* 108 */
	"W|DEL_BOX",
	"W|ENABLE_BOX",
	"W|DISABLE_BOX",
	"WWW|MOVE_BOX",
	/* 112 */
	NULL,
	NULL,
	"IB|DO_ICONS",
	"IBJ|IS_CLASS",
	/* 116 */
	"IB|SET_CLASS",
	"IB|UNSET_CLASS",
	NULL,
	"W|WAIT_SYNC",
	/* 120 */
	"W|SYNC",
	"BI|DEF_OBJ",
	NULL,
	NULL,
	/* 124 */
	NULL,
	"IJ|IS_SIBLING_WITH_A",
	"IBB|DO_CLASS_ICONS",
	"WW|PLAY_TUNE",
	/* 128 */
	NULL,
	NULL,
	"Bww|SET_ADJ_NOUN",
	NULL,
	/* 132 */
	"|SAVE_USER_GAME",
	"|LOAD_USER_GAME",
	"|STOP_TUNE",
	"|PAUSE",
	/* 136 */
	"IV|COPY_SF",
	"B|RESTORE_ICONS",
	"|FREEZE_ZONES",
	"II|SET_PARENT_SPECIAL",
	/* 140 */
	"|CLEAR_TIMERS",
	"BI|SET_M1_OR_M3",
	"WJ|IS_BOX",
	"I|START_ITEM_SUB",
	/* 144 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 148 */
	NULL,
	NULL,
	NULL,
	"BI|STORE_ITEM",
	/* 152 */
	"BB|GET_ITEM",
	"B|SET_BIT",
	"B|CLEAR_BIT",
	"BJ|IS_BIT_CLEAR",
	/* 156 */
	"BJ|IS_BIT_SET",
	"IBB|GET_ITEM_PROP",
	"IBW|SET_ITEM_PROP",
	NULL,
	/* 160 */
	"B|SET_INK",
	"BWBW|SETUP_TEXT",
	"BBT|PRINT_STR",
	"W|PLAY_EFFECT",
	/* 164 */
	"|getDollar2",
	"IWWJ|IS_ADJ_NOUN",
	"B|SET_BIT2",
	"B|CLEAR_BIT2",
	/* 168 */
	"BJ|IS_BIT2_CLEAR",
	"BJ|IS_BIT2_SET",
	NULL,
	NULL,
	/* 172 */
	NULL,
	NULL,
	NULL,
	"|LOCK_ZONES",
	/* 176 */
	"|UNLOCK_ZONES",
	"BBI|SCREEN_TEXT_POBJ",
	"WWBB|GETPATHPOSN",
	"BBB|SCREEN_TEXT_LONG_TEXT",
	/* 180 */
	"|MOUSE_ON",
	"|MOUSE_OFF",
	"|LOAD_BEARD",
	"|UNLOAD_BEARD",
	/* 184 */
	"W|UNLOAD_ZONE",
	"W|LOAD_SOUND_FILES",
	"|UNFREEZE_ZONES",
	"|FADE_TO_BLACK",
};

static const char *const simon1talkie_opcodeNameTable[256] = {
	/* 0 */
	"|NOT",
	"IJ|AT",
	"IJ|NOT_AT",
	NULL,
	/* 4 */
	NULL,
	"IJ|CARRIED",
	"IJ|NOT_CARRIED",
	"IIJ|IS_AT",
	/* 8 */
	NULL,
	NULL,
	NULL,
	"VJ|IS_ZERO",
	/* 12 */
	"VJ|ISNOT_ZERO",
	"VWJ|IS_EQ",
	"VWJ|IS_NEQ",
	"VWJ|IS_LE",
	/* 16 */
	"VWJ|IS_GE",
	"VVJ|IS_EQF",
	"VVJ|IS_NEQF",
	"VVJ|IS_LEF",
	/* 20 */
	"VVJ|IS_GEF",
	NULL,
	NULL,
	"WJ|CHANCE",
	/* 24 */
	NULL,
	"IJ|IS_ROOM",
	"IJ|IS_OBJECT",
	"IWJ|ITEM_STATE_IS",
	/* 28 */
	"IBJ|OBJECT_HAS_FLAG",
	NULL,
	NULL,
	"I|SET_NO_PARENT",
	/* 32 */
	NULL,
	"II|SET_PARENT",
	NULL,
	NULL,
	/* 36 */
	"VV|MOVE",
	NULL,
	NULL,
	NULL,
	/* 40 */
	NULL,
	"V|ZERO",
	"VW|SET",
	"VW|ADD",
	/* 44 */
	"VW|SUB",
	"VV|ADDF",
	"VV|SUBF",
	"VW|MUL",
	/* 48 */
	"VW|DIV",
	"VV|MULF",
	"VV|DIVF",
	"VW|MOD",
	/* 52 */
	"VV|MODF",
	"VW|RANDOM",
	NULL,
	"I|SET_A_PARENT",
	/* 56 */
	"IB|SET_CHILD2_BIT",
	"IB|CLEAR_CHILD2_BIT",
	"II|MAKE_SIBLING",
	"I|INC_STATE",
	/* 60 */
	"I|DEC_STATE",
	"IW|SET_STATE",
	"V|SHOW_INT",
	"T|SHOW_STRING_NL",
	/* 64 */
	"T|SHOW_STRING",
	"WWWWWB|ADD_TEXT_BOX",
	"BT|SET_SHORT_TEXT",
	"BTw|SET_LONG_TEXT",
	/* 68 */
	"x|END",
	"x|DONE",
	"V|SHOW_STRING_AR3",
	"W|START_SUB",
	/* 72 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 76 */
	"WW|ADD_TIMEOUT",
	"J|IS_SUBJECT_ITEM_EMPTY",
	"J|IS_OBJECT_ITEM_EMPTY",
	"ITJ|CHILD_FR2_IS",
	/* 80 */
	"IIJ|IS_ITEM_EQ",
	NULL,
	"B|DEBUG",
	"|RESCAN",
	/* 84 */
	NULL,
	NULL,
	NULL,
	"W|COMMENT",
	/* 88 */
	"|STOP_ANIMATION",
	"|RESTART_ANIMATION",
	"IB|GET_PARENT",
	"IB|GET_NEXT",
	/* 92 */
	"IB|GET_CHILDREN",
	NULL,
	NULL,
	NULL,
	/* 96 */
	"WB|PICTURE",
	"W|LOAD_ZONE",
	"WBWWW|ANIMATE",
	"W|STOP_ANIMATE",
	/* 100 */
	"|KILL_ANIMATE",
	"BWWWWWW|DEFINE_WINDOW",
	"B|CHANGE_WINDOW",
	"|CLS",
	/* 104 */
	"B|CLOSE_WINDOW",
	NULL,
	NULL,
	"WWWWWIW|ADD_BOX",
	/* 108 */
	"W|DEL_BOX",
	"W|ENABLE_BOX",
	"W|DISABLE_BOX",
	"WWW|MOVE_BOX",
	/* 112 */
	NULL,
	NULL,
	"IB|DO_ICONS",
	"IBJ|IS_CLASS",
	/* 116 */
	"IB|SET_CLASS",
	"IB|UNSET_CLASS",
	NULL,
	"W|WAIT_SYNC",
	/* 120 */
	"W|SYNC",
	"BI|DEF_OBJ",
	NULL,
	NULL,
	/* 124 */
	NULL,
	"IJ|IS_SIBLING_WITH_A",
	"IBB|DO_CLASS_ICONS",
	"WW|PLAY_TUNE",
	/* 128 */
	NULL,
	NULL,
	"Bww|SET_ADJ_NOUN",
	NULL,
	/* 132 */
	"|SAVE_USER_GAME",
	"|LOAD_USER_GAME",
	"|STOP_TUNE",
	"|PAUSE",
	/* 136 */
	"IV|COPY_SF",
	"B|RESTORE_ICONS",
	"|FREEZE_ZONES",
	"II|SET_PARENT_SPECIAL",
	/* 140 */
	"|CLEAR_TIMERS",
	"BI|SET_M1_OR_M3",
	"WJ|IS_BOX",
	"I|START_ITEM_SUB",
	/* 144 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 148 */
	NULL,
	NULL,
	NULL,
	"BI|STORE_ITEM",
	/* 152 */
	"BB|GET_ITEM",
	"B|SET_BIT",
	"B|CLEAR_BIT",
	"BJ|IS_BIT_CLEAR",
	/* 156 */
	"BJ|IS_BIT_SET",
	"IBB|GET_ITEM_PROP",
	"IBW|SET_ITEM_PROP",
	NULL,
	/* 160 */
	"B|SET_INK",
	"BWBW|SETUP_TEXT",
	"BBTW|PRINT_STR",
	"W|PLAY_EFFECT",
	/* 164 */
	"|getDollar2",
	"IWWJ|IS_ADJ_NOUN",
	"B|SET_BIT2",
	"B|CLEAR_BIT2",
	/* 168 */
	"BJ|IS_BIT2_CLEAR",
	"BJ|IS_BIT2_SET",
	NULL,
	NULL,
	/* 172 */
	NULL,
	NULL,
	NULL,
	"|LOCK_ZONES",
	/* 176 */
	"|UNLOCK_ZONES",
	"BBI|SCREEN_TEXT_POBJ",
	"WWBB|GETPATHPOSN",
	"BBB|SCREEN_TEXT_LONG_TEXT",
	/* 180 */
	"|MOUSE_ON",
	"|MOUSE_OFF",
	"|LOAD_BEARD",
	"|UNLOAD_BEARD",
	/* 184 */
	"W|UNLOAD_ZONE",
	"W|LOAD_SOUND_FILES",
	"|UNFREEZE_ZONES",
	"|FADE_TO_BLACK",
};

static const char *const simon2dos_opcodeNameTable[256] = {
	/* 0 */
	"|NOT",
	"IJ|AT",
	"IJ|NOT_AT",
	NULL,
	/* 4 */
	NULL,
	"IJ|CARRIED",
	"IJ|NOT_CARRIED",
	"IIJ|IS_AT",
	/* 8 */
	NULL,
	NULL,
	NULL,
	"VJ|IS_ZERO",
	/* 12 */
	"VJ|ISNOT_ZERO",
	"VWJ|IS_EQ",
	"VWJ|IS_NEQ",
	"VWJ|IS_LE",
	/* 16 */
	"VWJ|IS_GE",
	"VVJ|IS_EQF",
	"VVJ|IS_NEQF",
	"VVJ|IS_LEF",
	/* 20 */
	"VVJ|IS_GEF",
	NULL,
	NULL,
	"WJ|CHANCE",
	/* 24 */
	NULL,
	"IJ|IS_ROOM",
	"IJ|IS_OBJECT",
	"IWJ|ITEM_STATE_IS",
	/* 28 */
	"IBJ|OBJECT_HAS_FLAG",
	NULL,
	NULL,
	"I|SET_NO_PARENT",
	/* 32 */
	NULL,
	"II|SET_PARENT",
	NULL,
	NULL,
	/* 36 */
	"VV|MOVE",
	NULL,
	NULL,
	NULL,
	/* 40 */
	NULL,
	"V|ZERO",
	"VW|SET",
	"VW|ADD",
	/* 44 */
	"VW|SUB",
	"VV|ADDF",
	"VV|SUBF",
	"VW|MUL",
	/* 48 */
	"VW|DIV",
	"VV|MULF",
	"VV|DIVF",
	"VW|MOD",
	/* 52 */
	"VV|MODF",
	"VW|RANDOM",
	NULL,
	"I|SET_A_PARENT",
	/* 56 */
	"IB|SET_CHILD2_BIT",
	"IB|CLEAR_CHILD2_BIT",
	"II|MAKE_SIBLING",
	"I|INC_STATE",
	/* 60 */
	"I|DEC_STATE",
	"IW|SET_STATE",
	"V|SHOW_INT",
	"T|SHOW_STRING_NL",
	/* 64 */
	"T|SHOW_STRING",
	"WWWWWB|ADD_TEXT_BOX",
	"BT|SET_SHORT_TEXT",
	"BT|SET_LONG_TEXT",
	/* 68 */
	"x|END",
	"x|DONE",
	"V|SHOW_STRING_AR3",
	"W|START_SUB",
	/* 72 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 76 */
	"WW|ADD_TIMEOUT",
	"J|IS_SUBJECT_ITEM_EMPTY",
	"J|IS_OBJECT_ITEM_EMPTY",
	"ITJ|CHILD_FR2_IS",
	/* 80 */
	"IIJ|IS_ITEM_EQ",
	NULL,
	"B|DEBUG",
	"|RESCAN",
	/* 84 */
	NULL,
	NULL,
	NULL,
	"W|COMMENT",
	/* 88 */
	"|STOP_ANIMATION",
	"|RESTART_ANIMATION",
	"IB|GET_PARENT",
	"IB|GET_NEXT",
	/* 92 */
	"IB|GET_CHILDREN",
	NULL,
	NULL,
	NULL,
	/* 96 */
	"WB|PICTURE",
	"W|LOAD_ZONE",
	"WWBWWW|ANIMATE",
	"WW|STOP_ANIMATE",
	/* 100 */
	"|KILL_ANIMATE",
	"BWWWWWW|DEFINE_WINDOW",
	"B|CHANGE_WINDOW",
	"|CLS",
	/* 104 */
	"B|CLOSE_WINDOW",
	NULL,
	NULL,
	"WWWWWIW|ADD_BOX",
	/* 108 */
	"W|DEL_BOX",
	"W|ENABLE_BOX",
	"W|DISABLE_BOX",
	"WWW|MOVE_BOX",
	/* 112 */
	NULL,
	NULL,
	"IB|DO_ICONS",
	"IBJ|IS_CLASS",
	/* 116 */
	"IB|SET_CLASS",
	"IB|UNSET_CLASS",
	NULL,
	"W|WAIT_SYNC",
	/* 120 */
	"W|SYNC",
	"BI|DEF_OBJ",
	NULL,
	NULL,
	/* 124 */
	NULL,
	"IJ|IS_SIBLING_WITH_A",
	"IBB|DO_CLASS_ICONS",
	"WWB|PLAY_TUNE",
	/* 128 */
	NULL,
	NULL,
	"Bww|SET_ADJ_NOUN",
	NULL,
	/* 132 */
	"|SAVE_USER_GAME",
	"|LOAD_USER_GAME",
	"|STOP_TUNE",
	"|PAUSE",
	/* 136 */
	"IV|COPY_SF",
	"B|RESTORE_ICONS",
	"|FREEZE_ZONES",
	"II|SET_PARENT_SPECIAL",
	/* 140 */
	"|CLEAR_TIMERS",
	"BI|SET_M1_OR_M3",
	"WJ|IS_BOX",
	"I|START_ITEM_SUB",
	/* 144 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 148 */
	NULL,
	NULL,
	NULL,
	"BI|STORE_ITEM",
	/* 152 */
	"BB|GET_ITEM",
	"B|SET_BIT",
	"B|CLEAR_BIT",
	"BJ|IS_BIT_CLEAR",
	/* 156 */
	"BJ|IS_BIT_SET",
	"IBB|GET_ITEM_PROP",
	"IBW|SET_ITEM_PROP",
	NULL,
	/* 160 */
	"B|SET_INK",
	"BWBW|SETUP_TEXT",
	"BBT|PRINT_STR",
	"W|PLAY_EFFECT",
	/* 164 */
	"|getDollar2",
	"IWWJ|IS_ADJ_NOUN",
	"B|SET_BIT2",
	"B|CLEAR_BIT2",
	/* 168 */
	"BJ|IS_BIT2_CLEAR",
	"BJ|IS_BIT2_SET",
	NULL,
	NULL,
	/* 172 */
	NULL,
	NULL,
	NULL,
	"|LOCK_ZONES",
	/* 176 */
	"|UNLOCK_ZONES",
	"BBI|SCREEN_TEXT_POBJ",
	"WWBB|GETPATHPOSN",
	"BBB|SCREEN_TEXT_LONG_TEXT",
	/* 180 */
	"|MOUSE_ON",
	"|MOUSE_OFF",
	NULL,
	NULL,
	/* 184 */
	"W|UNLOAD_ZONE",
	NULL,
	"|UNFREEZE_ZONES",
	NULL,
	/* 188 */
	"BSJ|STRING2_IS",
	"|CLEAR_MARKS",
	"B|WAIT_FOR_MARK",
};

static const char *const simon2talkie_opcodeNameTable[256] = {
	/* 0 */
	"|NOT",
	"IJ|AT",
	"IJ|NOT_AT",
	NULL,
	/* 4 */
	NULL,
	"IJ|CARRIED",
	"IJ|NOT_CARRIED",
	"IIJ|IS_AT",
	/* 8 */
	NULL,
	NULL,
	NULL,
	"VJ|IS_ZERO",
	/* 12 */
	"VJ|ISNOT_ZERO",
	"VWJ|IS_EQ",
	"VWJ|IS_NEQ",
	"VWJ|IS_LE",
	/* 16 */
	"VWJ|IS_GE",
	"VVJ|IS_EQF",
	"VVJ|IS_NEQF",
	"VVJ|IS_LEF",
	/* 20 */
	"VVJ|IS_GEF",
	NULL,
	NULL,
	"WJ|CHANCE",
	/* 24 */
	NULL,
	"IJ|IS_ROOM",
	"IJ|IS_OBJECT",
	"IWJ|ITEM_STATE_IS",
	/* 28 */
	"IBJ|OBJECT_HAS_FLAG",
	NULL,
	NULL,
	"I|SET_NO_PARENT",
	/* 32 */
	NULL,
	"II|SET_PARENT",
	NULL,
	NULL,
	/* 36 */
	"VV|MOVE",
	NULL,
	NULL,
	NULL,
	/* 40 */
	NULL,
	"V|ZERO",
	"VW|SET",
	"VW|ADD",
	/* 44 */
	"VW|SUB",
	"VV|ADDF",
	"VV|SUBF",
	"VW|MUL",
	/* 48 */
	"VW|DIV",
	"VV|MULF",
	"VV|DIVF",
	"VW|MOD",
	/* 52 */
	"VV|MODF",
	"VW|RANDOM",
	NULL,
	"I|SET_A_PARENT",
	/* 56 */
	"IB|SET_CHILD2_BIT",
	"IB|CLEAR_CHILD2_BIT",
	"II|MAKE_SIBLING",
	"I|INC_STATE",
	/* 60 */
	"I|DEC_STATE",
	"IW|SET_STATE",
	"V|SHOW_INT",
	"T|SHOW_STRING_NL",
	/* 64 */
	"T|SHOW_STRING",
	"WWWWWB|ADD_TEXT_BOX",
	"BT|SET_SHORT_TEXT",
	"BTw|SET_LONG_TEXT",
	/* 68 */
	"x|END",
	"x|DONE",
	"V|SHOW_STRING_AR3",
	"W|START_SUB",
	/* 72 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 76 */
	"WW|ADD_TIMEOUT",
	"J|IS_SUBJECT_ITEM_EMPTY",
	"J|IS_OBJECT_ITEM_EMPTY",
	"ITJ|CHILD_FR2_IS",
	/* 80 */
	"IIJ|IS_ITEM_EQ",
	NULL,
	"B|DEBUG",
	"|RESCAN",
	/* 84 */
	NULL,
	NULL,
	NULL,
	"W|COMMENT",
	/* 88 */
	"|STOP_ANIMATION",
	"|RESTART_ANIMATION",
	"IB|GET_PARENT",
	"IB|GET_NEXT",
	/* 92 */
	"IB|GET_CHILDREN",
	NULL,
	NULL,
	NULL,
	/* 96 */
	"WB|PICTURE",
	"W|LOAD_ZONE",
	"WWBWWW|ANIMATE",
	"WW|STOP_ANIMATE",
	/* 100 */
	"|KILL_ANIMATE",
	"BWWWWWW|DEFINE_WINDOW",
	"B|CHANGE_WINDOW",
	"|CLS",
	/* 104 */
	"B|CLOSE_WINDOW",
	NULL,
	NULL,
	"WWWWWIW|ADD_BOX",
	/* 108 */
	"W|DEL_BOX",
	"W|ENABLE_BOX",
	"W|DISABLE_BOX",
	"WWW|MOVE_BOX",
	/* 112 */
	NULL,
	NULL,
	"IB|DO_ICONS",
	"IBJ|IS_CLASS",
	/* 116 */
	"IB|SET_CLASS",
	"IB|UNSET_CLASS",
	NULL,
	"W|WAIT_SYNC",
	/* 120 */
	"W|SYNC",
	"BI|DEF_OBJ",
	NULL,
	NULL,
	/* 124 */
	NULL,
	"IJ|IS_SIBLING_WITH_A",
	"IBB|DO_CLASS_ICONS",
	"WWB|PLAY_TUNE",
	/* 128 */
	NULL,
	NULL,
	"Bww|SET_ADJ_NOUN",
	NULL,
	/* 132 */
	"|SAVE_USER_GAME",
	"|LOAD_USER_GAME",
	"|STOP_TUNE",
	"|PAUSE",
	/* 136 */
	"IV|COPY_SF",
	"B|RESTORE_ICONS",
	"|FREEZE_ZONES",
	"II|SET_PARENT_SPECIAL",
	/* 140 */
	"|CLEAR_TIMERS",
	"BI|SET_M1_OR_M3",
	"WJ|IS_BOX",
	"I|START_ITEM_SUB",
	/* 144 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 148 */
	NULL,
	NULL,
	NULL,
	"BI|STORE_ITEM",
	/* 152 */
	"BB|GET_ITEM",
	"B|SET_BIT",
	"B|CLEAR_BIT",
	"BJ|IS_BIT_CLEAR",
	/* 156 */
	"BJ|IS_BIT_SET",
	"IBB|GET_ITEM_PROP",
	"IBW|SET_ITEM_PROP",
	NULL,
	/* 160 */
	"B|SET_INK",
	"BWBW|SETUP_TEXT",
	"BBTW|PRINT_STR",
	"W|PLAY_EFFECT",
	/* 164 */
	"|getDollar2",
	"IWWJ|IS_ADJ_NOUN",
	"B|SET_BIT2",
	"B|CLEAR_BIT2",
	/* 168 */
	"BJ|IS_BIT2_CLEAR",
	"BJ|IS_BIT2_SET",
	NULL,
	NULL,
	/* 172 */
	NULL,
	NULL,
	NULL,
	"|LOCK_ZONES",
	/* 176 */
	"|UNLOCK_ZONES",
	"BBI|SCREEN_TEXT_POBJ",
	"WWBB|GETPATHPOSN",
	"BBB|SCREEN_TEXT_LONG_TEXT",
	/* 180 */
	"|MOUSE_ON",
	"|MOUSE_OFF",
	NULL,
	NULL,
	/* 184 */
	"W|UNLOAD_ZONE",
	NULL,
	"|UNFREEZE_ZONES",
	NULL,
	/* 188 */
	"BSJ|STRING2_IS",
	"|CLEAR_MARKS",
	"B|WAIT_FOR_MARK",
};

static const char *const feeblefiles_opcodeNameTable[256] = {
	/* 0 */
	"|NOT",
	"IJ|AT",
	"IJ|NOT_AT",
	NULL,
	/* 4 */
	NULL,
	"IJ|CARRIED",
	"IJ|NOT_CARRIED",
	"IIJ|IS_AT",
	/* 8 */
	NULL,
	NULL,
	NULL,
	"VJ|IS_ZERO",
	/* 12 */
	"VJ|ISNOT_ZERO",
	"VWJ|IS_EQ",
	"VWJ|IS_NEQ",
	"VWJ|IS_LE",
	/* 16 */
	"VWJ|IS_GE",
	"VVJ|IS_EQF",
	"VVJ|IS_NEQF",
	"VVJ|IS_LEF",
	/* 20 */
	"VVJ|IS_GEF",
	NULL,
	NULL,
	"WJ|CHANCE",
	/* 24 */
	NULL,
	"IJ|IS_ROOM",
	"IJ|IS_OBJECT",
	"IWJ|ITEM_STATE_IS",
	/* 28 */
	"IBJ|OBJECT_HAS_FLAG",
	NULL,
	NULL,
	"I|SET_NO_PARENT",
	/* 32 */
	NULL,
	"II|SET_PARENT",
	NULL,
	NULL,
	/* 36 */
	"VV|MOVE",
	"B|JUMP_OUT",
	NULL,
	NULL,
	/* 40 */
	NULL,
	"V|ZERO",
	"VW|SET",
	"VW|ADD",
	/* 44 */
	"VW|SUB",
	"VV|ADDF",
	"VV|SUBF",
	"VW|MUL",
	/* 48 */
	"VW|DIV",
	"VV|MULF",
	"VV|DIVF",
	"VW|MOD",
	/* 52 */
	"VV|MODF",
	"VW|RANDOM",
	NULL,
	"I|SET_A_PARENT",
	/* 56 */
	"IB|SET_CHILD2_BIT",
	"IB|CLEAR_CHILD2_BIT",
	"II|MAKE_SIBLING",
	"I|INC_STATE",
	/* 60 */
	"I|DEC_STATE",
	"IW|SET_STATE",
	"V|SHOW_INT",
	"T|SHOW_STRING_NL",
	/* 64 */
	"T|SHOW_STRING",
	"WWWWWB|ADD_TEXT_BOX",
	"BT|SET_SHORT_TEXT",
	"BTw|SET_LONG_TEXT",
	/* 68 */
	"x|END",
	"x|DONE",
	"V|SHOW_STRING_AR3",
	"W|START_SUB",
	/* 72 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 76 */
	"WW|ADD_TIMEOUT",
	"J|IS_SUBJECT_ITEM_EMPTY",
	"J|IS_OBJECT_ITEM_EMPTY",
	"ITJ|CHILD_FR2_IS",
	/* 80 */
	"IIJ|IS_ITEM_EQ",
	NULL,
	"B|DEBUG",
	"|RESCAN",
	/* 84 */
	NULL,
	NULL,
	NULL,
	"W|COMMENT",
	/* 88 */
	"|STOP_ANIMATION",
	"|RESTART_ANIMATION",
	"IB|GET_PARENT",
	"IB|GET_NEXT",
	/* 92 */
	"IB|GET_CHILDREN",
	NULL,
	NULL,
	NULL,
	/* 96 */
	"WB|PICTURE",
	"W|LOAD_ZONE",
	"WWBWWW|ANIMATE",
	"WW|STOP_ANIMATE",
	/* 100 */
	"|KILL_ANIMATE",
	"BWWWWWW|DEFINE_WINDOW",
	"B|CHANGE_WINDOW",
	"|CLS",
	/* 104 */
	"B|CLOSE_WINDOW",
	NULL,
	NULL,
	"WWWWWIW|ADD_BOX",
	/* 108 */
	"W|DEL_BOX",
	"W|ENABLE_BOX",
	"W|DISABLE_BOX",
	"WWW|MOVE_BOX",
	/* 112 */
	NULL,
	NULL,
	"IB|DO_ICONS",
	"IBJ|IS_CLASS",
	/* 116 */
	"IB|SET_CLASS",
	"IB|UNSET_CLASS",
	NULL,
	"W|WAIT_SYNC",
	/* 120 */
	"W|SYNC",
	"BI|DEF_OBJ",
	"|ORACLE_TEXT_DOWN",
	"|ORACLE_TEXT_UP",
	/* 124 */
	"WJ|IF_TIME",
	"IJ|IS_SIBLING_WITH_A",
	"IBB|DO_CLASS_ICONS",
	NULL,
	/* 128 */
	NULL,
	NULL,
	"Bww|SET_ADJ_NOUN",
	"|SET_TIME",
	/* 132 */
	"|SAVE_USER_GAME",
	"|LOAD_USER_GAME",
	"|LIST_SAVED_GAMES",
	"|SWITCH_CD",
	/* 136 */
	"IV|COPY_SF",
	"B|RESTORE_ICONS",
	"|FREEZE_ZONES",
	"II|SET_PARENT_SPECIAL",
	/* 140 */
	"|CLEAR_TIMERS",
	"BI|SET_M1_OR_M3",
	"WJ|IS_BOX",
	"I|START_ITEM_SUB",
	/* 144 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 148 */
	NULL,
	NULL,
	NULL,
	"BI|STORE_ITEM",
	/* 152 */
	"BB|GET_ITEM",
	"B|SET_BIT",
	"B|CLEAR_BIT",
	"BJ|IS_BIT_CLEAR",
	/* 156 */
	"BJ|IS_BIT_SET",
	"IBB|GET_ITEM_PROP",
	"IBW|SET_ITEM_PROP",
	NULL,
	/* 160 */
	"B|SET_INK",
	"BWWW|SETUP_TEXT",
	"BBTW|PRINT_STR",
	"W|PLAY_EFFECT",
	/* 164 */
	"|getDollar2",
	"IWWJ|IS_ADJ_NOUN",
	"B|SET_BIT2",
	"B|CLEAR_BIT2",
	/* 168 */
	"BJ|IS_BIT2_CLEAR",
	"BJ|IS_BIT2_SET",
	NULL,
	"W|HYPERLINK_ON",
	/* 172 */
	"|HYPERLINK_OFF",
	"|CHECK_PATHS",
	NULL,
	"|LOCK_ZONES",
	/* 176 */
	"|UNLOCK_ZONES",
	"BBI|SCREEN_TEXT_POBJ",
	"WWBB|GETPATHPOSN",
	"BBB|SCREEN_TEXT_LONG_TEXT",
	/* 180 */
	"|MOUSE_ON",
	"|MOUSE_OFF",
	"T|LOAD_VIDEO",
	"|PLAY_VIDEO",
	/* 184 */
	"W|UNLOAD_ZONE",
	NULL,
	"|UNFREEZE_ZONES",
	"|CENTER_SCROLL",
	/* 188 */
	"BSJ|STRING2_IS",
	"|CLEAR_MARKS",
	"B|WAIT_FOR_MARK",
	"|RESET_PV_COUNT",
	/* 192 */
	"BBBB|SET_PATH_VALUES",
	"|STOP_CLOCK",
	"|RESTART_CLOCK",
	"BBBB|SET_COLOR",
	/* 196 */
	"B|B3_SET",
	"B|B3_CLEAR",
	"B|B3_ZERO",
	"B|B3_NOT_ZERO",
};

static const char *const puzzlepack_opcodeNameTable[256] = {
	/* 0 */
	"|NOT",
	"IJ|AT",
	"IJ|NOT_AT",
	NULL,
	/* 4 */
	NULL,
	"IJ|CARRIED",
	"IJ|NOT_CARRIED",
	"IIJ|IS_AT",
	/* 8 */
	NULL,
	NULL,
	NULL,
	"WJ|IS_ZERO",
	/* 12 */
	"WJ|ISNOT_ZERO",
	"WWJ|IS_EQ",
	"WWJ|IS_NEQ",
	"WWJ|IS_LE",
	/* 16 */
	"WWJ|IS_GE",
	"WWJ|IS_EQF",
	"WWJ|IS_NEQF",
	"WWJ|IS_LEF",
	/* 20 */
	"WWJ|IS_GEF",
	NULL,
	NULL,
	"WJ|CHANCE",
	/* 24 */
	NULL,
	"IJ|IS_ROOM",
	"IJ|IS_OBJECT",
	"IWJ|ITEM_STATE_IS",
	/* 28 */
	"IBJ|OBJECT_HAS_FLAG",
	NULL,
	"I|MINIMIZE_WINDOW",
	"I|SET_NO_PARENT",
	/* 32 */
	"I|RESTORE_OOOPS_POSITION",
	"II|SET_PARENT",
	NULL,
	NULL,
	/* 36 */
	"WW|MOVE",
	"B|CHECK_TILES",
	"IB|LOAD_MOUSE_IMAGE",
	NULL,
	/* 40 */
	NULL,
	"W|ZERO",
	"WW|SET",
	"WW|ADD",
	/* 44 */
	"WW|SUB",
	"WW|ADDF",
	"WW|SUBF",
	"WW|MUL",
	/* 48 */
	"WW|DIV",
	"WW|MULF",
	"WW|DIVF",
	"WW|MOD",
	/* 52 */
	"WW|MODF",
	"WW|RANDOM",
	NULL,
	"I|SET_A_PARENT",
	/* 56 */
	"IB|SET_CHILD2_BIT",
	"IB|CLEAR_CHILD2_BIT",
	"II|MAKE_SIBLING",
	"I|INC_STATE",
	/* 60 */
	"I|DEC_STATE",
	"IW|SET_STATE",
	"W|SHOW_INT",
	"T|SHOW_STRING_NL",
	/* 64 */
	"T|SHOW_STRING",
	"WWWWWB|ADD_TEXT_BOX",
	"BTWW|SET_SHORT_TEXT",
	"BTw|SET_LONG_TEXT",
	/* 68 */
	"x|END",
	"x|DONE",
	"V|SHOW_STRING_AR3",
	"W|START_SUB",
	/* 72 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 76 */
	"WW|ADD_TIMEOUT",
	"J|IS_SUBJECT_ITEM_EMPTY",
	"J|IS_OBJECT_ITEM_EMPTY",
	"ITJ|CHILD_FR2_IS",
	/* 80 */
	"IIJ|IS_ITEM_EQ",
	NULL,
	"B|DEBUG",
	"|RESCAN",
	/* 84 */
	NULL,
	NULL,
	NULL,
	"W|COMMENT",
	/* 88 */
	"|STOP_ANIMATION",
	"|RESTART_ANIMATION",
	"IB|GET_PARENT",
	"IB|GET_NEXT",
	/* 92 */
	"IB|GET_CHILDREN",
	NULL,
	NULL,
	NULL,
	/* 96 */
	"WB|PICTURE",
	"W|LOAD_ZONE",
	"WWBWWW|ANIMATE",
	"WW|STOP_ANIMATE",
	/* 100 */
	"|KILL_ANIMATE",
	"BWWWWWW|DEFINE_WINDOW",
	"B|CHANGE_WINDOW",
	"|CLS",
	/* 104 */
	"B|CLOSE_WINDOW",
	"B|LOAD_HIGH_SCORES",
	"BB|CHECK_HIGH_SCORES",
	"WWWWWIW|ADD_BOX",
	/* 108 */
	"W|DEL_BOX",
	"W|ENABLE_BOX",
	"W|DISABLE_BOX",
	"WWW|MOVE_BOX",
	/* 112 */
	NULL,
	NULL,
	"IB|DO_ICONS",
	"IBJ|IS_CLASS",
	/* 116 */
	"IB|SET_CLASS",
	"IB|UNSET_CLASS",
	NULL,
	"W|WAIT_SYNC",
	/* 120 */
	"W|SYNC",
	"BI|DEF_OBJ",
	"|ORACLE_TEXT_DOWN",
	"|ORACLE_TEXT_UP",
	/* 124 */
	"WJ|IF_TIME",
	"IJ|IS_SIBLING_WITH_A",
	"IBB|DO_CLASS_ICONS",
	NULL,
	/* 128 */
	NULL,
	NULL,
	"Bww|SET_ADJ_NOUN",
	"|SET_TIME",
	/* 132 */
	"|SAVE_USER_GAME",
	"|LOAD_USER_GAME",
	"|LIST_SAVED_GAMES",
	"|SWITCH_CD",
	/* 136 */
	"IV|COPY_SF",
	"B|RESTORE_ICONS",
	"|FREEZE_ZONES",
	"II|SET_PARENT_SPECIAL",
	/* 140 */
	"|CLEAR_TIMERS",
	"BI|SET_M1_OR_M3",
	"WJ|IS_BOX",
	"I|START_ITEM_SUB",
	/* 144 */
	NULL,
	NULL,
	NULL,
	NULL,
	/* 148 */
	NULL,
	NULL,
	NULL,
	"BI|STORE_ITEM",
	/* 152 */
	"BB|GET_ITEM",
	"W|SET_BIT",
	"W|CLEAR_BIT",
	"WJ|IS_BIT_CLEAR",
	/* 156 */
	"WJ|IS_BIT_SET",
	"IBB|GET_ITEM_PROP",
	"IBW|SET_ITEM_PROP",
	NULL,
	/* 160 */
	"B|SET_INK",
	"BWWW|SETUP_TEXT",
	"BBTW|PRINT_STR",
	"W|PLAY_EFFECT",
	/* 164 */
	"|getDollar2",
	"IWWJ|IS_ADJ_NOUN",
	"B|SET_BIT2",
	"B|CLEAR_BIT2",
	/* 168 */
	"BJ|IS_BIT2_CLEAR",
	"BJ|IS_BIT2_SET",
	NULL,
	"W|HYPERLINK_ON",
	/* 172 */
	"|HYPERLINK_OFF",
	"|SAVE_OOPS_POSITION",
	NULL,
	"|LOCK_ZONES",
	/* 176 */
	"|UNLOCK_ZONES",
	"BBI|SCREEN_TEXT_POBJ",
	"WWBB|GETPATHPOSN",
	"BBB|SCREEN_TEXT_LONG_TEXT",
	/* 180 */
	"|MOUSE_ON",
	"|MOUSE_OFF",
	"T|LOAD_VIDEO",
	"|PLAY_VIDEO",
	/* 184 */
	"W|UNLOAD_ZONE",
	NULL,
	"|UNFREEZE_ZONES",
	"|RESET_GAME_TIME",
	/* 188 */
	"BSJ|STRING2_IS",
	"|CLEAR_MARKS",
	"B|WAIT_FOR_MARK",
	"|RESET_PV_COUNT",
	/* 192 */
	"BBBB|SET_PATH_VALUES",
	"|STOP_CLOCK",
	"|RESTART_CLOCK",
	"BBBB|SET_COLOR",
};

const char *const pn_videoOpcodeNameTable[] = {
	/* 0 */
	"x|RET",
	"ddd|FADEOUT",
	"d|CALL",
	"ddddd|NEW_SPRITE",
	/* 4 */
	"ddd|FADEIN",
	"vdj|IF_EQUAL",
	"dj|IF_OBJECT_HERE",
	"dj|IF_OBJECT_NOT_HERE",
	/* 8 */
	"ddj|IF_OBJECT_IS_AT",
	"ddj|IF_OBJECT_STATE_IS",
	"dddd|DRAW",
	"d|ON_STOP",
	/* 12 */
	"|TEST_STOP",
	"d|DELAY",
	"d|SET_SPRITE_OFFSET_X",
	"d|SET_SPRITE_OFFSET_Y",
	/* 16 */
	"|SYNC",
	"d|WAIT_SYNC",
	"d|WAIT_END",
	"i|JUMP_REL",
	/* 20 */
	"|CHAIN_TO",
	"dd|SET_REPEAT",
	"i|END_REPEAT",
	"d|SET_PALETTE",
	/* 24 */
	"d|SET_PRIORITY",
	"diid|SET_SPRITE_XY",
	"x|HALT_SPRITE",
	"ddddd|SET_WINDOW",
	/* 28 */
	"|RESET",
	"dddd|PLAY_SOUND",
	"|STOP_ALL_SOUNDS",
	"d|SET_FRAME_RATE",
	/* 32 */
	"d|SET_WINDOW",
	"|SAVE_SCREEN",
	"|MOUSE_ON",
	"|MOUSE_OFF",
	/* 36 */
	"|PAUSE",
	"d|VC_37",
	"dd|CLEAR_WINDOW",
	"d|SET_VOLUME",
	/* 40 */
	"dd|SET_WINDOW_IMAGE",
	"dd|POKE_PALETTE",
	"|VC_42",
	"|VC_43",
	/* 44 */
	"d|ENABLE_BOX",
	"d|DISABLE_BOX",
	"d|MAX_BOX",
	"dd|VC_47",
	/* 48 */
	"dd|SPEC_EFFECT",
	"|VC_49",
	"ddddddddd|SET_BOX",
	"v|IF_VAR_NOT_ZERO",
	/* 52 */
	"vd|SET_VAR",
	"vd|ADD_VAR",
	"vd|SUB_VAR",
	"|SCAN_FLAGS",
};

const char *const elvira1_videoOpcodeNameTable[] = {
	/* 0 */
	"x|RET",
	"ddd|FADEOUT",
	"d|CALL",
	"ddddd|NEW_SPRITE",
	/* 4 */
	"ddd|FADEIN",
	"vdj|IF_EQUAL",
	"dj|IF_OBJECT_HERE",
	"dj|IF_OBJECT_NOT_HERE",
	/* 8 */
	"ddj|IF_OBJECT_IS_AT",
	"ddj|IF_OBJECT_STATE_IS",
	"dddd|DRAW",
	"d|ON_STOP",
	/* 12 */
	"|TEST_STOP",
	"d|DELAY",
	"d|SET_SPRITE_OFFSET_X",
	"d|SET_SPRITE_OFFSET_Y",
	/* 16 */
	"d|SYNC",
	"d|WAIT_SYNC",
	"d|WAIT_END",
	"i|JUMP_REL",
	/* 20 */
	"|CHAIN_TO",
	"dd|SET_REPEAT",
	"i|END_REPEAT",
	"d|SET_PALETTE",
	/* 24 */
	"d|SET_PRIORITY",
	"diid|SET_SPRITE_XY",
	"x|HALT_SPRITE",
	"ddddd|SET_WINDOW",
	/* 28 */
	"|RESET",
	"dddd|PLAY_SOUND",
	"|STOP_ALL_SOUNDS",
	"d|SET_FRAME_RATE",
	/* 32 */
	"d|SET_WINDOW",
	"|SAVE_SCREEN",
	"|MOUSE_ON",
	"|MOUSE_OFF",
	/* 36 */
	"|VC_36",
	"d|VC_37",
	"dd|CLEAR_WINDOW",
	"d|VC_39",
	/* 40 */
	"dd|SET_WINDOW_IMAGE",
	"dd|POKE_PALETTE",
	"|VC_42",
	"|VC_43",
	/* 44 */
	"d|VC_44",
	"d|VC_45",
	"d|VC_46",
	"dd|VC_47",
	/* 48 */
	"dd|VC_48",
	"|VC_49",
	"ddddddddd|VC_50",
	"v|IF_VAR_NOT_ZERO",
	/* 52 */
	"vd|SET_VAR",
	"vd|ADD_VAR",
	"vd|SUB_VAR",
	"|VC_55",
	"dd|DELAY_IF_NOT_EQ",
};

const char *const elvira2_videoOpcodeNameTable[] = {
	/* 0 */
	"x|RET",
	"ddd|FADEOUT",
	"d|CALL",
	"ddddd|NEW_SPRITE",
	/* 4 */
	"ddd|FADEIN",
	"vdj|IF_EQUAL",
	"dj|IF_OBJECT_HERE",
	"dj|IF_OBJECT_NOT_HERE",
	/* 8 */
	"ddj|IF_OBJECT_IS_AT",
	"ddj|IF_OBJECT_STATE_IS",
	"dddd|DRAW",
	"d|ON_STOP",
	/* 12 */
	"w|DELAY",
	"d|SET_SPRITE_OFFSET_X",
	"d|SET_SPRITE_OFFSET_Y",
	"d|SYNC",
	/* 16 */
	"d|WAIT_SYNC",
	"d|WAIT_END",
	"i|JUMP_REL",
	"|CHAIN_TO",
	/* 20 */
	"dd|SET_REPEAT",
	"i|END_REPEAT",
	"d|SET_PALETTE",
	"d|SET_PRIORITY",
	/* 24 */
	"diid|SET_SPRITE_XY",
	"x|HALT_SPRITE",
	"ddddd|SET_WINDOW",
	"|RESET",
	/* 28 */
	"dddd|PLAY_SOUND",
	"|STOP_ALL_SOUNDS",
	"d|SET_FRAME_RATE",
	"d|SET_WINDOW",
	/* 32 */
	"|SAVE_SCREEN",
	"|MOUSE_ON",
	"|MOUSE_OFF",
	"dd|CLEAR_WINDOW",
	/* 36 */
	"dd|SET_WINDOW_IMAGE",
	"dd|POKE_PALETTE",
	"vj|IF_VAR_NOT_ZERO",
	"vd|SET_VAR",
	/* 40 */
	"vd|ADD_VAR",
	"vd|SUB_VAR",
	"vd|DELAY_IF_NOT_EQ",
	"dj|IF_BIT_SET",
	/* 44 */
	"dj|IF_BIT_CLEAR",
	"dd|SET_WINDOW_PALETTE",
	"d|SET_PALETTE_SLOT1",
	"d|SET_PALETTE_SLOT2",
	/* 48 */
	"d|SET_PALETTE_SLOT3",
	"d|SET_BIT",
	"d|CLEAR_BIT",
	"d|ENABLE_BOX",
	/* 52 */
	"d|PLAY_EFFECT",
	"dd|DISSOLVE_IN",
	"ddd|DISSOLVE_OUT",
	"ddd|MOVE_BOX",
	/* 56 */
	"|FULL_SCREEN",
	"|BLACK_PALETTE",
	"|CHECK_CODE_WHEEL",
	"j|IF_EGA",
	/* 60 */
	"d|STOP_ANIMATE",
	"d|INTRO",
	"|FASTFADEOUT",
	"|FASTFADEIN",
};

const char *const ww_videoOpcodeNameTable[] = {
	/* 0 */
	"x|RET",
	"ddd|FADEOUT",
	"w|CALL",
	"ddddd|NEW_SPRITE",
	/* 4 */
	"ddd|FADEIN",
	"vdj|IF_EQUAL",
	"dj|IF_OBJECT_HERE",
	"dj|IF_OBJECT_NOT_HERE",
	/* 8 */
	"ddj|IF_OBJECT_IS_AT",
	"ddj|IF_OBJECT_STATE_IS",
	"dddd|DRAW",
	"d|ON_STOP",
	/* 12 */
	"w|DELAY",
	"d|SET_SPRITE_OFFSET_X",
	"d|SET_SPRITE_OFFSET_Y",
	"d|SYNC",
	/* 16 */
	"d|WAIT_SYNC",
	"d|WAIT_END",
	"i|JUMP_REL",
	"|CHAIN_TO",
	/* 20 */
	"dd|SET_REPEAT",
	"i|END_REPEAT",
	"d|SET_PALETTE",
	"d|SET_PRIORITY",
	/* 24 */
	"wiid|SET_SPRITE_XY",
	"x|HALT_SPRITE",
	"ddddd|SET_WINDOW",
	"|RESET",
	/* 28 */
	"dddd|PLAY_SOUND",
	"|STOP_ALL_SOUNDS",
	"d|SET_FRAME_RATE",
	"d|SET_WINDOW",
	/* 32 */
	"|SAVE_SCREEN",
	"|MOUSE_ON",
	"|MOUSE_OFF",
	"dd|CLEAR_WINDOW",
	/* 36 */
	"dd|SET_WINDOW_IMAGE",
	"dd|POKE_PALETTE",
	"vj|IF_VAR_NOT_ZERO",
	"vd|SET_VAR",
	/* 40 */
	"vd|ADD_VAR",
	"vd|SUB_VAR",
	"vd|DELAY_IF_NOT_EQ",
	"dj|IF_BIT_SET",
	/* 44 */
	"dj|IF_BIT_CLEAR",
	"dd|SET_WINDOW_PALETTE",
	"d|SET_PALETTE_SLOT1",
	"d|SET_PALETTE_SLOT2",
	/* 48 */
	"d|SET_PALETTE_SLOT3",
	"d|SET_BIT",
	"d|CLEAR_BIT",
	"d|ENABLE_BOX",
	/* 52 */
	"d|PLAY_EFFECT",
	"dd|DISSOLVE_IN",
	"ddd|DISSOLVE_OUT",
	"ddd|MOVE_BOX",
	/* 56 */
	"|FULL_SCREEN",
	"|BLACK_PALETTE",
	"|CHECK_CODE_WHEEL",
	"j|IF_EGA",
	/* 60 */
	"d|STOP_ANIMATE",
	"d|INTRO",
	"|FASTFADEOUT",
	"|FASTFADEIN",
};

const char *const simon1_videoOpcodeNameTable[] = {
	/* 0 */
	"x|RET",
	"ddd|FADEOUT",
	"w|CALL",
	"ddddd|NEW_SPRITE",
	/* 4 */
	"ddd|FADEIN",
	"vdj|IF_EQUAL",
	"dj|IF_OBJECT_HERE",
	"dj|IF_OBJECT_NOT_HERE",
	/* 8 */
	"ddj|IF_OBJECT_IS_AT",
	"ddj|IF_OBJECT_STATE_IS",
	"ddddd|DRAW",
	"|CLEAR_PATHFIND_ARRAY",
	/* 12 */
	"w|DELAY",
	"d|SET_SPRITE_OFFSET_X",
	"d|SET_SPRITE_OFFSET_Y",
	"d|SYNC",
	/* 16 */
	"d|WAIT_SYNC",
	"dq|SET_PATHFIND_ITEM",
	"i|JUMP_REL",
	"|CHAIN_TO",
	/* 20 */
	"dd|SET_REPEAT",
	"i|END_REPEAT",
	"dd|SET_PALETTE",
	"d|SET_PRIORITY",
	/* 24 */
	"wiid|SET_SPRITE_XY",
	"x|HALT_SPRITE",
	"ddddd|SET_WINDOW",
	"|RESET",
	/* 28 */
	"dddd|PLAY_SOUND",
	"|STOP_ALL_SOUNDS",
	"d|SET_FRAME_RATE",
	"d|SET_WINDOW",
	/* 32 */
	"vv|COPY_VAR",
	"|MOUSE_ON",
	"|MOUSE_OFF",
	"dd|CLEAR_WINDOW",
	/* 36 */
	"dd|SET_WINDOW_IMAGE",
	"v|SET_SPRITE_OFFSET_Y",
	"vj|IF_VAR_NOT_ZERO",
	"vd|SET_VAR",
	/* 40 */
	"vd|ADD_VAR",
	"vd|SUB_VAR",
	"vd|DELAY_IF_NOT_EQ",
	"dj|IF_BIT_SET",
	/* 44 */
	"dj|IF_BIT_CLEAR",
	"v|SET_SPRITE_X",
	"v|SET_SPRITE_Y",
	"vv|ADD_VAR_F",
	/* 48 */
	"|COMPUTE_YOFS",
	"d|SET_BIT",
	"d|CLEAR_BIT",
	"d|ENABLE_BOX",
	/* 52 */
	"d|PLAY_EFFECT",
	"dd|DUMMY_53",
	"ddd|DUMMY_54",
	"ddd|MOVE_BOX",
	/* 56 */
	"|DUMMY_56",
	"|BLACK_PALETTE",
	"|DUMMY_58",
	"j|IF_SPEECH",
	/* 60 */
	"d|STOP_ANIMATE",
	"wdd|MASK",
	"|FASTFADEOUT",
	"|FASTFADEIN",
};

const char *const simon2_videoOpcodeNameTable[] = {
	/* 0 */
	"x|RET",
	"ddd|FADEOUT",
	"w|CALL",
	"dddddd|NEW_SPRITE",
	/* 4 */
	"ddd|FADEIN",
	"vdj|IF_EQUAL",
	"dj|IF_OBJECT_HERE",
	"dj|IF_OBJECT_NOT_HERE",
	/* 8 */
	"ddj|IF_OBJECT_IS_AT",
	"ddj|IF_OBJECT_STATE_IS",
	"ddddb|DRAW",
	"|CLEAR_PATHFIND_ARRAY",
	/* 12 */
	"b|DELAY",
	"d|SET_SPRITE_OFFSET_X",
	"d|SET_SPRITE_OFFSET_Y",
	"d|SYNC",
	/* 16 */
	"d|WAIT_SYNC",
	"dq|SET_PATHFIND_ITEM",
	"i|JUMP_REL",
	"|CHAIN_TO",
	/* 20 */
	"dd|SET_REPEAT",
	"i|END_REPEAT",
	"dd|SET_PALETTE",
	"d|SET_PRIORITY",
	/* 24 */
	"wiib|SET_SPRITE_XY",
	"x|HALT_SPRITE",
	"ddddd|SET_WINDOW",
	"|RESET",
	/* 28 */
	"dddd|PLAY_SOUND",
	"|STOP_ALL_SOUNDS",
	"d|SET_FRAME_RATE",
	"d|SET_WINDOW",
	/* 32 */
	"vv|COPY_VAR",
	"|MOUSE_ON",
	"|MOUSE_OFF",
	"dd|CLEAR_WINDOW",
	/* 36 */
	"dd|SET_WINDOW_IMAGE",
	"v|SET_SPRITE_OFFSET_Y",
	"vj|IF_VAR_NOT_ZERO",
	"vd|SET_VAR",
	/* 40 */
	"vd|ADD_VAR",
	"vd|SUB_VAR",
	"vd|DELAY_IF_NOT_EQ",
	"dj|IF_BIT_SET",
	/* 44 */
	"dj|IF_BIT_CLEAR",
	"v|SET_SPRITE_X",
	"v|SET_SPRITE_Y",
	"vv|ADD_VAR_F",
	/* 48 */
	"|COMPUTE_YOFS",
	"d|SET_BIT",
	"d|CLEAR_BIT",
	"d|ENABLE_BOX",
	/* 52 */
	"d|PLAY_EFFECT",
	"dd|DUMMY_53",
	"ddd|DUMMY_54",
	"ddd|MOVE_BOX",
	/* 56 */
	"w|WAIT_BIG",
	"|BLACK_PALETTE",
	"ddd|SET_PRIORITIES",
	"ddd|STOP_ANIMATIONS",
	/* 60 */
	"dd|STOP_ANIMATE",
	"wdd|MASK",
	"|FASTFADEOUT",
	"|FASTFADEIN",
	/* 64 */
	"j|IF_SPEECH",
	"|SLOW_FADE_IN",
	"ddj|IF_VAR_EQUAL",
	"ddj|IF_VAR_LE",
	/* 68 */
	"ddj|IF_VAR_GE",
	"dd|PLAY_SEQ",
	"dd|JOIN_SEQ",
	"j|IF_SEQ_WAITING",
	/* 72 */
	"dd|SEQUE",
	"bb|SET_MARK",
	"bb|CLEAR_MARK",
};

const char *const feeblefiles_videoOpcodeNameTable[] = {
	/* 0 */
	"x|RET",
	"ddd|FADEOUT",
	"w|CALL",
	"dddddd|NEW_SPRITE",
	/* 4 */
	"ddd|FADEIN",
	"vdj|IF_EQUAL",
	"dj|IF_OBJECT_HERE",
	"dj|IF_OBJECT_NOT_HERE",
	/* 8 */
	"ddj|IF_OBJECT_IS_AT",
	"ddj|IF_OBJECT_STATE_IS",
	"ddddb|DRAW",
	"|CLEAR_PATHFIND_ARRAY",
	/* 12 */
	"b|DELAY",
	"d|SET_SPRITE_OFFSET_X",
	"d|SET_SPRITE_OFFSET_Y",
	"d|SYNC",
	/* 16 */
	"d|WAIT_SYNC",
	"dq|SET_PATHFIND_ITEM",
	"i|JUMP_REL",
	"|CHAIN_TO",
	/* 20 */
	"dd|SET_REPEAT",
	"i|END_REPEAT",
	"dd|SET_PALETTE",
	"d|SET_PRIORITY",
	/* 24 */
	"wiib|SET_SPRITE_XY",
	"x|HALT_SPRITE",
	"ddddd|SET_WINDOW",
	"|RESET",
	/* 28 */
	"dddd|PLAY_SOUND",
	"|STOP_ALL_SOUNDS",
	"d|SET_FRAME_RATE",
	"d|SET_WINDOW",
	/* 32 */
	"vv|COPY_VAR",
	"|MOUSE_ON",
	"|MOUSE_OFF",
	"dd|CLEAR_WINDOW",
	/* 36 */
	"dd|SET_WINDOW_IMAGE",
	"v|SET_SPRITE_OFFSET_Y",
	"vj|IF_VAR_NOT_ZERO",
	"vd|SET_VAR",
	/* 40 */
	"vd|ADD_VAR",
	"vd|SUB_VAR",
	"vd|DELAY_IF_NOT_EQ",
	"dj|IF_BIT_SET",
	/* 44 */
	"dj|IF_BIT_CLEAR",
	"v|SET_SPRITE_X",
	"v|SET_SPRITE_Y",
	"vv|ADD_VAR_F",
	/* 48 */
	"|COMPUTE_YOFS",
	"d|SET_BIT",
	"d|CLEAR_BIT",
	"d|ENABLE_BOX",
	/* 52 */
	"ddd|PLAY_EFFECT",
	"ddd|PAN_SFX",
	"ddd|DUMMY_54",
	"ddd|MOVE_BOX",
	/* 56 */
	"w|WAIT_BIG",
	"|BLACK_PALETTE",
	"ddd|SET_PRIORITIES",
	"ddd|STOP_ANIMATIONS",
	/* 60 */
	"dd|STOP_ANIMATE",
	"wdd|MASK",
	"|FASTFADEOUT",
	"|FASTFADEIN",
	/* 64 */
	"j|IF_SPEECH",
	"|SLOW_FADE_IN",
	"ddj|IF_VAR_EQUAL",
	"ddj|IF_VAR_LE",
	/* 68 */
	"ddj|IF_VAR_GE",
	"dd|PLAY_SEQ",
	"dd|JOIN_SEQ",
	"|IF_SEQ_WAITING",
	/* 72 */
	"dd|SEQUE",
	"bb|SET_MARK",
	"bb|CLEAR_MARK",
	"dd|SETSCALE",
	/* 76 */
	"ddd|SETSCALEXOFFS",
	"ddd|SETSCALEYOFFS",
	"|COMPUTEXY",
	"|COMPUTEPOSNUM",
	/* 80 */
	"wdd|SETOVERLAYIMAGE",
	"dd|SETRANDOM",
	"d|GETPATHVALUE",
	"ddd|PLAYSOUNDLOOP",
	"|STOPSOUNDLOOP",
};

const char *const puzzlepack_videoOpcodeNameTable[] = {
	/* 0 */
	"x|RET",
	"ddd|FADEOUT",
	"w|CALL",
	"dddddd|NEW_SPRITE",
	/* 4 */
	"ddd|FADEIN",
	"wdj|IF_EQUAL",
	"dj|IF_OBJECT_HERE",
	"dj|IF_OBJECT_NOT_HERE",
	/* 8 */
	"ddj|IF_OBJECT_IS_AT",
	"ddj|IF_OBJECT_STATE_IS",
	"ddddb|DRAW",
	"|CLEAR_PATHFIND_ARRAY",
	/* 12 */
	"b|DELAY",
	"d|SET_SPRITE_OFFSET_X",
	"d|SET_SPRITE_OFFSET_Y",
	"d|SYNC",
	/* 16 */
	"d|WAIT_SYNC",
	"dq|SET_PATHFIND_ITEM",
	"i|JUMP_REL",
	"|CHAIN_TO",
	/* 20 */
	"dd|SET_REPEAT",
	"i|END_REPEAT",
	"dd|SET_PALETTE",
	"d|SET_PRIORITY",
	/* 24 */
	"wiib|SET_SPRITE_XY",
	"x|HALT_SPRITE",
	"ddddd|SET_WINDOW",
	"|RESET",
	/* 28 */
	"dddd|PLAY_SOUND",
	"|STOP_ALL_SOUNDS",
	"d|SET_FRAME_RATE",
	"d|SET_WINDOW",
	/* 32 */
	"vv|COPY_VAR",
	"|MOUSE_ON",
	"|MOUSE_OFF",
	"dd|CLEAR_WINDOW",
	/* 36 */
	"dd|SET_WINDOW_IMAGE",
	"v|SET_SPRITE_OFFSET_Y",
	"wj|IF_VAR_NOT_ZERO",
	"wd|SET_VAR",
	/* 40 */
	"vd|ADD_VAR",
	"vd|SUB_VAR",
	"vd|DELAY_IF_NOT_EQ",
	"dj|IF_BIT_SET",
	/* 44 */
	"dj|IF_BIT_CLEAR",
	"v|SET_SPRITE_X",
	"v|SET_SPRITE_Y",
	"vv|ADD_VAR_F",
	/* 48 */
	"|COMPUTE_YOFS",
	"d|SET_BIT",
	"d|CLEAR_BIT",
	"d|ENABLE_BOX",
	/* 52 */
	"ddd|PLAY_EFFECT",
	"ddd|PAN_SFX",
	"ddd|DUMMY_54",
	"ddd|MOVE_BOX",
	/* 56 */
	"w|WAIT_BIG",
	"|BLACK_PALETTE",
	"ddd|SET_PRIORITIES",
	"ddd|STOP_ANIMATIONS",
	/* 60 */
	"dd|STOP_ANIMATE",
	"ddd|MASK",
	"|FASTFADEOUT",
	"|FASTFADEIN",
	/* 64 */
	"j|IF_SPEECH",
	"|SLOW_FADE_IN",
	"ddj|IF_VAR_EQUAL",
	"ddj|IF_VAR_LE",
	/* 68 */
	"ddj|IF_VAR_GE",
	"dd|PLAY_SEQ",
	"dd|JOIN_SEQ",
	"|IF_SEQ_WAITING",
	/* 72 */
	"dd|SEQUE",
	"bb|SET_MARK",
	"bb|CLEAR_MARK",
	"dd|SETSCALE",
	/* 76 */
	"ddd|SETSCALEXOFFS",
	"ddd|SETSCALEYOFFS",
	"|COMPUTEXY",
	"|COMPUTEPOSNUM",
	/* 80 */
	"wdd|SETOVERLAYIMAGE",
	"dd|SETRANDOM",
	"d|GETPATHVALUE",
	"ddd|PLAYSOUNDLOOP",
	"|STOPSOUNDLOOP",
};

} // End of namespace AGOS

#endif

================
File: debugger.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/config-manager.h"

#include "agos/debugger.h"
#include "agos/agos.h"
#include "agos/midi.h"
#include "agos/sound.h"

namespace AGOS {

Debugger::Debugger(AGOSEngine *vm)
	: GUI::Debugger() {
	_vm = vm;

	registerCmd("continue", WRAP_METHOD(Debugger, cmdExit));
	registerCmd("music",    WRAP_METHOD(Debugger, Cmd_PlayMusic));
	registerCmd("sound",    WRAP_METHOD(Debugger, Cmd_PlaySound));
	registerCmd("voice",    WRAP_METHOD(Debugger, Cmd_PlayVoice));
	registerCmd("bit",      WRAP_METHOD(Debugger, Cmd_SetBit));
	registerCmd("bit2",     WRAP_METHOD(Debugger, Cmd_SetBit2));
	registerCmd("bit3",     WRAP_METHOD(Debugger, Cmd_SetBit3));
	registerCmd("var",      WRAP_METHOD(Debugger, Cmd_SetVar));
	registerCmd("obj",      WRAP_METHOD(Debugger, Cmd_SetObjectFlag));
	registerCmd("sub",      WRAP_METHOD(Debugger, Cmd_StartSubroutine));
	registerCmd("dumpimage",      WRAP_METHOD(Debugger, Cmd_dumpImage));
	registerCmd("dumpscript",     WRAP_METHOD(Debugger, Cmd_dumpScript));

}

bool Debugger::Cmd_PlayMusic(int argc, const char **argv) {
	if (argc > 1) {
		uint music = atoi(argv[1]);
		if (music <= _vm->_numMusic) {
			if (_vm->getGameType() == GType_PP) {
				// TODO
			} else if (_vm->getGameType() == GType_SIMON2) {
				uint track = 0;
				if (argc > 2)
					track = atoi(argv[2]);
				_vm->loadMusic(music);
				_vm->_midi->play(track);
			} else {
				_vm->playMusic(music, 0);
			}
		} else
			debugPrintf("Music out of range (0 - %d)\n", _vm->_numMusic);
	} else
		debugPrintf("Syntax: music <musicnum> [<tracknum>]\n");

	return true;
}

bool Debugger::Cmd_PlaySound(int argc, const char **argv) {
	if (argc > 1) {
		uint sound = atoi(argv[1]);
		if (sound <= _vm->_numSFX)
			_vm->_sound->playEffects(sound);
		else
			debugPrintf("Sound out of range (0 - %d)\n", _vm->_numSFX);
	} else
		debugPrintf("Syntax: sound <soundnum>\n");

	return true;
}

bool Debugger::Cmd_PlayVoice(int argc, const char **argv) {
	if (argc > 1) {
		uint voice = atoi(argv[1]);
		if (voice <= _vm->_numSpeech)
			_vm->_sound->playVoice(voice);
		else
			debugPrintf("Voice out of range (0 - %d)\n", _vm->_numSpeech);
	} else
		debugPrintf("Syntax: voice <voicenum>\n");

	return true;
}

bool Debugger::Cmd_SetBit(int argc, const char **argv) {
	uint bit, value;
	if (argc > 2) {
		bit = atoi(argv[1]);
		value = atoi(argv[2]);
		if (value <= 1) {
			_vm->setBitFlag(bit, value != 0);
			debugPrintf("Set bit %d to %d\n", bit, value);
		} else
			debugPrintf("Bit value out of range (0 - 1)\n");
	} else if (argc > 1) {
		bit = atoi(argv[1]);
		value = _vm->getBitFlag(bit);
		debugPrintf("Bit %d is %d\n", bit, value);
	} else
		debugPrintf("Syntax: bit <bitnum> <value>\n");

	return true;
}

bool Debugger::Cmd_SetBit2(int argc, const char **argv) {
	uint bit, value;
	if (argc > 2) {
		bit = atoi(argv[1]);
		value = atoi(argv[2]);
		if (value == 0) {
			_vm->_bitArrayTwo[bit / 16] &= ~(1 << (bit & 15));
			debugPrintf("Set bit2 %d to %d\n", bit, value);
		} else if (value == 1) {
			_vm->_bitArrayTwo[bit / 16] |= (1 << (bit & 15));
			debugPrintf("Set bit2 %d to %d\n", bit, value);
		} else
			debugPrintf("Bit2 value out of range (0 - 1)\n");
	} else if (argc > 1) {
		bit = atoi(argv[1]);
		value = (_vm->_bitArrayTwo[bit / 16] & (1 << (bit & 15))) != 0;
		debugPrintf("Bit2 %d is %d\n", bit, value);
	} else
		debugPrintf("Syntax: bit2 <bitnum> <value>\n");

	return true;
}

bool Debugger::Cmd_SetBit3(int argc, const char **argv) {
	uint bit, value;
	if (argc > 2) {
		bit = atoi(argv[1]);
		value = atoi(argv[2]);
		if (value == 0) {
			_vm->_bitArrayThree[bit / 16] &= ~(1 << (bit & 15));
			debugPrintf("Set bit3 %d to %d\n", bit, value);
		} else if (value == 1) {
			_vm->_bitArrayThree[bit / 16] |= (1 << (bit & 15));
			debugPrintf("Set bit3 %d to %d\n", bit, value);
		} else
			debugPrintf("Bit3 value out of range (0 - 1)\n");
	} else if (argc > 1) {
		bit = atoi(argv[1]);
		value = (_vm->_bitArrayThree[bit / 16] & (1 << (bit & 15))) != 0;
		debugPrintf("Bit3 %d is %d\n", bit, value);
	} else
		debugPrintf("Syntax: bit3 <bitnum> <value>\n");

	return true;
}

bool Debugger::Cmd_SetVar(int argc, const char **argv) {
	uint var, value;
	if (argc > 1) {
		var = atoi(argv[1]);
		if (var < _vm->_numVars) {
			if (argc > 2) {
				value = atoi(argv[2]);
				_vm->writeVariable(var, value);
				debugPrintf("Set var %d to %d\n", var, value);
			} else {
				value = _vm->readVariable(var);
				debugPrintf("Var %d is %d\n", var, value);
			}
		} else
			debugPrintf("Var out of range (0 - %d)\n", _vm->_numVars - 1);
	} else
		debugPrintf("Syntax: var <varnum> <value>\n");

	return true;
}

bool Debugger::Cmd_SetObjectFlag(int argc, const char **argv) {
	uint obj, prop, value;
	if (argc > 2) {
		obj = atoi(argv[1]);
		prop = atoi(argv[2]);

		if (obj >= 1 && obj < _vm->_itemArraySize) {
			SubObject *o = (SubObject *)_vm->findChildOfType(_vm->derefItem(obj), kObjectType);
			if (o != nullptr) {
				if (o->objectFlags & (1 << prop) && prop < 16) {
					uint offs = _vm->getOffsetOfChild2Param(o, 1 << prop);
					if (argc > 3) {
						value = atoi(argv[3]);
						o->objectFlagValue[offs] = value;
						debugPrintf("Object %d Flag %d set to %d\n", obj, prop, value);
					} else {
						value = o->objectFlagValue[offs];
						debugPrintf("Object %d Flag %d is %d\n", obj, prop, value);
					}
				} else {
					debugPrintf("Object flag out of range\n");
				}
			} else {
				debugPrintf("Item isn't an object\n");
			}
		} else {
			debugPrintf("Item out of range (1 - %d)\n", _vm->_itemArraySize - 1);
		}
	} else {
		debugPrintf("Syntax: obj <itemnum> <flag> <value>\n");
	}

	return true;
}

bool Debugger::Cmd_StartSubroutine(int argc, const char **argv) {
	if (argc > 1) {
		uint subroutine = atoi(argv[1]);
		Subroutine *sub;
		sub = _vm->getSubroutineByID(subroutine);
		if (sub != nullptr)
			_vm->startSubroutine(sub);
	} else
		debugPrintf("Subroutine %d\n", _vm->_currentTable->id);

	return true;
}

bool Debugger::Cmd_dumpImage(int argc, const char **argv) {
	if (argc > 1) {
		uint16 zoneNum = atoi(argv[1]);
		_vm->loadZone(zoneNum, false);
		VgaPointersEntry *vpe = &_vm->_vgaBufferPointers[zoneNum];
		if (vpe->vgaFile2 != nullptr) {
			_vm->dumpVgaBitmaps(zoneNum);
		} else {
			debugPrintf("Invalid Zone Number %d\n", zoneNum);

		}
	} else
		debugPrintf("Syntax: dumpimage <zonenum>\n");

	return true;
}

bool Debugger::Cmd_dumpScript(int argc, const char **argv) {
	if (argc > 1) {
		uint16 zoneNum = atoi(argv[1]);
		_vm->loadZone(zoneNum, false);
		VgaPointersEntry *vpe = &_vm->_vgaBufferPointers[zoneNum];
		if (vpe->vgaFile1 != nullptr) {
			_vm->dumpVgaFile(vpe->vgaFile1);
		} else {
			debugPrintf("Invalid Zone Number %d\n", zoneNum);

		}
	} else
		debugPrintf("Syntax: dumpscript <zonenum>\n");

	return true;
}

} // End of namespace AGOS

================
File: debugger.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_DEBUGGER_H
#define AGOS_DEBUGGER_H

#include "gui/debugger.h"

namespace AGOS {

class AGOSEngine;

class Debugger : public GUI::Debugger {
public:
	Debugger(AGOSEngine *vm);

private:
	AGOSEngine *_vm;

	bool Cmd_PlayMusic(int argc, const char **argv);
	bool Cmd_PlaySound(int argc, const char **argv);
	bool Cmd_PlayVoice(int argc, const char **argv);
	bool Cmd_SetBit(int argc, const char **argv);
	bool Cmd_SetBit2(int argc, const char **argv);
	bool Cmd_SetBit3(int argc, const char **argv);
	bool Cmd_SetVar(int argc, const char **argv);
	bool Cmd_SetObjectFlag(int argc, const char **argv);
	bool Cmd_StartSubroutine(int argc, const char **argv);
	bool Cmd_dumpImage(int argc, const char **argv);
	bool Cmd_dumpScript(int argc, const char **argv);
};

} // End of namespace AGOS

#endif

================
File: detection.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "base/plugins.h"

#include "engines/advancedDetector.h"
#include "engines/obsolete.h"

#include "common/config-manager.h"
#include "common/system.h"
#include "common/textconsole.h"
#include "common/compression/installshield_cab.h"

#include "agos/detection.h"
#include "agos/intern_detection.h"
#include "agos/detection_fallback.h"
#include "agos/obsolete.h" // Obsolete ID table.
#include "agos/agos.h"

/**
 * Conversion table mapping old obsolete target names to the
 * corresponding new target and platform combination.
 *
 */

static const DebugChannelDef debugFlagList[] = {
	{AGOS::kDebugOpcode, "opcode", "Opcode debug level"},
	{AGOS::kDebugVGAOpcode, "vga_opcode", "VGA Opcode debug level"},
	{AGOS::kDebugSubroutine, "subroutine", "Subroutine debug level"},
	{AGOS::kDebugVGAScript, "vga_script", "VGA Script debug level"},
	DEBUG_CHANNEL_END
};

static const PlainGameDescriptor agosGames[] = {
	{"pn", "Personal Nightmare"},
	{"elvira1", "Elvira: Mistress of the Dark"},
	{"elvira2", "Elvira II: The Jaws of Cerberus"},
	{"waxworks", "Waxworks"},
	{"simon1", "Simon the Sorcerer"},
	{"simon2", "Simon the Sorcerer II: The Lion, the Wizard and the Wardrobe"},
	{"feeble", "The Feeble Files"},
	{"dimp", "Simon the Sorcerer's Puzzle Pack: Demon in my Pocket"},
	{"jumble", "Simon the Sorcerer's Puzzle Pack: Jumble"},
	{"puzzle", "Simon the Sorcerer's Puzzle Pack: NoPatience"},
	{"swampy", "Simon the Sorcerer's Puzzle Pack: Swampy Adventures"},
	{nullptr, nullptr}
};

#include "agos/detection_tables.h"

static const char *const directoryGlobs[] = {
	"execute", // Used by Simon1 Acorn CD
	nullptr
};

using namespace AGOS;

class AgosMetaEngineDetection : public AdvancedMetaEngineDetection<AGOS::AGOSGameDescription> {
public:
	AgosMetaEngineDetection() : AdvancedMetaEngineDetection(AGOS::gameDescriptions, agosGames) {
		_guiOptions = GUIO1(GUIO_NOLAUNCHLOAD);
		_maxScanDepth = 2;
		_directoryGlobs = directoryGlobs;
	}

	PlainGameDescriptor findGame(const char *gameId) const override {
		return Engines::findGameID(gameId, _gameIds, obsoleteGameIDsTable);
	}

	Common::Error identifyGame(DetectedGame &game, const void **descriptor) override {
		Engines::upgradeTargetIfNecessary(obsoleteGameIDsTable);
		return AdvancedMetaEngineDetection::identifyGame(game, descriptor);
	}

	const char *getName() const override {
		return "agos";
	}

	const char *getEngineName() const override {
		return "AGOS";
	}

	const char *getOriginalCopyright() const override {
		return "AGOS (C) Adventure Soft";
	}

	const DebugChannelDef *getDebugChannels() const override {
		return debugFlagList;
	}

	ADDetectedGame fallbackDetect(const FileMap &allFiles, const Common::FSList &fslist, ADDetectedGameExtraInfo **extra) const override {
		ADDetectedGame detectedGame = detectGameFilebased(allFiles, AGOS::fileBased);
		if (!detectedGame.desc) {
			return ADDetectedGame();
		}

		return detectedGame;
	}

};

REGISTER_PLUGIN_STATIC(AGOS_DETECTION, PLUGIN_TYPE_ENGINE_DETECTION, AgosMetaEngineDetection);

================
File: detection.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_DETECTION_H
#define AGOS_DETECTION_H

#include "engines/advancedDetector.h"

namespace AGOS {

enum SIMONGameType {
	GType_PN = 0,
	GType_ELVIRA1 = 1,
	GType_ELVIRA2 = 2,
	GType_WW = 3,
	GType_SIMON1 = 4,
	GType_SIMON2 = 5,
	GType_FF = 6,
	GType_PP = 7
};

struct AGOSGameDescription {
	AD_GAME_DESCRIPTION_HELPERS(desc);

	ADGameDescription desc;

	int gameType;
	int gameId;
	uint32 features;
};

#define GAMEOPTION_OPL3_MODE            GUIO_GAMEOPTIONS1
#define GAMEOPTION_DOS_TEMPOS           GUIO_GAMEOPTIONS2
#define GAMEOPTION_WINDOWS_TEMPOS       GUIO_GAMEOPTIONS3
#define GAMEOPTION_PREFER_DIGITAL_SFX   GUIO_GAMEOPTIONS4
#define GAMEOPTION_DISABLE_FADE_EFFECTS GUIO_GAMEOPTIONS5
#define GAMEOPTION_COPY_PROTECTION      GUIO_GAMEOPTIONS6

} // End of namespace AGOS

#endif // AGOS_DETECTION_H

================
File: detection_fallback.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

namespace AGOS {

static const AGOSGameDescription fallbackDescs[] = {

	// Simon the Sorcerer 1 - DOS Floppy
	{
		{
			"simon1",
			"Floppy",
			{
				{ "gamepc",			GAME_BASEFILE,	NULL, AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	NULL, AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	NULL, AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	NULL, AD_NO_SIZE},
				AD_LISTEND
			},
			Common::UNK_LANG,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO4(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1DOS,
		GF_OLD_BUNDLE
	},

	// Simon the Sorcerer 1 - DOS CD
	{
		{
			"simon1",
			"CD",
			{
				{ "simon.gme",		GAME_GMEFILE,	NULL, AD_NO_SIZE},
				{ "gamepc"	,		GAME_BASEFILE,	NULL, AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	NULL, AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	NULL, AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	NULL, AD_NO_SIZE},
				AD_LISTEND
			},
			Common::UNK_LANG,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO3(GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - DOS Floppy
	{
		{
			"simon2",
			"Floppy",
			{
				{ "game32",			GAME_BASEFILE,	NULL, AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	NULL, AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	NULL, AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	NULL, AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	NULL, AD_NO_SIZE},
				AD_LISTEND
			},
			Common::UNK_LANG,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		0
	},

	// Simon the Sorcerer 2 - DOS CD
	{
		{
			"simon2",
			"CD",
			{
				{ "gsptr30",		GAME_BASEFILE,	NULL, AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	NULL, AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	NULL, AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	NULL, AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	NULL, AD_NO_SIZE},
				AD_LISTEND
			},
			Common::UNK_LANG,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// The Feeble Files - Windows
	{
		{
			"feeble",
			"CD",
			{
				{ "game22",		GAME_BASEFILE,	NULL, AD_NO_SIZE},
				{ "tbllist",	GAME_TBLFILE,	NULL, AD_NO_SIZE},
				AD_LISTEND
			},
			Common::UNK_LANG,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_TALKIE
	},

	{ AD_TABLE_END_MARKER, 0, 0, 0 }
};

static const ADFileBasedFallback fileBased[] = {
	{ &fallbackDescs[ 0].desc, { "gamepc", "icon.dat", "stripped.txt", "tbllist", 0 } },
	{ &fallbackDescs[ 1].desc, { "simon.gme", "gamepc", "icon.dat", "stripped.txt", "tbllist", 0 } },
	{ &fallbackDescs[ 2].desc, { "game32", "icon.dat", "simon2.gme", "stripped.txt", "tbllist", 0 } },
	{ &fallbackDescs[ 3].desc, { "gsptr30", "icon.dat", "simon2.gme", "stripped.txt", "tbllist", 0 } },
	{ &fallbackDescs[ 4].desc, { "game22", "tbllist", 0 } },

	{ 0, { 0 } }
};

} // End of namespace AGOS

================
File: detection_tables.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

namespace AGOS {

static const AGOSGameDescription gameDescriptions[] = {
	// Personal Nightmare 1.1 - English Amiga
	{
		{
			"pn",
			"Floppy",

			{
				{ "icon.tmp",		GAME_ICONFILE,	"cd94091218ac2c46918fd3c0cbd81d5e", AD_NO_SIZE},
				{ "night.dbm",		GAME_BASEFILE,	"712c445d8e938956403a759978eab01b", AD_NO_SIZE},
				{ "night.txt",		GAME_TEXTFILE,	"52630ad100f473a2cdc7c699536d6730", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_PN,
		GID_PN,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_PLANAR
	},

	// Personal Nightmare - English Atari ST Floppy Demo
	{
		{
			"pn",
			"Non-Interactive Demo",

			{
				{ "01.IN",		GAME_VGAFILE,	"23a4c8c4c9ac460fee7281080b5274e3", 756},
				{ "02.IN",		GAME_VGAFILE,	"31be87808826538f0c0caebd5fedd48f", 73100},
				{ "03.IN",		GAME_VGAFILE,	"0e125f3df4e4b800936ebdcc8dc96060", 101664},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAtariST,
			ADGF_DEMO,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_PN,
		GID_PN,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_PLANAR | GF_DEMO
	},

	// Personal Nightmare 1.1 - English AtariST Floppy
	{
		{
			"pn",
			"Floppy",

			{
				{ "night.dbm",		GAME_BASEFILE,	"712c445d8e938956403a759978eab01b", AD_NO_SIZE},
				{ "night.txt",		GAME_TEXTFILE,	"52630ad100f473a2cdc7c699536d6730", AD_NO_SIZE},
				{ "test.prg",		GAME_ICONFILE,	"0f316bbd7341a98c8d5f27d16fe50524", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAtariST,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_PN,
		GID_PN,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_PLANAR
	},

	// Personal Nightmare 1.1c - EGA English DOS Floppy
	{
		{
			"pn",
			"Floppy",

			{
				{ "icon.out",		GAME_ICONFILE,	"40d8347c3154bfa8b642d6860a4b9481", AD_NO_SIZE},
				{ "night.dbm",		GAME_BASEFILE,	"177311ae059243f6a2740e950585d786", AD_NO_SIZE},
				{ "night.txt",		GAME_TEXTFILE,	"861fc1fa0864eef585f5865dee52e325", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO1(GUIO_NOSPEECH)
		},

		GType_PN,
		GID_PN,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_EGA | GF_PLANAR
	},

	// Elvira 1 - English Amiga Floppy Demo
	{
		{
			"elvira1",
			"Non-Interactive Demo",

			{
				{ "agos.mdf",		GAME_MENUFILE,	"825bc8eecd599f4c26732902ba2c2c77", 98},
				{ "englishdemo",	GAME_BASEFILE,	"7bbc2dfe8619ef579004ff57674c6e92", 21587},
				{ "icon.dat",		GAME_ICONFILE,	"68b329da9893e34099c7d8ad5cb9c940", 1},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAmiga,
			ADGF_DEMO,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_ELVIRA1,
		GID_ELVIRA1,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_PLANAR | GF_DEMO
	},

	// Elvira 1 - English Amiga Floppy
	{
		{
			"elvira1",
			"Floppy",
			{
				{ "gameamiga",		GAME_BASEFILE,	"7bdaff4a118d8035047cf9b1393b3fa0", 218977},
				{ "icon.dat",		GAME_ICONFILE,	"2db931e84f1ca01f0816dddfae3f49e1", 36573},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_ELVIRA1,
		GID_ELVIRA1,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_PLANAR
	},

	// Elvira 1 - French Amiga Floppy
	{
		{
			"elvira1",
			"Floppy",
			{
				{ "gameamiga",		GAME_BASEFILE,	"ab1a0798f74e71cc58a06e7e0db6f8a7", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"2db931e84f1ca01f0816dddfae3f49e1", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::FR_FRA,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_ELVIRA1,
		GID_ELVIRA1,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_PLANAR
	},

	// Elvira 1 - German Amiga Floppy
	{
		{
			"elvira1",
			"Floppy",
			{
				{ "gameamiga",		GAME_BASEFILE,	"bde0334344c7b3a278ccc9a300f3085c", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"2db931e84f1ca01f0816dddfae3f49e1", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_ELVIRA1,
		GID_ELVIRA1,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_PLANAR
	},

	// Elvira 1 - English Atari ST Floppy Demo
	{
		{
			"elvira1",
			"Non-Interactive Demo",

			{
				{ "991.out",		GAME_VGAFILE,	"9238242d3274bb770cb4925d2b268f83", 1822},
				{ "992.out",		GAME_VGAFILE,	"5526cd64e515f1c5f9ff8f2fb569c4eb", 192236},
				{ "993.out",		GAME_VGAFILE,	"d41d8cd98f00b204e9800998ecf8427e", 0},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAtariST,
			ADGF_DEMO,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_ELVIRA1,
		GID_ELVIRA1,
		GF_OLD_BUNDLE | GF_PLANAR | GF_DEMO
	},

	// Elvira 1 - English Atari ST Floppy
	{
		{
			"elvira1",
			"Floppy",

			{
				{ "gamest",		GAME_BASEFILE,	"8942859018fcfb2dbed13e83d974d1ab", AD_NO_SIZE},
				{ "icon.dat",	GAME_ICONFILE,	"2db931e84f1ca01f0816dddfae3f49e1", AD_NO_SIZE},
				{ "tbllist",	GAME_TBLFILE,	"5b6ff494bf7e24213758598ef4ac0a8b", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAtariST,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_ELVIRA1,
		GID_ELVIRA1,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_PLANAR
	},

	// Elvira 1 - English Atari ST Floppy alternative?
	{
		{
			"elvira1",
			"Floppy",

			{
				{ "gamest",		GAME_BASEFILE,	"ce2100ba71284f55ac302847d7f94747", 119851},
				{ "icon.dat",	GAME_ICONFILE,	"2db931e84f1ca01f0816dddfae3f49e1", 36573},
				{ "tbllist",	GAME_TBLFILE,	"5b6ff494bf7e24213758598ef4ac0a8b", 476},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAtariST,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_ELVIRA1,
		GID_ELVIRA1,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_PLANAR
	},

	// Elvira 1 - English DOS Floppy Demo
	{
		{
			"elvira1",
			"Non-Interactive Demo",

			{
				{ "demo",		GAME_BASEFILE,	"54b43b6ab38964bd7fd17e9f1b41cc64", 2308},
				{ "icon.dat",	GAME_ICONFILE,	"55d8dd70c54340397ca518665274a477", 576},
				{ "tbllist",	GAME_TBLFILE,	"319f6b227c7822a551f57d24e70f8149", 368},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_DEMO,
			GUIO2(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE)
		},

		GType_ELVIRA1,
		GID_ELVIRA1,
		GF_OLD_BUNDLE | GF_DEMO
	},

	// Elvira 1 - English DOS Floppy
	{
		{
			"elvira1",
			"Floppy",

			{
				{ "gamepc",		GAME_BASEFILE,	"a49e132a1f18306dd5d1ec2fe435e178", 135332},
				{ "icon.dat",	GAME_ICONFILE,	"fda48c9da7f3e72d0313e2f5f760fc45", 56448},
				{ "tbllist",	GAME_TBLFILE,	"319f6b227c7822a551f57d24e70f8149", 368},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE)
		},

		GType_ELVIRA1,
		GID_ELVIRA1,
		GF_OLD_BUNDLE
	},

	// Elvira 1 - English DOS Floppy with Czech patch(v1.08)
	{
		{
			"elvira1",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"5e73b4a609fdd0c0db2f076b871a5d5b", 137655},
				{ "icon.dat",		GAME_ICONFILE,	"fda48c9da7f3e72d0313e2f5f760fc45", 56448},
				{ "tbllist",		GAME_TBLFILE,	"319f6b227c7822a551f57d24e70f8149", 368},
				AD_LISTEND
			},
			Common::CS_CZE,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE)
		},

		GType_ELVIRA1,
		GID_ELVIRA1,
		GF_OLD_BUNDLE
	},

	// Elvira 1 - English DOS Floppy, with Spanish patch
	{
		{
			"elvira1",
			"Floppy",

			{
				{ "gamepc",		GAME_BASEFILE,	"97d2f74db08845c43474312a87330cf6", 137361},
				{ "icon.dat",	GAME_ICONFILE,	"fda48c9da7f3e72d0313e2f5f760fc45", 56448},
				{ "tbllist",	GAME_TBLFILE,	"319f6b227c7822a551f57d24e70f8149", 368},
				AD_LISTEND
			},
			Common::ES_ESP,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE)
		},

		GType_ELVIRA1,
		GID_ELVIRA1,
		GF_OLD_BUNDLE
	},

	// Elvira 1 - French DOS Floppy
	{
		{
			"elvira1",
			"Floppy",

			{
				{ "gamepc",		GAME_BASEFILE,	"9076d507d60cc454df662316438ec843", AD_NO_SIZE},
				{ "icon.dat",	GAME_ICONFILE,	"fda48c9da7f3e72d0313e2f5f760fc45", AD_NO_SIZE},
				{ "tbllist",	GAME_TBLFILE,	"319f6b227c7822a551f57d24e70f8149", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::FR_FRA,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE)
		},

		GType_ELVIRA1,
		GID_ELVIRA1,
		GF_OLD_BUNDLE
	},

	// Elvira 1 - German DOS Floppy
	{
		{
			"elvira1",
			"Floppy",

			{
				{ "gamepc",		GAME_BASEFILE,	"d0b593143e21fc150c044819df2c0b98", AD_NO_SIZE},
				{ "icon.dat",	GAME_ICONFILE,	"fda48c9da7f3e72d0313e2f5f760fc45", AD_NO_SIZE},
				{ "tbllist",	GAME_TBLFILE,	"319f6b227c7822a551f57d24e70f8149", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE)
		},

		GType_ELVIRA1,
		GID_ELVIRA1,
		GF_OLD_BUNDLE
	},

	// Elvira 1 - Japanese PC-98
	{
		{
			"elvira1",
			0,
			{
				{ "gamepcj.dat",	GAME_BASEFILE,	"f170990deafbf9adee360021a6b5f375", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"fda48c9da7f3e72d0313e2f5f760fc45", AD_NO_SIZE},
				{ "tbllist.dat",	GAME_TBLFILE,	"319f6b227c7822a551f57d24e70f8149", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::JA_JPN,
			Common::kPlatformPC98,
			ADGF_NO_FLAGS,
			GUIO1(GUIO_NOSPEECH)
		},

		GType_ELVIRA1,
		GID_ELVIRA1,
		GF_OLD_BUNDLE
	},

	// Elvira 2 - English Amiga Floppy
	{
		{
			"elvira2",
			"Floppy",

			{
				{ "gameamiga",		GAME_BASEFILE,	"4aa163967f5d2bd319f8350d6af03186", 134799},
				{ "icon.dat",		GAME_ICONFILE,	"a88b1c02e13ab04dd790ec30502c323d", 69860},
				{ "menus.dat",		GAME_MENUFILE,	"a2fdc88a77c8bdffec6b36cbeda4d955", 108},
				{ "start",			GAME_RESTFILE,	"a9f876c6c66dfd011b971da3dc7b4ada", 27752},
				{ "stripped.txt",	GAME_STRFILE,	"41c975a9c1106cb5298a0bc3df0a266e", 72},
				{ "tbllist",		GAME_TBLFILE,	"177f5f2640e80ef92d1421d32de06a5e", 272},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_ELVIRA2,
		GID_ELVIRA2,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_PLANAR
	},

	// Elvira 2 - French Amiga Floppy
	{
		{
			"elvira2",
			"Floppy",

			{
				{ "gameamiga",		GAME_BASEFILE,	"7bb91fd61a135243b18b74b51ebca6bf", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"a88b1c02e13ab04dd790ec30502c323d", AD_NO_SIZE},
				{ "menus.dat",		GAME_MENUFILE,	"a2fdc88a77c8bdffec6b36cbeda4d955", AD_NO_SIZE},
				{ "start",			GAME_RESTFILE,	"a9f876c6c66dfd011b971da3dc7b4ada", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"41c975a9c1106cb5298a0bc3df0a266e", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"177f5f2640e80ef92d1421d32de06a5e", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::FR_FRA,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_ELVIRA2,
		GID_ELVIRA2,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_PLANAR
	},

	// Elvira 2 - German Amiga Floppy
	{
		{
			"elvira2",
			"Floppy",

			{
				{ "menus.dat",		GAME_MENUFILE,	"a2fdc88a77c8bdffec6b36cbeda4d955", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"41c975a9c1106cb5298a0bc3df0a266e", AD_NO_SIZE},
				{ "gameamiga",		GAME_BASEFILE,	"7af80eb9759bcafcd8df21e61c5af200", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"a88b1c02e13ab04dd790ec30502c323d", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"177f5f2640e80ef92d1421d32de06a5e", AD_NO_SIZE},
				{ "start",			GAME_RESTFILE,	"a9f876c6c66dfd011b971da3dc7b4ada", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_ELVIRA2,
		GID_ELVIRA2,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_PLANAR
	},

	// Elvira 2 - Italian Amiga Floppy
	{
		{
			"elvira2",
			"Floppy",

			{
				{ "gameamiga",		GAME_BASEFILE,	"3d4e0c8da4ebd222e50de2dffed92955", 139505},
				{ "icon.dat",		GAME_ICONFILE,	"a88b1c02e13ab04dd790ec30502c323d", 69860},
				{ "menus.dat",		GAME_MENUFILE,	"a2fdc88a77c8bdffec6b36cbeda4d955", 108},
				{ "start",			GAME_RESTFILE,	"a9f876c6c66dfd011b971da3dc7b4ada", 27752},
				{ "stripped.txt",	GAME_STRFILE,	"41c975a9c1106cb5298a0bc3df0a266e", 72},
				{ "tbllist",		GAME_TBLFILE,	"177f5f2640e80ef92d1421d32de06a5e", 272},
				AD_LISTEND
			},
			Common::IT_ITA,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_ELVIRA2,
		GID_ELVIRA2,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_PLANAR
	},

	// Elvira 2 - Spanish Amiga Floppy
	{
		{
			"elvira2",
			"Floppy",

			{
				{ "gameamiga",		GAME_BASEFILE,	"fddfac048a759c84ecf96e3d0cb368cc", 139126},
				{ "icon.dat",		GAME_ICONFILE,	"a88b1c02e13ab04dd790ec30502c323d", 69860},
				{ "menus.dat",		GAME_MENUFILE,	"a2fdc88a77c8bdffec6b36cbeda4d955", 108},
				{ "start",			GAME_RESTFILE,	"a9f876c6c66dfd011b971da3dc7b4ada", 27752},
				{ "stripped.txt",	GAME_STRFILE,	"41c975a9c1106cb5298a0bc3df0a266e", 72},
				{ "tbllist",		GAME_TBLFILE,	"177f5f2640e80ef92d1421d32de06a5e", 272},
				AD_LISTEND
			},
			Common::ES_ESP,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_ELVIRA2,
		GID_ELVIRA2,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_PLANAR
	},

	// Elvira 2 - English Atari ST Floppy
	{
		{
			"elvira2",
			"Floppy",

			{
				{ "gamest",			GAME_BASEFILE,	"1b1acd637d32bee79859b7cc9de070e7", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"9a4eaf4df0cdf5cc85a5134150f96589", AD_NO_SIZE},
				{ "menus.dat",		GAME_MENUFILE,	"a2fdc88a77c8bdffec6b36cbeda4d955", AD_NO_SIZE},
				{ "start",			GAME_RESTFILE,	"8cddf461f418ea12f711fda3d3dd62fe", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"41c975a9c1106cb5298a0bc3df0a266e", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"177f5f2640e80ef92d1421d32de06a5e", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAtariST,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_ELVIRA2,
		GID_ELVIRA2,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_PLANAR
	},

	// Elvira 2 - French Atari ST Floppy
	{
		{
			"elvira2",
			"Floppy",

			{
				{ "gamest",			GAME_BASEFILE,	"7bb91fd61a135243b18b74b51ebca6bf", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"9a4eaf4df0cdf5cc85a5134150f96589", AD_NO_SIZE},
				{ "menus.dat",		GAME_MENUFILE,	"a2fdc88a77c8bdffec6b36cbeda4d955", AD_NO_SIZE},
				{ "start",			GAME_RESTFILE,	"8cddf461f418ea12f711fda3d3dd62fe", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"41c975a9c1106cb5298a0bc3df0a266e", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"177f5f2640e80ef92d1421d32de06a5e", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::FR_FRA,
			Common::kPlatformAtariST,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSPEECH, GUIO_NOMIDI)
		},

		GType_ELVIRA2,
		GID_ELVIRA2,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_PLANAR
	},


	// Elvira 2 - English DOS Floppy
	{
		{
			"elvira2",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"3313254722031b22d833a2cf45a91fd7", 125702},
				{ "icon.dat",		GAME_ICONFILE,	"83a7278bff55c82fbb3aef92981866c9", 54471},
				{ "menus.dat",		GAME_MENUFILE,	"a2fdc88a77c8bdffec6b36cbeda4d955", 108},
				{ "start",			GAME_RESTFILE,	"4d380a35ba941d03ee5084c71d20055b", 27876},
				{ "stripped.txt",	GAME_STRFILE,	"c2533277b7ff11f5495967d55355ea17", 81},
				{ "tbllist",		GAME_TBLFILE,	"8252660df0edbdbc3e6377e155bbd0c5", 284},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_PREFER_DIGITAL_SFX)
		},

		GType_ELVIRA2,
		GID_ELVIRA2,
		GF_OLD_BUNDLE
	},

	// Elvira 2 - English DOS Floppy, Alternate 1
	{
		{
			"elvira2",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"1282fd5c520861ae2b73bf653afef547", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"83a7278bff55c82fbb3aef92981866c9", AD_NO_SIZE},
				{ "menus.dat",		GAME_MENUFILE,	"a2fdc88a77c8bdffec6b36cbeda4d955", AD_NO_SIZE},
				{ "start",			GAME_RESTFILE,	"4d380a35ba941d03ee5084c71d20055b", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"c2533277b7ff11f5495967d55355ea17", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"8252660df0edbdbc3e6377e155bbd0c5", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_PREFER_DIGITAL_SFX)
		},

		GType_ELVIRA2,
		GID_ELVIRA2,
		GF_OLD_BUNDLE
	},

	// Elvira 2 - English DOS Floppy, Alternate 2
	{
		{
			"elvira2",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"75d814739585b6fa89a025045885e3b9", 125665},
				{ "icon.dat",		GAME_ICONFILE,	"83a7278bff55c82fbb3aef92981866c9", 54471},
				{ "menus.dat",		GAME_MENUFILE,	"a2fdc88a77c8bdffec6b36cbeda4d955", 108},
				{ "start",			GAME_RESTFILE,	"016107aced82d0cc5d758a9fba716270", 27852},
				{ "stripped.txt",	GAME_STRFILE,	"c3a8f644551a27c8a2fec0f8070b46b7", 81},
				{ "tbllist",		GAME_TBLFILE,	"8252660df0edbdbc3e6377e155bbd0c5", 284},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_PREFER_DIGITAL_SFX)
		},

		GType_ELVIRA2,
		GID_ELVIRA2,
		GF_OLD_BUNDLE
	},

	// Elvira 2 - English DOS Floppy with Czech patch
	{
		{
			"elvira2",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"022536512981f1962276c0813a1351d8", 122729},
				{ "icon.dat",		GAME_ICONFILE,	"83a7278bff55c82fbb3aef92981866c9", 54471},
				{ "menus.dat",		GAME_MENUFILE,	"a2fdc88a77c8bdffec6b36cbeda4d955", 108},
				{ "start",			GAME_RESTFILE,	"4d380a35ba941d03ee5084c71d20055b", 27876},
				{ "stripped.txt",	GAME_STRFILE,	"c2533277b7ff11f5495967d55355ea17", 81},
				{ "tbllist",		GAME_TBLFILE,	"8252660df0edbdbc3e6377e155bbd0c5", 284},
				AD_LISTEND
			},
			Common::CS_CZE,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_PREFER_DIGITAL_SFX)
		},

		GType_ELVIRA2,
		GID_ELVIRA2,
		GF_OLD_BUNDLE
	},

	// Elvira 2 - French DOS Floppy
	{
		{
			"elvira2",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"4bf28ab00f5324fd938e632595742382", 130980},
				{ "icon.dat",		GAME_ICONFILE,	"83a7278bff55c82fbb3aef92981866c9", 54471},
				{ "menus.dat",		GAME_MENUFILE,	"a2fdc88a77c8bdffec6b36cbeda4d955", 108},
				{ "start",			GAME_RESTFILE,	"016107aced82d0cc5d758a9fba716270", 27852},
				{ "stripped.txt",	GAME_STRFILE,	"c3a8f644551a27c8a2fec0f8070b46b7", 81},
				{ "tbllist",		GAME_TBLFILE,	"8252660df0edbdbc3e6377e155bbd0c5", 284},
				AD_LISTEND
			},
			Common::FR_FRA,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_PREFER_DIGITAL_SFX)
		},

		GType_ELVIRA2,
		GID_ELVIRA2,
		GF_OLD_BUNDLE
	},

	// Elvira 2 - German DOS Floppy
	{
		{
			"elvira2",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"d1979d2fbc5fb5276563578ca55cbcec", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"83a7278bff55c82fbb3aef92981866c9", AD_NO_SIZE},
				{ "menus.dat",		GAME_MENUFILE,	"a2fdc88a77c8bdffec6b36cbeda4d955", AD_NO_SIZE},
				{ "start",			GAME_RESTFILE,	"016107aced82d0cc5d758a9fba716270", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"c3a8f644551a27c8a2fec0f8070b46b7", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"8252660df0edbdbc3e6377e155bbd0c5", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_PREFER_DIGITAL_SFX)
		},

		GType_ELVIRA2,
		GID_ELVIRA2,
		GF_OLD_BUNDLE
	},

	// Elvira 2 - Italian DOS Floppy
	{
		{
			"elvira2",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"09a3f1087f2977ff462ad2417bde0a5c", 129833},
				{ "icon.dat",		GAME_ICONFILE,	"83a7278bff55c82fbb3aef92981866c9", 54471},
				{ "menus.dat",		GAME_MENUFILE,	"a2fdc88a77c8bdffec6b36cbeda4d955", 108},
				{ "start",			GAME_RESTFILE,	"016107aced82d0cc5d758a9fba716270", 27852},
				{ "stripped.txt",	GAME_STRFILE,	"c3a8f644551a27c8a2fec0f8070b46b7", 81},
				{ "tbllist",		GAME_TBLFILE,	"8252660df0edbdbc3e6377e155bbd0c5", 284},
				AD_LISTEND
			},
			Common::IT_ITA,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_PREFER_DIGITAL_SFX)
		},

		GType_ELVIRA2,
		GID_ELVIRA2,
		GF_OLD_BUNDLE
	},

	// Elvira 2 - Spanish DOS Floppy
	{
		{
			"elvira2",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"bfcd74d704ad481d75eb6ba5b828333a", 129577},
				{ "icon.dat",		GAME_ICONFILE,	"83a7278bff55c82fbb3aef92981866c9", 54471},
				{ "menus.dat",		GAME_MENUFILE,	"a2fdc88a77c8bdffec6b36cbeda4d955", 108},
				{ "start",			GAME_RESTFILE,	"016107aced82d0cc5d758a9fba716270", 27852},
				{ "stripped.txt",	GAME_STRFILE,	"c3a8f644551a27c8a2fec0f8070b46b7", 81},
				{ "tbllist",		GAME_TBLFILE,	"8252660df0edbdbc3e6377e155bbd0c5", 284},
				AD_LISTEND
			},
			Common::ES_ESP,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_PREFER_DIGITAL_SFX)
		},

		GType_ELVIRA2,
		GID_ELVIRA2,
		GF_OLD_BUNDLE
	},

	// Elvira 2 - Spanish DOS Floppy, Alternate
	{
		{
			"elvira2",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"e84e1ac84f63d9a39270e517196c5ff9", 129577},
				{ "icon.dat",		GAME_ICONFILE,	"83a7278bff55c82fbb3aef92981866c9", 54471},
				{ "menus.dat",		GAME_MENUFILE,	"a2fdc88a77c8bdffec6b36cbeda4d955", 108},
				{ "start",			GAME_RESTFILE,	"016107aced82d0cc5d758a9fba716270", 27852},
				{ "stripped.txt",	GAME_STRFILE,	"c3a8f644551a27c8a2fec0f8070b46b7", 81},
				{ "tbllist",		GAME_TBLFILE,	"8252660df0edbdbc3e6377e155bbd0c5", 284},
				AD_LISTEND
			},
			Common::ES_ESP,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_PREFER_DIGITAL_SFX)
		},

		GType_ELVIRA2,
		GID_ELVIRA2,
		GF_OLD_BUNDLE
	},

	// Waxworks - English Amiga Floppy
	{
		{
			"waxworks",
			"Floppy",

			{
				{ "gameamiga",		GAME_BASEFILE,	"eca24fe7c3e005caca47cecac56f7245", 43392},
				{ "icon.pkd",		GAME_ICONFILE,	"4822a91c18b1b2005ac17fc617f7dcbe", 18940},
				{ "menus.dat",		GAME_MENUFILE,	"3409eeb8ca8b46fc04da99de67573f5e", 320},
				{ "start",			GAME_RESTFILE,	"b575b336e741dde1725edd4079d5ab67", 20902},
				{ "stripped.txt",	GAME_STRFILE,	"6faaebff2786216900061eeb978f10af", 225},
				{ "tbllist",		GAME_TBLFILE,	"95c44bfc380770a6b6dd0dfcc69e80a0", 309},
				{ "xtbllist",		GAME_XTBLFILE,	"6c7b3db345d46349a5226f695c03e20f", 88},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GUIO_NOMIDI, GAMEOPTION_COPY_PROTECTION)
		},

		GType_WW,
		GID_WAXWORKS,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_CRUNCHED_GAMEPC | GF_PLANAR
	},

	// Waxworks - German Amiga Floppy
	{
		{
			"waxworks",
			"Floppy",

			{
				{ "gameamiga",		GAME_BASEFILE,	"2938a17103de603c4c6f05e6a433b365", 44640},
				{ "icon.pkd",		GAME_ICONFILE,	"4822a91c18b1b2005ac17fc617f7dcbe", 18940},
				{ "menus.dat",		GAME_MENUFILE,	"3409eeb8ca8b46fc04da99de67573f5e", 320},
				{ "start",			GAME_RESTFILE,	"b575b336e741dde1725edd4079d5ab67", 20902},
				{ "stripped.txt",	GAME_STRFILE,	"6faaebff2786216900061eeb978f10af", 225},
				{ "tbllist",		GAME_TBLFILE,	"95c44bfc380770a6b6dd0dfcc69e80a0", 309},
				{ "xtbllist",		GAME_XTBLFILE,	"6c7b3db345d46349a5226f695c03e20f", 88},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GUIO_NOMIDI, GAMEOPTION_COPY_PROTECTION)
		},

		GType_WW,
		GID_WAXWORKS,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_CRUNCHED_GAMEPC | GF_PLANAR
	},

	// Waxworks - French Amiga Floppy
	// Supplied by CaptainHIT in bug report #11597
	{
		{
			"waxworks",
			"Floppy",

			{
				{ "gameamiga",		GAME_BASEFILE,	"06531f4677496b73184dfc58f641c19f", 44204},
				{ "icon.pkd",		GAME_ICONFILE,	"4822a91c18b1b2005ac17fc617f7dcbe", 18940},
				{ "menus.dat",		GAME_MENUFILE,	"3409eeb8ca8b46fc04da99de67573f5e", 320},
				{ "start",			GAME_RESTFILE,	"b575b336e741dde1725edd4079d5ab67", 20902},
				{ "stripped.txt",	GAME_STRFILE,	"6faaebff2786216900061eeb978f10af", 225},
				{ "tbllist",		GAME_TBLFILE,	"95c44bfc380770a6b6dd0dfcc69e80a0", 309},
				{ "xtbllist",		GAME_XTBLFILE,	"6c7b3db345d46349a5226f695c03e20f", 88},
				AD_LISTEND
			},
			Common::FR_FRA,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GUIO_NOMIDI, GAMEOPTION_COPY_PROTECTION)
		},

		GType_WW,
		GID_WAXWORKS,
		GF_OLD_BUNDLE | GF_CRUNCHED | GF_CRUNCHED_GAMEPC | GF_PLANAR
	},

	// Waxworks - English DOS Floppy Demo
	{
		{
			"waxworks",
			"Non-Interactive Demo",

			{
				{ "demo",			GAME_BASEFILE,	"50704abde6c68a226001400461620129", 7238},
				{ "icon.dat",		GAME_ICONFILE,	"ef1b8ad3494cf103dc10a99fe152ef9a", 20901},
				{ "menus.dat",		GAME_MENUFILE,	"c4103f122d27677c9db144cae1394a66", 2},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_DEMO,
			GUIO3(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_PREFER_DIGITAL_SFX)
		},

		GType_WW,
		GID_WAXWORKS,
		GF_OLD_BUNDLE | GF_DEMO
	},

	// Waxworks - English DOS Floppy
	{
		{
			"waxworks",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"7751e9358e894e32ef40ef3b3bae0f2a", 51327},
				{ "icon.dat",		GAME_ICONFILE,	"ef1b8ad3494cf103dc10a99fe152ef9a", 20901},
				{ "menus.dat",		GAME_MENUFILE,	"3409eeb8ca8b46fc04da99de67573f5e", 320},
				{ "roomslst",		GAME_RMSLFILE,	"e3758c46ab8f3c23a1ac012bd607108d", 128},
				{ "start",			GAME_RESTFILE,	"036b647973d6884cdfc2042a3d12df83", 15354},
				{ "statelst",		GAME_STATFILE,	"469e98c69f00928a8366ba415d91902d", 11104},
				{ "stripped.txt",	GAME_STRFILE,	"f259e3e07a1cde8d0404a767d815e12c", 225},
				{ "tbllist",		GAME_TBLFILE,	"95c44bfc380770a6b6dd0dfcc69e80a0", 309},
				{ "xtbllist",		GAME_XTBLFILE,	"6c7b3db345d46349a5226f695c03e20f", 88},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO4(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_PREFER_DIGITAL_SFX, GAMEOPTION_COPY_PROTECTION)
		},

		GType_WW,
		GID_WAXWORKS,
		GF_OLD_BUNDLE
	},

	// Waxworks - French DOS Floppy
	{
		{
			"waxworks",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"7edfdcccbf7627532882192c1a356150", 53681},
				{ "icon.dat",		GAME_ICONFILE,	"ef1b8ad3494cf103dc10a99fe152ef9a", 20901},
				{ "menus.dat",		GAME_MENUFILE,	"3409eeb8ca8b46fc04da99de67573f5e", 320},
				{ "roomslst",		GAME_RMSLFILE,	"e3758c46ab8f3c23a1ac012bd607108d", 128},
				{ "start",			GAME_RESTFILE,	"036b647973d6884cdfc2042a3d12df83", 15354},
				{ "statelst",		GAME_STATFILE,	"469e98c69f00928a8366ba415d91902d", 11104},
				{ "stripped.txt",	GAME_STRFILE,	"f259e3e07a1cde8d0404a767d815e12c", 225},
				{ "tbllist",		GAME_TBLFILE,	"95c44bfc380770a6b6dd0dfcc69e80a0", 309},
				{ "xtbllist",		GAME_XTBLFILE,	"6c7b3db345d46349a5226f695c03e20f", 88},
				AD_LISTEND
			},
			Common::FR_FRA,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO4(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_PREFER_DIGITAL_SFX, GAMEOPTION_COPY_PROTECTION)
		},

		GType_WW,
		GID_WAXWORKS,
		GF_OLD_BUNDLE
	},

	// Waxworks - German DOS Floppy
	{
		{
			"waxworks",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"32ee34134422e286525c73e71bd0ea2d", 53523},
				{ "icon.dat",		GAME_ICONFILE,	"ef1b8ad3494cf103dc10a99fe152ef9a", 20901},
				{ "menus.dat",		GAME_MENUFILE,	"3409eeb8ca8b46fc04da99de67573f5e", 320},
				{ "roomslst",		GAME_RMSLFILE,	"e3758c46ab8f3c23a1ac012bd607108d", 128},
				{ "start",			GAME_RESTFILE,	"036b647973d6884cdfc2042a3d12df83", 15354},
				{ "statelst",		GAME_STATFILE,	"469e98c69f00928a8366ba415d91902d", 11104},
				{ "stripped.txt",	GAME_STRFILE,	"f259e3e07a1cde8d0404a767d815e12c", 225},
				{ "tbllist",		GAME_TBLFILE,	"95c44bfc380770a6b6dd0dfcc69e80a0", 309},
				{ "xtbllist",		GAME_XTBLFILE,	"6c7b3db345d46349a5226f695c03e20f", 88},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO4(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_PREFER_DIGITAL_SFX, GAMEOPTION_COPY_PROTECTION)
		},

		GType_WW,
		GID_WAXWORKS,
		GF_OLD_BUNDLE
	},

	// Waxworks - Spanish DOS Floppy
	{
		{
			"waxworks",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"b0d513069920a5e2eac2ea5d290692f1", 53307},
				{ "icon.dat",		GAME_ICONFILE,	"ef1b8ad3494cf103dc10a99fe152ef9a", 20901},
				{ "menus.dat",		GAME_MENUFILE,	"3409eeb8ca8b46fc04da99de67573f5e", 320},
				{ "roomslst",		GAME_RMSLFILE,	"e3758c46ab8f3c23a1ac012bd607108d", 128},
				{ "start",			GAME_RESTFILE,	"036b647973d6884cdfc2042a3d12df83", 15354},
				{ "statelst",		GAME_STATFILE,	"469e98c69f00928a8366ba415d91902d", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"f259e3e07a1cde8d0404a767d815e12c", 225},
				{ "tbllist",		GAME_TBLFILE,	"95c44bfc380770a6b6dd0dfcc69e80a0", 309},
				{ "xtbllist",		GAME_XTBLFILE,	"6c7b3db345d46349a5226f695c03e20f", 88},
				AD_LISTEND
			},
			Common::ES_ESP,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO4(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_PREFER_DIGITAL_SFX, GAMEOPTION_COPY_PROTECTION)
		},

		GType_WW,
		GID_WAXWORKS,
		GF_OLD_BUNDLE
	},

	// Simon the Sorcerer 1 - English Acorn Floppy Demo
	{
		{
			"simon1",
			"Floppy Demo",

			{
				{ "gamebase",	GAME_BASEFILE,	"a12b696170f14eca5ff75f1549829251", 24850},
				{ "icondata",	GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "stripped",	GAME_STRFILE,	"8edde5b9498dc9f31da1093028da467c", 27},
				{ "tbllist",	GAME_TBLFILE,	"1247e024e1f13ca54c1e354120c7519c", 105},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAcorn,
			ADGF_DEMO,
			GUIO3(GUIO_NOSPEECH, GUIO_NOMIDI, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_OLD_BUNDLE
	},

	// Simon the Sorcerer 1 - English Acorn Floppy
	{
		{
			"simon1",
			"Floppy",

			{
				{ "gamebase",	GAME_BASEFILE,	"c392e494dcabed797b98cbcfc687b33a", 36980},
				{ "icondata",	GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "stripped",	GAME_STRFILE,	"c95a0a1ee973e19c2a1c5d12026c139f", 252},
				{ "tbllist",	GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAcorn,
			ADGF_NO_FLAGS,
			GUIO4(GUIO_NOSPEECH, GUIO_NOMIDI, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_OLD_BUNDLE
	},

	// Simon the Sorcerer 1 - English Acorn CD Demo
	{
		{
			"simon1",
			"CD Demo",

			{
				{ "data",		GAME_GMEFILE,	"b4a7526ced425ba8ad0d548d0ec69900", 1237886},
				{ "gamebase",	GAME_BASEFILE,	"425c7d1957699d35abca7e12a08c7422", 30879},
				{ "icondata",	GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "stripped",	GAME_STRFILE,	"d9de7542612d9f4e0819ad0df5eac56b", 252},
				{ "tbllist",	GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAcorn,
			ADGF_DEMO,
			GUIO3(GUIO_NOSUBTITLES, GAMEOPTION_WINDOWS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - English Acorn CD
	{
		{
			"simon1",
			"CD",

			{
				{ "data",		GAME_GMEFILE,	"64958b3a38afdcb85da1eeed85169806", 6943110},
				{ "gamebase",	GAME_BASEFILE,	"28261b99cd9da1242189b4f6f2841bd6", 29176},
				{ "icondata",	GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "stripped",	GAME_STRFILE,	"f3b27a3fbb45dcd323a48159496e45e8", 252},
				{ "tbllist",	GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAcorn,
			ADGF_CD,
			GUIO3(GUIO_NOSUBTITLES, GAMEOPTION_WINDOWS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - English Amiga OCS Floppy
	{
		{
			"simon1",
			"OCS Floppy",

			{
				{ "gameamiga",		GAME_BASEFILE,	"bb94a688e247695d912cce9d0173d73a", 37991},
				{ "icon.pkd",		GAME_ICONFILE,	"565ef7a98dcc21ef526a2bb10b6f42ed", 18979},
				{ "stripped.txt",	GAME_STRFILE,	"f5fc67db3b8c5283cda51c43b98a74f8", 243},
				{ "tbllist",		GAME_TBLFILE,	"f9d5bf2ce09f82289c791c3ca26e1e4b", 696},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO4(GUIO_NOSPEECH, GUIO_NOMIDI, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_32COLOR | GF_CRUNCHED | GF_OLD_BUNDLE | GF_PLANAR
	},

	// Simon the Sorcerer 1 - English Amiga OCS Demo
	{
		{
			"simon1",
			"OCS Demo",

			{
				{ "gameamiga",		GAME_BASEFILE,	"4696309eed9d7335c62ebb87a0f006ad", 12764},
				{ "icon.pkd",		GAME_ICONFILE,	"ebc96af15bfaf75ba8210326b9260d2f", 9124},
				{ "stripped.txt",	GAME_STRFILE,	"8edde5b9498dc9f31da1093028da467c", 27},
				{ "tbllist",		GAME_TBLFILE,	"1247e024e1f13ca54c1e354120c7519c", 105},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAmiga,
			ADGF_DEMO,
			GUIO3(GUIO_NOSPEECH, GUIO_NOMIDI, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_32COLOR | GF_CRUNCHED | GF_CRUNCHED_GAMEPC | GF_OLD_BUNDLE | GF_PLANAR
	},

	// Simon the Sorcerer 1 - German Amiga OCS Floppy
	{
		{
			"simon1",
			"OCS Floppy",

			{
				{ "gameamiga",		GAME_BASEFILE,	"634c82b7a0b760214fd71add328c7a00", 39493},
				{ "icon.pkd",		GAME_ICONFILE,	"565ef7a98dcc21ef526a2bb10b6f42ed", 18979},
				{ "stripped.txt",	GAME_STRFILE,	"f5fc67db3b8c5283cda51c43b98a74f8", 243},
				{ "tbllist",		GAME_TBLFILE,	"f9d5bf2ce09f82289c791c3ca26e1e4b", 696},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO4(GUIO_NOSPEECH, GUIO_NOMIDI, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_32COLOR | GF_CRUNCHED | GF_OLD_BUNDLE | GF_PLANAR
	},

	// Simon the Sorcerer 1 - English Amiga AGA Floppy
	{
		{
			"simon1",
			"AGA Floppy",

			{
				{ "gameamiga",		GAME_BASEFILE,	"6c9ad2ff571d34a4cf0c696cf4e13500", 38057},
				{ "icon.pkd",		GAME_ICONFILE,	"565ef7a98dcc21ef526a2bb10b6f42ed", 18979},
				{ "stripped.txt",	GAME_STRFILE,	"c649fcc0439766810e5097ee7e81d4c8", 243},
				{ "tbllist",		GAME_TBLFILE,	"f9d5bf2ce09f82289c791c3ca26e1e4b", 696},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO4(GUIO_NOSPEECH, GUIO_NOMIDI, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_CRUNCHED | GF_OLD_BUNDLE | GF_PLANAR
	},

	// Simon the Sorcerer 1 - French Amiga AGA Floppy
	{
		{
			"simon1",
			"AGA Floppy",

			{
				{ "gameamiga",		GAME_BASEFILE,	"bd9828b9d4e5d89b50fe8c47a8e6bc07", AD_NO_SIZE},
				{ "icon.pkd",		GAME_ICONFILE,	"565ef7a98dcc21ef526a2bb10b6f42ed", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"2297baec985617d0d5612a0124bac359", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"f9d5bf2ce09f82289c791c3ca26e1e4b", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::FR_FRA,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO4(GUIO_NOSPEECH, GUIO_NOMIDI, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_CRUNCHED | GF_OLD_BUNDLE | GF_PLANAR
	},

	// Simon the Sorcerer 1 - German Amiga AGA Floppy
	{
		{
			"simon1",
			"AGA Floppy",

			{
				{ "gameamiga",		GAME_BASEFILE,	"a2de9553f3b73064369948b5af38bb30", AD_NO_SIZE},
				{ "icon.pkd",		GAME_ICONFILE,	"565ef7a98dcc21ef526a2bb10b6f42ed", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"c649fcc0439766810e5097ee7e81d4c8", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"f9d5bf2ce09f82289c791c3ca26e1e4b", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO4(GUIO_NOSPEECH, GUIO_NOMIDI, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_CRUNCHED | GF_OLD_BUNDLE | GF_PLANAR
	},

	// Simon the Sorcerer 1 - Italian Amiga AGA Floppy
	{
		{
			"simon1",
			"AGA Floppy",

			{
				{ "gameamiga",		GAME_BASEFILE,	"55dc304e7d3f8ad518af3b7f69da02b6", 38941},
				{ "icon.pkd",		GAME_ICONFILE,	"565ef7a98dcc21ef526a2bb10b6f42ed", 18979},
				{ "stripped.txt",	GAME_STRFILE,	"c649fcc0439766810e5097ee7e81d4c8", 243},
				{ "tbllist",		GAME_TBLFILE,	"f9d5bf2ce09f82289c791c3ca26e1e4b", 696},
				AD_LISTEND
			},
			Common::IT_ITA,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO4(GUIO_NOSPEECH, GUIO_NOMIDI, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_CRUNCHED | GF_OLD_BUNDLE | GF_PLANAR
	},

	// Simon the Sorcerer 1 - Italian Amiga 9-Floppy version
	// Bugreport #10963
	{
		{
			"simon1",
			"Floppy",

			{
				{ "gameamiga",		GAME_BASEFILE,	"bd5c70845f2506e8d44b9c39b82db699", 38875},
				{ "icon.pkd",		GAME_ICONFILE,	"565ef7a98dcc21ef526a2bb10b6f42ed", 18979},
				{ "stripped.txt",	GAME_STRFILE,	"f5fc67db3b8c5283cda51c43b98a74f8", 243},
				{ "tbllist",		GAME_TBLFILE,	"f9d5bf2ce09f82289c791c3ca26e1e4b", 696},
				AD_LISTEND
			},
			Common::IT_ITA,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO4(GUIO_NOSPEECH, GUIO_NOMIDI, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_CRUNCHED | GF_OLD_BUNDLE | GF_PLANAR
	},

	// Simon the Sorcerer 1 - English Amiga CD32
	{
		{
			"simon1",
			"CD32",

			{
				{ "gameamiga",		GAME_BASEFILE,	"bab7f19237cf7d7619b6c73631da1854", 30139},
				{ "icon.pkd",		GAME_ICONFILE,	"565ef7a98dcc21ef526a2bb10b6f42ed", 18979},
				{ "stripped.txt",	GAME_STRFILE,	"59be788020441e21861e284236fd08c1", 243},
				{ "tbllist",		GAME_TBLFILE,	"f9d5bf2ce09f82289c791c3ca26e1e4b", 696},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAmiga,
			ADGF_CD,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMIDI, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1CD32,
		GF_TALKIE | GF_OLD_BUNDLE | GF_PLANAR
	},

	// Simon the Sorcerer 1 - English Amiga CD32 alternative?
	{
		{
			"simon1",
			"CD32",

			{
				{ "gameamiga",		GAME_BASEFILE,	"ec5358680c117f29b128cbbb322111a4", AD_NO_SIZE},
				{ "icon.pkd",		GAME_ICONFILE,	"8ce5a46466a4f8f6d0f780b0ef00d5f5", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"59be788020441e21861e284236fd08c1", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"f9d5bf2ce09f82289c791c3ca26e1e4b", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAmiga,
			ADGF_CD,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMIDI, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1CD32,
		GF_TALKIE | GF_OLD_BUNDLE | GF_PLANAR
	},

		// Simon the Sorcerer 1 - English Amiga CD32 demo, from the cover disc of
		// issue 5 (October 1994) of Amiga CD32 Gamer
	{
		{
			"simon1",
			"CD32 Demo",

			{
				{ "gameamiga",		GAME_BASEFILE,	"e243f9229f9728b3476e54d2cf5f18a1", 27998},
				{ "icon.pkd",		GAME_ICONFILE,	"565ef7a98dcc21ef526a2bb10b6f42ed", 18979},
				{ "stripped.txt",	GAME_STRFILE,	"94413c71c86c32ed9baaa1c74a151cb3", 243},
				{ "tbllist",		GAME_TBLFILE,	"f9d5bf2ce09f82289c791c3ca26e1e4b", 696},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAmiga,
			ADGF_CD | ADGF_DEMO,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMIDI, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1CD32,
		GF_TALKIE | GF_OLD_BUNDLE | GF_PLANAR
	},


	// Simon the Sorcerer 1 - English DOS Floppy Demo
	{
		{
			"simon1",
			"Floppy Demo",

			{
				{ "gdemo",			GAME_BASEFILE,	"2be4a21bc76e2fdc071867c130651439", 25288},
				{ "icon.dat",		GAME_ICONFILE,	"55af3b4d93972bc58bfee38a86b76c3f", 11495},
				{ "stripped.txt",	GAME_STRFILE,	"33a2e329b97b2a349858d6a093159eb7", 27},
				{ "tbllist",		GAME_TBLFILE,	"1247e024e1f13ca54c1e354120c7519c", 105},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_DEMO,
			GUIO3(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1DOS,
		GF_OLD_BUNDLE | GF_DEMO
	},

	// Simon the Sorcerer 1 - English DOS Floppy
	{
		{
			"simon1",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"c392e494dcabed797b98cbcfc687b33a", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"c95a0a1ee973e19c2a1c5d12026c139f", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO5(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1DOS,
		GF_OLD_BUNDLE
	},

	// Simon the Sorcerer 1 - English DOS Floppy with Czech patch
	{
		{
			"simon1",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"62de24fc579b94fac7d3d23201b65b14", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"c95a0a1ee973e19c2a1c5d12026c139f", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::CS_CZE,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO5(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1DOS,
		GF_OLD_BUNDLE
	},

	// Simon the Sorcerer 1 - English DOS Floppy with Russian patch
	{
		{
			"simon1",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"605fb866e03ec1c41b10c6a518ddfa49", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"c95a0a1ee973e19c2a1c5d12026c139f", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::RU_RUS,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO5(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1DOS,
		GF_OLD_BUNDLE
	},

	// Simon the Sorcerer 1 - English DOS Floppy (Infocom)
	{
		{
			"simon1",
			"Infocom Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"9f93d27432ce44a787eef10adb640870", 37070},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "stripped.txt",	GAME_STRFILE,	"2af9affc5981eec44b90d4c556145cb8", 252},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO5(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1DOS,
		GF_OLD_BUNDLE
	},

	// Simon the Sorcerer 1 - English DOS Floppy (Infocom) with Czech patch
	{
		{
			"simon1",
			"Infocom Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"62de24fc579b94fac7d3d23201b65b14", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"2af9affc5981eec44b90d4c556145cb8", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::CS_CZE,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO5(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1DOS,
		GF_OLD_BUNDLE
	},

	// Simon the Sorcerer 1 - English DOS Floppy (Infocom) with Russian patch
	{
		{
			"simon1",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"605fb866e03ec1c41b10c6a518ddfa49", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"2af9affc5981eec44b90d4c556145cb8", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::RU_RUS,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO5(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1DOS,
		GF_OLD_BUNDLE
	},

	// Simon the Sorcerer 1 - French DOS Floppy
	{
		{
			"simon1",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"34759d0d4285a2f4b21b8e03b8fcefb3", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"aa01e7386057abc0c3e27dbaa9c4ba5b", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::FR_FRA,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO5(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1DOS,
		GF_OLD_BUNDLE
	},

	// Simon the Sorcerer 1 - German DOS Floppy
	{
		{
			"simon1",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"063015e6ce7d90b570dbc21fe0c667b1", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"c95a0a1ee973e19c2a1c5d12026c139f", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO5(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1DOS,
		GF_OLD_BUNDLE
	},

	// Simon the Sorcerer 1 - Italian DOS Floppy
	{
		{
			"simon1",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"65c9b2dea57df84ef55d1eaf384ebd30", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"2af9affc5981eec44b90d4c556145cb8", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::IT_ITA,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO5(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1DOS,
		GF_OLD_BUNDLE
	},

	// Simon the Sorcerer 1 - Spanish DOS Floppy
	{
		{
			"simon1",
			"Floppy",

			{
				{ "gamepc",			GAME_BASEFILE,	"5374fafdea2068134f33deab225feed3", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"2af9affc5981eec44b90d4c556145cb8", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::ES_ESP,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO5(GUIO_NOSPEECH, GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON1,
		GID_SIMON1DOS,
		GF_OLD_BUNDLE
	},

	// Simon the Sorcerer 1 - English DOS CD Demo
	{
		{
			"simon1",
			"CD Demo",

			{
				{ "simon.gme",		GAME_GMEFILE,	"b4a7526ced425ba8ad0d548d0ec69900", 1237886},
				{ "gamepc"	,		GAME_BASEFILE,	"425c7d1957699d35abca7e12a08c7422", 30879},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "stripped.txt",	GAME_STRFILE,	"d9de7542612d9f4e0819ad0df5eac56b", 252},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_DEMO,
			GUIO4(GUIO_NOSUBTITLES, GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - English DOS CD Demo from Zork Anthology CD
	// Bugreport #11200
	{
		{
			"simon1",
			"CD Demo",

			{
				{ "simon.gme",		GAME_GMEFILE,	"a8c91fe4f316b3e047d6782811eb1b70", 1236298},
				{ "gamepc"	,		GAME_BASEFILE,	"425c7d1957699d35abca7e12a08c7422", 30879},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "stripped.txt",	GAME_STRFILE,	"d9de7542612d9f4e0819ad0df5eac56b", 252},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_DEMO,
			GUIO4(GUIO_NOSUBTITLES, GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - English DOS CD
	{
		{
			"simon1",
			"CD",

			{
				{ "gamepc",			GAME_BASEFILE,	"28261b99cd9da1242189b4f6f2841bd6", 29176},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "simon.gme",		GAME_GMEFILE,	"64958b3a38afdcb85da1eeed85169806", 6943110},
				{ "stripped.txt",	GAME_STRFILE,	"f3b27a3fbb45dcd323a48159496e45e8", 252},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO4(GUIO_NOSUBTITLES, GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - English DOS CD  (Infocom)
	{
		{
			"simon1",
			"Infocom CD",

			{
				{ "gamepc",			GAME_BASEFILE,	"c0b948b6821d2140f8b977144f21027a", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", AD_NO_SIZE},
				{ "simon.gme",		GAME_GMEFILE,	"64f73e94639b63af846ac4a8a94a23d8", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"f3b27a3fbb45dcd323a48159496e45e8", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO4(GUIO_NOSUBTITLES, GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - English DOS CD with Russian patch
	{
		{
			"simon1",
			"CD",

			{
				{ "gamepc",			GAME_BASEFILE,	"3fac46064f69e5298f4f027f204c5aab", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", AD_NO_SIZE},
				{ "simon.gme",		GAME_GMEFILE,	"91321f0d806f8d9fef71a00e58581427", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"ef51ac74c946881ae4d7ca66cc7a0d1e", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::RU_RUS,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO3(GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - French DOS CD
	{
		{
			"simon1",
			"CD",

			{
				{ "gamepc",			GAME_BASEFILE,	"3cfb9d1ff4ec725af9924140126cf69f", 39310},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "simon.gme",		GAME_GMEFILE,	"638049fa5d41b81fb6fb11671721b871", 7041803},
				{ "stripped.txt",	GAME_STRFILE,	"ef51ac74c946881ae4d7ca66cc7a0d1e", 252},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::FR_FRA,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO3(GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - German DOS CD
	{
		{
			"simon1",
			"CD",

			{
				{ "gamepc",			GAME_BASEFILE,	"48b1f3499e2e0d731047f4d481ff7817", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", AD_NO_SIZE},
				{ "simon.gme",		GAME_GMEFILE,	"7db9912acac4f1d965a64bdcfc370ba1", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"40d68bec54042ef930f084ad9a4342a1", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO4(GUIO_NOSUBTITLES, GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - Hebrew DOS CD
	{
		{
			"simon1",
			"CD",

			{
				{ "gamepc",			GAME_BASEFILE,	"bc66e9c0b296e1b155a246917133f71a", 34348},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "simon.gme",		GAME_GMEFILE,	"a34b2c8642f2e3676d7088b5c8b3e884", 6976948},
				{ "stripped.txt",	GAME_STRFILE,	"9d31bef42db1a8abe4e9f368014df1d5", 252},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::HE_ISR,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO3(GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - Hebrew DOS CD - Fan Dub, make sure to delete SIMON.WAV if you have it
	{
		{
			"simon1",
			"CD, Fan Dub",

			{
				{ "simon.gme",		GAME_GMEFILE,	"19f57784a1b83d238870b3eac49cccc1", 6976776},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "gamepc",			GAME_BASEFILE,	"5bea08657999726d8332e96cda670591", 34615},
				{ "stripped.txt",	GAME_STRFILE,	"9d31bef42db1a8abe4e9f368014df1d5", 252},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				{ NULL, 0, NULL, 0}
			},
			Common::HE_ISR,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO3(GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - Italian DOS CD
	{
		{
			"simon1",
			"CD",

			{
				{ "gamepc",			GAME_BASEFILE,	"8d3ca654e158c91b860c7eae31d65312", 37807},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "simon.gme",		GAME_GMEFILE,	"52e315e0e02feca86d15cc82e3306b6c", 7035767},
				{ "stripped.txt",	GAME_STRFILE,	"9d31bef42db1a8abe4e9f368014df1d5", 252},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::IT_ITA,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO3(GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - Italian DOS CD alternate
	{
		{
			"simon1",
			"CD",

			{
				{ "gamepc",			GAME_BASEFILE,	"8d3ca654e158c91b860c7eae31d65312", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", AD_NO_SIZE},
				{ "simon.gme",		GAME_GMEFILE,	"104efd83c8f3edf545982e07d87f66ac", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"9d31bef42db1a8abe4e9f368014df1d5", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", AD_NO_SIZE},
				AD_LISTEND
			},
			// FIXME: DOS version which uses WAV format
			Common::IT_ITA,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO3(GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - Spanish DOS CD
	{
		{
			"simon1",
			"CD",

			{
				{ "gamepc",			GAME_BASEFILE,	"439f801ba52c02c9d1844600d1ce0f5e", 37847},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "simon.gme",		GAME_GMEFILE,	"eff2774a73890b9eac533db90cd1afa1", 7030485},
				{ "stripped.txt",	GAME_STRFILE,	"9d31bef42db1a8abe4e9f368014df1d5", 252},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::ES_ESP,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO3(GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - English Windows CD
	{
		{
			"simon1",
			"CD",

			{
				{ "gamepc",			GAME_BASEFILE,	"c7c12fea7f6d0bfd22af5cdbc8166862", 36152},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "simon.gme",		GAME_GMEFILE,	"b1b18d0731b64c0738c5cc4a2ee792fc", 7030377},
				{ "stripped.txt",	GAME_STRFILE,	"a27e87a9ba21212d769804b3df47bfb2", 252},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO3(GUIO_NOSUBTITLES, GAMEOPTION_WINDOWS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - German Windows CD
	{
		{
			"simon1",
			"CD",

			{
				{ "gamepc",			GAME_BASEFILE,	"48b1f3499e2e0d731047f4d481ff7817", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", AD_NO_SIZE},
				{ "simon.gme",		GAME_GMEFILE,	"acd9cc438525b142d93b15c77a6f551b", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"40d68bec54042ef930f084ad9a4342a1", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO3(GUIO_NOSUBTITLES, GAMEOPTION_WINDOWS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - 25th Anniversary Edition - English CD
	{
		{
			"simon1",
			"25th Anniversary Edition",

			{
				{ "gamepc",			GAME_BASEFILE,	"a21272b3c51ebd18bcbfe88715340924", 36191},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "simon.gme",		GAME_GMEFILE,	"b1b18d0731b64c0738c5cc4a2ee792fc", 7030377},
				{ "stripped.txt",	GAME_STRFILE,	"a27e87a9ba21212d769804b3df47bfb2", 252},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO3(GUIO_NOSUBTITLES, GAMEOPTION_WINDOWS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - 25th Anniversary Edition - Spanish CD
	{
		{
			"simon1",
			"25th Anniversary Edition",

			{
				{ "gamepc",			GAME_BASEFILE,	"71adc00b0ee14a59ef4f969f2f52829d", 37877},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "simon.gme",		GAME_GMEFILE,	"eff2774a73890b9eac533db90cd1afa1", 7030485},
				{ "stripped.txt",	GAME_STRFILE,	"9d31bef42db1a8abe4e9f368014df1d5", 252},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::ES_ESP,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO3(GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - 25th Anniversary Edition - French CD
	{
		{
			"simon1",
			"25th Anniversary Edition",

			{
				{ "gamepc",			GAME_BASEFILE,	"226e152e0d2333d46c091a0b71de84f0", 39354},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "simon.gme",		GAME_GMEFILE,	"638049fa5d41b81fb6fb11671721b871", 7041803},
				{ "stripped.txt",	GAME_STRFILE,	"ef51ac74c946881ae4d7ca66cc7a0d1e", 252},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::FR_FRA,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO3(GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - 25th Anniversary Edition - Hebrew CD Subtitled
	{
		{
			"simon1",
			"25th Anniversary Edition",

			{
				{ "gamepc",			GAME_BASEFILE,	"c5a1fe539d96e22e12b7b6e2576090ad", 34376},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "simon.gme",		GAME_GMEFILE,	"a34b2c8642f2e3676d7088b5c8b3e884", 6976948},
				{ "stripped.txt",	GAME_STRFILE,	"9d31bef42db1a8abe4e9f368014df1d5", 252},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::HE_ISR,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO3(GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 1 - 25th Anniversary Edition - Italian CD
	{
		{
			"simon1",
			"25th Anniversary Edition",

			{
				{ "gamepc",			GAME_BASEFILE,	"6fd37fefa04315fdd5889e52e4c01731", 37840},
				{ "icon.dat",		GAME_ICONFILE,	"22107c24dfb31b66ac503c28a6e20b19", 14361},
				{ "simon.gme",		GAME_GMEFILE,	"52e315e0e02feca86d15cc82e3306b6c", 7035767},
				{ "stripped.txt",	GAME_STRFILE,	"9d31bef42db1a8abe4e9f368014df1d5", 252},
				{ "tbllist",		GAME_TBLFILE,	"d198a80de2c59e4a0cd24b98814849e8", 711},
				AD_LISTEND
			},
			Common::IT_ITA,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO3(GAMEOPTION_OPL3_MODE, GAMEOPTION_DOS_TEMPOS, GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON1,
		GID_SIMON1,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - English DOS Floppy
	{
		{
			"simon2",
			"Floppy",

			{
				{ "game32",			GAME_BASEFILE,	"604d04315935e77624bd356ac926e068", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"aa6840420899a31874204f90bb214108", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"e229f84d46fa83f99b4a7115679f3fb6", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON2,
		GID_SIMON2,
		0
	},

	// Simon the Sorcerer 2 - English DOS Floppy with Russian patch
	{
		{
			"simon2",
			"Floppy",

			{
				{ "game32",			GAME_BASEFILE,	"7edfc633dd50f8caa719c478443db70b", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"aa6840420899a31874204f90bb214108", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"e229f84d46fa83f99b4a7115679f3fb6", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::RU_RUS,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON2,
		GID_SIMON2,
		0
	},

	// Simon the Sorcerer 2 - German DOS Floppy
	{
		{
			"simon2",
			"Floppy",

			{
				{ "game32",			GAME_BASEFILE,	"eb6e3e37fe52993f948d7e2d6b869828", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"5fa9d080b04c610f526bd685be1bf747", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"fd30df01cc248ecbaef302af855e0212", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON2,
		GID_SIMON2,
		0
	},

	// Simon the Sorcerer 2 - German DOS Floppy alternate?
	{
		{
			"simon2",
			"Floppy",

			{
				{ "game32",			GAME_BASEFILE,	"604d04315935e77624bd356ac926e068", 59111},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", 18089},
				{ "simon2.gme",		GAME_GMEFILE,	"ec9f0f24fd895e7ea72e3c8e448c0240", 19698755},
				{ "stripped.txt",	GAME_STRFILE,	"6de6292c9ac11bfb2e70fdb0f773ba85", 171},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", 513},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON2,
		GID_SIMON2,
		0
	},

	// Simon the Sorcerer 2 - Italian DOS Floppy
	{
		{
			"simon2",
			"Floppy",

			{
				{ "game32",			GAME_BASEFILE,	"3e11d400bea0638f360a724687005cd1", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"f306a397565d7f13bec7ecf14c723de7", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"bea6843fb9f3b2144fcb146d62db0b9a", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::IT_ITA,
			Common::kPlatformDOS,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSPEECH, GAMEOPTION_DISABLE_FADE_EFFECTS, GAMEOPTION_COPY_PROTECTION)
		},

		GType_SIMON2,
		GID_SIMON2,
		0
	},

	// Simon the Sorcerer 2 - English DOS CD Demo
	{
		{
			"simon2",
			"CD Demo",

			{
				{ "gsptr30",		GAME_BASEFILE,	"3794c15887539b8578bacab694ccf08a", 58757},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", 18089},
				{ "simon2.gme",		GAME_GMEFILE,	"f8c9e6df1e55923a749e115ba74210c4", 4187270},
				{ "stripped.txt",	GAME_STRFILE,	"e229f84d46fa83f99b4a7115679f3fb6", 171},
				{ "tbllist",		GAME_TBLFILE,	"a0d5a494b5d3d209d1a1d76cc8d76601", 513},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_DEMO,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - German DOS CD Demo
	{
		{
			"simon2",
			"CD Demo",

			{
				{ "gsptr30",		GAME_BASEFILE,	"7596ef2644fde56ee5fad0dcd483a01e", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"3f308f201f6b1ddf7c2704c1fc43a3e1", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"4c68cf64e581a9bd638a56c900b08bfe", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"a0d5a494b5d3d209d1a1d76cc8d76601", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformDOS,
			ADGF_DEMO,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - German DOS CD Non-Interactive Demo
	{
		{
			"simon2",
			"CD Non-Interactive Demo",

			{
				{ "gsptr30",		GAME_BASEFILE,	"c45facd0605860684d464b6a62323567", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"30ea02d374327cab6c78444f3c198c1c", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"4c68cf64e581a9bd638a56c900b08bfe", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"a0d5a494b5d3d209d1a1d76cc8d76601", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformDOS,
			ADGF_DEMO,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - English DOS CD
	{
		{
			"simon2",
			"CD",

			{
				{ "gsptr30",		GAME_BASEFILE,	"8c301fb9c4fcf119d2730ccd2a565eb3", 58652},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", 18089},
				{ "simon2.gme",		GAME_GMEFILE,	"9c535d403966750ae98bdaf698375a38", 19687892},
				{ "stripped.txt",	GAME_STRFILE,	"e229f84d46fa83f99b4a7115679f3fb6", 171},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", 513},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - English DOS CD alternate?
	{
		{
			"simon2",
			"CD",

			{
				{ "gsptr30",		GAME_BASEFILE,	"608e277904d87dd28725fa08eacc2c0d", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"8d6dcc65577e285dbca03ff6d7d9323c", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"e229f84d46fa83f99b4a7115679f3fb6", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"a0d5a494b5d3d209d1a1d76cc8d76601", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - French DOS CD
	{
		{
			"simon2",
			"CD",

			{
				{ "gsptr30",		GAME_BASEFILE,	"43b3a04d2f0a0cbd1b024c814856561a", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"8af0e02c0c3344db64dffc12196eb59d", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"5ea27977b4d7dcfd50eb5074e162ebbf", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::FR_FRA,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - German DOS CD
	{
		{
			"simon2",
			"CD",

			{
				{ "gsptr30",		GAME_BASEFILE,	"0d05c3f4c06c9a4ceb3d2f5bc0b18e11", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"6c5fdfdd0eab9038767c2d22858406b2", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"6de6292c9ac11bfb2e70fdb0f773ba85", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - German DOS CD alternate?
	{
		{
			"simon2",
			"CD",

			{
				{ "gsptr30",		GAME_BASEFILE,	"a76ea940076b5d9316796dea225a9b69", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"ec9f0f24fd895e7ea72e3c8e448c0240", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"6de6292c9ac11bfb2e70fdb0f773ba85", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - Hebrew DOS CD
	{
		{
			"simon2",
			"CD",

			{
				{ "gsptr30",		GAME_BASEFILE,	"952a2b1be23c3c609ba8d988a9a1627d", 53366},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", 18089},
				{ "simon2.gme",		GAME_GMEFILE,	"a2b249a82ea182af09789eb95fb6c5be", 19650639},
				{ "stripped.txt",	GAME_STRFILE,	"de9dbc24158660e153483fa0cf6c3172", 171},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", 513},
				AD_LISTEND
			},
			Common::HE_ISR,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - Italian DOS CD
	{
		{
			"simon2",
			"CD",

			{
				{ "gsptr30",		GAME_BASEFILE,	"3e11d400bea0638f360a724687005cd1", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"344aca58e5ad5e25c517d5eb1d85c435", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"bea6843fb9f3b2144fcb146d62db0b9a", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			// FIXME: DOS version which uses WAV format
			Common::IT_ITA,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - Spanish DOS CD
	{
		{
			"simon2",
			"CD",

			{
				{ "gsptr30",		GAME_BASEFILE,	"268dc322aa73bcf27bb016b8e8ceb889", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"4f43bd06b6cc78dbd25a7475ca964eb1", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"d13753796bd81bf313a2449f34d8b112", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::ES_ESP,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - Russian DOS CD
	{
		{
			"simon2",
			"CD",

			{
				{ "gsptr30",		GAME_BASEFILE,	"e26d162e573587f4601b88701292212c", 58851},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", 18089},
				{ "simon2.gme",		GAME_GMEFILE,	"9c535d403966750ae98bdaf698375a38", 19687892},
				{ "stripped.txt",	GAME_STRFILE,	"e229f84d46fa83f99b4a7115679f3fb6", 171},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", 513},
				AD_LISTEND
			},
			Common::RU_RUS,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - Czech Windows CD
	{
		{
			"simon2",
			"CD",

			{
				{ "gsptr30",		GAME_BASEFILE,	"eb8217f9ec4628d12ca606033146c48c", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"2d1074788501c55dcd9e59269ea0aaed", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"e229f84d46fa83f99b4a7115679f3fb6", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::CS_CZE,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - English Windows CD
	{
		{
			"simon2",
			"CD",

			{
				{ "gsptr30",		GAME_BASEFILE,	"608e277904d87dd28725fa08eacc2c0d", 58652},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", 18089},
				{ "simon2.gme",		GAME_GMEFILE,	"e749c4c103d7e7d51b34620ed76c5a04", 20046789},
				{ "stripped.txt",	GAME_STRFILE,	"e229f84d46fa83f99b4a7115679f3fb6", 171},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", 513},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - French Windows CD
	{
		{
			"simon2",
			"CD",

			{
				{ "gsptr30",		GAME_BASEFILE,	"6e217d75f4089b92270fad879e091e29", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"1d2f867a7eba818c85c1e4849821e812", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"5ea27977b4d7dcfd50eb5074e162ebbf", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::FR_FRA,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - German Windows CD
	{
		{
			"simon2",
			"CD",

			{
				{ "gsptr30",		GAME_BASEFILE,	"a76ea940076b5d9316796dea225a9b69", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"9609a933c541fed2e00c6c3479d7c181", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"6de6292c9ac11bfb2e70fdb0f773ba85", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - Polish Windows CD
	{
		{
			"simon2",
			"CD",

			{
				{ "gsptr30",		GAME_BASEFILE,	"657fd873f5d0637097ee02315b447e6f", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"7b9afcf82a94722707e0d025c0192be8", AD_NO_SIZE},
				{ "stripped.txt",	GAME_STRFILE,	"e229f84d46fa83f99b4a7115679f3fb6", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::PL_POL,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - Polish Windows CD
	// Supplied by paboum Bugreport #11770
	{
		{
			"simon2",
			"CD",

			{
				{ "gsptr30",		GAME_BASEFILE,	"63b68bdd395baa108b865cfbc0f9afff", 58652},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", 18089},
				{ "simon2.gme",		GAME_GMEFILE,	"e749c4c103d7e7d51b34620ed76c5a04", 20046789},
				{ "stripped.txt",	GAME_STRFILE,	"e229f84d46fa83f99b4a7115679f3fb6", 171},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", 513},
				AD_LISTEND
			},
			Common::PL_POL,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE
	},

	// Simon the Sorcerer 2 - English with MT-32 hack (25th Anniversary Edition)
	// Bugreport #11394
	{
		{
			"simon2",
			"25th Anniversary Edition",

			{
				{ "gsptr30",        GAME_BASEFILE, "608e277904d87dd28725fa08eacc2c0d", 58652 },
				{ "icon.dat",       GAME_ICONFILE, "72096a62d36e6034ea9fecc13b2dbdab", 18089 },
				{ "simon2.gme",     GAME_GMEFILE, "d5e4e2e539565471774ecd22ebf15623", 20054555 },
				{ "stripped.txt",   GAME_STRFILE, "e229f84d46fa83f99b4a7115679f3fb6", 171 },
				{ "tbllist",        GAME_TBLFILE, "2082f8d02075e590300478853a91ffd9", 513 },
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE | GF_MT32_XMIDI | GF_MT32_TRACK10_FIX
	},

	// Simon the Sorcerer 2 - German with MT-32 hack (25th Anniversary Edition)
	{
		{
			"simon2",
			"25th Anniversary Edition",

			{
				{ "gsptr30",		GAME_BASEFILE, "a76ea940076b5d9316796dea225a9b69", 62346 },
				{ "icon.dat",		GAME_ICONFILE, "72096a62d36e6034ea9fecc13b2dbdab", 18089 },
				{ "simon2.gme",		GAME_GMEFILE, "8aab32f1ed8567b6b9fa46139a1e492c", 20065511 },
				{ "stripped.txt",	GAME_STRFILE, "6de6292c9ac11bfb2e70fdb0f773ba85", 171 },
				{ "tbllist",		GAME_TBLFILE, "2082f8d02075e590300478853a91ffd9", 513 },
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE | GF_MT32_XMIDI | GF_MT32_TRACK10_FIX
	},

	// Simon the Sorcerer 2 - French with MT-32 hack (25th Anniversary Edition)
	{
		{
			"simon2",
			"25th Anniversary Edition",

			{
				{ "gsptr30",		GAME_BASEFILE, "43b3a04d2f0a0cbd1b024c814856561a", 60857 },
				{ "icon.dat",		GAME_ICONFILE, "72096a62d36e6034ea9fecc13b2dbdab", 18089 },
				{ "simon2.gme",		GAME_GMEFILE, "d71807365d4e13063009ea0b9a849190", 20072692 },
				{ "stripped.txt",	GAME_STRFILE, "5ea27977b4d7dcfd50eb5074e162ebbf", 171 },
				{ "tbllist",		GAME_TBLFILE, "2082f8d02075e590300478853a91ffd9", 513 },
				AD_LISTEND
			},
			Common::FR_FRA,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE | GF_MT32_XMIDI | GF_MT32_TRACK10_FIX
	},

	// Simon the Sorcerer 2 - Russian Fan with MT-32 hack (25th Anniversary Edition)
	// Note: unlike the other 25th Anniversary versions, this uses VOC and XMIDI data.
	{
		{
			"simon2",
			"25th Anniversary Edition",

			{
				{ "gsptr30",        GAME_BASEFILE, "e26d162e573587f4601b88701292212c", 58851 },
				{ "icon.dat",       GAME_ICONFILE, "72096a62d36e6034ea9fecc13b2dbdab", 18089 },
				{ "simon2.gme",     GAME_GMEFILE, "f1727b15b3e389f0248363d890751ee7", 19695662 },
				{ "stripped.txt",   GAME_STRFILE, "e229f84d46fa83f99b4a7115679f3fb6", 171 },
				{ "tbllist",        GAME_TBLFILE, "2082f8d02075e590300478853a91ffd9", 513 },
				AD_LISTEND
			},
			Common::RU_RUS,
			Common::kPlatformDOS,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE | GF_MT32_TRACK10_FIX
	},

	// Simon the Sorcerer 2 - Polish with MT-32 hack (25th Anniversary Edition)
	{
		{
			"simon2",
			"25th Anniversary Edition",

			{
				{ "gsptr30",		GAME_BASEFILE,	"657fd873f5d0637097ee02315b447e6f", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"212fa5638a76869537d092d4e76524c0", 20037221},
				{ "stripped.txt",	GAME_STRFILE,	"e229f84d46fa83f99b4a7115679f3fb6", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::PL_POL,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE | GF_MT32_XMIDI | GF_MT32_TRACK10_FIX
	},

	// Simon the Sorcerer 2 - Hebrew with MT-32 hack (25th Anniversary Edition)
	{
		{
			"simon2",
			"25th Anniversary Edition",

			{
				{ "gsptr30",		GAME_BASEFILE,	"952a2b1be23c3c609ba8d988a9a1627d", 53366},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", 18089},
				{ "simon2.gme",		GAME_GMEFILE,	"40ac2d4763d97a9268023dc6db17e2ce", 20017302},
				{ "stripped.txt",	GAME_STRFILE,	"de9dbc24158660e153483fa0cf6c3172", 171},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", 513},
				AD_LISTEND
			},
			Common::HE_ISR,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE | GF_MT32_XMIDI | GF_MT32_TRACK10_FIX
	},

	// Simon the Sorcerer 2 - Italian with MT-32 hack (25th Anniversary Edition)
	{
		{
			"simon2",
			"25th Anniversary Edition",

			{
				{ "gsptr30",		GAME_BASEFILE,	"3e11d400bea0638f360a724687005cd1", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"510d012bcc5775a8513923163ffe4458", 20066490},
				{ "stripped.txt",	GAME_STRFILE,	"bea6843fb9f3b2144fcb146d62db0b9a", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::IT_ITA,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE | GF_MT32_XMIDI | GF_MT32_TRACK10_FIX
	},

	// Simon the Sorcerer 2 - Czech with MT-32 hack (25th Anniversary Edition)
	{
		{
			"simon2",
			"25th Anniversary Edition",

			{
				{ "gsptr30",		GAME_BASEFILE,	"eb8217f9ec4628d12ca606033146c48c", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"50188f9fde0d063c824476972936a52f", 20054555},
				{ "stripped.txt",	GAME_STRFILE,	"e229f84d46fa83f99b4a7115679f3fb6", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::CS_CZE,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE | GF_MT32_XMIDI | GF_MT32_TRACK10_FIX
	},

	// Simon the Sorcerer 2 - Spanish with MT-32 hack (25th Anniversary Edition)
	{
		{
			"simon2",
			"25th Anniversary Edition",

			{
				{ "gsptr30",		GAME_BASEFILE,	"268dc322aa73bcf27bb016b8e8ceb889", AD_NO_SIZE},
				{ "icon.dat",		GAME_ICONFILE,	"72096a62d36e6034ea9fecc13b2dbdab", AD_NO_SIZE},
				{ "simon2.gme",		GAME_GMEFILE,	"2b997db3c677fb3d2174c73ba2cc53e1", 20049608},
				{ "stripped.txt",	GAME_STRFILE,	"d13753796bd81bf313a2449f34d8b112", AD_NO_SIZE},
				{ "tbllist",		GAME_TBLFILE,	"2082f8d02075e590300478853a91ffd9", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::ES_ESP,
			Common::kPlatformWindows,
			ADGF_CD,
			GUIO1(GAMEOPTION_DISABLE_FADE_EFFECTS)
		},

		GType_SIMON2,
		GID_SIMON2,
		GF_TALKIE | GF_MT32_XMIDI | GF_MT32_TRACK10_FIX
	},

	// The Feeble Files - English DOS Demo
	{
		{
			"feeble",
			"Demo",

			{
				{ "MAINMENU.SMK",		GAME_VGAFILE,	"b62df52fc36f514eb0464120853f22b6", 968808},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformDOS,
			ADGF_DEMO,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_DEMO
	},

	// The Feeble Files - German DOS Demo
	{
		{
			"feeble",
			"Demo",

			{
				{ "MAINMENU.SMK",		GAME_VGAFILE,	"e18d365044eabea7352934917bbfd2e4", 976436},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformDOS,
			ADGF_DEMO,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_DEMO
	},

	// The Feeble Files - English Amiga CD
	{
		{
			"feeble",
			"CD",

			{
				{ "game22",			GAME_BASEFILE,	"629762ea9ca9ee9ff85f4774d219f5c7", 259576},
				{ "gfxindex.dat",	GAME_GFXIDXFILE,"f550f7915c5ce3a68c9f870f507449c2", 48000},
				{ "setup",			GAME_RESTFILE,	"71512fc98501a8071a26b683a31dde78", 3360},
				{ "tbllist",		GAME_TBLFILE,	"0bbfee8e69739111eb36b0d138da8ddf", 668},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_ZLIBCOMP | GF_TALKIE
	},

	// The Feeble Files - German Amiga CD
	{
		{
			"feeble",
			"CD",

			{
				{ "game22",			GAME_BASEFILE,	"bcd76ac080003eee3649df18db25b60e", 262517},
				{ "gfxindex.dat",	GAME_GFXIDXFILE,"f550f7915c5ce3a68c9f870f507449c2", 48000},
				{ "setup",			GAME_RESTFILE,	"71512fc98501a8071a26b683a31dde78", 3360},
				{ "tbllist",		GAME_TBLFILE,	"0bbfee8e69739111eb36b0d138da8ddf", 668},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformAmiga,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_ZLIBCOMP | GF_TALKIE
	},

	// The Feeble Files - English Macintosh CD
	{
		{
			"feeble",
			"CD",

			{
				{ "game22",			GAME_BASEFILE,	"629762ea9ca9ee9ff85f4774d219f5c7", 259576},
				{ "graphics.vga",	GAME_GFXIDXFILE,"11a4853cb35956846976e9473ee0e41e", 67456693},
				{ "setup",			GAME_RESTFILE,	"71512fc98501a8071a26b683a31dde78", 3360},
				{ "tbllist",		GAME_TBLFILE,	"0bbfee8e69739111eb36b0d138da8ddf", 668},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformMacintosh,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_ZLIBCOMP | GF_TALKIE
	},

	// The Feeble Files - French Macintosh CD
	{
		{
			"feeble",
			"CD",

			{
				{ "game22",			GAME_BASEFILE,	"ba90b40a47726039671d9e91630dd7ed", 259668},
				{ "graphics.vga",	GAME_GFXIDXFILE,"11a4853cb35956846976e9473ee0e41e", 67456693},
				{ "setup",			GAME_RESTFILE,	"71512fc98501a8071a26b683a31dde78", 3360},
				{ "tbllist",		GAME_TBLFILE,	"0bbfee8e69739111eb36b0d138da8ddf", 668},
				AD_LISTEND
			},
			Common::FR_FRA,
			Common::kPlatformMacintosh,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_ZLIBCOMP | GF_TALKIE
	},

	// The Feeble Files - German Macintosh CD
	{
		{
			"feeble",
			"CD",

			{
				{ "game22",			GAME_BASEFILE,	"bcd76ac080003eee3649df18db25b60e", 262517},
				{ "graphics.vga",	GAME_GFXIDXFILE,"11a4853cb35956846976e9473ee0e41e", 67456693},
				{ "setup",			GAME_RESTFILE,	"71512fc98501a8071a26b683a31dde78", 3360},
				{ "tbllist",		GAME_TBLFILE,	"0bbfee8e69739111eb36b0d138da8ddf", 668},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformMacintosh,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_ZLIBCOMP | GF_TALKIE
	},

	// The Feeble Files - Spanish Macintosh CD
	{
		{
			"feeble",
			"CD",

			{
				{ "game22",			GAME_BASEFILE,	"71d7d2d5e479b053c5a9757f1702c9c3", 265629},
				{ "graphics.vga",	GAME_GFXIDXFILE,"11a4853cb35956846976e9473ee0e41e", 67456693},
				{ "setup",			GAME_RESTFILE,	"71512fc98501a8071a26b683a31dde78", 3360},
				{ "tbllist",		GAME_TBLFILE,	"0bbfee8e69739111eb36b0d138da8ddf", 668},
				AD_LISTEND
			},
			Common::ES_ESP,
			Common::kPlatformMacintosh,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_ZLIBCOMP | GF_TALKIE
	},

	// The Feeble Files - English Windows 2CD (with InstallShield cab)
	{
		{
			"feeble",
			"2CD/unextracted",

			{
				{ "data1.cab",	GAME_CABFILE,	"600db08891e7a21badc8215e604cd88f", 28845430},
				{ "0882.vga",				0,	"6655780ef361ed92d0a99d50217502f3", 713180},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_TALKIE | GF_PACKED
	},

	// The Feeble Files - English Windows 2CD
	{
		{
			"feeble",
			"2CD",

			{
				{ "game22",		GAME_BASEFILE,	"629762ea9ca9ee9ff85f4774d219f5c7", 259576},
				{ "save.999",	GAME_RESTFILE,	"71512fc98501a8071a26b683a31dde78", 3360},
				{ "tbllist",	GAME_TBLFILE,	"0bbfee8e69739111eb36b0d138da8ddf", 668},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_TALKIE
	},

	// The Feeble Files - Polish Windows 2CD
	{
		{
			"feeble",
			"2CD",

			{
				{ "game33",		GAME_BASEFILE,	"cda37c422c04dde8b8ab3405178b3ef9", 266565},
				{ "save.999",	GAME_RESTFILE,	"71512fc98501a8071a26b683a31dde78", 3360},
				{ "tbllist",	GAME_TBLFILE,	"0bbfee8e69739111eb36b0d138da8ddf", 668},
				AD_LISTEND
			},
			Common::PL_POL,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_TALKIE
	},

	// The Feeble Files - English Windows 4CD (with InstallShield cab)
	{
		{
			"feeble",
			"4CD/unextracted",

			{
				{ "data1.cab",	GAME_CABFILE,	"65804cbc9036ac4b1275d97e0de3be2f", 28943062},
				{ "0882.vga",				0,	"6655780ef361ed92d0a99d50217502f3", 713180},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_TALKIE | GF_PACKED | GF_BROKEN_FF_RATING
	},

	// The Feeble Files - English Windows 4CD
	{
		{
			"feeble",
			"4CD",

			{
				{ "game22",		GAME_BASEFILE,	"a8746407a5b20a7da0da0a14c380af1c", 251647},
				{ "save.999",	GAME_RESTFILE,	"71512fc98501a8071a26b683a31dde78", 3360},
				{ "tbllist",	GAME_TBLFILE,	"0bbfee8e69739111eb36b0d138da8ddf", 668},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_TALKIE | GF_BROKEN_FF_RATING
	},

	// The Feeble Files - French Windows 4CD
	{
		{
			"feeble",
			"4CD",

			{
				{ "game22",		GAME_BASEFILE,	"ba90b40a47726039671d9e91630dd7ed", AD_NO_SIZE},
				{ "save.999",	GAME_RESTFILE,	"71512fc98501a8071a26b683a31dde78", AD_NO_SIZE},
				{ "tbllist",	GAME_TBLFILE,	"0bbfee8e69739111eb36b0d138da8ddf", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::FR_FRA,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_TALKIE
	},

	// The Feeble Files - German Windows 4CD
	{
		{
			"feeble",
			"4CD",

			{
				{ "game22",		GAME_BASEFILE,	"bcd76ac080003eee3649df18db25b60e", AD_NO_SIZE},
				{ "save.999",	GAME_RESTFILE,	"71512fc98501a8071a26b683a31dde78", AD_NO_SIZE},
				{ "tbllist",	GAME_TBLFILE,	"0bbfee8e69739111eb36b0d138da8ddf", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_TALKIE
	},

	// The Feeble Files - German Windows 4CD (with InstallShield cab)
	{
		{
			"feeble",
			"4CD/unextracted",

			{
				{ "data1.cab",	GAME_CABFILE,	"600ece2bc02cfffd17afce721bc5ab21", 23201553},
				{ "0882.vga",				0,	"6655780ef361ed92d0a99d50217502f3", 713180},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_TALKIE | GF_PACKED
	},

	// The Feeble Files - Italian Windows 4CD
	{
		{
			"feeble",
			"4CD",

			{
				{ "game22",		GAME_BASEFILE,	"80576f2e1ed4c912b63921fe77af313e", AD_NO_SIZE},
				{ "save.999",	GAME_RESTFILE,	"71512fc98501a8071a26b683a31dde78", AD_NO_SIZE},
				{ "tbllist",	GAME_TBLFILE,	"0bbfee8e69739111eb36b0d138da8ddf", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::IT_ITA,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_TALKIE
	},

	// The Feeble Files - German Windows 4CD (with InstallShield cab)
	// Provided by goodoldgeorge Bugreport #12495
	{
		{
			"feeble",
			"4CD/unextracted",

			{
				{ "data1.cab",	GAME_CABFILE,	"fa49e1f9910e519ebdcae365da10697e", 26296986},
				{ "0882.vga",				0,	"6655780ef361ed92d0a99d50217502f3", 713180},
				AD_LISTEND
			},
			Common::IT_ITA,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_TALKIE | GF_PACKED
	},

	// The Feeble Files - Polish Windows 4CD
	{
		{
			"feeble",
			"4CD",

			{
				{ "game22",		GAME_BASEFILE,	"c498f892a5dbcbc968e0dbb8697884fc", 258660},
				{ "save.999",	GAME_RESTFILE,	"71512fc98501a8071a26b683a31dde78", 3360},
				{ "tbllist",	GAME_TBLFILE,	"0bbfee8e69739111eb36b0d138da8ddf", 668},
				AD_LISTEND
			},
			Common::PL_POL,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_TALKIE
	},

	// The Feeble Files - German Windows 4CD (with InstallShield cab)
	// Provided by goodoldgeorge Bugreport #12496
	{
		{
			"feeble",
			"4CD/unextracted",

			{
				{ "data1.cab",	GAME_CABFILE,	"7722489a6609e8bba40272f64502494e", 28938871},
				{ "0882.vga",				0,	"6655780ef361ed92d0a99d50217502f3", 713180},
				AD_LISTEND
			},
			Common::PL_POL,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_TALKIE | GF_PACKED
	},

	// The Feeble Files - Spanish Windows 4CD (with InstallShield cab)
	// Provided by mgtroyas in bug report #15461
	{
		{
			"feeble",
			"4CD/unextracted",

			{
				{ "data1.cab",	GAME_CABFILE,	"2c4372076fe36bcbcff9eec1d5e32047", 26700598},
				{ "0882.vga",				0,	"6655780ef361ed92d0a99d50217502f3", 713180},
				AD_LISTEND
			},
			Common::ES_ESP,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_TALKIE | GF_PACKED
	},

	// The Feeble Files - Spanish Windows 4CD
	{
		{
			"feeble",
			"4CD",

			{
				{ "game22",		GAME_BASEFILE,	"71d7d2d5e479b053c5a9757f1702c9c3", AD_NO_SIZE},
				{ "save.999",	GAME_RESTFILE,	"71512fc98501a8071a26b683a31dde78", AD_NO_SIZE},
				{ "tbllist",	GAME_TBLFILE,	"0bbfee8e69739111eb36b0d138da8ddf", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::ES_ESP,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_FF,
		GID_FEEBLEFILES,
		GF_OLD_BUNDLE | GF_TALKIE
	},

	// Simon the Sorcerer's Puzzle Pack - Demon in my Pocket (with InstallShield cab)
	{
		{
			"dimp",
			"CD/unextracted",

			{
				{ "data1.cab", GAME_CABFILE, "36dd86c1d872cea81ac1de7753dd684a", 40394693},
				{ "0841.vga",			0,	 "b3048a73648d43ff921370da8590e5b3", 40828},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_PP,
		GID_DIMP,
		GF_OLD_BUNDLE | GF_TALKIE | GF_PACKED
	},

	// Simon the Sorcerer's Puzzle Pack - Demon in my Pocket
	{
		{
			"dimp",
			"CD",

			{
				{ "Gdimp",		GAME_BASEFILE,	"0b1e89ae1dc2e012b7fa7a987b4ac42a", 6208},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO3(GUIO_NOSUBTITLES, GUIO_NOMUSIC, GUIO_NOASPECT)
		},

		GType_PP,
		GID_DIMP,
		GF_OLD_BUNDLE | GF_TALKIE
	},

	// Simon the Sorcerer's Puzzle Pack - Jumble (with InstallShield cab)
	{
		{
			"jumble",
			"CD/unextracted",

			{
				{ "data1.cab", GAME_CABFILE, "36dd86c1d872cea81ac1de7753dd684a", 40394693},
				{ "0841.vga",			0,	 "b3048a73648d43ff921370da8590e5b3", 40828},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSUBTITLES, GUIO_NOASPECT)
		},

		GType_PP,
		GID_JUMBLE,
		GF_OLD_BUNDLE | GF_TALKIE | GF_PACKED
	},

	// Simon the Sorcerer's Puzzle Pack - Jumble
	{
		{
			"jumble",
			"CD",

			{
				{ "Gjumble",	GAME_BASEFILE,	"d54cce46d339038d1a6b74ea213655bc", 5953},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSUBTITLES, GUIO_NOASPECT)
		},

		GType_PP,
		GID_JUMBLE,
		GF_OLD_BUNDLE | GF_TALKIE
	},

	// Simon the Sorcerer's Puzzle Pack - NoPatience (with InstallShield cab)
	{
		{
			"puzzle",
			"CD/unextracted",

			{
				{ "data1.cab", GAME_CABFILE, "36dd86c1d872cea81ac1de7753dd684a", 40394693},
				{ "0841.vga",			0,	 "b3048a73648d43ff921370da8590e5b3", 40828},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSUBTITLES, GUIO_NOASPECT)
		},

		GType_PP,
		GID_PUZZLE,
		GF_OLD_BUNDLE | GF_TALKIE | GF_PACKED
	},

	// Simon the Sorcerer's Puzzle Pack - NoPatience
	{
		{
			"puzzle",
			"CD",

			{
				{ "Gpuzzle",	GAME_BASEFILE,	"3f80dac8e0d85401a1058a560fe49ab6", 23218},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSUBTITLES, GUIO_NOASPECT)
		},

		GType_PP,
		GID_PUZZLE,
		GF_OLD_BUNDLE | GF_TALKIE
	},

	// Simon the Sorcerer's Puzzle Pack - Swampy Adventures - English (with InstallShield cab)
	{
		{
			"swampy",
			"CD/unextracted",

			{
				{ "data1.cab", GAME_CABFILE, "36dd86c1d872cea81ac1de7753dd684a", 40394693},
				{ "0841.vga",			0,	 "b3048a73648d43ff921370da8590e5b3", 40828},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSUBTITLES, GUIO_NOASPECT)
		},

		GType_PP,
		GID_SWAMPY,
		GF_OLD_BUNDLE | GF_TALKIE | GF_PACKED
	},

	// Simon the Sorcerer's Puzzle Pack - Swampy Adventures - English
	{
		{
			"swampy",
			"CD",

			{
				{ "Gswampy",	GAME_BASEFILE,	"3a6d4d7b2433e660f2483f9396cc87a2", 30360},
				AD_LISTEND
			},
			Common::EN_ANY,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSUBTITLES, GUIO_NOASPECT)
		},

		GType_PP,
		GID_SWAMPY,
		GF_OLD_BUNDLE | GF_TALKIE
	},

	// Simon the Sorcerer's Puzzle Pack - Swampy Adventures - German
	{
		{
			"swampy",
			"CD",

			{
				{ "Gswampy",	GAME_BASEFILE,	"4b44f26f51c9c4a16210b4ff9875d24c", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::DE_DEU,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSUBTITLES, GUIO_NOASPECT)
		},

		GType_PP,
		GID_SWAMPY,
		GF_OLD_BUNDLE | GF_TALKIE
	},

	// Simon the Sorcerer's Puzzle Pack - Swampy Adventures - Polish
	{
		{
			"swampy",
			"CD",

			{
				{ "Gswampy",	GAME_BASEFILE,	"31bfb5169b47ccc19177e61bd31d4391", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::PL_POL,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSUBTITLES, GUIO_NOASPECT)
		},

		GType_PP,
		GID_SWAMPY,
		GF_OLD_BUNDLE | GF_TALKIE
	},

	// Simon the Sorcerer's Puzzle Pack - Swampy Adventures - Spanish
	{
		{
			"swampy",
			"CD",

			{
				{ "Gswampy",	GAME_BASEFILE,	"a534faabea5881d1f350544362edab87", AD_NO_SIZE},
				AD_LISTEND
			},
			Common::ES_ESP,
			Common::kPlatformWindows,
			ADGF_NO_FLAGS,
			GUIO2(GUIO_NOSUBTITLES, GUIO_NOASPECT)
		},

		GType_PP,
		GID_SWAMPY,
		GF_OLD_BUNDLE | GF_TALKIE
	},

	{ AD_TABLE_END_MARKER, 0, 0, 0 }
};

} // End of namespace AGOS

================
File: draw.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/endian.h"
#include "common/system.h"

#include "graphics/surface.h"
#include "graphics/paletteman.h"

#include "agos/agos.h"
#include "agos/intern.h"

namespace AGOS {

byte *AGOSEngine::getBackBuf() {
	return (byte *)_backBuf->getPixels();
}

byte *AGOSEngine::getBackGround() {
	return (byte *)_backGroundBuf->getPixels();
}

byte *AGOSEngine::getScaleBuf() {
	return (byte *)_scaleBuf->getPixels();
}

#ifdef ENABLE_AGOS2
void AGOSEngine_Feeble::animateSpritesByY() {
	VgaSprite *vsp;
	VgaPointersEntry *vpe;
	int16 spriteTable[180][2];

	byte *src;
	int height, slot, y;
	uint i, numSprites = 0;

	vsp = _vgaSprites;
	while (vsp->id) {
		if (vsp->flags & kDFScaled) {
			y = vsp->y;
		} else if (vsp->flags & kDFMasked) {
			vpe = &_vgaBufferPointers[vsp->zoneNum];
			src = vpe->vgaFile2 + vsp->image * 8;
			height = READ_LE_UINT16(src + 4) & 0x7FFF;
			y = vsp->y + height;
		} else {
			y = vsp->priority;
		}

		spriteTable[numSprites][0] = y;
		spriteTable[numSprites][1] = numSprites;
		numSprites++;
		vsp++;
	}

	while (1) {
		y = spriteTable[0][0];
		slot = spriteTable[0][1];

		for (i = 0; i < numSprites; i++) {
			if (y >= spriteTable[i][0]) {
				y = spriteTable[i][0];
				slot = spriteTable[i][1];
			}
		}

		if (y == 9999)
			break;

		for (i = 0; i < numSprites; i++) {
			if (slot == spriteTable[i][1]) {
				spriteTable[i][0] = 9999;
				break;
			}
		}

		vsp = &_vgaSprites[slot];

		vsp->windowNum &= ~0x8000;

		vpe = &_vgaBufferPointers[vsp->zoneNum];
		_curVgaFile1 = vpe->vgaFile1;
		_curVgaFile2 = vpe->vgaFile2;
		_curSfxFile = vpe->sfxFile;
		_windowNum = vsp->windowNum;
		_vgaCurSpriteId = vsp->id;
		_vgaCurSpritePriority = vsp->priority;

		drawImage_init(vsp->image, vsp->palette, vsp->x, vsp->y, vsp->flags);
	}

	_displayFlag++;
}

void AGOSEngine_Feeble::animateSprites() {
	VgaSprite *vsp;
	VgaPointersEntry *vpe;

	if (_paletteFlag == 2)
		_paletteFlag = 1;

	if (_scrollCount) {
		scrollEvent();
	}

	if (getBitFlag(84)) {
		animateSpritesByY();
		return;
	}

	vsp = _vgaSprites;
	while (vsp->id) {
		vsp->windowNum &= ~0x8000;

		vpe = &_vgaBufferPointers[vsp->zoneNum];
		_curVgaFile1 = vpe->vgaFile1;
		_curVgaFile2 = vpe->vgaFile2;
		_curSfxFile = vpe->sfxFile;
		_windowNum = vsp->windowNum;
		_vgaCurSpriteId = vsp->id;
		_vgaCurSpritePriority = vsp->priority;

		drawImage_init(vsp->image, vsp->palette, vsp->x, vsp->y, vsp->flags);
		vsp++;
	}

	_displayFlag++;
}
#endif

void AGOSEngine::animateSprites() {
	VgaSprite *vsp;
	VgaPointersEntry *vpe;

	if (_copyScnFlag) {
		_copyScnFlag--;
		_vgaSpriteChanged++;
	}

	if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2) {
		const uint var = (getGameType() == GType_ELVIRA1) ? 293 : 71;
		if (_wallOn && !_variableArray[var]) {
			_wallOn--;

			VC10_state state;
			state.srcPtr = getBackGround() + 3 * _backGroundBuf->pitch + 3 * 16;
			state.height = state.draw_height = 127;
			state.width = state.draw_width = 14;
			state.y = 0;
			state.x = 0;
			state.palette = 0;
			state.paletteMod = 0;
			state.flags = kDFNonTrans;

			_windowNum = 4;

			_backFlag = true;
			drawImage(&state);
			_backFlag = false;

			_vgaSpriteChanged++;
		}
	}

	if (!_scrollFlag && !_vgaSpriteChanged) {
		return;
	}

	_vgaSpriteChanged = 0;

	if (_paletteFlag == 2)
		_paletteFlag = 1;

	if (getGameType() == GType_SIMON2 && _scrollFlag) {
		scrollScreen();
	}

	if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
		dirtyClips();
	}

	restoreBackGround();

	vsp = _vgaSprites;
	for (; vsp->id !=0; vsp++) {
		if ((getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) &&
			!(vsp->windowNum & 0x8000)) {
			continue;
		}

		vsp->windowNum &= ~0x8000;

		vpe = &_vgaBufferPointers[vsp->zoneNum];
		_curVgaFile1 = vpe->vgaFile1;
		_curVgaFile2 = vpe->vgaFile2;
		_curSfxFile = vpe->sfxFile;
		_windowNum = vsp->windowNum;
		_vgaCurSpriteId = vsp->id;

		saveBackGround(vsp);

		drawImage_init(vsp->image, vsp->palette, vsp->x, vsp->y, vsp->flags);
	}

	if (getGameType() == GType_ELVIRA1 && _variableArray[293]) {
		// Used by the Fire Wall and Ice Wall spells
		debug(0, "Using special wall");

		uint8 color, h, len;
		byte *dst = (byte *)_window4BackScn->getPixels();

		color = (_variableArray[293] & 1) ? 13 : 15;
		_wallOn = 2;

		h = 127;
		while (h) {
			len = 112;
			while (len--) {
				*dst++ = color;
				dst++;
			}

			h--;
			if (h == 0)
				break;

			len = 112;
			while (len--) {
				dst++;
				*dst++ = color;
			}
			h--;
		}

		_window4Flag = 1;
		setMoveRect(0, 0, 224, 127);
	} else if (getGameType() == GType_ELVIRA2 && _variableArray[71] & 2) {
		// Used by the Unholy Barrier spell
		uint8 color, h, len;
		byte *dst = (byte *)_window4BackScn->getPixels();

		color = 1;
		_wallOn = 2;

		h = 43;
		while (h) {
			len = 56;
			while (len--) {
				*dst++ = color;
				dst += 3;
			}

			h--;
			if (h == 0)
				break;

			dst += 448;

			len = 56;
			while (len--) {
				dst += 2;
				*dst++ = color;
				dst += 1;
			}
			dst += 448;
			h--;
		}

		_window4Flag = 1;
		setMoveRect(0, 0, 224, 127);
	}

	if (_window6Flag == 1)
		_window6Flag++;

	if (_window4Flag == 1)
		_window4Flag++;

	_displayFlag++;
}

void AGOSEngine::dirtyClips() {
	int16 x, y, w, h;
restart:
	_newDirtyClip = 0;

	VgaSprite *vsp = _vgaSprites;
	while (vsp->id != 0) {
		if (vsp->windowNum & 0x8000) {
			x = vsp->x;
			y = vsp->y;
			w = 1;
			h = 1;

			if (vsp->image != 0) {
				VgaPointersEntry *vpe = &_vgaBufferPointers[vsp->zoneNum];
				const byte *ptr = vpe->vgaFile2 + vsp->image * 8;
				w = READ_BE_UINT16(ptr + 6) / 8;
				h = ptr[5];
			}

			dirtyClipCheck(x, y, w, h);
		}
		vsp++;
	}

	AnimTable *animTable = _screenAnim1;
	while (animTable->srcPtr != nullptr) {
		if (animTable->windowNum & 0x8000) {
			x = animTable->x + _scrollX;
			y = animTable->y;
			w = animTable->width * 2;
			h = animTable->height;

			dirtyClipCheck(x, y, w, h);
		}
		animTable++;
	}

	if (_newDirtyClip != 0)
		goto restart;

}

void AGOSEngine::dirtyClipCheck(int16 x, int16 y, int16 w, int16 h) {
	int16 width, height, tmp;

	VgaSprite *vsp = _vgaSprites;
	for (; vsp->id != 0; vsp++) {
		if (vsp->windowNum & 0x8000)
			continue;

		if (vsp->image == 0)
			continue;

		VgaPointersEntry *vpe = &_vgaBufferPointers[vsp->zoneNum];
		const byte *ptr = vpe->vgaFile2 + vsp->image * 8;
		width = READ_BE_UINT16(ptr + 6) / 8;
		height = ptr[5];

		tmp = vsp->x;
		if (tmp >= x) {
			tmp -= w;
			if (tmp >= x)
				continue;
		} else {
			tmp += width;
			if (tmp < x)
				continue;
		}

		tmp = vsp->y;
		if (tmp >= y) {
			tmp -= h;
			if (tmp >= y)
				continue;
		} else {
			tmp += height;
			if (tmp < y)
				continue;
		}

		vsp->windowNum |= 0x8000;
		_newDirtyClip = 1;
	}

	AnimTable *animTable = _screenAnim1;
	for (; animTable->srcPtr != nullptr; animTable++) {
		if (animTable->windowNum & 0x8000)
			continue;

		width = animTable->width * 2;
		height = animTable->height;

		tmp = animTable->x + _scrollX;
		if (tmp >= x) {
			tmp -= w;
			if (tmp >= x)
				continue;
		} else {
			tmp += width;
			if (tmp < x)
				continue;
		}

		tmp = animTable->y;
		if (tmp >= y) {
			tmp -= h;
			if (tmp >= y)
				continue;
		} else {
			tmp += height;
			if (tmp < y)
				continue;
		}

		animTable->windowNum |= 0x8000;
		_newDirtyClip = 1;
	}
}

void AGOSEngine::restoreBackGround() {
	AnimTable *animTable;
	uint images = 0;

	animTable = _screenAnim1;
	while (animTable->srcPtr) {
		animTable++;
		images++;
	}

	while (images--) {
		animTable--;

		if ((getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) &&
			!(animTable->windowNum & 0x8000)) {
			continue;
		}

		_windowNum = animTable->windowNum & ~0x8000;

		VC10_state state;
		state.srcPtr = animTable->srcPtr;
		state.height = state.draw_height = animTable->height;
		state.width = state.draw_width = animTable->width;
		state.y = animTable->y;
		state.x = animTable->x;
		state.palette = 0;
		state.paletteMod = 0;
		state.flags = kDFNonTrans;

		_backFlag = true;
		drawImage(&state);

		if (getGameType() != GType_SIMON1 && getGameType() != GType_SIMON2) {
			animTable->srcPtr = nullptr;
		}
	}
	_backFlag = false;

	if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
		AnimTable *animTableTmp;

		animTable = animTableTmp = _screenAnim1;
		while (animTable->srcPtr) {
			if (!(animTable->windowNum & 0x8000)) {
				memmove(animTableTmp, animTable, sizeof(AnimTable));
				animTableTmp++;
			}
			animTable++;
		}
		animTableTmp->srcPtr = nullptr;
	}
}

void AGOSEngine::saveBackGround(VgaSprite *vsp) {
	if (getGameType() == GType_ELVIRA1 && getPlatform() == Common::kPlatformAtariST &&
		(getFeatures() & GF_DEMO)) {
		return;
	}

	if ((vsp->flags & kDFSkipStoreBG) || !vsp->image)
		return;

	AnimTable *animTable = _screenAnim1;

	while (animTable->srcPtr)
		animTable++;

	const byte *ptr = _curVgaFile2 + vsp->image * 8;
	int16 x = vsp->x - _scrollX;
	int16 y = vsp->y - _scrollY;

	if (_window3Flag == 1) {
		animTable->srcPtr = (const byte *)_window4BackScn->getPixels();
	} else {
		int xoffs = (_videoWindows[vsp->windowNum * 4 + 0] * 2 + x) * 8;
		int yoffs = (_videoWindows[vsp->windowNum * 4 + 1] + y);
		animTable->srcPtr = getBackGround() + yoffs * _backGroundBuf->pitch + xoffs;
	}

	animTable->x = x;
	animTable->y = y;

	animTable->width = (getPlatform() == Common::kPlatformPC98 ? READ_LE_UINT16(ptr + 6) : READ_BE_UINT16(ptr + 6)) / 16;
	if (vsp->flags & 0x40) {
		animTable->width++;
	}

	animTable->height = ptr[5];
	animTable->windowNum = vsp->windowNum;
	animTable->id = vsp->id;
	animTable->zoneNum = vsp->zoneNum;

	animTable++;
	animTable->srcPtr = nullptr;
}

void AGOSEngine::displayBoxStars() {
	HitArea *ha, *dha;
	uint count;
	uint y_, x_;
	byte *dst;
	uint color;

	o_haltAnimation();

	if (getGameType() == GType_SIMON2)
		color = 236;
	else
		color = 225;

	uint curHeight = (getGameType() == GType_SIMON2) ? _boxStarHeight : 134;


	for (int i = 0; i < 5; i++) {
		ha = _hitAreas;
		count = ARRAYSIZE(_hitAreas);

		Graphics::Surface *screen = getBackendSurface();

		do {
			if (ha->id != 0 && ha->flags & kBFBoxInUse && !(ha->flags & kBFBoxDead)) {

				dha = _hitAreas;
				if (ha->flags & kBFTextBox) {
					while (dha != ha && dha->flags != ha->flags)
						++dha;
					if (dha != ha && dha->flags == ha->flags)
						continue;
				} else {
					dha = _hitAreas;
					while (dha != ha && dha->itemPtr != ha->itemPtr)
						++dha;
					if (dha != ha && dha->itemPtr == ha->itemPtr)
						continue;
				}

				if (ha->y >= curHeight)
					continue;

				y_ = (ha->height / 2) - 4 + ha->y;

				x_ = (ha->width / 2) - 4 + ha->x - (_scrollX * 8);

				if (x_ >= 311)
					continue;

				dst = (byte *)screen->getPixels();

				dst += (((screen->pitch / 4) * y_) * 4) + x_;

				dst[4] = color;
				dst += screen->pitch;
				dst[1] = color;
				dst[4] = color;
				dst[7] = color;
				dst += screen->pitch;
				dst[2] = color;
				dst[4] = color;
				dst[6] = color;
				dst += screen->pitch;
				dst[3] = color;
				dst[5] = color;
				dst += screen->pitch;
				dst[0] = color;
				dst[1] = color;
				dst[2] = color;
				dst[6] = color;
				dst[7] = color;
				dst[8] = color;
				dst += screen->pitch;
				dst[3] = color;
				dst[5] = color;
				dst += screen->pitch;
				dst[2] = color;
				dst[4] = color;
				dst[6] = color;
				dst += screen->pitch;
				dst[1] = color;
				dst[4] = color;
				dst[7] = color;
				dst += screen->pitch;
				dst[4] = color;
			}
		} while (ha++, --count);

		updateBackendSurface();

		delay(100);

		setMoveRect(0, 0, 320, curHeight);
		_window4Flag = 2;

		displayScreen();
		delay(100);
	}

	o_restartAnimation();
}

void AGOSEngine::scrollScreen() {
	byte *dst;
	const byte *src;
	uint x, y;

	dst = getBackGround();

	if (_scrollXMax == 0) {
		uint screenSize = 8 * _screenWidth;
		if (_scrollFlag < 0) {
			memmove(dst + screenSize, dst, _scrollWidth * _screenHeight - screenSize);
		} else {
			memmove(dst, dst + screenSize, _scrollWidth * _screenHeight - screenSize);
		}

		y = _scrollY - 8;

		if (_scrollFlag > 0) {
			dst += _screenHeight * _screenWidth - screenSize;
			y += 488;
		}

		src = _scrollImage + y / 2;
		decodeRow(dst, src + readUint32Wrapper(src), _scrollWidth, _backGroundBuf->pitch);

		_scrollY += _scrollFlag;
		vcWriteVar(250, _scrollY);

		fillBackFromBackGround(_screenHeight, _scrollWidth);
	} else {
		if (_scrollFlag < 0) {
			memmove(dst + 8, dst, _screenWidth * _scrollHeight - 8);
		} else {
			memmove(dst, dst + 8, _screenWidth * _scrollHeight - 8);
		}

		x = _scrollX;
		x -= (getGameType() == GType_FF) ? 8 : 1;

		if (_scrollFlag > 0) {
			dst += _screenWidth - 8;
			x += (getGameType() == GType_FF) ? 648 : 41;
		}

		if (getGameType() == GType_FF)
			src = _scrollImage + x / 2;
		else
			src = _scrollImage + x * 4;
		decodeColumn(dst, src + readUint32Wrapper(src), _scrollHeight, _backGroundBuf->pitch);

		_scrollX += _scrollFlag;
		vcWriteVar(251, _scrollX);

		if (getGameType() == GType_SIMON2) {
			src = getBackGround();
			dst = (byte *)_window4BackScn->getPixels();
			for (int i = 0; i < _scrollHeight; i++) {
				memcpy(dst, src, _screenWidth);
				src += _backGroundBuf->pitch;
				dst += _window4BackScn->pitch;
			}
		} else {
			fillBackFromBackGround(_scrollHeight, _screenWidth);
		}

		setMoveRect(0, 0, 320, _scrollHeight);

		_window4Flag = 1;
	}

	_scrollFlag = 0;

	if (getGameType() == GType_SIMON2) {
		AnimTable *animTable = _screenAnim1;
		while (animTable->srcPtr) {
			animTable->srcPtr = nullptr;
			animTable++;
		}

		VgaSprite *vsp = _vgaSprites;
		while (vsp->id) {
			vsp->windowNum |= 0x8000;
			vsp++;
		}
	}
}

void AGOSEngine::clearSurfaces() {
	_system->fillScreen(0);

	if (_backBuf) {
		memset(getBackBuf(), 0, _backBuf->h * _backBuf->pitch);
	}
}

void AGOSEngine::fillBackFromBackGround(uint16 height, uint16 width) {
	byte *src = getBackGround();
	byte *dst = getBackBuf();
	for (int i = 0; i < height; i++) {
		memcpy(dst, src, width);
		src += _backGroundBuf->pitch;
		dst += _backBuf->pitch;
	}
}

void AGOSEngine::fillBackFromFront() {
	Graphics::Surface *screen = getBackendSurface();
	byte *src = (byte *)screen->getPixels();
	byte *dst = getBackBuf();

	for (int i = 0; i < _screenHeight; i++) {
		memcpy(dst, src, _screenWidth);
		src += screen->pitch;
		dst += _backBuf->pitch;
	}
	updateBackendSurface();
}

void AGOSEngine::fillBackGroundFromBack() {
	byte *src = getBackBuf();
	byte *dst = getBackGround();
	for (int i = 0; i < _screenHeight; i++) {
		memcpy(dst, src, _screenWidth);
		src += _backBuf->pitch;
		dst += _backGroundBuf->pitch;
	}
}

void AGOSEngine::fillBackGroundFromFront() {
	Graphics::Surface *screen = getBackendSurface();
	byte *src = (byte *)screen->getPixels();
	byte *dst = getBackGround();

	for (int i = 0; i < _screenHeight; i++) {
		memcpy(dst, src, _screenWidth);
		src += screen->pitch;
		dst += _backGroundBuf->pitch;
	}
	updateBackendSurface();
}

void AGOSEngine::setMoveRect(uint16 x, uint16 y, uint16 width, uint16 height) {
	if (x < _moveXMin)
		_moveXMin = x;

	if (y < _moveYMin)
		_moveYMin = y;

	if (width > _moveXMax)
		_moveXMax = width;

	if (height > _moveYMax)
		_moveYMax = height;
}

void AGOSEngine::displayScreen() {
	if (_fastFadeInFlag == 0 && _paletteFlag == 1) {
		_paletteFlag = 0;
		if (memcmp(_displayPalette, _currentPalette, sizeof(_currentPalette)) != 0) {
			memcpy(_currentPalette, _displayPalette, sizeof(_displayPalette));
			_system->getPaletteManager()->setPalette(_displayPalette, 0, 256);
		}
	}

	Graphics::Surface *screen = getBackendSurface();
	if (getGameType() == GType_PP || getGameType() == GType_FF) {
		byte *src = getBackBuf();
		byte *dst = (byte *)screen->getPixels();
		for (int i = 0; i < _screenHeight; i++) {
			memcpy(dst, src, _screenWidth);
			src += _backBuf->pitch;
			dst += screen->pitch;
		}
		if (getGameId() != GID_DIMP)
			fillBackFromBackGround(_screenHeight, _screenWidth);
	} else {
		if (_window4Flag == 2) {
			_window4Flag = 0;

			uint16 srcWidth, width, height;
			byte *dst = (byte *)screen->getPixels();

			const byte *src = (const byte *)_window4BackScn->getPixels();
			if (_window3Flag == 1) {
				src = getBackGround();
			}

			dst += (_moveYMin + _videoWindows[17]) * screen->pitch;
			dst += (_videoWindows[16] * 16) + _moveXMin;

			src += (_videoWindows[18] * 16 * _moveYMin);
			src += _moveXMin;

			srcWidth = _videoWindows[18] * 16;

			width = _moveXMax - _moveXMin;
			height = _moveYMax - _moveYMin;

			for (; height > 0; height--) {
				memcpy(dst, src, width);
				dst += screen->pitch;
				src += srcWidth;
			}

			_moveXMin = 0xFFFF;
			_moveYMin = 0xFFFF;
			_moveXMax = 0;
			_moveYMax = 0;
		}

		if (_window6Flag == 2) {
			_window6Flag = 0;

			byte *src = (byte *)_window6BackScn->getPixels();
			byte *dst = (byte *)screen->getBasePtr(0, 51);
			for (int i = 0; i < 80; i++) {
				memcpy(dst, src, _window6BackScn->w);
				dst += screen->pitch;
				src += _window6BackScn->pitch;
			}
		}
	}

	updateBackendSurface();

	if (getGameType() == GType_FF && _scrollFlag) {
		scrollScreen();
	}

	if (_fastFadeInFlag) {
		fastFadeIn();
	}
}

void AGOSEngine::fastFadeIn() {
	if (_fastFadeInFlag & 0x8000) {
		slowFadeIn();
	} else {
		_paletteFlag = false;
		memcpy(_currentPalette, _displayPalette, sizeof(_displayPalette));
		_system->getPaletteManager()->setPalette(_displayPalette, 0, _fastFadeInFlag);
		_fastFadeInFlag = 0;
	}
}

void AGOSEngine::slowFadeIn() {
	uint8 *src, *dst;
	int c, p;

	_fastFadeInFlag &= ~0x8000;
	_paletteFlag = false;

	memset(_currentPalette, 0, sizeof(_currentPalette));

	for (c = 255; c >= 0; c -= 4) {
		src = _displayPalette;
		dst = _currentPalette;

		for (p = _fastFadeInFlag; p != 0; p -= 3) {
			if (src[0] >= c)
				dst[0] += 4;
			if (src[1] >= c)
				dst[1] += 4;
			if (src[2] >= c)
				dst[2] += 4;
			src += 3;
			dst += 3;
		}
		_system->getPaletteManager()->setPalette(_currentPalette, 0, _fastFadeCount);
		delay(5);
	}
	_fastFadeInFlag = 0;
}

} // End of namespace AGOS

================
File: event.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "agos/agos.h"
#include "agos/animation.h"
#include "agos/debugger.h"
#include "agos/sound.h"
#include "agos/intern.h"

#include "common/events.h"
#include "common/system.h"
#include "common/textconsole.h"

#include "backends/audiocd/audiocd.h"

#include "gui/about.h"

#include "graphics/surface.h"


namespace AGOS {

void AGOSEngine::addTimeEvent(int32 timeout, uint16 subroutine_id) {
	TimeEvent *te = (TimeEvent *)malloc(sizeof(TimeEvent)), *first, *last = nullptr;
	uint32 cur_time = getTime();

	if (getGameId() == GID_DIMP) {
		timeout /= 2;
	}

	if ((int32)(cur_time + timeout - _gameStoppedClock) < 0) {
		// This basically fixes a signed/unsigned bug. See comment in AGOSEngine_Elvira2::loadGame().
		warning("AGOSEngine::addTimeEvent(): Invalid timer encountered (probably from an older savegame) - applying workaround");
		timeout = 0;
	}

	te->time = cur_time + timeout - _gameStoppedClock;
	if (getGameType() == GType_FF && _clockStopped)
		te->time -= (getTime() - _clockStopped);
	te->subroutine_id = subroutine_id;

	first = _firstTimeStruct;
	while (first) {
		if (te->time <= first->time) {
			if (last) {
				last->next = te;
				te->next = first;
				return;
			}
			te->next = _firstTimeStruct;
			_firstTimeStruct = te;
			return;
		}

		last = first;
		first = first->next;
	}

	if (last) {
		last->next = te;
		te->next = nullptr;
	} else {
		_firstTimeStruct = te;
		te->next = nullptr;
	}
}

void AGOSEngine::delTimeEvent(TimeEvent *te) {
	TimeEvent *cur;

	if (te == _pendingDeleteTimeEvent)
		_pendingDeleteTimeEvent = nullptr;

	if (te == _firstTimeStruct) {
		_firstTimeStruct = te->next;
		free(te);
		return;
	}

	cur = _firstTimeStruct;
	if (cur == nullptr)
		error("delTimeEvent: none available");

	for (;;) {
		if (cur->next == nullptr)
			error("delTimeEvent: no such te");
		if (te == cur->next) {
			cur->next = te->next;
			free(te);
			return;
		}
		cur = cur->next;
	}
}

void AGOSEngine::invokeTimeEvent(TimeEvent *te) {
	Subroutine *sub;

	_scriptVerb = 0;

	if (_runScriptReturn1)
		return;

	sub = getSubroutineByID(te->subroutine_id);
	if (sub != nullptr)
		startSubroutineEx(sub);

	_runScriptReturn1 = false;
}

void AGOSEngine::killAllTimers() {
	TimeEvent *cur, *next;

	for (cur = _firstTimeStruct; cur; cur = next) {
		next = cur->next;
		delTimeEvent(cur);
	}
	_clickOnly = false;
}

bool AGOSEngine::kickoffTimeEvents() {
	uint32 cur_time;
	TimeEvent *te;
	bool result = false;

	if (getGameType() == GType_FF && _clockStopped)
		return result;

	cur_time = getTime() - _gameStoppedClock;

	while ((te = _firstTimeStruct) != nullptr && te->time <= cur_time && !shouldQuit()) {
		result = true;
		_pendingDeleteTimeEvent = te;
		invokeTimeEvent(te);
		if (_pendingDeleteTimeEvent) {
			_pendingDeleteTimeEvent = nullptr;
			delTimeEvent(te);
		}
	}

	return result;
}

bool AGOSEngine::isVgaQueueEmpty() {
	VgaTimerEntry *vte = _vgaTimerList;
	bool result = false;

	while (vte->delay) {
		if (vte->zoneNum == _variableArray[999] && vte->id >= 100) {
			result = true;
			break;
		}
		vte++;
	}
	return result;
}

void AGOSEngine::haltAnimation() {
	if (_videoLockOut & 0x10)
		return;

	_videoLockOut |= 0x10;

	if (_displayFlag) {
		displayScreen();
		_displayFlag = 0;
	}
}

void AGOSEngine::restartAnimation() {
	if (!(_videoLockOut & 0x10))
		return;

	if (getGameType() != GType_PN) {
		_window4Flag = 2;
		setMoveRect(0, 0, 224, 127);
		displayScreen();
	}

	_videoLockOut &= ~0x10;
}

void AGOSEngine::addVgaEvent(uint16 num, uint8 type, const byte *codePtr, uint16 curSprite, uint16 curZoneNum) {
	VgaTimerEntry *vte;

	_videoLockOut |= 1;

	for (vte = _vgaTimerList; vte->delay; vte++) {
	}

	vte->delay = num;
	vte->codePtr = codePtr;
	vte->id = curSprite;
	vte->zoneNum = curZoneNum;
	vte->type = type;

	_videoLockOut &= ~1;
}

void AGOSEngine::deleteVgaEvent(VgaTimerEntry * vte) {
	_videoLockOut |= 1;

	if (vte + 1 <= _nextVgaTimerToProcess) {
		_nextVgaTimerToProcess--;
	}

	do {
		memcpy(vte, vte + 1, sizeof(VgaTimerEntry));
		vte++;
	} while (vte->delay);

	_videoLockOut &= ~1;
}

void AGOSEngine::processVgaEvents() {
	VgaTimerEntry *vte = _vgaTimerList;

	_vgaTickCounter++;

	while (vte->delay) {
		vte->delay -= _vgaBaseDelay;
		if (vte->delay <= 0) {
			uint16 curZoneNum = vte->zoneNum;
			uint16 curSprite = vte->id;
			const byte *script_ptr = vte->codePtr;

			switch (vte->type) {
			case ANIMATE_INT:
				vte->delay = (getGameType() == GType_SIMON2) ? 5 : _frameCount;
				animateSprites();
				vte++;
				break;
			case ANIMATE_EVENT:
				_nextVgaTimerToProcess = vte + 1;
				deleteVgaEvent(vte);
				animateEvent(script_ptr, curZoneNum, curSprite);
				vte = _nextVgaTimerToProcess;
				break;
			case SCROLL_EVENT:
				_nextVgaTimerToProcess = vte + 1;
				deleteVgaEvent(vte);
				scrollEvent();
				vte = _nextVgaTimerToProcess;
				break;
			case PLAYER_DAMAGE_EVENT:
				playerDamageEvent(vte, curZoneNum);
				vte = _nextVgaTimerToProcess;
				break;
			case MONSTER_DAMAGE_EVENT:
				monsterDamageEvent(vte, curZoneNum);
				vte = _nextVgaTimerToProcess;
				break;
			default:
				error("processVgaEvents: Unknown event type %d", vte->type);
			}
		} else {
			vte++;
		}
	}
}

void AGOSEngine::animateEvent(const byte *codePtr, uint16 curZoneNum, uint16 curSprite) {
	VgaPointersEntry *vpe;

	_vgaCurSpriteId = curSprite;

	_vgaCurZoneNum = curZoneNum;
	_zoneNumber = curZoneNum;
	vpe = &_vgaBufferPointers[curZoneNum];

	_curVgaFile1 = vpe->vgaFile1;
	_curVgaFile2 = vpe->vgaFile2;
	_curSfxFile = vpe->sfxFile;
	_curSfxFileSize = vpe->sfxFileEnd - vpe->sfxFile;

	_vcPtr = codePtr;

	runVgaScript();
}

void AGOSEngine::scrollEvent() {
	if (_scrollCount == 0)
		return;

	if (getGameType() == GType_FF) {
		if (_scrollCount < 0) {
			if (_scrollFlag != -8) {
				_scrollFlag = -8;
				_scrollCount += 8;
			}
		} else {
			if (_scrollFlag != 8) {
				_scrollFlag = 8;
				_scrollCount -= 8;
			}
		}
	} else {
		if (_scrollCount < 0) {
			if (_scrollFlag != -1) {
				_scrollFlag = -1;
				if (++_scrollCount == 0)
					return;
			}
		} else {
			if (_scrollFlag != 1) {
				_scrollFlag = 1;
				if (--_scrollCount == 0)
					return;
			}
		}

		addVgaEvent(6, SCROLL_EVENT, nullptr, 0, 0);
	}
}

static const byte _image1[32] = {
	0x3A, 0x37, 0x3B, 0x37,
	0x3A, 0x3E, 0x3F, 0x3E,
	0x37, 0x3F, 0x31, 0x3F,
	0x37, 0x3F, 0x31, 0x3F,
	0x3A, 0x3E, 0x3F, 0x3E,
	0x3A, 0x37, 0x3B, 0x37,
};

static const byte _image2[32] = {
	0x3A, 0x3A, 0x3B, 0x3A,
	0x3A, 0x37, 0x3E, 0x37,
	0x3A, 0x37, 0x3E, 0x37,
	0x3A, 0x37, 0x3E, 0x37,
	0x3A, 0x37, 0x3E, 0x37,
	0x3A, 0x3A, 0x3B, 0x3A,
};

static const byte _image3[32] = {
	0x3A, 0x32, 0x3B, 0x32,
	0x3A, 0x39, 0x3F, 0x39,
	0x32, 0x3F, 0x31, 0x3F,
	0x32, 0x3F, 0x31, 0x3F,
	0x3A, 0x39, 0x3F, 0x39,
	0x3A, 0x32, 0x3B, 0x32,
};

static const byte _image4[32] = {
	0x3A, 0x3A, 0x3B, 0x3A,
	0x3A, 0x32, 0x39, 0x32,
	0x3A, 0x32, 0x38, 0x32,
	0x3A, 0x32, 0x38, 0x32,
	0x3A, 0x32, 0x39, 0x32,
	0x3A, 0x3A, 0x3B, 0x3A,
};

void AGOSEngine::drawStuff(const byte *src, uint xoffs) {
	const uint8 y = (getPlatform() == Common::kPlatformAtariST) ? 132 : 135;

	Graphics::Surface *screen = getBackendSurface();
	byte *dst = (byte *)screen->getBasePtr(xoffs, y);

	for (uint h = 0; h < 6; h++) {
		memcpy(dst, src, 4);
		src += 4;
		dst += screen->pitch;
	}

	Common::Rect dirtyRect(xoffs, y, xoffs + 4, y + 6);
	updateBackendSurface(&dirtyRect);
}

void AGOSEngine::playerDamageEvent(VgaTimerEntry * vte, uint dx) {
	// Draws damage indicator gauge when player hit
	_nextVgaTimerToProcess = vte + 1;

	if (!_opcode177Var1) {
		drawStuff(_image1, 4 + _opcode177Var2 * 4);
		_opcode177Var2++;
		if (_opcode177Var2 == dx) {
			_opcode177Var1 = 1;
			vte->delay = 16 - dx;
		} else {
			vte->delay = 1;
		}
	} else if (_opcode177Var2) {
		_opcode177Var2--;
		drawStuff(_image2, 4 + _opcode177Var2 * 4);
		vte->delay = 3;
	} else {
		deleteVgaEvent(vte);
	}
}

void AGOSEngine::monsterDamageEvent(VgaTimerEntry * vte, uint dx) {
	// Draws damage indicator gauge when monster hit
	_nextVgaTimerToProcess = vte + 1;

	if (!_opcode178Var1) {
		drawStuff(_image3, 275 + _opcode178Var2 * 4);
		_opcode178Var2++;
		if (_opcode178Var2 >= 10 || _opcode178Var2 == dx) {
			_opcode178Var1 = 1;
			vte->delay = 16 - dx;
		} else {
			vte->delay = 1;
		}
	} else if (_opcode178Var2) {
		_opcode178Var2--;
		drawStuff(_image4, 275 + _opcode178Var2 * 4);
		vte->delay = 3;
	} else {
		deleteVgaEvent(vte);
	}
}

void AGOSEngine::delay(uint amount) {
	Common::Event event;

	uint32 start = _system->getMillis();
	uint32 cur = start;
	uint this_delay, vgaPeriod;

	_system->getAudioCDManager()->update();

	vgaPeriod = (_fastMode) ? 10 : _vgaPeriod;
	if (getGameType() == GType_PP && getGameId() != GID_DIMP) {
		if (vgaPeriod == 15 && _variableArray[999] == 0)
			vgaPeriod = 30;
	}

	_rnd.getRandomNumber(2);

	do {
		while (!_inCallBack && cur >= _lastVgaTick + vgaPeriod && !_pause) {
			_lastVgaTick += vgaPeriod;

			// don't get too many frames behind
			if (cur >= _lastVgaTick + vgaPeriod * 2)
				_lastVgaTick = cur;

			_inCallBack = true;
			timerProc();
			_inCallBack = false;
		}

		while (_eventMan->pollEvent(event)) {
			switch (event.type) {
			case Common::EVENT_JOYBUTTON_DOWN:
				_joyaction = event.joystick;
				break;
			case Common::EVENT_JOYBUTTON_UP:
				_joyaction.axis = 0;
				_joyaction.button = 0;
				_joyaction.position = 0;
				break;
			case Common::EVENT_CUSTOM_ENGINE_ACTION_START:
				_action = (AGOSAction)event.customType;
				if (event.customType == kActionToggleFastMode) {
					_fastMode = !_fastMode;
				}
				break;
			case Common::EVENT_CUSTOM_ENGINE_ACTION_END:
				_action = kActionNone;
				break;
			case Common::EVENT_KEYDOWN:
				if (event.kbd.keycode >= Common::KEYCODE_0 && event.kbd.keycode <= Common::KEYCODE_9
					&& (event.kbd.hasFlags(Common::KBD_ALT) ||
						event.kbd.hasFlags(Common::KBD_CTRL))) {
					_saveLoadSlot = event.kbd.keycode - Common::KEYCODE_0;

					// There is no save slot 0
					if (_saveLoadSlot == 0)
						_saveLoadSlot = 10;

					memset(_saveLoadName, 0, sizeof(_saveLoadName));
					Common::sprintf_s(_saveLoadName, "Quick %d", _saveLoadSlot);
					_saveLoadType = (event.kbd.hasFlags(Common::KBD_ALT)) ? 1 : 2;
					quickLoadOrSave();
				} else if (event.kbd.hasFlags(Common::KBD_ALT)) {
					if (event.kbd.keycode == Common::KEYCODE_u) {
						dumpAllSubroutines();
					} else if (event.kbd.keycode == Common::KEYCODE_i) {
						dumpAllVgaImageFiles();
					} else if (event.kbd.keycode == Common::KEYCODE_v) {
						dumpAllVgaScriptFiles();
					}
				} else if (event.kbd.hasFlags(Common::KBD_CTRL)) {
					if (event.kbd.keycode == Common::KEYCODE_a) {
						GUI::AboutDialog aboutDialog;
						aboutDialog.runModal();
					}
				}

				// Waxworks: 'F' key toggles fighting mode
				if (getGameType() == GType_WW &&
					event.kbd.keycode == Common::KEYCODE_f &&
					!_controlLock) {
					static_cast<AGOSEngine_Waxworks *>(_vm)->startSubroutineByVerb(208);
				}

				if (getGameType() == GType_PP) {
					if (event.kbd.hasFlags(Common::KBD_SHIFT))
						_variableArray[41] = 0;
					else
						_variableArray[41] = 1;
				}

				_keyPressed = event.kbd;
				break;
			case Common::EVENT_MOUSEMOVE:
				break;
			case Common::EVENT_LBUTTONDOWN:
				if (getGameType() == GType_FF)
					setBitFlag(89, true);
				_leftButtonDown = true;
				_leftButton = 1;
				break;
			case Common::EVENT_LBUTTONUP:
				if (getGameType() == GType_FF)
					setBitFlag(89, false);

				_leftButton = 0;
				_leftButtonCount = 0;
				_leftClick = true;
				break;
			case Common::EVENT_RBUTTONDOWN:
				if (getGameType() == GType_FF)
					setBitFlag(92, false);
				_rightButtonDown = true;
				break;
			case Common::EVENT_RBUTTONUP:
				_rightClick = true;
				break;
			case Common::EVENT_RETURN_TO_LAUNCHER:
			case Common::EVENT_QUIT:
				return;
			case Common::EVENT_WHEELUP:
				handleMouseWheelUp();
				break;
			case Common::EVENT_WHEELDOWN:
				handleMouseWheelDown();
				break;
			default:
				break;
			}
		}

		if (_leftButton == 1)
			_leftButtonCount++;

		_system->getAudioCDManager()->update();

		_system->updateScreen();

		if (amount == 0)
			break;

		this_delay = _fastMode ? 1 : 20;
		if (this_delay > amount)
			this_delay = amount;
		_system->delayMillis(this_delay);

		cur = _system->getMillis();
	} while (cur < start + amount && !shouldQuit());
}

#ifdef ENABLE_AGOS2
void AGOSEngine_DIMP::timerProc() {
	_lastTickCount = _system->getMillis();

	AGOSEngine_Feeble::timerProc();
	dimpIdle();
}

void AGOSEngine_Feeble::timerProc() {
	if (_videoLockOut & 0x80E9 || _videoLockOut & 2)
		return;

	_syncCount++;

	_videoLockOut |= 2;

	if (!(_videoLockOut & 0x10)) {
		_syncFlag2 = !_syncFlag2;
		if (!_syncFlag2) {
			processVgaEvents();
		} else {
			// Double speed on Oracle
			if (getGameType() == GType_FF && getBitFlag(99)) {
				processVgaEvents();
			} else if (_scrollCount == 0) {
				_videoLockOut &= ~2;
				return;
			}
		}

		if (getGameType() == GType_FF && _interactiveVideo) {
			// Controls Omni TV videos
			if (getBitFlag(42)) {
				stopInteractiveVideo();
			} else {
				_moviePlayer->nextFrame();
			}
		}

		animateSprites();
	}

	if (_displayFlag) {
		if (getGameType() == GType_FF && !(getFeatures() & GF_DEMO)) {
			if (!getBitFlag(78)) {
				oracleLogo();
			}
			if (getBitFlag(76)) {
				swapCharacterLogo();
			}
		}
		handleMouseMoved();
		displayScreen();
		_displayFlag = 0;
	}

	_videoLockOut &= ~2;
}
#endif

void AGOSEngine_PN::timerProc() {
	if (_videoLockOut & 0x80E9 || _videoLockOut & 2)
		return;

	_syncCount++;

	_videoLockOut |= 2;

	_sound->handleSoundQueue();
	handleMouseMoved();
	handleKeyboard();

	if (!(_videoLockOut & 0x10)) {
		if (_sampleWait) {
			_vgaCurSpriteId = 0xFFFF;
			vc15_sync();
			_sampleWait = false;
		}
		if (_sampleEnd) {
			_vgaCurSpriteId = 0xFFFE;
			vc15_sync();
			_sampleEnd = false;
		}

		processVgaEvents();
		processVgaEvents();
		_cepeFlag = !_cepeFlag;
		if (!_cepeFlag)
			processVgaEvents();
	}

	if (_displayFlag) {
		displayScreen();
		_displayFlag = 0;
	}

	_videoLockOut &= ~2;
}

void AGOSEngine::timerProc() {
	if (_videoLockOut & 0x80E9 || _videoLockOut & 2)
		return;

	_syncCount++;

	_videoLockOut |= 2;

	handleMouseMoved();

	if (!(_videoLockOut & 0x10)) {
		processVgaEvents();
		processVgaEvents();
		_cepeFlag = !_cepeFlag;
		if (!_cepeFlag)
			processVgaEvents();
	}

	if (_displayFlag) {
		displayScreen();
		_displayFlag = 0;
	}

	_videoLockOut &= ~2;
}

#ifdef ENABLE_AGOS2
void AGOSEngine_DIMP::dimpIdle() {
	int z, n;

	_iconToggleCount++;
	if (_iconToggleCount == 30) {
		if ((_variableArray[110] < 3) || (_variableArray[111] < 3) || (_variableArray[112] < 3)) {
			_voiceCount++;
			if (_voiceCount == 50) {
				if (!getBitFlag(14) && !getBitFlag(11) && !getBitFlag(13)) {
					loadSoundFile("Whistle.WAV");
					z = 0;
					while (z == 0) {
						n = _rnd.getRandomNumber(2);
						switch (n) {
							default:
							case(0):
								if (_variableArray[110] > 2)
									break;
								n = _rnd.getRandomNumber(6);
								switch (n) {
									default:
									case(0): loadSoundFile("And01.wav");break;
									case(1): loadSoundFile("And02.wav");break;
									case(2): loadSoundFile("And03.wav");break;
									case(3): loadSoundFile("And04.wav");break;
									case(4): loadSoundFile("And05.wav");break;
									case(5): loadSoundFile("And06.wav");break;
									case(6): loadSoundFile("And07.wav");break;
								}
								z = 1;
								break;
							case(1):
								if (_variableArray[111] > 2)
									break;
								n = _rnd.getRandomNumber(6);
								switch (n) {
									default:
									case(0): loadSoundFile("And08.wav");break;
									case(1): loadSoundFile("And09.wav");break;
									case(2): loadSoundFile("And0a.wav");break;
									case(3): loadSoundFile("And0b.wav");break;
									case(4): loadSoundFile("And0c.wav");break;
									case(5): loadSoundFile("And0d.wav");break;
									case(6): loadSoundFile("And0e.wav");break;
								}
								z = 1;
								break;
							case(2):
								if (_variableArray[112] > 2)
									break;
								n = _rnd.getRandomNumber(4);
								switch (n) {
									default:
									case(0): loadSoundFile("And0f.wav");break;
									case(1): loadSoundFile("And0g.wav");break;
									case(2): loadSoundFile("And0h.wav");break;
									case(3): loadSoundFile("And0i.wav");break;
									case(4): loadSoundFile("And0j.wav");break;
								}
								z = 1;
								break;
						}
					}
				}
				_voiceCount = 0;
			}
		} else {
			_voiceCount = 48;
		}
		_iconToggleCount = 0;
	}

	if (_variableArray[121] == 0) {
		_variableArray[121]++;
		_startSecondCount = _lastTickCount;
	}
	if (((_lastTickCount - _startSecondCount) / 1000) != _tSecondCount) {
		if (_startSecondCount != 0) {
			uint32 x = (_variableArray[123] * 65536) + _variableArray[122] + ((_lastTickCount - _startSecondCount) / 1000) - _tSecondCount;
			_variableArray[122] = (uint16)(x % 65536);
			_variableArray[123] = (uint16)(x / 65536);
			_tSecondCount = (_lastTickCount - _startSecondCount) / 1000;
		}
	}
}
#endif

} // End of namespace AGOS

================
File: feeble.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */



#ifdef ENABLE_AGOS2

#include "common/config-manager.h"

#include "agos/intern.h"
#include "agos/agos.h"
#include "agos/animation.h"

namespace AGOS {

AGOSEngine_Feeble::AGOSEngine_Feeble(OSystem *system, const AGOSGameDescription *gd)
	: AGOSEngine_Simon2(system, gd) {

	_interactiveVideo = 0;
	_moviePlayer = 0;
	_vgaCurSpritePriority = 0;
	_mouseToggle = false;
	_opcodesFeeble = nullptr;
}

AGOSEngine_Feeble::~AGOSEngine_Feeble() {
	delete _moviePlayer;
}

static const GameSpecificSettings feeblefiles_settings = {
	"game22",                               // base_filename
	"save.999",                             // restore_filename
	"tbllist",                              // tbl_filename
	"",                                     // effects_filename
	"VOICES",                               // speech_filename
};

void AGOSEngine_Feeble::setupGame() {
	gss = &feeblefiles_settings;
	_numVideoOpcodes = 85;
	_vgaMemSize = 7500000;
	_itemMemSize = 20000;
	_tableMemSize = 200000;
	_frameCount = 1;
	_vgaBaseDelay = 5;
	_vgaPeriod = 50;
	_numBitArray1 = 16;
	_numBitArray2 = 16;
	_numBitArray3 = 16;
	_numItemStore = 10;
	_numTextBoxes = 40;
	_numVars = 255;

	_numSpeech = 10000;
	_numZone = 450;

	AGOSEngine::setupGame();
}

void AGOSEngine_Feeble::runSubroutine101() {
	if ((getPlatform() == Common::kPlatformAmiga || getPlatform() == Common::kPlatformMacintosh) &&
		getGameType() == GType_FF) {
		playVideo("epic.dxa");
	}

	AGOSEngine::runSubroutine101();
}

void AGOSEngine_Feeble::playVideo(const char *filename, bool lastSceneUsed) {
	if (shouldQuit())
		return;

	if (lastSceneUsed)
		setBitFlag(41, true);

	_moviePlayer = makeMoviePlayer(this, filename);
	assert(_moviePlayer);

	_moviePlayer->load();
	_moviePlayer->play();

	delete _moviePlayer;
	_moviePlayer = NULL;

	if (lastSceneUsed)
		setBitFlag(41, false);
}

void AGOSEngine_Feeble::stopInteractiveVideo() {
	if (_interactiveVideo) {
		_interactiveVideo = 0;
		_moviePlayer->stopVideo();
		delete _moviePlayer;
		_moviePlayer = NULL;
	}
}

AGOSEngine_FeebleDemo::AGOSEngine_FeebleDemo(OSystem *system, const AGOSGameDescription *gd)
	: AGOSEngine_Feeble(system, gd) {

	_filmMenuUsed = 0;
}

Common::Error AGOSEngine_FeebleDemo::go() {
	// Main menu
	defineBox( 1,  80,  75,  81, 117, kBFBoxDead, 0, NULL);
	defineBox( 2, 267,  21, 105,  97, kBFBoxDead, 0, NULL);
	defineBox( 3, 456,  89, 125, 103, kBFBoxDead, 0, NULL);
	defineBox( 4, 151, 225, 345,  41, kBFBoxDead, 0, NULL);
	defineBox( 5, 169, 319, 109, 113, kBFBoxDead, 0, NULL);
	defineBox( 6, 404, 308,  62, 117, kBFBoxDead, 0, NULL);

	// Film menu
	defineBox(11,  28,  81, 123,  93, kBFBoxDead, 0, NULL);
	defineBox(12, 182,  81, 123,  93, kBFBoxDead, 0, NULL);
	defineBox(13, 335,  81, 123,  93, kBFBoxDead, 0, NULL);
	defineBox(14, 488,  81, 123,  93, kBFBoxDead, 0, NULL);
	defineBox(15,  28, 201, 123,  93, kBFBoxDead, 0, NULL);
	defineBox(16, 182, 201, 123,  93, kBFBoxDead, 0, NULL);
	defineBox(17, 335, 201, 123,  93, kBFBoxDead, 0, NULL);
	defineBox(18, 488, 201, 123,  93, kBFBoxDead, 0, NULL);
	defineBox(19, 255, 357, 135,  45, kBFBoxDead, 0, NULL);

	// Exit Menu
	defineBox(21, 548, 421,  42,  21, kBFBoxDead, 0, NULL);

	// Text Window used by Feeble Files Data section
	if (_language ==Common::DE_DEU) {
		_textWindow = openWindow(322, 457, 196, 15, 1, 0, 255);
	} else {
		_textWindow = openWindow(444, 452, 196, 15, 1, 0, 255);
	}

	playVideo("winasoft.smk");
	playVideo("fbigtalk.smk");

	while (!shouldQuit())
		mainMenu();

	return Common::kNoError;
}

void AGOSEngine_FeebleDemo::exitMenu() {
	for (int i = 1; i <= 20; i++)
		disableBox(i);

	enableBox(21);

	playVideo("fhypno.smk");
	playVideo("fbye1.smk", true);

	HitArea *ha;
	do {
		_lastHitArea = NULL;
		_lastHitArea3 = NULL;

		while (!shouldQuit() && _lastHitArea3 == 0) {
			delay(1);
		}

		ha = _lastHitArea;
	} while (!shouldQuit() && !(ha != NULL && ha->id == 21));

	playVideo("fbye2.smk");
	quitGame();
	delay(0);
}

void AGOSEngine_FeebleDemo::filmMenu() {
	for (int i = 1; i <= 6; i++)
		disableBox(i);

	for (int i = 11; i <= 19; i++)
		enableBox(i);

	if (!_filmMenuUsed) {
		playVideo("fclipsin.smk", true);
	} else {
		playVideo("fclipin2.smk", true);
	}

	_filmMenuUsed = true;

	HitArea *ha;
	while (!shouldQuit()) {
		_lastHitArea = NULL;
		_lastHitArea3 = NULL;

		while (!shouldQuit() && _lastHitArea3 == 0) {
			handleWobble();
			delay(1);
		}

		ha = _lastHitArea;

		if (ha == NULL)
			continue;

		stopInteractiveVideo();

		if (ha->id == 11) {
			playVideo("fgo1.smk");
			playVideo("maze.smk");
		} else if (ha->id == 12) {
			playVideo("fgo2.smk");
			playVideo("radioin.smk");
		} else if (ha->id == 13) {
			playVideo("fgo3.smk");
			playVideo("pad.smk");
		} else if (ha->id == 14) {
			playVideo("fgo4.smk");
			playVideo("bridge.smk");
		} else if (ha->id == 15) {
			playVideo("fgo5.smk");
			playVideo("pilldie.smk");
		} else if (ha->id == 16) {
			playVideo("fgo6.smk");
			playVideo("bikebust.smk");
		} else if (ha->id == 17) {
			playVideo("fgo7.smk");
			playVideo("statue.smk");
		} else if (ha->id == 18) {
			playVideo("fgo8.smk");
			playVideo("junkout.smk");
		} else if (ha->id == 19) {
			playVideo("fgo9.smk");
			break;
		}

		playVideo("fclipin2.smk", true);
	}
}

void AGOSEngine_FeebleDemo::handleText() {
	if (_lastClickRem == _currentBox)
		return;

	if (_currentBox && (_currentBox->id >= 1 && _currentBox->id <= 6)) {
		// TODO: Add the subtitles for menu options
	}

	_lastClickRem = _currentBox;
}

void AGOSEngine_FeebleDemo::handleWobble() {
	if (_lastClickRem == _currentBox)
		return;

	stopInteractiveVideo();

	if (_currentBox && (_currentBox->id >= 11 && _currentBox->id <= 19)) {
		char filename[15];
		Common::sprintf_s(filename, "wobble%d.smk", _currentBox->id - 10);

		startInteractiveVideo(filename);
	}

	_lastClickRem = _currentBox;
}

void AGOSEngine_FeebleDemo::mainMenu() {
	for (int i = 1; i <= 6; i++)
		enableBox(i);

	for (int i = 11; i <= 19; i++)
		disableBox(i);

	playVideo("mmfadein.smk", true);

	startInteractiveVideo("mainmenu.smk");

	HitArea *ha = 0;
	do {
		_lastHitArea = NULL;
		_lastHitArea3 = NULL;

		while (_lastHitArea3 == 0) {
			if (shouldQuit())
				return;
			handleText();
			delay(1);
		}

		ha = _lastHitArea;
	} while (ha == NULL || !(ha->id >= 1 && ha->id <= 6));

	if (shouldQuit())
		return;

	stopInteractiveVideo();

	if (ha->id == 1) {
		// Feeble Files Data
		playVideo("ffade5.smk");
		playVideo("ftext0.smk");
		playVideo("ftext1.smk", true);
		waitForSpace();
		playVideo("ftext2.smk", true);
		waitForSpace();
		playVideo("ftext3.smk", true);
		waitForSpace();
		playVideo("ftext4.smk", true);
		waitForSpace();
		playVideo("ftext5.smk", true);
		waitForSpace();
	} else if (ha->id == 2) {
		// Opening Sequence
		playVideo("ffade1.smk");
		playVideo("musosp1.smk");
		playVideo("newcred.smk");
		playVideo("fasall.smk");
		playVideo("mus5p2.smk");
		playVideo("coach.smk");
		playVideo("outmin.smk");
	} else if (ha->id == 3) {
		// Technical Information
		playVideo("ffade3.smk");
		playVideo("idfx4a.smk");
		playVideo("idfx4b.smk");
		playVideo("idfx4c.smk");
		playVideo("idfx4d.smk");
		playVideo("idfx4e.smk");
		playVideo("idfx4f.smk");
		playVideo("idfx4g.smk");
	} else if (ha->id == 4) {
		// About AdventureSoft
		playVideo("ffade2.smk");
		playVideo("fscene3b.smk");
		playVideo("fscene3a.smk");
		playVideo("fscene3c.smk");
		playVideo("fscene3g.smk");
	} else if (ha->id == 5) {
		// Video Clips
		playVideo("ffade4.smk");
		filmMenu();
	} else if (ha->id == 6) {
		// Exit InfoDisk
		playVideo("ffade6.smk");
		exitMenu();
	}
}

void AGOSEngine_FeebleDemo::startInteractiveVideo(const char *filename) {
	setBitFlag(40, true);
	_interactiveVideo = MoviePlayer::TYPE_LOOPING;
	_moviePlayer = makeMoviePlayer(this, filename);
	assert(_moviePlayer);
	_moviePlayer->load();
	_moviePlayer->play();
	setBitFlag(40, false);
}

void AGOSEngine_FeebleDemo::waitForSpace() {
	const char *message;

	if (_language == Common::DE_DEU) {
		message = "Dr\x81""cken Sie die <Leertaste>, um fortzufahren...";
	} else {
		message = "Press <SPACE> to continue...";
	}

	windowPutChar(_textWindow, 12);
	for (; *message; message++)
		windowPutChar(_textWindow, *message);

	mouseOff();
	do {
		delay(1);
	} while (!shouldQuit() && (_keyPressed.keycode != Common::KEYCODE_SPACE));
	_keyPressed.reset();
	mouseOn();
}

} // End of namespace AGOS

#endif // ENABLE_AGOS2

================
File: gfx.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/debug-channels.h"
#include "common/endian.h"
#include "common/system.h"
#include "common/textconsole.h"

#include "graphics/surface.h"

#include "agos/agos.h"
#include "agos/intern.h"
#include "agos/vga.h"

namespace AGOS {

byte *vc10_depackColumn(VC10_state * vs) {
	int8 a = vs->depack_cont;
	const byte *src = vs->srcPtr;
	byte *dst = vs->depack_dest;
	uint16 dh = vs->dh;
	byte color;

	if (a == -0x80)
		a = *src++;

	for (;;) {
		if (a >= 0) {
			color = *src++;
			do {
				*dst++ = color;
				if (!--dh) {
					if (--a < 0)
						a = -0x80;
					else
						src--;
					goto get_out;
				}
			} while (--a >= 0);
		} else {
			do {
				*dst++ = *src++;
				if (!--dh) {
					if (++a == 0)
						a = -0x80;
					goto get_out;
				}
			} while (++a != 0);
		}
		a = *src++;
	}

get_out:;
	vs->srcPtr = src;
	vs->depack_cont = a;
	return vs->depack_dest + vs->y_skip;
}

void vc10_skip_cols(VC10_state *vs) {
	while (vs->x_skip) {
		vc10_depackColumn(vs);
		vs->x_skip--;
	}
}

void AGOSEngine::decodeColumn(byte *dst, const byte *src, uint16 height, uint16 pitch) {
	int8 reps = (int8)0x80;
	byte color;
	byte *dstPtr = dst;
	uint h = height, w = 8;

	for (;;) {
		reps = *src++;
		if (reps >= 0) {
			color = *src++;

			do {
				*dst = color;
				dst += pitch;

				/* reached bottom? */
				if (--h == 0) {
					/* reached right edge? */
					if (--w == 0)
						return;
					dst = ++dstPtr;
					h = height;
				}
			} while (--reps >= 0);
		} else {

			do {
				*dst = *src++;
				dst += pitch;

				/* reached bottom? */
				if (--h == 0) {
					/* reached right edge? */
					if (--w == 0)
						return;
					dst = ++dstPtr;
					h = height;
				}
			} while (++reps != 0);
		}
	}
}

void AGOSEngine::decodeRow(byte *dst, const byte *src, uint16 width, uint16 pitch) {
	int8 reps = (int8)0x80;
	byte color;
	byte *dstPtr = dst;
	uint w = width, h = 8;

	for (;;) {
		reps = *src++;
		if (reps >= 0) {
			color = *src++;

			do {
				*dst++ = color;

				/* reached right edge? */
				if (--w == 0) {
					/* reached bottom? */
					if (--h == 0)
						return;
					dstPtr += pitch;
					dst = dstPtr;
					w = width;
				}
			} while (--reps >= 0);
		} else {

			do {
				*dst++ = *src++;

				/* reached right edge? */
				if (--w == 0) {
					/* reached bottom? */
					if (--h == 0)
						return;
					dstPtr += pitch;
					dst = dstPtr;
					w = width;
				}
			} while (++reps != 0);
		}
	}
}

bool AGOSEngine::drawImage_clip(VC10_state *state) {
	const uint16 *vlut;
	uint maxWidth, maxHeight;
	int cur;

	vlut = &_videoWindows[_windowNum * 4];

	if (getGameType() != GType_FF && getGameType() != GType_PP) {
		state->draw_width = state->width * 2;
	}

	cur = state->x;
	if (cur < 0) {
		do {
			if (!--state->draw_width)
				return 0;
			state->x_skip++;
		} while (++cur);
	}
	state->x = cur;

	maxWidth = (getGameType() == GType_FF || getGameType() == GType_PP) ? _screenWidth : (vlut[2] * 2);
	cur += state->draw_width - maxWidth;
	if (cur > 0) {
		do {
			if (!--state->draw_width)
				return 0;
		} while (--cur);
	}

	cur = state->y;
	if (cur < 0) {
		do {
			if (!--state->draw_height)
				return 0;
			state->y_skip++;
		} while (++cur);
	}
	state->y = cur;

	maxHeight = (getGameType() == GType_FF || getGameType() == GType_PP) ? _screenHeight : vlut[3];
	cur += state->draw_height - maxHeight;
	if (cur > 0) {
		do {
			if (!--state->draw_height)
				return 0;
		} while (--cur);
	}

	if (getGameType() != GType_FF && getGameType() != GType_PP) {
		state->draw_width *= 4;
	}

	return (state->draw_width != 0 && state->draw_height != 0);
}

#ifdef ENABLE_AGOS2
void AGOSEngine_Feeble::scaleClip(int16 h, int16 w, int16 y, int16 x, int16 scrollY) {
	Common::Rect srcRect, dstRect;
	float factor, xscale;

	srcRect.left = 0;
	srcRect.top = 0;
	srcRect.right = w;
	srcRect.bottom = h;

	if (scrollY > _baseY)
		factor = 1 + ((scrollY - _baseY) * _scale);
	else
		factor = 1 - ((_baseY - scrollY) * _scale);

	xscale = ((w * factor) / 2);

	dstRect.left = (int16)(x - xscale);
	if (dstRect.left > _screenWidth - 1)
		return;
	dstRect.top = (int16)(y - (h * factor));
	if (dstRect.top > _screenHeight - 1)
		return;

	dstRect.right = (int16)(x + xscale);
	dstRect.bottom = y;

	_feebleRect = dstRect;

	_variableArray[20] = _feebleRect.top;
	_variableArray[21] = _feebleRect.left;
	_variableArray[22] = _feebleRect.bottom;
	_variableArray[23] = _feebleRect.right;

	debug(5, "Left %d Right %d Top %d Bottom %d", dstRect.left, dstRect.right, dstRect.top, dstRect.bottom);

	// Unlike normal rectangles in ScummVM, it seems that in the case of
	// the destination rectangle the bottom and right coordinates are
	// considered to be inside the rectangle. For the source rectangle,
	// I believe that they are not.

	int scaledW = dstRect.width() + 1;
	int scaledH = dstRect.height() + 1;

	byte *src = getScaleBuf();
	byte *dst = getBackBuf();

	dst += dstRect.top * _backBuf->pitch + dstRect.left;

	for (int dstY = 0; dstY < scaledH; dstY++) {
		if (dstRect.top + dstY >= 0 && dstRect.top + dstY < _screenHeight) {
			int srcY = (dstY * h) / scaledH;
			byte *srcPtr = src + _scaleBuf->pitch * srcY;
			byte *dstPtr = dst + _backBuf->pitch * dstY;
			for (int dstX = 0; dstX < scaledW; dstX++) {
				if (dstRect.left + dstX >= 0 && dstRect.left + dstX < _screenWidth) {
					int srcX = (dstX * w) / scaledW;
					if (srcPtr[srcX])
						dstPtr[dstX] = srcPtr[srcX];
				}
			}
		}
	}
}

void AGOSEngine_Feeble::drawImage(VC10_state *state) {
	state->surf_addr = getBackBuf();
	state->surf_pitch = _backBuf->pitch;

	if (state->flags & kDFCompressed) {
		if (state->flags & kDFScaled) {
			state->surf_addr = getScaleBuf();
			state->surf_pitch = _scaleBuf->pitch;

			uint w, h;
			byte *src, *dst, *dstPtr;

			state->dl = state->width;
			state->dh = state->height;

			dstPtr = state->surf_addr;
			w = 0;
			do {
				src = vc10_depackColumn(state);
				dst = dstPtr;

				h = 0;
				do {
					*dst = *src;
					dst += state->surf_pitch;
					src++;
				} while (++h != state->draw_height);
				dstPtr++;
			} while (++w != state->draw_width);

			if (_vgaCurSpritePriority % 10 != 9) {
				_scaleX = state->x;
				_scaleY = state->y;
				_scaleWidth = state->width;
				_scaleHeight = state->height;
			} else {
				scaleClip(state->height, state->width, state->y, state->x, state->y + _scrollY);
			}
		} else if (state->flags & kDFOverlayed) {
			state->surf_addr = getScaleBuf();
			state->surf_pitch = _scaleBuf->pitch;
			state->surf_addr += (state->x + _scrollX) + (state->y + _scrollY) * state->surf_pitch;

			uint w, h;
			byte *src, *dst, *dstPtr;

			state->dl = state->width;
			state->dh = state->height;

			dstPtr = state->surf_addr;
			w = 0;
			do {
				byte color;

				src = vc10_depackColumn(state);
				dst = dstPtr;

				h = 0;
				do {
					color = *src;
					if (color != 0)
						*dst = color;
					dst += state->surf_pitch;
					src++;
				} while (++h != state->draw_height);
				dstPtr++;
			} while (++w != state->draw_width);

			if (_vgaCurSpritePriority % 10 == 9) {
				scaleClip(_scaleHeight, _scaleWidth, _scaleY, _scaleX, _scaleY + _scrollY);
			}
		} else {
			if (!drawImage_clip(state)) {
				return;
			}

			state->surf_addr += state->x + state->y * state->surf_pitch;

			uint w, h;
			byte *src, *dst, *dstPtr;

			state->dl = state->width;
			state->dh = state->height;

			vc10_skip_cols(state);


			if (state->flags & kDFMasked) {
				if (getGameType() == GType_FF && !getBitFlag(81)) {
					if (state->x > _feebleRect.right) {
						return;
					}
					if (state->y > _feebleRect.bottom) {
						return;
					}
					if (state->x + state->width < _feebleRect.left) {
						return;
					}
					if (state->y + state->height < _feebleRect.top) {
						return;
					}
				}

				dstPtr = state->surf_addr;
				w = 0;
				do {
					byte color;

					src = vc10_depackColumn(state);
					dst = dstPtr;

					h = 0;
					do {
						color = *src;
						if (color)
							*dst = color;
						dst += state->surf_pitch;
						src++;
					} while (++h != state->draw_height);
					dstPtr++;
				} while (++w != state->draw_width);
			} else {
				dstPtr = state->surf_addr;
				w = 0;
				do {
					byte color;

					src = vc10_depackColumn(state);
					dst = dstPtr;

					h = 0;
					do {
						color = *src;
						if ((state->flags & kDFNonTrans) || color != 0)
							*dst = color;
						dst += state->surf_pitch;
						src++;
					} while (++h != state->draw_height);
					dstPtr++;
				} while (++w != state->draw_width);
			}
		}
	} else {
		if (!drawImage_clip(state)) {
			return;
		}

		state->surf_addr += state->x + state->y * state->surf_pitch;

		const byte *src;
		byte *dst;
		uint count;

		src = state->srcPtr + state->width * state->y_skip;
		dst = state->surf_addr;
		do {
			for (count = 0; count != state->draw_width; count++) {
				byte color;
				color = src[count + state->x_skip];
				if (color) {
					if ((state->flags & kDFShaded) && color == 220)
						color = 244;

					dst[count] = color;
				}
			}
			dst += state->surf_pitch;
			src += state->width;
		} while (--state->draw_height);
	}
}
#endif

void AGOSEngine_Simon1::drawMaskedImage(VC10_state *state) {
	if (getGameType() == GType_SIMON1 && (_windowNum == 3 || _windowNum == 4 || _windowNum >= 10)) {
		state->surf2_addr += _videoWindows[17] * 320;
	}

	if (getFeatures() & GF_32COLOR) {
		const byte *mask = state->srcPtr + (state->width * state->y_skip * 16) + (state->x_skip * 8);
		byte *src = state->surf2_addr;
		byte *dst = state->surf_addr;

		state->draw_width *= 2;

		uint h = state->draw_height;
		do {
			for (uint i = 0; i != state->draw_width; i++) {
				if (getGameType() == GType_SIMON1 && getBitFlag(88)) {
					/* transparency */
					if (mask[i] && (dst[i] & 16))
						dst[i] = src[i];
				} else {
					/* no transparency */
					if (mask[i])
						dst[i] = src[i];
				}
			}
			dst += state->surf_pitch;
			src += state->surf2_pitch;
			mask += state->width * 16;
		} while (--h);
	} else if (state->flags & kDFCompressed) {
		byte *mask, *src, *dst;
		byte h;
		uint w;

		state->x_skip *= 4;
		state->dl = state->width;
		state->dh = state->height;

		vc10_skip_cols(state);

		w = 0;
		do {
			mask = vc10_depackColumn(state);	/* esi */
			src = state->surf2_addr + w * 2;	/* ebx */
			dst = state->surf_addr + w * 2;		/* edi */

			h = state->draw_height;
			do {
				if (getGameType() == GType_SIMON1 && getBitFlag(88)) {
					/* transparency */
					if ((mask[0] & 0xF0) && (dst[0] & 0x0F0) == 0x20)
						dst[0] = src[0];
					if ((mask[0] & 0x0F) && (dst[1] & 0x0F0) == 0x20)
						dst[1] = src[1];
				} else {
					/* no transparency */
					if (mask[0] & 0xF0)
						dst[0] = src[0];
					if (mask[0] & 0x0F)
						dst[1] = src[1];
				}
				mask++;
				dst += state->surf_pitch;
				src += state->surf2_pitch;
			} while (--h);
		} while (++w != state->draw_width);
	} else {
		const byte *src, *mask;
		byte *dst;
		uint count;

		mask = state->srcPtr + (state->width * state->y_skip) * 8;
		src = state->surf2_addr;
		dst = state->surf_addr;

		state->x_skip *= 4;

		do {
			for (count = 0; count != state->draw_width; count++) {
				if (getGameType() == GType_SIMON1 && getBitFlag(88)) {
					/* transparency */
					if (mask[count + state->x_skip] & 0xF0)
						if ((dst[count * 2] & 0xF0) == 0x20)
							dst[count * 2] = src[count * 2];
					if (mask[count + state->x_skip] & 0x0F)
						if ((dst[count * 2 + 1] & 0xF0) == 0x20)
							dst[count * 2 + 1] = src[count * 2 + 1];
				} else {
					/* no transparency */
					if (mask[count + state->x_skip] & 0xF0)
						dst[count * 2] = src[count * 2];
					if (mask[count + state->x_skip] & 0x0F)
						dst[count * 2 + 1] = src[count * 2 + 1];
				}
			}
			src += state->surf2_pitch;
			dst += state->surf_pitch;
			mask += state->width * 8;
		} while (--state->draw_height);
	}
}

void AGOSEngine_Simon1::draw32ColorImage(VC10_state *state) {
	const byte *src;
	byte *dst;
	uint h, i;

	if (state->flags & kDFCompressed) {
		byte *dstPtr = state->surf_addr;
		src = state->srcPtr;
		/* AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE
		 * aaaaabbb bbcccccd ddddeeee efffffgg ggghhhhh
		 */

		do {
			uint count = state->draw_width / 4;

			dst = dstPtr;
			do {
				uint32 bits = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | (src[3]);
				byte color;

				color = (byte)((bits >> (32 - 5)) & 31);
				if ((state->flags & kDFNonTrans) || color)
					dst[0] = color;
				color = (byte)((bits >> (32 - 10)) & 31);
				if ((state->flags & kDFNonTrans) || color)
					dst[1] = color;
				color = (byte)((bits >> (32 - 15)) & 31);
				if ((state->flags & kDFNonTrans) || color)
					dst[2] = color;
				color = (byte)((bits >> (32 - 20)) & 31);
				if ((state->flags & kDFNonTrans) || color)
					dst[3] = color;
				color = (byte)((bits >> (32 - 25)) & 31);
				if ((state->flags & kDFNonTrans) || color)
					dst[4] = color;
				color = (byte)((bits >> (32 - 30)) & 31);
				if ((state->flags & kDFNonTrans) || color)
					dst[5] = color;

				bits = (bits << 8) | src[4];

				color = (byte)((bits >> (40 - 35)) & 31);
				if ((state->flags & kDFNonTrans) || color)
					dst[6] = color;
				color = (byte)((bits) & 31);
				if ((state->flags & kDFNonTrans) || color)
					dst[7] = color;

				dst += 8;
				src += 5;
			} while (--count);
			dstPtr += state->surf_pitch;
		} while (--state->draw_height);
	} else {
		src = state->srcPtr + (state->width * state->y_skip * 16) + (state->x_skip * 8);
		dst = state->surf_addr;

		state->draw_width *= 2;

		h = state->draw_height;
		do {
			for (i = 0; i != state->draw_width; i++)
				if ((state->flags & kDFNonTrans) || src[i])
					dst[i] = src[i] + state->paletteMod;
			dst += state->surf_pitch;
			src += state->width * 16;
		} while (--h);
	}
}

void AGOSEngine_Simon1::drawImage(VC10_state *state) {
	const uint16 *vlut = &_videoWindows[_windowNum * 4];

	if (!drawImage_clip(state))
		return;

	Graphics::Surface *screen = getBackendSurface();

	if (getFeatures() & GF_32COLOR)
		state->palette = 0xC0;

	uint16 xoffs, yoffs;
	if (getGameType() == GType_SIMON2) {
		state->surf2_addr = getBackGround();
		state->surf2_pitch = _backGroundBuf->pitch;

		state->surf_addr = (byte *)_window4BackScn->getPixels();
		state->surf_pitch = _window4BackScn->pitch;

		xoffs = ((vlut[0] - _videoWindows[16]) * 2 + state->x) * 8;
		yoffs = (vlut[1] - _videoWindows[17] + state->y);

		uint xmax = (xoffs + state->draw_width * 2);
		uint ymax = (yoffs + state->draw_height);
		setMoveRect(xoffs, yoffs, xmax, ymax);

		_window4Flag = 1;
	} else if (getGameType() == GType_SIMON1 && (getFeatures() & GF_DEMO)) {
		// The DOS Floppy demo was based off Waxworks engine
		if (_windowNum == 4 || (_windowNum >= 10 && _windowNum <= 27)) {
			state->surf2_addr = getBackGround();
			state->surf2_pitch = _backGroundBuf->pitch;

			state->surf_addr = (byte *)_window4BackScn->getPixels();
			state->surf_pitch = _videoWindows[18] * 16;

			xoffs = ((vlut[0] - _videoWindows[16]) * 2 + state->x) * 8;
			yoffs = (vlut[1] - _videoWindows[17] + state->y);

			uint xmax = (xoffs + state->draw_width * 2);
			uint ymax = (yoffs + state->draw_height);
			setMoveRect(xoffs, yoffs, xmax, ymax);

			_window4Flag = 1;
		} else {
			state->surf_addr = (byte *)screen->getPixels();
			state->surf_pitch = screen->pitch;

			xoffs = (vlut[0] * 2 + state->x) * 8;
			yoffs = vlut[1] + state->y;
		}
	} else {
		if (_windowNum == 3 || _windowNum == 4 || _windowNum >= 10) {
			if (_window3Flag == 1) {
				state->surf2_addr = getBackGround();
				state->surf2_pitch = _backGroundBuf->pitch;

				state->surf_addr = getBackGround();
				state->surf_pitch = _backGroundBuf->pitch;
			} else {
				state->surf2_addr = getBackGround();
				state->surf2_pitch = _backGroundBuf->pitch;

				state->surf_addr = (byte *)_window4BackScn->getPixels();
				state->surf_pitch = _window4BackScn->pitch;
			}

			xoffs = ((vlut[0] - _videoWindows[16]) * 2 + state->x) * 8;
			yoffs = (vlut[1] - _videoWindows[17] + state->y);

			uint xmax = (xoffs + state->draw_width * 2);
			uint ymax = (yoffs + state->draw_height);
			setMoveRect(xoffs, yoffs, xmax, ymax);

			_window4Flag = 1;
		} else {
			state->surf2_addr = getBackGround();
			state->surf2_pitch = _backGroundBuf->pitch;

			state->surf_addr = (byte *)screen->getPixels();
			state->surf_pitch = screen->pitch;

			xoffs = (vlut[0] * 2 + state->x) * 8;
			yoffs = vlut[1] + state->y;
		}
	}

	state->surf_addr += xoffs + yoffs * state->surf_pitch;
	state->surf2_addr += xoffs + yoffs * state->surf2_pitch;

	if ((getFeatures() & GF_32COLOR) && !_window3Flag && yoffs > 133) {
		state->paletteMod = 208;
	}

	if (_backFlag) {
		drawBackGroundImage(state);
	} else if (state->flags & kDFMasked) {
		drawMaskedImage(state);
	} else if (((_videoLockOut & 0x20) && state->palette == 0) || state->palette == 0xC0) {
		draw32ColorImage(state);
	} else {
		drawVertImage(state);
	}

	updateBackendSurface();
}

void AGOSEngine::drawBackGroundImage(VC10_state *state) {
	state->width = _screenWidth;
	if (_window3Flag == 1) {
		state->width = 0;
		state->x_skip = 0;
		state->y_skip = 0;
	}

	const byte* src = state->srcPtr + (state->width * state->y_skip) + (state->x_skip * 8);
	byte* dst = state->surf_addr;

	state->draw_width *= 2;

	uint h = state->draw_height;
	const uint w = state->draw_width;
	const byte paletteMod = state->paletteMod;
	do {
		for (uint i = 0; i != w; i+=2) {
			dst[i] = src[i] + paletteMod;
			dst[i+1] = src[i+1] + paletteMod;
		}
		dst += state->surf_pitch;
		src += state->width;
	} while (--h);
}

void AGOSEngine::drawVertImage(VC10_state *state) {
	if (state->flags & kDFCompressed) {
		drawVertImageCompressed(state);
	} else {
		drawVertImageUncompressed(state);
	}
}

void AGOSEngine::drawVertImageUncompressed(VC10_state *state) {
	assert((state->flags & kDFCompressed) == 0);

	const byte *src;
	byte *dst;
	uint count;

	src = state->srcPtr + (state->width * state->y_skip) * 8;
	dst = state->surf_addr;
	state->x_skip *= 4;

	do {
		for (count = 0; count != state->draw_width; count++) {
			byte color;
			color = (src[count + state->x_skip] / 16) + state->paletteMod;
			if ((state->flags & kDFNonTrans) || color)
				dst[count * 2] = color | state->palette;
			color = (src[count + state->x_skip] & 15) + state->paletteMod;
			if ((state->flags & kDFNonTrans) || color)
				dst[count * 2 + 1] = color | state->palette;
		}
		dst += state->surf_pitch;
		src += state->width * 8;
	} while (--state->draw_height);
}

void AGOSEngine::drawVertImageCompressed(VC10_state *state) {
	assert(state->flags & kDFCompressed);
	uint w, h;

	state->x_skip *= 4;				/* reached */

	state->dl = state->width;
	state->dh = state->height;

	vc10_skip_cols(state);

	byte *dstPtr = state->surf_addr;
	if (!(state->flags & kDFNonTrans) && (state->flags & 0x40)) { /* reached */
		dstPtr += vcReadVar(252);
	}
	w = 0;
	do {
		byte color;

		const byte *src = vc10_depackColumn(state);
		byte *dst = dstPtr;

		h = 0;
		if (state->flags & kDFNonTrans) {
			do {
				byte colors = *src;
				color = (colors / 16);
				dst[0] = color | state->palette;
				color = (colors & 15);
				dst[1] = color | state->palette;
				dst += state->surf_pitch;
				src++;
			} while (++h != state->draw_height);
		} else {
			do {
				byte colors = *src;
				color = (colors / 16);
				if (color != 0)
					dst[0] = color | state->palette;
				color = (colors & 15);
				if (color != 0)
					dst[1] = color | state->palette;
				dst += state->surf_pitch;
				src++;
			} while (++h != state->draw_height);
		}
		dstPtr += 2;
	} while (++w != state->draw_width);
}

void AGOSEngine::drawImage(VC10_state *state) {
	const uint16 *vlut = &_videoWindows[_windowNum * 4];

	if (!drawImage_clip(state))
		return;

	Graphics::Surface *screen = getBackendSurface();

	uint16 xoffs = 0, yoffs = 0, xmax = 0, ymax = 0;
	if (getGameType() == GType_WW) {
		if (_windowNum == 4 || (_windowNum >= 10 && _windowNum <= 27)) {
			state->surf_addr = (byte *)_window4BackScn->getPixels();
			state->surf_pitch = _videoWindows[18] * 16;

			xoffs = ((vlut[0] - _videoWindows[16]) * 2 + state->x) * 8;
			yoffs = (vlut[1] - _videoWindows[17] + state->y);

			xmax = (xoffs + state->draw_width * 2);
			ymax = (yoffs + state->draw_height);
			setMoveRect(xoffs, yoffs, xmax, ymax);

			_window4Flag = 1;
		} else {
			state->surf_addr = (byte *)screen->getPixels();
			state->surf_pitch = screen->pitch;

			xoffs = (vlut[0] * 2 + state->x) * 8;
			yoffs = vlut[1] + state->y;
			xmax = (xoffs + state->draw_width * 2);
			ymax = (yoffs + state->draw_height);
		}
	} else if (getGameType() == GType_ELVIRA2) {
		if (_windowNum == 4 || _windowNum >= 10) {
			state->surf_addr = (byte *)_window4BackScn->getPixels();
			state->surf_pitch = _videoWindows[18] * 16;

			xoffs = ((vlut[0] - _videoWindows[16]) * 2 + state->x) * 8;
			yoffs = (vlut[1] - _videoWindows[17] + state->y);

			xmax = (xoffs + state->draw_width * 2);
			ymax = (yoffs + state->draw_height);
			setMoveRect(xoffs, yoffs, xmax, ymax);

			_window4Flag = 1;
		} else {
			state->surf_addr = (byte *)screen->getPixels();
			state->surf_pitch = screen->pitch;

			xoffs = (vlut[0] * 2 + state->x) * 8;
			yoffs = vlut[1] + state->y;
			xmax = (xoffs + state->draw_width * 2);
			ymax = (yoffs + state->draw_height);
		}
	} else if (getGameType() == GType_ELVIRA1) {
		if (_windowNum == 6) {
			state->surf_addr = (byte *)_window6BackScn->getPixels();
			state->surf_pitch = _window6BackScn->pitch;

			xoffs = state->x * 8;
			yoffs = state->y;
			xmax = xoffs + vlut[2] * 16;
			ymax = yoffs + vlut[3];
		} else if (_windowNum == 2 || _windowNum == 3) {
			state->surf_addr = (byte *)screen->getPixels();
			state->surf_pitch = screen->pitch;

			xoffs = (vlut[0] * 2 + state->x) * 8;
			yoffs = vlut[1] + state->y;
			xmax = xoffs + state->draw_width * 2;
			ymax = yoffs + state->draw_height;
		} else {
			state->surf_addr = (byte *)_window4BackScn->getPixels();
			state->surf_pitch = _videoWindows[18] * 16;

			xoffs = ((vlut[0] - _videoWindows[16]) * 2 + state->x) * 8;
			yoffs = (vlut[1] - _videoWindows[17] + state->y);

			xmax = (xoffs + state->draw_width * 2);
			ymax = (yoffs + state->draw_height);
			setMoveRect(xoffs, yoffs, xmax, ymax);

			_window4Flag = 1;
		}
	} else {
		state->surf_addr = (byte *)screen->getPixels();
		state->surf_pitch = screen->pitch;

		xoffs = (vlut[0] * 2 + state->x) * 8;
		yoffs = vlut[1] + state->y;
		xmax = (xoffs + state->draw_width * 2);
		ymax = (yoffs + state->draw_height);
	}

	state->surf_addr += xoffs + yoffs * state->surf_pitch;

	if (getGameType() == GType_ELVIRA1 && (state->flags & kDFNonTrans) && yoffs > 133)
		state->paletteMod = _paletteModNext;
	_paletteModNext = 16;

	if (getGameType() == GType_ELVIRA2 || getGameType() == GType_WW)
		state->palette = state->surf_addr[0] & 0xF0;

	if (getGameType() == GType_ELVIRA2 && getPlatform() == Common::kPlatformAtariST && yoffs > 133)
		state->palette = 208;

	if (_backFlag) {
		drawBackGroundImage(state);
	} else {
		drawVertImage(state);
	}

	Common::Rect dirtyRect(xoffs, yoffs, xmax, ymax);
	updateBackendSurface(&dirtyRect);
}

void AGOSEngine::horizontalScroll(VC10_state *state) {
	const byte *src;
	byte *dst;
	int dstPitch, w;

	if (getGameType() == GType_FF)
		_scrollXMax = state->width - 640;
	else
		_scrollXMax = state->width * 2 - 40;
	_scrollYMax = 0;
	_scrollImage = state->srcPtr;
	_scrollHeight = state->height;
	if (_variableArrayPtr[34] < 0)
		state->x = _variableArrayPtr[251];

	_scrollX = state->x;

	vcWriteVar(251, _scrollX);

	if (getGameType() == GType_SIMON2) {
		dst = (byte *)_window4BackScn->getPixels();
		dstPitch = _window4BackScn->pitch;
	} else {
		dst = getBackBuf();
		dstPitch = _backBuf->pitch;
	}

	if (getGameType() == GType_FF)
		src = state->srcPtr + _scrollX / 2;
	else
		src = state->srcPtr + _scrollX * 4;

	for (w = 0; w < _screenWidth; w += 8) {
		decodeColumn(dst, src + readUint32Wrapper(src), state->height, dstPitch);
		dst += 8;
		src += 4;
	}

	setMoveRect(0, 0, 320, _scrollHeight);

	_window4Flag = 1;
}

void AGOSEngine::verticalScroll(VC10_state *state) {
	const byte *src;
	byte *dst;
	int h;

	_scrollXMax = 0;
	_scrollYMax = state->height - 480;
	_scrollImage = state->srcPtr;
	_scrollWidth = state->width;
	if (_variableArrayPtr[34] < 0)
		state->y = _variableArrayPtr[250];

	_scrollY = state->y;

	vcWriteVar(250, _scrollY);

	dst = getBackBuf();
	src = state->srcPtr + _scrollY / 2;

	for (h = 0; h < _screenHeight; h += 8) {
		decodeRow(dst, src + READ_LE_UINT32(src), state->width, _backBuf->pitch);
		dst += 8 * state->width;
		src += 4;
	}
}

Graphics::Surface *AGOSEngine::getBackendSurface() const {
	return (getGameId() == GID_ELVIRA1 && getPlatform() == Common::kPlatformPC98) ? _backBuf : _system->lockScreen();
}

void AGOSEngine::updateBackendSurface(Common::Rect *area) const {
	if (getGameId() == GID_ELVIRA1 && getPlatform() == Common::kPlatformPC98) {
		int x = 0;
		int y = 0;
		int w = _screenWidth;
		int h = _screenHeight;

		if (area) {
			x = area->left;
			y = area->top;
			w = area->width();
			h = area->height();
		}

		Graphics::Surface *screen = _system->lockScreen();

		int src0Pitch = _backBuf->pitch;
		int src1Pitch = _scaleBuf->pitch;
		int dst1Pitch = screen->pitch;
		const byte *src00 = (byte*)_backBuf->getBasePtr(x, y);
		const byte *src10 = (byte*)_scaleBuf->getBasePtr(x << 1, y << 1);
		const byte *src11 = src10 + src1Pitch;
		byte *dst10 = (byte*)screen->getBasePtr(x << 1, y << 1);
		byte *dst11 = dst10 + dst1Pitch;
		src0Pitch -= w;
		src1Pitch += (src1Pitch - (w << 1));
		dst1Pitch += (dst1Pitch - (w << 1));

		while (h--) {
			for (int i = 0; i < w; ++i) {
				uint8 v0 = *src00++;
				uint8 v1 = *src10++;
				*dst10++ = v1 ? v1 : v0;
				v1 = *src10++;
				*dst10++ = v1 ? v1 : v0;
				v1 = *src11++;
				*dst11++ = v1 ? v1 : v0;
				v1 = *src11++;
				*dst11++ = v1 ? v1 : v0;
			}
			src00 += src0Pitch;
			src10 += src1Pitch;
			src11 += src1Pitch;
			dst10 += dst1Pitch;
			dst11 += dst1Pitch;
		}
	}

	_system->unlockScreen();
}

void AGOSEngine::paletteFadeOut(byte *palPtr, uint num, uint size) {
	byte *p = palPtr;

	do {
		if (p[0] >= size)
			p[0] -= size;
		else
			p[0] = 0;
		if (p[1] >= size)
			p[1] -= size;
		else
			p[1] = 0;
		if (p[2] >= size)
			p[2] -= size;
		else
			p[2] = 0;
		p += 3;
	} while (--num);
}

void AGOSEngine::animate(uint16 windowNum, uint16 zoneNum, uint16 vgaSpriteId, int16 x, int16 y, uint16 palette, bool vgaScript) {
	VgaSprite *vsp;
	VgaPointersEntry *vpe;
	byte *p, *pp;
	uint count;

	if (getGameType() != GType_PN && getGameType() != GType_ELVIRA1) {
		if (isSpriteLoaded(vgaSpriteId, zoneNum))
			return;
	}

	vsp = _vgaSprites;
	while (vsp->id != 0)
		vsp++;

	vsp->windowNum = windowNum;
	vsp->priority = 0;
	vsp->flags = 0;

	vsp->y = y;
	vsp->x = x;
	vsp->image = 0;
	if (getGameType() == GType_PN || getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2 || getGameType() == GType_WW)
		vsp->palette = 0;
	else
		vsp->palette = palette;
	vsp->id = vgaSpriteId;
	vsp->zoneNum = zoneNum;

	for (;;) {
		vpe = &_vgaBufferPointers[zoneNum];
		_curVgaFile1 = vpe->vgaFile1;
		if (vgaScript) {
			if (vpe->vgaFile1 != nullptr)
				break;
			if (_zoneNumber != zoneNum)
				_noOverWrite = _zoneNumber;

			loadZone(zoneNum);
			_noOverWrite = 0xFFFF;
		} else {
			_zoneNumber = zoneNum;
			if (vpe->vgaFile1 != nullptr)
				break;
			loadZone(zoneNum);
		}
	}

	pp = _curVgaFile1;
	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		p = pp + READ_LE_UINT16(pp + 2);
		count = READ_LE_UINT16(&((VgaFile1Header_Feeble *) p)->animationCount);
		p = pp + READ_LE_UINT16(&((VgaFile1Header_Feeble *) p)->animationTable);

		while (count--) {
			if (READ_LE_UINT16(&((AnimationHeader_Feeble *) p)->id) == vgaSpriteId)
				break;
			p += sizeof(AnimationHeader_Feeble);
		}
		assert(READ_LE_UINT16(&((AnimationHeader_Feeble *) p)->id) == vgaSpriteId);
	} else if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
		p = pp + READ_BE_UINT16(pp + 4);
		count = READ_BE_UINT16(&((VgaFile1Header_Common *) p)->animationCount);
		p = pp + READ_BE_UINT16(&((VgaFile1Header_Common *) p)->animationTable);

		while (count--) {
			if (READ_BE_UINT16(&((AnimationHeader_Simon *) p)->id) == vgaSpriteId)
				break;
			p += sizeof(AnimationHeader_Simon);
		}

		assert(READ_BE_UINT16(&((AnimationHeader_Simon *) p)->id) == vgaSpriteId);
	} else {
		p = pp + READ_BE_UINT16(pp + 10);
		p += 20;

		count = READ_BE_UINT16(&((VgaFile1Header_Common *) p)->animationCount);
		p = pp + READ_BE_UINT16(&((VgaFile1Header_Common *) p)->animationTable);

		while (count--) {
			if (READ_BE_UINT16(&((AnimationHeader_WW *) p)->id) == vgaSpriteId)
				break;
			p += sizeof(AnimationHeader_WW);
		}
		assert(READ_BE_UINT16(&((AnimationHeader_WW *) p)->id) == vgaSpriteId);
	}

	if (DebugMan.isDebugChannelEnabled(kDebugVGAScript)) {
		if (getGameType() == GType_FF || getGameType() == GType_PP) {
			dumpVgaScript(_curVgaFile1 + READ_LE_UINT16(&((AnimationHeader_Feeble*)p)->scriptOffs), zoneNum, vgaSpriteId);
		} else if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
			dumpVgaScript(_curVgaFile1 + READ_BE_UINT16(&((AnimationHeader_Simon*)p)->scriptOffs), zoneNum, vgaSpriteId);
		} else {
			dumpVgaScript(_curVgaFile1 + READ_BE_UINT16(&((AnimationHeader_WW*)p)->scriptOffs), zoneNum, vgaSpriteId);
		}
	}

	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		addVgaEvent(_vgaBaseDelay, ANIMATE_EVENT, _curVgaFile1 + READ_LE_UINT16(&((AnimationHeader_Feeble *) p)->scriptOffs), vgaSpriteId, zoneNum);
	} else if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
		addVgaEvent(_vgaBaseDelay, ANIMATE_EVENT, _curVgaFile1 + READ_BE_UINT16(&((AnimationHeader_Simon *) p)->scriptOffs), vgaSpriteId, zoneNum);
	} else {
		addVgaEvent(_vgaBaseDelay, ANIMATE_EVENT, _curVgaFile1 + READ_BE_UINT16(&((AnimationHeader_WW *) p)->scriptOffs), vgaSpriteId, zoneNum);
	}
}

void AGOSEngine::setImage(uint16 vgaSpriteId, bool vgaScript) {
	uint zoneNum;
	VgaPointersEntry *vpe;
	byte *bb, *b;
	uint16 count;
	const byte *vc_ptr_org;

	zoneNum = (getGameType() == GType_PN) ? 0 : vgaSpriteId / 100;

	for (;;) {
		vpe = &_vgaBufferPointers[zoneNum];
		_curVgaFile1 = vpe->vgaFile1;
		_curVgaFile2 = vpe->vgaFile2;

		if (vgaScript) {
			if (vpe->vgaFile1 != nullptr)
				break;
			if (_zoneNumber != zoneNum)
				_noOverWrite = _zoneNumber;

			loadZone(zoneNum);
			_noOverWrite = 0xFFFF;
		} else {
			_curSfxFile = vpe->sfxFile;
			_curSfxFileSize = vpe->sfxFileEnd - vpe->sfxFile;
			_zoneNumber = zoneNum;

			if (vpe->vgaFile1 != nullptr)
				break;

			loadZone(zoneNum);
		}
	}

	bb = _curVgaFile1;
	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		b = bb + READ_LE_UINT16(bb + 2);
		count = READ_LE_UINT16(&((VgaFile1Header_Feeble *) b)->imageCount);
		b = bb + READ_LE_UINT16(&((VgaFile1Header_Feeble *) b)->imageTable);

		while (count--) {
			if (READ_LE_UINT16(&((ImageHeader_Feeble *) b)->id) == vgaSpriteId)
				break;
			b += sizeof(ImageHeader_Feeble);
		}
		assert(READ_LE_UINT16(&((ImageHeader_Feeble *) b)->id) == vgaSpriteId);
	} else if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
		b = bb + READ_BE_UINT16(bb + 4);
		count = READ_BE_UINT16(&((VgaFile1Header_Common *) b)->imageCount);
		b = bb + READ_BE_UINT16(&((VgaFile1Header_Common *) b)->imageTable);

		while (count--) {
			if (READ_BE_UINT16(&((ImageHeader_Simon *) b)->id) == vgaSpriteId)
				break;
			b += sizeof(ImageHeader_Simon);
		}
		assert(READ_BE_UINT16(&((ImageHeader_Simon *) b)->id) == vgaSpriteId);

		if (!vgaScript)
			clearVideoWindow(_windowNum, READ_BE_UINT16(&((ImageHeader_Simon *) b)->color));
	} else {
		b = bb + READ_BE_UINT16(bb + 10);
		b += 20;

		count = READ_BE_UINT16(&((VgaFile1Header_Common *) b)->imageCount);
		b = bb + READ_BE_UINT16(&((VgaFile1Header_Common *) b)->imageTable);

		while (count--) {
			if (READ_BE_UINT16(&((ImageHeader_WW *) b)->id) == vgaSpriteId)
				break;
			b += sizeof(ImageHeader_WW);
		}
		assert(READ_BE_UINT16(&((ImageHeader_WW *) b)->id) == vgaSpriteId);

		if (!vgaScript) {
			uint16 color = READ_BE_UINT16(&((ImageHeader_WW *) b)->color);
			if (getGameType() == GType_PN) {
				if (color & 0x80)
					_wiped = true;
				else if (_wiped == true)
					restoreMenu();
				color &= 0xFF7F;
			}
			clearVideoWindow(_windowNum, color);
		}
	}

	if (DebugMan.isDebugChannelEnabled(kDebugVGAScript)) {
		if (getGameType() == GType_FF || getGameType() == GType_PP) {
			dumpVgaScript(_curVgaFile1 + READ_LE_UINT16(&((ImageHeader_Feeble*)b)->scriptOffs), zoneNum, vgaSpriteId);
		} else if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
			dumpVgaScript(_curVgaFile1 + READ_BE_UINT16(&((ImageHeader_Simon*)b)->scriptOffs), zoneNum, vgaSpriteId);
		} else {
			dumpVgaScript(_curVgaFile1 + READ_BE_UINT16(&((ImageHeader_WW*)b)->scriptOffs), zoneNum, vgaSpriteId);
		}
	}

	vc_ptr_org = _vcPtr;

	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		_vcPtr = _curVgaFile1 + READ_LE_UINT16(&((ImageHeader_Feeble *) b)->scriptOffs);
	} else if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
		_vcPtr = _curVgaFile1 + READ_BE_UINT16(&((ImageHeader_Simon *) b)->scriptOffs);
	} else {
		_vcPtr = _curVgaFile1 + READ_BE_UINT16(&((ImageHeader_WW *) b)->scriptOffs);
	}

	runVgaScript();
	_vcPtr = vc_ptr_org;
}

void AGOSEngine_PN::setWindowImageEx(uint16 mode, uint16 vga_res) {
	if (!_initMouse) {
		_initMouse = 1;
		vc33_setMouseOn();
	}
	setWindowImage(mode, vga_res);
}

void AGOSEngine::setWindowImageEx(uint16 mode, uint16 vgaSpriteId) {
	_window3Flag = 0;

	if (mode == 4) {
		vc29_stopAllSounds();

		if (getGameType() == GType_ELVIRA1) {
			if (_variableArray[299] == 0) {
				_variableArray[293] = 0;
				_wallOn = 0;
			}
		} else if (getGameType() == GType_ELVIRA2) {
			if (_variableArray[70] == 0) {
				_variableArray[71] = 0;
				_wallOn = 0;
			}
		}

	}

	if (_videoLockOut & 0x10)
		error("setWindowImageEx: _videoLockOut & 0x10");

	if (getGameType() != GType_PP && getGameType() != GType_FF) {
		if (getGameType() == GType_WW && (mode == 6 || mode == 8 || mode == 9)) {
			setWindowImage(mode, vgaSpriteId);
		} else {
			while (_copyScnFlag && !shouldQuit())
				delay(1);

			setWindowImage(mode, vgaSpriteId);
		}
	} else {
		setWindowImage(mode, vgaSpriteId);
	}

	// Amiga versions wait for verb area to be displayed.
	if (getGameType() == GType_SIMON1 && getPlatform() == Common::kPlatformAmiga && vgaSpriteId == 1) {
		_copyScnFlag = 5;
		while (_copyScnFlag && !shouldQuit())
			delay(1);
	}
}

void AGOSEngine::setWindowImage(uint16 mode, uint16 vgaSpriteId, bool specialCase) {
	uint16 updateWindow;

	_windowNum = updateWindow = mode;
	_videoLockOut |= 0x20;

	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		vc27_resetSprite();
	} else if (!specialCase) {
		VgaTimerEntry *vte = _vgaTimerList;
		while (vte->type != ANIMATE_INT)
			vte++;

		vte->delay = 2;
	}

	if (getGameType() == GType_PN) {
		AnimTable *animTable = _screenAnim1;
		while (animTable->srcPtr) {
			animTable->srcPtr = nullptr;
			animTable++;
		}
	}

	if (getGameType() == GType_SIMON2 || getGameType() == GType_FF) {
		_scrollX = 0;
		_scrollY = 0;
		_scrollXMax = 0;
		_scrollYMax = 0;
		_scrollCount = 0;
		_scrollFlag = 0;
		_scrollHeight = 134;
		_variableArrayPtr = _variableArray;
		if (_variableArray[34] >= 0) {
			if (getGameType() == GType_FF)
				_variableArray[250] = 0;
			_variableArray[251] = 0;
		}
	}

	setImage(vgaSpriteId, specialCase);

	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		fillBackGroundFromBack();
		_syncFlag2 = true;
	} else {
		_copyScnFlag = 2;
		_vgaSpriteChanged++;

		if (_window3Flag == 1) {
			clearVideoBackGround(3, 0);
			_videoLockOut &= ~0x20;
			return;
		}

		uint xoffs = _videoWindows[updateWindow * 4 + 0] * 16;
		uint yoffs = _videoWindows[updateWindow * 4 + 1];
		uint width = _videoWindows[updateWindow * 4 + 2] * 16;
		uint height = _videoWindows[updateWindow * 4 + 3];

		Graphics::Surface *screen = getBackendSurface();
		byte *dst = (byte *)_backGroundBuf->getBasePtr(xoffs, yoffs);
		byte *src = nullptr;
		uint srcWidth = 0;

		if (getGameType() == GType_SIMON2) {
			src = (byte *)_window4BackScn->getBasePtr(xoffs, yoffs);
			srcWidth = 320;
		} else if (getGameType() == GType_SIMON1 && (getFeatures() & GF_DEMO)) {
			// The DOS Floppy demo was based off Waxworks engine
			if (updateWindow == 4 || updateWindow >= 10) {
				src = (byte *)_window4BackScn->getPixels();
				srcWidth = _videoWindows[18] * 16;
			} else if (updateWindow == 3 || updateWindow == 9) {
				src = (byte *)screen->getBasePtr(xoffs, yoffs);
				srcWidth = screen->pitch;
			} else {
				updateBackendSurface();
				_videoLockOut &= ~0x20;
				return;
			}
		} else if (getGameType() == GType_SIMON1) {
			if (updateWindow == 4) {
				src = (byte *)_window4BackScn->getPixels();
				srcWidth = _videoWindows[18] * 16;
			} else if (updateWindow >= 10) {
				src = (byte *)_window4BackScn->getBasePtr(xoffs, yoffs);
				srcWidth = _videoWindows[18] * 16;
			} else if (updateWindow == 0) {
				src = (byte *)screen->getBasePtr(xoffs, yoffs);
				srcWidth = screen->pitch;
			} else {
				updateBackendSurface();
				_videoLockOut &= ~0x20;
				return;
			}
		} else if (getGameType() == GType_WW) {
			if (updateWindow == 4 || updateWindow >= 10) {
				src = (byte *)_window4BackScn->getPixels();
				srcWidth = _videoWindows[18] * 16;
			} else if (updateWindow == 3 || updateWindow == 9) {
				src = (byte *)screen->getBasePtr(xoffs, yoffs);
				srcWidth = screen->pitch;
			} else {
				updateBackendSurface();
				_videoLockOut &= ~0x20;
				return;
			}
		} else if (getGameType() == GType_ELVIRA2) {
			if (updateWindow == 4 || updateWindow >= 10) {
				src = (byte *)_window4BackScn->getPixels();
				srcWidth = _videoWindows[18] * 16;
			} else if (updateWindow == 3) {
				src = (byte *)screen->getBasePtr(xoffs, yoffs);
				srcWidth = screen->pitch;
			} else {
				updateBackendSurface();
				_videoLockOut &= ~0x20;
				return;
			}
		} else if (getGameType() == GType_ELVIRA1) {
			if (updateWindow == 6) {
				_window6Flag = 1;
				src = (byte *)_window6BackScn->getPixels();
				srcWidth = 48;
			} else if (updateWindow == 2 || updateWindow == 3) {
				src = (byte *)screen->getBasePtr(xoffs, yoffs);
				srcWidth = screen->pitch;
			} else {
				src = (byte *)_window4BackScn->getPixels();
				srcWidth = _videoWindows[18] * 16;
			}
		} else {
			src = (byte *)screen->getBasePtr(xoffs, yoffs);
			srcWidth = screen->pitch;
		}

		_boxStarHeight = height;

		for (; height > 0; height--) {
			memcpy(dst, src, width);
			dst += _backGroundBuf->pitch;
			src += srcWidth;
		}

		if (getGameType() == GType_PN && !_wiped && !specialCase) {
			uint8 color = (getPlatform() == Common::kPlatformDOS) ? 7 : 15;
			dst = (byte *)screen->getBasePtr(48, 0);
			memset(dst, color, 224);

			dst = (byte *)screen->getBasePtr(48, 132);
			memset(dst, color, 224);
		} else if (getGameType() == GType_ELVIRA1 && updateWindow == 3 && _bottomPalette) {
			dst = (byte *)screen->getBasePtr(0, 133);

			for (int h = 0; h < 67; h++) {
				for (int w = 0; w < _screenWidth; w++)
					dst[w] += 0x10;
				dst += screen->pitch;
			}

			if (getPlatform() == Common::kPlatformPC98) {
				Common::Rect dirtyRect(0, 133, _screenWidth, _screenHeight);
				updateBackendSurface(&dirtyRect);
			}
		}

		Common::Rect dirtyRect(xoffs, yoffs, xoffs + width, yoffs + _boxStarHeight);
		updateBackendSurface(&dirtyRect);
	}

	_videoLockOut &= ~0x20;
}

// Personal Nightmare specific
void AGOSEngine::drawEdging() {
	byte *dst;
	uint8 color = (getPlatform() == Common::kPlatformDOS) ? 7 : 15;

	Graphics::Surface *screen = getBackendSurface();

	dst = (byte *)screen->getBasePtr(0, 136);
	uint8 len = 52;

	while (len--) {
		dst[0] = color;
		dst[319] = color;
		dst += screen->pitch;
	}

	dst = (byte *)screen->getBasePtr(0, 187);
	memset(dst, color, _screenWidth);

	updateBackendSurface();
}

} // End of namespace AGOS

================
File: icons.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/file.h"
#include "common/system.h"
#include "common/textconsole.h"

#include "graphics/surface.h"

#include "agos/agos.h"
#include "agos/intern.h"

namespace AGOS {

void AGOSEngine::loadIconFile() {
	Common::File in;
	uint32 srcSize;

	in.open(getFileName(GAME_ICONFILE));
	if (in.isOpen() == false)
		error("Can't open icons file '%s'", getFileName(GAME_ICONFILE));

	srcSize = in.size();

	if (getGameType() == GType_WW && getPlatform() == Common::kPlatformAmiga) {
		byte *srcBuf = (byte *)malloc(srcSize);
		in.read(srcBuf, srcSize);

		uint32 dstSize = READ_BE_UINT32(srcBuf + srcSize - 4);
		_iconFilePtr = (byte *)malloc(dstSize);
		if (_iconFilePtr == nullptr)
			error("Out of icon memory");

		decrunchFile(srcBuf, _iconFilePtr, srcSize);
		free(srcBuf);
	} else if (getGameType() == GType_PN && getPlatform() == Common::kPlatformAtariST) {
		// The icon data is hard coded in the program file.
		_iconFilePtr = (byte *)malloc(15038);
		if (_iconFilePtr == nullptr)
			error("Out of icon memory");

		in.seek(48414);
		in.read(_iconFilePtr, 15038);
	} else {
		_iconFilePtr = (byte *)malloc(srcSize);
		if (_iconFilePtr == nullptr)
			error("Out of icon memory");

		in.read(_iconFilePtr, srcSize);
	}
	in.close();
}

void AGOSEngine::loadIconData() {
	loadZone(8);
	VgaPointersEntry *vpe = &_vgaBufferPointers[8];

	byte *src = vpe->vgaFile2 + READ_LE_UINT32(vpe->vgaFile2 + 8);

	_iconFilePtr = (byte *)malloc(43 * 336);
	if (_iconFilePtr == nullptr)
		error("Out of icon memory");

	memcpy(_iconFilePtr, src, 43 * 336);
	unfreezeBottom();
}

// Thanks to Stuart Caie for providing the original
// C conversion upon which this function is based.
static void decompressIconPlanar(byte *dst, byte *src, uint width, uint height, byte base, uint pitch, bool decompress = true) {
	byte *i, *icon_pln, *o, *srcPtr;
	byte x, y;

	icon_pln = nullptr;
	srcPtr = src;

	if (decompress) {
		icon_pln = (byte *)calloc(width * height, 1);

		// Decode RLE planar icon data
		i = src;
		o = icon_pln;
		while (o < &icon_pln[width * height]) {
			x = *i++;
			if (x < 128) {
				do {
					*o++ = *i++;
					*o++ = *i++;
					*o++ = *i++;
				} while (x-- > 0);
			} else {
				x = 256 - x;
				do {
					*o++ = i[0];
					*o++ = i[1];
					*o++ = i[2];
				} while (x-- > 0);
				i += 3;
			}
		}
		srcPtr = icon_pln;
	}

	// Translate planar data to chunky (very slow method)
	for (y = 0; y < height * 2; y++) {
		for (x = 0; x < width; x++) {
			byte pixel =
				  (srcPtr[((height * 0 + y) * 3) + (x >> 3)] & (1 << (7 - (x & 7))) ? 1 : 0)
				| (srcPtr[((height * 2 + y) * 3) + (x >> 3)] & (1 << (7 - (x & 7))) ? 2 : 0)
				| (srcPtr[((height * 4 + y) * 3) + (x >> 3)] & (1 << (7 - (x & 7))) ? 4 : 0)
				| (srcPtr[((height * 6 + y) * 3) + (x >> 3)] & (1 << (7 - (x & 7))) ? 8 : 0);
			if (pixel)
				dst[x] = pixel | base;
		}
		dst += pitch;
	}

	free(icon_pln);
}

static void decompressIcon(byte *dst, byte *src, uint width, uint height, byte base, uint pitch) {
	int8 reps;
	byte color_1, color_2;
	byte *dst_org = dst;
	uint h = height;

	for (;;) {
		reps = *src++;
		if (reps < 0) {
			reps--;
			color_1 = *src >> 4;
			if (color_1 != 0)
				color_1 |= base;
			color_2 = *src++ & 0xF;
			if (color_2 != 0)
				color_2 |= base;

			do {
				if (color_1 != 0)
					*dst = color_1;
				dst += pitch;
				if (color_2 != 0)
					*dst = color_2;
				dst += pitch;

				// reached bottom?
				if (--h == 0) {
					// reached right edge?
					if (--width == 0)
						return;
					dst = ++dst_org;
					h = height;
				}
			} while (++reps != 0);
		} else {
			do {
				color_1 = *src >> 4;
				if (color_1 != 0)
					*dst = color_1 | base;
				dst += pitch;

				color_2 = *src++ & 0xF;
				if (color_2 != 0)
					*dst = color_2 | base;
				dst += pitch;

				// reached bottom?
				if (--h == 0) {
					// reached right edge?
					if (--width == 0)
						return;
					dst = ++dst_org;
					h = height;
				}
			} while (--reps >= 0);
		}
	}
}

void AGOSEngine_Simon2::drawIcon(WindowBlock *window, uint icon, uint x, uint y) {
	byte *dst;
	byte *src;

	_videoLockOut |= 0x8000;

	Graphics::Surface *screen = getBackendSurface();
	dst = (byte *)screen->getPixels();

	dst += 110;
	dst += x;
	dst += (y + window->y) * screen->pitch;

	src = _iconFilePtr;
	src += READ_LE_UINT16(src + icon * 4 + 0);
	decompressIcon(dst, src, 20, 10, 224, screen->pitch);

	src = _iconFilePtr;
	src += READ_LE_UINT16(src + icon * 4 + 2);
	decompressIcon(dst, src, 20, 10, 208, screen->pitch);

	updateBackendSurface();

	_videoLockOut &= ~0x8000;
}

void AGOSEngine_Simon1::drawIcon(WindowBlock *window, uint icon, uint x, uint y) {
	byte *dst;
	byte *src;

	_videoLockOut |= 0x8000;

	Graphics::Surface *screen = getBackendSurface();
	dst = (byte *)screen->getPixels();

	dst += (x + window->x) * 8;
	dst += (y * 25 + window->y) * screen->pitch;

	if (getPlatform() == Common::kPlatformAmiga) {
		src = _iconFilePtr;
		src += READ_BE_UINT32(src + icon * 4);
		uint8 color = (getFeatures() & GF_32COLOR) ? 224 : 240;
		decompressIconPlanar(dst, src, 24, 12, color, screen->pitch);
	} else {
		src = _iconFilePtr;
		src += READ_LE_UINT16(src + icon * 2);
		decompressIcon(dst, src, 24, 12, 224, screen->pitch);
	}

	updateBackendSurface();

	_videoLockOut &= ~0x8000;
}

void AGOSEngine_Waxworks::drawIcon(WindowBlock *window, uint icon, uint x, uint y) {
	byte *dst;
	byte *src;

	_videoLockOut |= 0x8000;

	Graphics::Surface *screen = getBackendSurface();
	dst = (byte *)screen->getPixels();

	dst += (x + window->x) * 8;
	dst += (y * 20 + window->y) * screen->pitch;

	uint8 color = dst[0] & 0xF0;
	if (getPlatform() == Common::kPlatformAmiga) {
		src = _iconFilePtr;
		src += READ_BE_UINT32(src + icon * 4);
		decompressIconPlanar(dst, src, 24, 10, color, screen->pitch);
	} else {
		src = _iconFilePtr;
		src += READ_LE_UINT16(src + icon * 2);
		decompressIcon(dst, src, 24, 10, color, screen->pitch);
	}

	updateBackendSurface();

	_videoLockOut &= ~0x8000;
}

void AGOSEngine_Elvira2::drawIcon(WindowBlock *window, uint icon, uint x, uint y) {
	byte *dst;
	byte *src;

	_videoLockOut |= 0x8000;

	Graphics::Surface *screen = getBackendSurface();
	dst = (byte *)screen->getPixels();

	dst += (x + window->x) * 8;
	dst += (y * 8 + window->y) * screen->pitch;

	uint color = dst[0] & 0xF0;
	if (getFeatures() & GF_PLANAR) {
		src = _iconFilePtr;
		src += READ_BE_UINT32(src + icon * 4);
		decompressIconPlanar(dst, src, 24, 12, color, screen->pitch);
	} else {
		src = _iconFilePtr;
		src += READ_LE_UINT16(src + icon * 2);
		decompressIcon(dst, src, 24, 12, color, screen->pitch);
	}

	updateBackendSurface();

	_videoLockOut &= ~0x8000;
}

void AGOSEngine_Elvira1::drawIcon(WindowBlock *window, uint icon, uint x, uint y) {
	byte *dst;
	byte *src;

	_videoLockOut |= 0x8000;

	Graphics::Surface *screen = getBackendSurface();
	dst = (byte *)screen->getPixels();

	x = (x + window->x) * 8;
	y = (y * 8 + window->y);
	dst += y * screen->pitch + x;

	if (getFeatures() & GF_PLANAR) {
		src = _iconFilePtr;
		src += READ_BE_UINT16(src + icon * 2);
		decompressIconPlanar(dst, src, 24, 12, 16, screen->pitch);
	} else {
		src = _iconFilePtr;
		src += icon * 288;
		decompressIconPlanar(dst, src, 24, 12, 16, screen->pitch, false);
	}

	Common::Rect dirtyRect(x, y, x + 24, y + 24);
	updateBackendSurface(&dirtyRect);

	_videoLockOut &= ~0x8000;
}

void AGOSEngine::drawIcon(WindowBlock *window, uint icon, uint x, uint y) {
	byte *dst;
	byte *src;

	_videoLockOut |= 0x8000;

	Graphics::Surface *screen = getBackendSurface();
	dst = (byte *)screen->getBasePtr(x * 8, y);
	src = _iconFilePtr + icon * 146;

	if (icon == 0xFF) {
		// Draw Blank Icon
		for (int yp = 0; yp < 24; yp++) {
			memset(dst, 0, 24);
			dst += screen->pitch;
		}
	} else {
		uint8 palette[4];
		palette[0] = *src >> 4;
		palette[1] = *src++ & 0xf;
		palette[2] = *src >> 4;
		palette[3] = *src++ & 0xf;
		for (int yp = 0; yp < 24; ++yp, src += 6) {
			// Get bit-set representing the 24 pixels for the line
			uint32 v1 = (READ_BE_UINT16(src) << 8) | *(src + 4);
			uint32 v2 = (READ_BE_UINT16(src + 2) << 8) | *(src + 5);
			for (int xp = 0; xp < 24; ++xp, v1 >>= 1, v2 >>= 1) {
				dst[yp * screen->pitch + (23 - xp)] = palette[((v1 & 1) << 1) | (v2 & 1)];
			}
		}
	}

	updateBackendSurface();

	_videoLockOut &= ~0x8000;
}

#ifdef ENABLE_AGOS2
void AGOSEngine_Feeble::drawIconArray(uint num, Item *itemRef, int line, int classMask) {
	Item *item_ptr_org = itemRef;
	WindowBlock *window;
	uint16 flagnumber = 201;
	uint16 iconperline = 458;
	uint16 iconsdown = 384;
	uint16 idone = 0;
	uint16 icount = 0;
	uint16 xp = 188, yp = 306;
	int k;
	_iOverflow = 0;

	line = _variableArray[30];
	if (line == 0)
		_variableArray[31] = 0;

	window = _windowArray[num & 7];
	if (window == NULL)
		return;

	for (k = flagnumber; k <= flagnumber + 18; k++)
		_variableArray[k] = 0;

	if (window->iconPtr)
		removeIconArray(num);

	window->iconPtr=(IconBlock *)malloc(sizeof(IconBlock));
	window->iconPtr->itemRef = itemRef;
	window->iconPtr->upArrow = -1;
	window->iconPtr->downArrow = -1;
	window->iconPtr->line = line;
	window->iconPtr->classMask = classMask;

	itemRef = derefItem(itemRef->child);
	k = flagnumber;

	while (itemRef && (line > 65)) {
		uint16 ct = xp;
		while (itemRef && ct < iconperline) {
			if ((classMask == 0) || ((itemRef->classFlags & classMask) != 0)) {
				if (hasIcon(itemRef)) {
					ct += 45;
					k++;
				}
			}
			itemRef = derefItem(itemRef->next);
		}
		line -= 52;
		if (k == (flagnumber + 18))
			k = flagnumber;
	}
	yp -= line;	// Adjust starting y

	if (itemRef == NULL) {
		window->iconPtr->line = 0;
		itemRef = derefItem(item_ptr_org->child);
	}

	while (itemRef) {
		if ((classMask != 0) && ((itemRef->classFlags & classMask) == 0))
			goto l1;
		if (hasIcon(itemRef) == 0)
			goto l1;
		if (!idone) {
/*
 *	Create thee icon and graphics rendering
 */
			window->iconPtr->iconArray[icount].item = itemRef;
			_variableArray[k] = itemGetIconNumber(itemRef);
			window->iconPtr->iconArray[icount++].boxCode =
				setupIconHitArea(window, k++, xp, yp, itemRef);
		} else {
/*
 *	Just remember the overflow has occurred
 */
			window->iconPtr->iconArray[icount].item = NULL;	/* END MARKINGS */
			_iOverflow = 1;
		}
		xp += 45;
		if (xp >= iconperline) {	/* End of line ? */
			if (k == (flagnumber + 18))
				k = flagnumber;
			xp = 188;
			yp += 52;		/* Move down */
			if (yp >= iconsdown) {	/* Full ? */
				idone = 1;	/* Note completed screen */
			}
		}
l1:;		itemRef = derefItem(itemRef->next);
	}
	window->iconPtr->iconArray[icount].item = NULL;	/* END MARKINGS */
	if (_variableArray[30] == 0) {
		if (yp != 306)
			_variableArray[31] = 52;
		if ((xp == 188) && (yp == 358))
			_variableArray[31] = 0;
	}

	/* Plot arrows and add their boxes */
	addArrows(window, num);
	window->iconPtr->upArrow = _scrollUpHitArea;
	window->iconPtr->downArrow = _scrollDownHitArea;
}
#endif

void AGOSEngine::drawIconArray(uint num, Item *itemRef, int line, int classMask) {
	Item *item_ptr_org = itemRef;
	WindowBlock *window;
	uint width, height;
	uint k, curWidth;
	bool item_again, showArrows;
	uint x_pos, y_pos;
	const int iconSize = (getGameType() == GType_SIMON2) ? 20 : 1;

	window = _windowArray[num & 7];

	if (getGameType() == GType_SIMON2) {
		width = 100;
		height = 40;
	} else if (getGameType() == GType_WW) {
		width = window->width / 3;
		height = window->height / 2;
	} else {
		width = window->width / 3;
		height = window->height / 3;
	}

	if (window == nullptr)
		return;

	if (window->iconPtr)
		removeIconArray(num);

	window->iconPtr = (IconBlock *) malloc(sizeof(IconBlock));
	window->iconPtr->itemRef = itemRef;
	window->iconPtr->upArrow = -1;
	window->iconPtr->downArrow = -1;
	window->iconPtr->line = line;
	window->iconPtr->classMask = classMask;

	itemRef = derefItem(itemRef->child);

	while (itemRef && line-- != 0) {
		curWidth = 0;
		while (itemRef && width > curWidth) {
			if ((classMask == 0 || itemRef->classFlags & classMask) && hasIcon(itemRef))
				curWidth += iconSize;
			itemRef = derefItem(itemRef->next);
		}
	}

	if (itemRef == nullptr) {
		window->iconPtr->line = 0;
		itemRef = derefItem(item_ptr_org->child);
	}

	x_pos = 0;
	y_pos = 0;
	k = 0;
	item_again = false;
	showArrows = false;

	while (itemRef) {
		if ((classMask == 0 || itemRef->classFlags & classMask) && hasIcon(itemRef)) {
			if (item_again == false) {
				window->iconPtr->iconArray[k].item = itemRef;
				if (getGameType() == GType_SIMON2) {
					drawIcon(window, itemGetIconNumber(itemRef), x_pos, y_pos);
					window->iconPtr->iconArray[k].boxCode =
						setupIconHitArea(window, 0, x_pos, y_pos, itemRef);
				} else if (getGameType() == GType_SIMON1 || getGameType() == GType_WW) {
					drawIcon(window, itemGetIconNumber(itemRef), x_pos * 3, y_pos);
					window->iconPtr->iconArray[k].boxCode =
						setupIconHitArea(window, 0, x_pos * 3, y_pos, itemRef);
				} else {
					drawIcon(window, itemGetIconNumber(itemRef), x_pos * 3, y_pos * 3);
					window->iconPtr->iconArray[k].boxCode =
						setupIconHitArea(window, 0, x_pos * 3, y_pos * 3, itemRef);
				}
				k++;
			} else {
				window->iconPtr->iconArray[k].item = nullptr;
				showArrows = 1;
			}

			x_pos += iconSize;
			if (x_pos >= width) {
				x_pos = 0;
				y_pos += iconSize;
				if (y_pos >= height)
					item_again = true;
			}
		}
		itemRef = derefItem(itemRef->next);
	}

	window->iconPtr->iconArray[k].item = nullptr;

	if (showArrows != 0 || window->iconPtr->line != 0) {
		/* Plot arrows and add their boxes */
		addArrows(window, num);
		window->iconPtr->upArrow = _scrollUpHitArea;
		window->iconPtr->downArrow = _scrollDownHitArea;
	}
}

#ifdef ENABLE_AGOS2
uint AGOSEngine_Feeble::setupIconHitArea(WindowBlock *window, uint num, uint x, uint y, Item *itemPtr) {
	HitArea *ha = findEmptyHitArea();

	ha->x = x;
	ha->y = y;
	ha->itemPtr = itemPtr;
	ha->width = 45;
	ha->height = 44;
	ha->flags = kBFBoxInUse | kBFBoxItem;
	ha->id = num;
	ha->priority = 100;
	ha->verb = 208;

	return ha - _hitAreas;
}
#endif

uint AGOSEngine_Simon2::setupIconHitArea(WindowBlock *window, uint num, uint x, uint y, Item *itemPtr) {
	HitArea *ha = findEmptyHitArea();

	ha->x = x + 110;
	ha->y = window->y + y;
	ha->itemPtr = itemPtr;
	ha->width = 20;
	ha->height = 20;
	ha->flags = kBFDragBox | kBFBoxInUse | kBFBoxItem;
	ha->id = 0x7FFD;
	ha->priority = 100;
	ha->verb = 208;

	return ha - _hitAreas;
}

uint AGOSEngine_Simon1::setupIconHitArea(WindowBlock *window, uint num, uint x, uint y, Item *itemPtr) {
	HitArea *ha = findEmptyHitArea();

	ha->x = (x + window->x) * 8;
	ha->y = y * 25 + window->y;
	ha->itemPtr = itemPtr;
	ha->width = 24;
	ha->height = 24;
	ha->flags = kBFDragBox | kBFBoxInUse | kBFBoxItem;
	ha->id = 0x7FFD;
	ha->priority = 100;
	ha->verb = 208;

	return ha - _hitAreas;
}

uint AGOSEngine_Waxworks::setupIconHitArea(WindowBlock *window, uint num, uint x, uint y, Item *itemPtr) {
	HitArea *ha = findEmptyHitArea();

	ha->x = (x + window->x) * 8;
	ha->y = y * 20 + window->y;
	ha->itemPtr = itemPtr;
	ha->width = 24;
	ha->height = 20;
	ha->flags = kBFDragBox | kBFBoxInUse | kBFBoxItem;
	ha->id = 0x7FFD;
	ha->priority = 100;
	ha->verb = 208;

	return ha - _hitAreas;
}

uint AGOSEngine_Elvira2::setupIconHitArea(WindowBlock *window, uint num, uint x, uint y, Item *itemPtr) {
	HitArea *ha = findEmptyHitArea();

	ha->x = (x + window->x) * 8;
	ha->y = y * 8 + window->y;
	ha->itemPtr = itemPtr;
	ha->width = 24;
	ha->height = 24;
	ha->id = 0x7FFD;
	ha->priority = 100;

	if (window->iconPtr->classMask == 2) {
		ha->flags = kBFDragBox | kBFBoxInUse;
		ha->verb = 248 + 0x4000;
	} else {
		ha->flags = kBFDragBox | kBFBoxInUse | kBFBoxItem;
		ha->verb = 208;
	}

	return ha - _hitAreas;
}

uint AGOSEngine::setupIconHitArea(WindowBlock *window, uint num, uint x, uint y, Item *itemPtr) {
	HitArea *ha = findEmptyHitArea();

	ha->x = (x + window->x) * 8;
	ha->y = y * 8 + window->y;
	ha->itemPtr = itemPtr;
	ha->width = 24;
	ha->height = 24;
	ha->flags = kBFDragBox | kBFBoxInUse | kBFBoxItem;
	ha->id = 0x7FFD;
	ha->priority = 100;
	ha->verb = 253;

	return ha - _hitAreas;
}

#ifdef ENABLE_AGOS2
void AGOSEngine_Feeble::addArrows(WindowBlock *window, uint8 num) {
	HitArea *ha;

	ha = findEmptyHitArea();
	_scrollUpHitArea = ha - _hitAreas;

	ha->x = 496;
	ha->y = 279;
	ha->width = 30;
	ha->height = 45;
	ha->flags = kBFBoxInUse | kBFNoTouchName;
	ha->id = 0x7FFB;
	ha->priority = 100;
	ha->window = window;
	ha->verb = 1;

	ha = findEmptyHitArea();
	_scrollDownHitArea = ha - _hitAreas;

	ha->x = 496;
	ha->y = 324;
	ha->width = 30;
	ha->height = 44;
	ha->flags = kBFBoxInUse | kBFNoTouchName;
	ha->id = 0x7FFC;
	ha->priority = 100;
	ha->window = window;
	ha->verb = 1;
}
#endif

void AGOSEngine_Simon2::addArrows(WindowBlock *window, uint8 num) {
	HitArea *ha;

	ha = findEmptyHitArea();
	_scrollUpHitArea = ha - _hitAreas;

	ha->x = 81;
	ha->y = 158;
	ha->width = 12;
	ha->height = 26;
	ha->flags = kBFBoxInUse | kBFNoTouchName;
	ha->id = 0x7FFB;
	ha->priority = 100;
	ha->window = window;
	ha->verb = 1;

	ha = findEmptyHitArea();
	_scrollDownHitArea = ha - _hitAreas;

	ha->x = 227;
	ha->y = 162;
	ha->width = 12;
	ha->height = 26;
	ha->flags = kBFBoxInUse | kBFNoTouchName;
	ha->id = 0x7FFC;
	ha->priority = 100;
	ha->window = window;
	ha->verb = 1;
}

void AGOSEngine_Simon1::addArrows(WindowBlock *window, uint8 num) {
	HitArea *ha;

	ha = findEmptyHitArea();
	_scrollUpHitArea = ha - _hitAreas;

	ha->x = 308;
	ha->y = 149;
	ha->width = 12;
	ha->height = 17;
	ha->flags = kBFBoxInUse | kBFNoTouchName;
	ha->id = 0x7FFB;
	ha->priority = 100;
	ha->window = window;
	ha->verb = 1;

	ha = findEmptyHitArea();
	_scrollDownHitArea = ha - _hitAreas;

	ha->x = 308;
	ha->y = 176;
	ha->width = 12;
	ha->height = 17;
	ha->flags = kBFBoxInUse | kBFNoTouchName;
	ha->id = 0x7FFC;
	ha->priority = 100;
	ha->window = window;
	ha->verb = 1;

	_videoLockOut |= 0x8;

	VgaPointersEntry *vpe = &_vgaBufferPointers[1];
	byte *curVgaFile2Orig = _curVgaFile2;
	uint16 windowNumOrig = _windowNum;
	uint8 palette = (getPlatform() == Common::kPlatformAmiga) ? 15 : 14;

	_windowNum = 0;
	_curVgaFile2 = vpe->vgaFile2;
	drawImage_init(1, palette, 38, 150, 4);

	_curVgaFile2 = curVgaFile2Orig;
	_windowNum = windowNumOrig;

	_videoLockOut &= ~0x8;
}

void AGOSEngine_Waxworks::addArrows(WindowBlock *window, uint8 num) {
	HitArea *ha;

	ha = findEmptyHitArea();
	_scrollUpHitArea = ha - _hitAreas;

	setBitFlag(22, true);
	ha->x = 255;
	ha->y = 153;
	ha->width = 9;
	ha->height = 11;
	ha->flags = kBFBoxInUse | kBFNoTouchName;
	ha->id = 0x7FFB;
	ha->priority = 100;
	ha->window = window;
	ha->verb = 1;

	ha = findEmptyHitArea();
	_scrollDownHitArea = ha - _hitAreas;

	ha->x = 255;
	ha->y = 170;
	ha->width = 9;
	ha->height = 11;
	ha->flags = kBFBoxInUse | kBFNoTouchName;
	ha->id = 0x7FFC;
	ha->priority = 100;
	ha->window = window;
	ha->verb = 1;
	setWindowImageEx(6, 103);
}

void AGOSEngine_Elvira2::addArrows(WindowBlock *window, uint8 num) {
	HitArea *ha;

	ha = findEmptyHitArea();
	_scrollUpHitArea = ha - _hitAreas;

	setBitFlag(21, true);
	ha->x = 54;
	ha->y = 154;
	ha->width = 12;
	ha->height = 10;
	ha->flags = kBFBoxInUse;
	ha->id = 0x7FFB;
	ha->priority = 100;
	ha->window = window;
	ha->verb = 1;

	ha = findEmptyHitArea();
	_scrollDownHitArea = ha - _hitAreas;

	ha->x = 54;
	ha->y = 178;
	ha->width = 12;
	ha->height = 10;
	ha->flags = kBFBoxInUse;
	ha->id = 0x7FFC;
	ha->priority = 100;
	ha->window = window;
	ha->verb = 1;
	setWindowImageEx(6, 106);
}

void AGOSEngine::addArrows(WindowBlock *window, uint8 num) {
	HitArea *ha;
	uint16 x, y;

	x = 30;
	y = 151;
	if (num != 2) {
		y = window->y + window->height * 4 - 19;
		x = window->x + window->width;
	}
	drawArrow(x, y, 16);

	ha = findEmptyHitArea();
	_scrollUpHitArea = ha - _hitAreas;

	ha->x = x * 8;
	ha->y = y;
	ha->width = 16;
	ha->height = 19;
	ha->flags = kBFBoxInUse;
	ha->id = 0x7FFB;
	ha->priority = 100;
	ha->window = window;
	ha->verb = 1;

	x = 30;
	y = 170;
	if (num != 2) {
		y = window->y + window->height * 4;
		x = window->x + window->width;
	}
	drawArrow(x, y, -16);

	ha = findEmptyHitArea();
	_scrollDownHitArea = ha - _hitAreas;

	ha->x = x * 8;
	ha->y = y;
	ha->width = 16;
	ha->height = 19;
	ha->flags = kBFBoxInUse;
	ha->id = 0x7FFC;
	ha->priority = 100;
	ha->window = window;
	ha->verb = 1;
}

static const byte _arrowImage[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
	0x0b, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b,
	0x0a, 0x0b, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b, 0x0a,
	0x0d, 0x0a, 0x0b, 0x0a, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b, 0x0a, 0x0d,
	0x03, 0x0d, 0x0a, 0x0b, 0x0a, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0a, 0x0b, 0x0a, 0x0d, 0x03,
	0x04, 0x03, 0x0d, 0x0a, 0x0b, 0x0a, 0x00, 0x00,
	0x00, 0x00, 0x0a, 0x0b, 0x0a, 0x0d, 0x03, 0x04,
	0x0f, 0x04, 0x03, 0x0d, 0x0a, 0x0b, 0x0a, 0x00,
	0x00, 0x0a, 0x0b, 0x0a, 0x0d, 0x0d, 0x0d, 0x03,
	0x04, 0x03, 0x0d, 0x0d, 0x0d, 0x0a, 0x0b, 0x0a,
	0x00, 0x0b, 0x0a, 0x0a, 0x0a, 0x0a, 0x09, 0x0d,
	0x03, 0x0d, 0x09, 0x0a, 0x0a, 0x0a, 0x0a, 0x0b,
	0x00, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0a, 0x0d,
	0x0d, 0x0d, 0x0a, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
	0x00, 0x0a, 0x0a, 0x0a, 0x0e, 0x0b, 0x0b, 0x0c,
	0x0e, 0x0c, 0x0b, 0x0b, 0x0e, 0x0a, 0x0a, 0x0a,
	0x00, 0x00, 0x02, 0x02, 0x0a, 0x0b, 0x0a, 0x0d,
	0x0d, 0x0d, 0x0a, 0x0b, 0x0a, 0x02, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x0a, 0x0b, 0x0b, 0x0c,
	0x0e, 0x0c, 0x0b, 0x0b, 0x0a, 0x02, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b, 0x0a, 0x0d,
	0x0d, 0x0d, 0x0a, 0x0b, 0x0a, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b, 0x0b, 0x0c,
	0x0e, 0x0c, 0x0b, 0x0b, 0x0a, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0a, 0x0b, 0x0b, 0x0b,
	0x0b, 0x0b, 0x0b, 0x0b, 0x0a, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0x0a, 0x0a,
	0x0e, 0x0a, 0x0a, 0x0e, 0x02, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00,
	0x0a, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
};

void AGOSEngine::drawArrow(uint16 x, uint16 y, int8 dir) {
	const byte *src;
	uint8 w, h;

	if (dir < 0) {
		src = _arrowImage + 288;
	} else {
		src = _arrowImage;
	}

	Graphics::Surface *screen = getBackendSurface();
	byte *dst = (byte *)screen->getBasePtr(x * 8, y);

	for (h = 0; h < 19; h++) {
		for (w = 0; w < 16; w++) {
			if (src[w])
				dst[w] = src[w] + 16;
		}

		src += dir;
		dst+= screen->pitch;
	}

	Common::Rect dirtyRect(x * 8, y, x * 8 + 16, y + 19);
	updateBackendSurface(&dirtyRect);
}

void AGOSEngine_Simon1::removeArrows(WindowBlock *window, uint num) {
	if (getGameType() == GType_SIMON1) {
		restoreBlock(304, 146, 320, 200);
	}
}

void AGOSEngine_Waxworks::removeArrows(WindowBlock *window, uint num) {
	setBitFlag(22, false);
	setWindowImageEx(6, 103);
}

void AGOSEngine_Elvira2::removeArrows(WindowBlock *window, uint num) {
	setBitFlag(21, false);
	setWindowImageEx(6, 106);
}

void AGOSEngine::removeArrows(WindowBlock *window, uint num) {
	if (num != 2) {
		uint y = window->y + window->height * 4 - 19;
		uint x = (window->x + window->width) * 8;
		restoreBlock(x, y, x + 16, y + 38);
	} else {
		colorBlock(window, 240, 151, 16, 38);
	}
}

void AGOSEngine::removeIconArray(uint num) {
	WindowBlock *window;
	uint16 curWindow;
	uint16 i;

	window = _windowArray[num & 7];
	curWindow = _curWindow;

	if (window == nullptr || window->iconPtr == nullptr)
		return;

	if (getGameType() != GType_FF && getGameType() != GType_PP) {
		changeWindow(num);
		sendWindow(12);
		changeWindow(curWindow);
	}

	for (i = 0; window->iconPtr->iconArray[i].item != nullptr; i++) {
		freeBox(window->iconPtr->iconArray[i].boxCode);
	}

	if (window->iconPtr->upArrow != -1) {
		freeBox(window->iconPtr->upArrow);
	}

	if (window->iconPtr->downArrow != -1) {
		freeBox(window->iconPtr->downArrow);
		removeArrows(window, num);
	}

	free(window->iconPtr);
	window->iconPtr = nullptr;

	_fcsData1[num] = 0;
	_fcsData2[num] = 0;
}

static const byte hitBarData[12 * 7] = {
	0x3C, 0x00, 0x80, 0x00, 0x88, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00,
	0x20, 0x00, 0x04, 0x00, 0xD8, 0x00, 0x00, 0x04, 0x48, 0x00, 0x00, 0x00,
	0x20, 0x89, 0x8E, 0x00, 0xA8, 0x86, 0x10, 0x04, 0x08, 0x21, 0x88, 0x00,
	0x38, 0x50, 0x84, 0x00, 0x89, 0x49, 0x28, 0x04, 0x08, 0x52, 0x14, 0x00,
	0x20, 0x20, 0x84, 0x00, 0x89, 0x48, 0x38, 0x04, 0x08, 0x53, 0x9C, 0x00,
	0x20, 0x50, 0x84, 0x00, 0x89, 0x48, 0x20, 0x04, 0x48, 0x50, 0x90, 0x00,
	0x3C, 0x89, 0xC3, 0x00, 0x88, 0x88, 0x18, 0x03, 0x86, 0x23, 0x0C, 0x00
};

// Personal Nightmare specific
void AGOSEngine_PN::drawIconHitBar() {
	Graphics::Surface *screen = getBackendSurface();
	byte *dst = (byte *)screen->getBasePtr(6 * 8, 3);
	const byte *src = hitBarData;
	uint8 color = (getPlatform() == Common::kPlatformDOS) ? 7 : 15;

	for (int h = 0; h < 7; h++) {
		for (int w = 0; w < 12; w++) {
			int8 b = *src++;
			for (int i = 0; i < 8; i++) {
				if (b < 0) {
					dst[w * 8 + i] = color;
				}

				b <<= 1;
			}
		}
		dst += screen->pitch;
	}

	updateBackendSurface();
}

void AGOSEngine_PN::iconPage() {
	_objectCountS = -1;

	mouseOff();

	uint8 objRoom = getptr(_quickptr[12] + _variableArray[210] * _quickshort[5] + 20);
	uint8 iconNum = getptr(_quickptr[0] + objRoom * _quickshort[0] + 4);

	drawIcon(nullptr, iconNum, 6, 12);

	HitArea *ha = _invHitAreas + 5;
	for (uint8 r = 0; r < 5; r++) {
		for (uint8 i = 0; i < 7; i++) {
			printIcon(ha, i, r);
			ha++;
		}
	}

	mouseOn();
}

bool AGOSEngine_PN::ifObjectInInv(uint16 a) {
	return _variableArray[210] == getptr(_quickptr[11] + a * _quickshort[4] + 2);
}

bool AGOSEngine_PN::testContainer(uint16 a) {
	return bitextract(_quickptr[1] + a * _quickshort[1], 0) != 0;
}

bool AGOSEngine_PN::testObvious(uint16 a) {
	return bitextract(_quickptr[1] + a * _quickshort[1], 4) != 0;
}

bool AGOSEngine_PN::testSeen(uint16 a) {
	return bitextract(_quickptr[1] + a * _quickshort[1], 3) != 0;
}

void AGOSEngine_PN::printIcon(HitArea *ha, uint8 i, uint8 r) {
	 if (_objects == _objectCountS) {
		ha->flags |= kOBFBoxDisabled;
		drawIcon(nullptr, 0xFF, 12 + i * 3, 12 + 24 * r);
	} else {
		_objectCountS++;
		if (!ifObjectInInv(_objectCountS) || !testObvious(_objectCountS)) {
			printIcon(ha, i, r);
		} else {

			uint8 iconNum = getptr(_quickptr[0] + _objectCountS * _quickshort[0] + 4);
			drawIcon(nullptr, iconNum, 12 + i * 3, 12 + 24 * r);

			ha->msg1 = _objectCountS | 0x8000;
			ha->flags &= ~kOBFBoxDisabled;
		}
	}
}

} // End of namespace AGOS

================
File: input.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/config-manager.h"
#include "common/events.h"
#include "common/file.h"

#include "agos/intern.h"
#include "agos/agos.h"
#include "agos/midi.h"
#include "agos/sound.h"
#include "agos/vga.h"

namespace AGOS {

uint AGOSEngine::setVerbText(HitArea *ha) {
	uint id = 0xFFFF;

	if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2)
		return id;

	if (ha->flags & kBFTextBox) {
		if (getGameType() == GType_PP)
			id = ha->id;
		else if (getGameType() == GType_FF && (ha->flags & kBFHyperBox))
			id = ha->data;
		else
			id = ha->flags / 256;
	}
	if (getGameType() == GType_PP)
		_variableArray[199] = id;
	else if (getGameType() == GType_WW)
		_variableArray[10] = id;
	else
		_variableArray[60] = id;

	return id;
}

void AGOSEngine::setup_cond_c_helper() {
	HitArea *last;

	_noRightClick = true;

	if (getGameType() == GType_WW)
		clearMenuStrip();

	if (getGameType() == GType_FF) {
		int cursor = 5;
		int animMax = 16;

		if (getBitFlag(200)) {
			cursor = 11;
			animMax = 5;
		} else if (getBitFlag(201)) {
			cursor = 12;
			animMax = 5;
		} else if (getBitFlag(202)) {
			cursor = 13;
			animMax = 5;
		} else if (getBitFlag(203)) {
			cursor = 14;
			animMax = 9;
		} else if (getBitFlag(205)) {
			cursor = 17;
			animMax = 11;
		} else if (getBitFlag(206)) {
			cursor = 16;
			animMax = 2;
		} else if (getBitFlag(208)) {
			cursor = 26;
			animMax = 2;
		} else if (getBitFlag(209)) {
			cursor = 27;
			animMax = 9;
		} else if (getBitFlag(210)) {
			cursor = 28;
			animMax = 9;
		}

		_animatePointer = false;
		_mouseCursor = cursor;
		_mouseAnimMax = animMax;
		_mouseAnim = 1;
		_needHitAreaRecalc++;
	}

	if (getGameType() == GType_SIMON2) {
		_mouseCursor = 0;
		if (_defaultVerb != 999) {
			_mouseCursor = 9;
			_needHitAreaRecalc++;
			_defaultVerb = 0;
		}
	}

	_lastHitArea = nullptr;
	_hitAreaObjectItem = nullptr;
	_nameLocked = false;

	last = _lastNameOn;
	clearName();
	_lastNameOn = last;

	while (!shouldQuit()) {
		_lastHitArea = nullptr;
		_lastHitArea3 = nullptr;
		_leftButtonDown = false;

		do {
			if (_exitCutscene && getBitFlag(9)) {
				endCutscene();
				goto out_of_here;
			}

			if (getGameType() == GType_FF) {
				if (_variableArray[254] == 63) {
					hitarea_stuff_helper_2();
				} else if (_variableArray[254] == 75) {
					hitarea_stuff_helper_2();
					_variableArray[60] = 9999;
					goto out_of_here;
				}
			}

			delay(100);
		} while ((_lastHitArea3 == (HitArea *) -1 || _lastHitArea3 == nullptr) && !shouldQuit());

		if (_lastHitArea == nullptr) {
		} else if (_lastHitArea->id == 0x7FFB) {
			inventoryUp(_lastHitArea->window);
		} else if (_lastHitArea->id == 0x7FFC) {
			inventoryDown(_lastHitArea->window);
		} else if (_lastHitArea->itemPtr != nullptr) {
			_hitAreaObjectItem = _lastHitArea->itemPtr;
			setVerbText(_lastHitArea);
			break;
		}
	}

out_of_here:
	_lastHitArea3 = nullptr;
	_lastHitArea = nullptr;
	_lastNameOn = nullptr;

	_mouseCursor = 0;
	_noRightClick = 0;
}

void AGOSEngine::waitForInput() {
	HitArea *ha;
	uint id;

	_leftButtonDown = false;
	_lastHitArea = nullptr;
	//_lastClickRem = 0;
	_verbHitArea = 0;
	_hitAreaSubjectItem = nullptr;
	_hitAreaObjectItem = nullptr;
	_clickOnly = false;
	_nameLocked = false;

	if (getGameType() == GType_WW) {
		_mouseCursor = 0;
		_needHitAreaRecalc++;
		clearMenuStrip();
	} else {
		resetVerbs();
	}

	while (!shouldQuit()) {
		_lastHitArea = nullptr;
		_lastHitArea3 = nullptr;
		_dragAccept = true;

		while (!shouldQuit()) {
			if ((getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) &&
				_action == kActionShowObjects)
				displayBoxStars();
			if (processSpecialKeys()) {
				if (getGameId() != GID_DIMP)
					goto out_of_here;
			}
			if (_lastHitArea3 == (HitArea *) -1) {
				_lastHitArea = nullptr;
				_lastHitArea3 = nullptr;
				_dragAccept = true;
			} else {
				if (_lastHitArea3 || _dragMode)
					break;
				hitarea_stuff_helper();
				delay(100);
			}
		}

		if (!_lastHitArea3 && _dragMode) {
			ha = _lastClickRem;

			if (ha == nullptr || ha->itemPtr == nullptr || !(ha->flags & kBFDragBox)) {
				_dragFlag = false;
				_dragMode = false;
				_dragCount = 0;
				_dragEnd = false;
				continue;
			}

			_hitAreaSubjectItem = ha->itemPtr;
			_verbHitArea = 500;

			do {
				processSpecialKeys();
				hitarea_stuff_helper();
				delay(100);

				if (!_dragFlag) {
					_dragFlag = false;
					_dragMode = false;
					_dragCount = 0;
					_dragEnd = false;
				}
			} while (!_dragEnd);

			_dragFlag = false;
			_dragMode = false;
			_dragCount = 0;
			_dragEnd = false;

			boxController(_mouse.x, _mouse.y, 1);

			if (_currentBox != nullptr) {
				_hitAreaObjectItem = _currentBox->itemPtr;
				setVerbText(_currentBox);
			}

			break;
		}

		ha = _lastHitArea;
		if (ha == nullptr) {
		} else if (ha->id == 0x7FFB) {
			inventoryUp(ha->window);
		} else if (ha->id == 0x7FFC) {
			inventoryDown(ha->window);
		} else if ((getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) &&
			(ha->id >= 101 && ha->id < 113)) {
			_verbHitArea = ha->verb;
			setVerb(ha);
			_defaultVerb = 0;
		} else {
			if (getGameType() == GType_WW) {
				if (_mouseCursor == 3)
					_verbHitArea = 236;

				if (ha->id == 98) {
					animate(2, 1, 110, 0, 0, 0);
					waitForSync(34);
				} else if (ha->id == 108) {
					animate(2, 1, 106, 0, 0, 0);
					waitForSync(34);
				} else if (ha->id == 109) {
					animate(2, 1, 107, 0, 0, 0);
					waitForSync(34);
				} else if (ha->id == 115) {
					animate(2, 1, 109, 0, 0, 0);
					waitForSync(34);
				} else if (ha->id == 116) {
					animate(2, 1, 113, 0, 0, 0);
					waitForSync(34);
				} else if (ha->id == 117) {
					animate(2, 1, 112, 0, 0, 0);
					waitForSync(34);
				} else if (ha->id == 118) {
					animate(2, 1, 108, 0, 0, 0);
					waitForSync(34);
				} else if (ha->id == 119) {
					animate(2, 1, 111, 0, 0, 0);
					waitForSync(34);
				}
			}
			if (ha->itemPtr && (!ha->verb || _verbHitArea ||
					(_hitAreaSubjectItem != ha->itemPtr && (ha->flags & kBFBoxItem)))
				) {
				_hitAreaSubjectItem = ha->itemPtr;
				id = setVerbText(ha);
				_nameLocked = false;
				displayName(ha);
				_nameLocked = true;

				if (_verbHitArea) {
					break;
				}

				if (getGameType() == GType_WW)
					doMenuStrip(menuFor_ww(ha->itemPtr, id));
				else if (getGameType() == GType_ELVIRA2)
					doMenuStrip(menuFor_e2(ha->itemPtr));
				else if (getGameType() == GType_ELVIRA1)
					lightMenuStrip(getUserFlag1(ha->itemPtr, 6));
			} else {
				if (ha->verb) {
					if (getGameType() == GType_WW && _mouseCursor && _mouseCursor < 4) {
						_hitAreaSubjectItem = ha->itemPtr;
						break;
					}

					_verbHitArea = ha->verb & 0xBFFF;
					if (ha->verb & 0x4000) {
						_hitAreaSubjectItem = ha->itemPtr;
						break;
					}
					if (_hitAreaSubjectItem != nullptr)
						break;

					if (getGameType() == GType_WW) {
						if (ha->id == 109) {
							_mouseCursor = 2;
							_needHitAreaRecalc++;
						} else if (ha->id == 117) {
							_mouseCursor = 3;
							_needHitAreaRecalc++;
						}
					}
				}
			}
		}
	}

out_of_here:
	if (getGameType() == GType_ELVIRA2 || getGameType() == GType_WW)
		clearMenuStrip();
	else if (getGameType() == GType_ELVIRA1)
		unlightMenuStrip();

	_nameLocked = false;
	_needHitAreaRecalc++;
	_dragAccept = false;

	if (getGameType() == GType_WW && _mouseCursor < 3)
		_mouseCursor = 0;
}

void AGOSEngine::hitarea_stuff_helper() {
	if (getGameType() == GType_SIMON2 || getGameType() == GType_FF ||
		getGameType() == GType_PP) {
		if (_variableArray[254] || _variableArray[249]) {
			hitarea_stuff_helper_2();
		}
	} else if (getGameType() == GType_ELVIRA2 || getGameType() == GType_WW ||
		getGameType() == GType_SIMON1) {
		uint subr_id = (uint16)_variableArray[254];
		if (subr_id) {
			Subroutine *sub = getSubroutineByID(subr_id);
			if (sub != nullptr) {
				startSubroutineEx(sub);
				permitInput();
			}
			_variableArray[254] = 0;
			_runScriptReturn1 = false;
		}
	}

	uint32 cur_time = getTime();
	if (cur_time != _lastTime) {
		_lastTime = cur_time;
		if (kickoffTimeEvents())
			permitInput();
	}

	if (getGameId() == GID_DIMP)
		delay(200);
}

void AGOSEngine::hitarea_stuff_helper_2() {
	uint subr_id;
	Subroutine *sub;

	subr_id = (uint16)_variableArray[249];
	if (subr_id) {
		sub = getSubroutineByID(subr_id);
		if (sub != nullptr) {
			_variableArray[249] = 0;
			startSubroutineEx(sub);
			permitInput();
		}
		_variableArray[249] = 0;
	}

	subr_id = (uint16)_variableArray[254];
	if (subr_id) {
		sub = getSubroutineByID(subr_id);
		if (sub != nullptr) {
			_variableArray[254] = 0;
			startSubroutineEx(sub);
			permitInput();
		}
		_variableArray[254] = 0;
	}

	_runScriptReturn1 = false;
}

#ifdef ENABLE_AGOS2
void AGOSEngine_Feeble::handleMouseWheelUp() {
	if (getGameType() == GType_PP || !(getBitFlag(99)))
		return;

	if (_mouse.x >= 128 && _mouse.x <= 515 && _mouse.y >= 102 && _mouse.y <= 206) {
		oracleTextDown();
	} else if (_mouse.x >= 172 && _mouse.x <= 469 && _mouse.y >= 287 && _mouse.y <= 382) {
		HitArea *ha = findBox(0x7FFB);
		if (ha != NULL && (ha->flags & kBFBoxInUse)) {
			if (!isSpriteLoaded(21, 9) && !isSpriteLoaded(23, 9))
				inventoryUp(ha->window);
		}
	}
}

void AGOSEngine_Feeble::handleMouseWheelDown() {
	if (getGameType() == GType_PP || !(getBitFlag(99)))
		return;

	if (_mouse.x >= 128 && _mouse.x <= 515 && _mouse.y >= 102 && _mouse.y <= 206) {
		oracleTextUp();
	} else if (_mouse.x >= 172 && _mouse.x <= 469 && _mouse.y >= 287 && _mouse.y <= 382) {
		HitArea *ha = findBox(0x7FFC);
		if (ha != NULL && (ha->flags & kBFBoxInUse)) {
			if (!isSpriteLoaded(21, 9) && !isSpriteLoaded(23, 9))
					inventoryDown(ha->window);
		}
	}
}
#endif

void AGOSEngine_Simon1::handleMouseWheelUp() {
	HitArea *ha = findBox(206);
	if (ha != nullptr && (ha->flags & kBFBoxInUse) && !(ha->flags & kBFBoxDead)) {
			if (_saveLoadRowCurPos != 1) {
				if (_saveLoadRowCurPos < 7)
					_saveLoadRowCurPos = 1;
				else
					_saveLoadRowCurPos -= 1;

				_saveLoadEdit = false;
				listSaveGames();
			}
	} else {
		AGOSEngine::handleMouseWheelUp();
	}
}

void AGOSEngine_Simon1::handleMouseWheelDown() {
	HitArea *ha = findBox(207);
	if (ha != nullptr && (ha->flags & kBFBoxInUse) && !(ha->flags & kBFBoxDead)) {
			if (_saveDialogFlag) {
				_saveLoadRowCurPos += 1;
				if (_saveLoadRowCurPos >= _numSaveGameRows)
					_saveLoadRowCurPos = _numSaveGameRows;

				_saveLoadEdit = false;
				listSaveGames();
			}
	} else {
		AGOSEngine::handleMouseWheelDown();
	}
}

void AGOSEngine_Elvira2::handleMouseWheelUp() {
	HitArea *ha = findBox(224);
	if (ha != nullptr && (ha->flags & kBFBoxInUse)) {
			_saveGameNameLen = 0;

			if (_saveLoadRowCurPos < 3)
				_saveLoadRowCurPos = 1;
			else
				_saveLoadRowCurPos -= 3;

			listSaveGames();
	} else if ((ha = findBox(0x7FFB)) && ha->window && ha->window->iconPtr) {
		_lastHitArea3 = _lastHitArea = ha;
	}
}

void AGOSEngine_Elvira2::handleMouseWheelDown() {
	HitArea *ha =  findBox(224);
	if (ha != nullptr && (ha->flags & kBFBoxInUse)) {
			_saveGameNameLen = 0;
			_saveLoadRowCurPos += 3;
			if (_saveLoadRowCurPos >= _numSaveGameRows)
				_saveLoadRowCurPos = 1;

			listSaveGames();
	} else if ((ha = findBox(0x7FFC)) && ha->window && ha->window->iconPtr) {
		_lastHitArea3 = _lastHitArea = ha;
	}
}

void AGOSEngine::handleMouseWheelUp() {
	HitArea *ha = findBox(0x7FFB);
	if (ha != nullptr && (ha->flags & kBFBoxInUse) && !(getGameId() == GID_ELVIRA1 && _windowNum == 3)) {
		inventoryUp(ha->window);
	}
}

void AGOSEngine::handleMouseWheelDown() {
	HitArea *ha = findBox(0x7FFC);
	if (ha != nullptr && (ha->flags & kBFBoxInUse) && !(getGameId() == GID_ELVIRA1 && _windowNum == 3)) {
		inventoryDown(ha->window);
	}
}

void AGOSEngine::permitInput() {
	if (_mortalFlag)
		return;

	_mortalFlag = true;
	justifyOutPut(0);

	if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) {
		int n = 0;
		while (n < 8) {
			if ((_fcsData1[n]) && (_windowArray[n]) && (_windowArray[n]->flags & 128)) {
				_textWindow = _windowArray[n];
				waitWindow(_textWindow);
				clsCheck(_textWindow);
			}
			_fcsData1[n]=0;
			n++;
		}

		restartAnimation();
	}

	_curWindow = 0;
	if (_windowArray[0]) {
		_textWindow = _windowArray[0];
		justifyStart();
	}
	_mortalFlag = false;

}

bool AGOSEngine::processSpecialKeys() {
	bool verbCode = false;

	if (getGameId() == GID_DIMP) {
		uint32 t1 = getTime() / 30;
		if (!_lastMinute)
			_lastMinute = t1;
		if (t1 - _lastMinute) {
			_variableArray[120] += (t1 - _lastMinute);
			_lastMinute = t1;
		}
	}

	if (shouldQuit())
		_exitCutscene = true;

	switch (_action) {
	case kActionWalkForward:
		if (getGameType() == GType_PP)
			_verbHitArea = 302;
		else if (getGameType() == GType_WW)
			_verbHitArea = 239;
		else if (getGameType() == GType_ELVIRA2 && isBoxDead(101))
			_verbHitArea = 200;
		else if (getGameType() == GType_ELVIRA1 && isBoxDead(101))
			_verbHitArea = 214;
		verbCode = true;
		break;
	case kActionTurnBack:
		if (getGameType() == GType_PP)
			_verbHitArea = 304;
		else if (getGameType() == GType_WW)
			_verbHitArea = 241;
		else if (getGameType() == GType_ELVIRA2 && isBoxDead(107))
			_verbHitArea = 202;
		else if (getGameType() == GType_ELVIRA1 && isBoxDead(105))
			_verbHitArea = 215;
		verbCode = true;
		break;
	case kActionTurnRight:
		if (getGameType() == GType_PP)
			_verbHitArea = 303;
		else if (getGameType() == GType_WW)
			_verbHitArea = 240;
		else if (getGameType() == GType_ELVIRA2 && isBoxDead(102))
			_verbHitArea = 201;
		else if (getGameType() == GType_ELVIRA1 && isBoxDead(103))
			_verbHitArea = 216;
		verbCode = true;
		break;
	case kActionTurnLeft:
		if (getGameType() == GType_PP)
			_verbHitArea = 301;
		else if (getGameType() == GType_WW)
			_verbHitArea = 242;
		else if (getGameType() == GType_ELVIRA2 && isBoxDead(104))
			_verbHitArea = 203;
		else if (getGameType() == GType_ELVIRA1 && isBoxDead(107))
			_verbHitArea = 217;
		verbCode = true;
		break;
	case kActionExitCutscene:
		_exitCutscene = true;
		break;
	case kActionTextSpeedFast:
		if (getGameType() == GType_SIMON2) {
			vcWriteVar(5, 50);
			vcWriteVar(86, 0);
		} else if (getGameType() == GType_SIMON1) {
			vcWriteVar(5, 40);
			vcWriteVar(86, 0);
		}
		break;
	case kActionTextSpeedMedium:
		if (getGameType() == GType_SIMON2) {
			vcWriteVar(5, 75);
			vcWriteVar(86, 1);
		} else if (getGameType() == GType_SIMON1) {
			vcWriteVar(5, 60);
			vcWriteVar(86, 1);
		}
		break;
	case kActionTextSpeedSlow:
		if (getGameType() == GType_SIMON2) {
			vcWriteVar(5, 125);
			vcWriteVar(86, 2);
		} else if (getGameType() == GType_SIMON1) {
			vcWriteVar(5, 100);
			vcWriteVar(86, 2);
		}
		break;
	case kActionToggleSwitchCharacter:
		if (getGameType() == GType_FF && getBitFlag(76))
			_variableArray[254] = 70;
		break;
	case kActionToggleHitboxName:
		if (getGameType() == GType_FF)
			setBitFlag(73, !getBitFlag(73));
		break;
	case kActionSpeed_GTYPEPP:
		if (getGameType() == GType_PP && getGameId() != GID_DIMP) {
			if (!getBitFlag(110)) {
				setBitFlag(107, !getBitFlag(107));
				_vgaPeriod = (getBitFlag(107) != 0) ? 15 : 30;
			}
		}
		break;
	case kActionPause:
		pause();
		break;
	case kActionToggleSubtitle:
		if (getGameType() == GType_FF || (getGameType() == GType_SIMON2 && (getFeatures() & GF_TALKIE)) ||
			((getFeatures() & GF_TALKIE) && _language != Common::EN_ANY && _language != Common::DE_DEU)) {
			if (_speech)
				_subtitles = !_subtitles;
		}
		break;
	case kActionToggleSpeech:
		if (getGameType() == GType_FF || (getGameType() == GType_SIMON2 && (getFeatures() & GF_TALKIE))) {
			if (_subtitles) {
				_speech = !_speech;
				syncSoundSettingsIntern();
			}
		}
		break;
	case kActionMusicUp:
		if (_musicMuted) {
			_musicMuted = false;
			_musicVolume = 16;
		} else {
			_musicVolume = CLIP(_musicVolume + 16, 0, 256);
		}
		syncSoundSettingsIntern();
		break;
	case kActionMusicDown:
		if (!_musicMuted) {
			_musicVolume = CLIP(_musicVolume - 16, 0, 256);
			if (_musicVolume == 0) {
				_musicMuted = true;
			}
			syncSoundSettingsIntern();
		}
		break;
	case kActionToggleMusic:
		_musicMuted = !_musicMuted;
		if (!_musicMuted && _musicVolume == 0)
			// If last used music volume is 0 when unmuting, use ScummVM
			// default volume.
			_musicVolume = 192;
		syncSoundSettingsIntern();
		break;
	case kActionToggleSoundEffects:
		_effectsMuted = !_effectsMuted;
		if (!_effectsMuted && _effectsVolume == 0)
			// If last used SFX volume is 0 when unmuting, use ScummVM
			// default volume.
			_effectsVolume = 192;
		syncSoundSettingsIntern();
		break;
	case kActionToggleBackgroundSound:
		if (getGameType() == GType_SIMON2) {
			_ambientMuted = !_ambientMuted;
			if (!_ambientMuted && _effectsVolume == 0)
				// If last used SFX volume is 0 when unmuting, use ScummVM
				// default volume.
				_effectsVolume = 192;
			syncSoundSettingsIntern();
		}
		break;
	default:
		break;
	}

	_keyPressed.reset();
	return verbCode;
}

} // End of namespace AGOS

================
File: input_pn.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "agos/agos.h"
#include "agos/intern.h"

namespace AGOS {

void AGOSEngine_PN::clearInputLine() {
	_inputting = false;
	_inputReady = false;
	clearWindow(_windowArray[2]);
}

void AGOSEngine_PN::handleKeyboard() {
	if (!_inputReady)
		return;

	if (_keymapEnabled) {
		Common::Keymapper *keymapper = AGOSEngine::getEventManager()->getKeymapper();
		keymapper->getKeymap("game-shortcuts")->setEnabled(false);
		_keymapEnabled = false;
	}

	if (_hitCalled != 0) {
		mouseHit();
	}

	int16 chr = -1;
	if (_mouseString) {
		const char *strPtr = _mouseString;
		while (*strPtr != 0 && *strPtr != 13)
			addChar(*strPtr++);
		_mouseString = nullptr;

		chr = *strPtr;
		if (chr == 13) {
			addChar(13);
		}
	}
	if (_mouseString1 && chr != 13) {
		const char *strPtr = _mouseString1;
		while (*strPtr != 13)
			addChar(*strPtr++);
		_mouseString1 = nullptr;

		chr = *strPtr;
		if (chr == 13) {
			addChar(13);
		}
	}
	if (chr == -1) {
		if (_keyPressed.keycode == Common::KEYCODE_BACKSPACE || _keyPressed.keycode == Common::KEYCODE_RETURN) {
			chr = _keyPressed.keycode;
			addChar(chr);
		} else if (!(_videoLockOut & 0x10)) {
			chr = _keyPressed.ascii;
			if (chr >= 32)
				addChar(chr);
		}
	}

	if (chr == 13) {
		_mouseString = nullptr;
		_mouseString1 = nullptr;
		_mousePrintFG = 0;
		_inputReady = false;
		if (!_keymapEnabled) {
			Common::Keymapper *keymapper = AGOSEngine::getEventManager()->getKeymapper();
			keymapper->getKeymap("game-shortcuts")->setEnabled(true);
			_keymapEnabled = true;
		}
	}

	_keyPressed.reset();
}

void AGOSEngine_PN::interact(char *buffer, uint8 size) {
	if (!_inputting) {
		memset(_keyboardBuffer, 0, sizeof(_keyboardBuffer));
		_intputCounter = 0;
		_inputMax = size;
		_inputWindow = _windowArray[_curWindow];
		windowPutChar(_inputWindow, 128);
		windowPutChar(_inputWindow, 8);
		_inputting = true;
		_inputReady = true;
	}

	while (!shouldQuit() && _inputReady) {
		if (!_noScanFlag && _scanFlag) {
			buffer[0] = 1;
			buffer[1] = 0;
			_scanFlag = 0;
			break;
		}
		delay(1);
	}

	if (!_inputReady) {
		memcpy(buffer, _keyboardBuffer, size);
		_inputting = false;
	}
}

void AGOSEngine_PN::addChar(uint8 chr) {
	if (chr == 13) {
		_keyboardBuffer[_intputCounter++] = chr;
		windowPutChar(_inputWindow, 13);
	} else if (chr == 8 && _intputCounter) {
		clearCursor(_inputWindow);
		windowPutChar(_inputWindow, 8);
		windowPutChar(_inputWindow, 128);
		windowPutChar(_inputWindow, 8);

		_keyboardBuffer[--_intputCounter] = 0;
	} else if (chr >= 32 && _intputCounter < _inputMax) {
		_keyboardBuffer[_intputCounter++] = chr;

		clearCursor(_inputWindow);
		windowPutChar(_inputWindow, chr);
		windowPutChar(_inputWindow, 128);
		windowPutChar(_inputWindow, 8);
	}
}

void AGOSEngine_PN::clearCursor(WindowBlock *window) {
	byte oldTextColor = window->textColor;

	window->textColor = window->fillColor;
	windowPutChar(window, 128);
	window->textColor = oldTextColor;

	windowPutChar(window, 8);
}

bool AGOSEngine_PN::processSpecialKeys() {
	if (shouldQuit())
		_exitCutscene = true;

	switch (_action) {
	case kActionExitCutscene:
		_exitCutscene = true;
		break;
	case kActionPause:
		pause();
		break;
	default:
		break;
	}

	_keyPressed.reset();
	return false;
}

} // End of namespace AGOS

================
File: intern.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_INTERN_H
#define AGOS_INTERN_H

#include "agos/intern_detection.h"

namespace AGOS {

enum ChildType {
	kRoomType = 1,
	kObjectType = 2,
	kPlayerType = 3,
	kGenExitType = 4,   // Elvira 1 specific
	kSuperRoomType = 4, // Elvira 2 specific

	kContainerType = 7,
	kChainType = 8,
	kUserFlagType = 9,

	kInheritType = 255
};

struct Child {
	Child *next;
	uint16 type;
};

struct SubRoom : Child {
	uint16 subroutine_id;
	uint16 roomExitStates;
	uint16 roomExit[1];
	uint16 roomShort;
	uint16 roomLong;
	uint16 flags;
};

struct SubSuperRoom : Child {
	uint16 subroutine_id;
	uint16 roomX;
	uint16 roomY;
	uint16 roomZ;
	uint16 roomExitStates[1];
};

struct SubObject : Child {
	uint16 objectName;
	uint16 objectSize;
	uint16 objectWeight;
	uint32 objectFlags;
	int16 objectFlagValue[1];
};

struct SubPlayer : Child {
	int16 userKey;
	int16 size;
	int16 weight;
	int16 strength;
	int16 flags;
	int16 level;
	int32 score;
};

struct SubGenExit : Child {
	uint16 subroutine_id;
	uint16 dest[6];
};

struct SubContainer : Child {
	uint16 subroutine_id;
	uint16 volume;
	uint16 flags;
};

struct SubChain : Child {
	uint16 subroutine_id;
	uint16 chChained;
};

struct SubUserFlag : Child {
	uint16 subroutine_id;
	uint16 userFlags[8];
	uint16 userItems[1];
};

struct SubInherit : Child {
	uint16 subroutine_id;
	uint16 inMaster;
};

enum {
	SubRoom_SIZE = sizeof(SubRoom) - sizeof(uint16),
	SubSuperRoom_SIZE = sizeof(SubSuperRoom) - sizeof(uint16),
	SubObject_SIZE = sizeof(SubObject) - sizeof(int16)
};

struct RoomState {
	uint16 state;
	uint16 classFlags;
	uint16 roomExitStates;

	RoomState() { memset(this, 0, sizeof(*this)); }
};

struct Item {
	uint16 parent;
	uint16 child;
	uint16 next;
	int16 noun;
	int16 adjective;
	int16 state;										/* signed int */
	uint16 classFlags;
	uint16 itemName;
	Child *children;

	Item() { memset(this, 0, sizeof(*this)); }
};

struct IconEntry {
	Item *item;
	uint16 boxCode;
};

struct IconBlock {
	int16 line;
	Item *itemRef;
	IconEntry iconArray[64];
	int16 upArrow, downArrow;
	uint16 classMask;
};

struct WindowBlock {
	byte mode;
	byte flags;
	int16 x, y;
	int16 width, height;
	int16 textColumn, textRow;
	int16 scrollY;
	uint16 textColumnOffset, textLength, textMaxLength;
	uint8 fillColor, textColor;
	IconBlock *iconPtr;
	WindowBlock() { memset(this, 0, sizeof(*this)); }
	~WindowBlock() { free (iconPtr); }
};
// note on text offset:
// the actual x-coordinate is: textColumn * 8 + textColumnOffset
// the actual y-coordinate is: textRow * 8

enum {
	SUBROUTINE_LINE_SMALL_SIZE = 2,
	SUBROUTINE_LINE_BIG_SIZE = 8
};

#include "common/pack-start.h"

struct Subroutine {
	uint16 id;								/* subroutine ID */
	uint16 first;								/* offset from subroutine start to first subroutine line */
	Subroutine *next;							/* next subroutine in linked list */
};

struct SubroutineLine {
	uint16 next;
	int16 verb;
	int16 noun1;
	int16 noun2;
};

#include "common/pack-end.h"

struct TimeEvent {
	uint32 time;
	uint16 subroutine_id;
	TimeEvent *next;
};

struct GameSpecificSettings {
	const char *base_filename;
	const char *restore_filename;
	const char *tbl_filename;
	const char *effects_filename;
	const char *speech_filename;
};

enum BoxFlags {
	kBFToggleBox      = 0x1, // Elvira 1/2
	kBFTextBox        = 0x1, // Others
	kBFBoxSelected    = 0x2,
	kBFInvertSelect   = 0x4, // Elvira 1/2
	kBFNoTouchName    = 0x4, // Others
	kBFInvertTouch    = 0x8,
	kBFHyperBox       = 0x10, // Feeble Files
	kBFDragBox        = 0x10, // Others
	kBFBoxInUse       = 0x20,
	kBFBoxDead        = 0x40,
	kBFBoxItem        = 0x80
};

enum OldBoxFlags_PN {
	kOBFObject         = 0x1,
	kOBFExit           = 0x2,
	kOBFDraggable      = 0x4,
	kOBFUseEmptyLine   = 0x8,
	kOBFBoxDisabled    = 0x10,
	kOBFInventoryBox   = 0x20,
	kOBFRoomBox        = 0x40,
	kOBFMoreBox        = 0x80,
	kOBFNoShowName     = 0x100,
	kOBFUseMessageList = 0x400,
	// ScummVM specific
	kOBFBoxSelected    = 0x800,
	kOBFInvertTouch    = 0x1000
};

enum SubObjectFlags {
	kOFText           = 0x1,
	kOFSize           = 0x2,
	kOFWorn           = 0x4, // Elvira 1
	kOFWeight         = 0x4, // Others
	kOFVolume         = 0x8,
	kOFIcon           = 0x10,
	kOFKeyColor1      = 0x20,
	kOFKeyColor2      = 0x40,
	kOFMenu           = 0x80,
	kOFNumber         = 0x100,
	kOFSoft           = 0x200, // Waxworks
	kOFVoice          = 0x200  // Others
};

} // End of namespace AGOS

#endif

================
File: intern_detection.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Game detection - related enums, taken from agos/intern.h

namespace AGOS {

enum GameIds {
	GID_PN,
	GID_ELVIRA1,
	GID_ELVIRA2,
	GID_WAXWORKS,

	GID_SIMON1,
	GID_SIMON1DOS,
	GID_SIMON1CD32,

	GID_SIMON2,

	GID_FEEBLEFILES,

	GID_DIMP,
	GID_JUMBLE,
	GID_PUZZLE,
	GID_SWAMPY
};

enum GameFeatures {
	GF_TALKIE           = 1 << 0,
	GF_OLD_BUNDLE       = 1 << 1,
	GF_CRUNCHED         = 1 << 2,
	GF_CRUNCHED_GAMEPC  = 1 << 3,
	GF_ZLIBCOMP         = 1 << 4,
	GF_32COLOR          = 1 << 5,
	GF_EGA              = 1 << 6,
	GF_PLANAR           = 1 << 7,
	GF_DEMO             = 1 << 8,
	GF_PACKED           = 1 << 9,
	GF_BROKEN_FF_RATING = 1 << 10,
	GF_WAVSFX           = 1 << 11,
	GF_MT32_XMIDI       = 1 << 12,
	GF_MT32_TRACK10_FIX = 1 << 13
};

enum GameFileTypes {
	GAME_BASEFILE = 1 << 0,
	GAME_ICONFILE = 1 << 1,
	GAME_GMEFILE  = 1 << 2,
	GAME_MENUFILE = 1 << 3,
	GAME_STRFILE  = 1 << 4,
	GAME_RMSLFILE = 1 << 5,
	GAME_STATFILE = 1 << 6,
	GAME_TBLFILE  = 1 << 7,
	GAME_XTBLFILE = 1 << 8,
	GAME_RESTFILE = 1 << 9,
	GAME_TEXTFILE = 1 << 10,
	GAME_VGAFILE  = 1 << 11,
	GAME_GFXIDXFILE = 1 << 12,
	GAME_CABFILE  = 1 << 13

};


} // End of namespace AGOS

================
File: items.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/file.h"
#include "common/textconsole.h"

#include "agos/intern.h"
#include "agos/agos.h"
#include "agos/vga.h"

namespace AGOS {

Child *AGOSEngine::allocateChildBlock(Item *i, uint type, uint size) {
	Child *child = (Child *)allocateItem(size);
	child->next = i->children;
	i->children = child;
	child->type = type;
	return child;
}

void *AGOSEngine::allocateItem(uint size) {
	byte *item = new byte[size]();
	_itemHeap.push_back(item);
	return item;
}

void AGOSEngine::allocItemHeap() {
	_itemHeap.clear();
}

bool AGOSEngine_Elvira2::hasIcon(Item *item) {
	SubObject *child = (SubObject *)findChildOfType(item, kObjectType);
	return (child && (child->objectFlags & kOFIcon) != 0);
}

bool AGOSEngine::hasIcon(Item *item) {
	return (getUserFlag(item, 7) != 0);
}

uint AGOSEngine_Elvira2::itemGetIconNumber(Item *item) {
	SubObject *child = (SubObject *)findChildOfType(item, kObjectType);
	uint offs;

	if (child == nullptr || !(child->objectFlags & kOFIcon))
		return 0;

	offs = getOffsetOfChild2Param(child, 0x10);
	return child->objectFlagValue[offs];
}

uint AGOSEngine::itemGetIconNumber(Item *item) {
	return getUserFlag(item, 7);
}

void AGOSEngine::setItemState(Item *item, int value) {
	item->state = value;
}

void AGOSEngine::createPlayer() {
	SubPlayer *p;

	_currentPlayer = _itemArrayPtr[1];
	_currentPlayer->adjective = -1;
	_currentPlayer->noun = 10000;

	p = (SubPlayer *)allocateChildBlock(_currentPlayer, kPlayerType, sizeof(SubPlayer));
	if (p == nullptr)
		error("createPlayer: player create failure");

	p->size = 0;
	p->weight = 0;
	p->strength = 6000;
	p->flags = 1; // Male
	p->level = 1;
	p->score = 0;

	setUserFlag(_currentPlayer, 0, 0);
}

Child *AGOSEngine::findChildOfType(Item *i, uint type) {
	Item *b = nullptr;
	Child *child = i->children;

	for (; child; child = child->next) {
		if (child->type == type)
			return child;
		if (child->type == 255)
			b = derefItem(((SubInherit *)(child))->inMaster);
	}
	if (b) {
		child = b->children;
		for (; child; child = child->next) {
			if (child->type == type)
				return child;
		}
	}

	return nullptr;
}

int AGOSEngine::getUserFlag(Item *item, int a) {
	SubUserFlag *subUserFlag;

	subUserFlag = (SubUserFlag *)findChildOfType(item, kUserFlagType);
	if (subUserFlag == nullptr)
		return 0;

	int max = (getGameType() == GType_ELVIRA1) ? 7 : 3;
	if (a < 0 || a > max)
		return 0;

	return subUserFlag->userFlags[a];
}

int AGOSEngine::getUserFlag1(Item *item, int a) {
	SubUserFlag *subUserFlag;

	if (item == nullptr || item == _dummyItem2 || item == _dummyItem3)
		return -1;

	subUserFlag = (SubUserFlag *)findChildOfType(item, kUserFlagType);
	if (subUserFlag == nullptr)
		return 0;

	if (a < 0 || a > 7)
		return 0;

	return	subUserFlag->userFlags[a];
}

void AGOSEngine::setUserFlag(Item *item, int a, int b) {
	SubUserFlag *subUserFlag;

	subUserFlag = (SubUserFlag *)findChildOfType(item, kUserFlagType);
	if (subUserFlag == nullptr) {
		subUserFlag = (SubUserFlag *)allocateChildBlock(item, kUserFlagType, sizeof(SubUserFlag));
	}

	if (a < 0 || a > 7)
		return;

	subUserFlag->userFlags[a] = b;
}

int AGOSEngine::getUserItem(Item *item, int n) {
	SubUserFlag *subUserFlag;

	subUserFlag = (SubUserFlag *)findChildOfType(item, kUserFlagType);
	if (subUserFlag == nullptr)
		return 0;

	if (n < 0 || n > 0)
		return 0;

	return	subUserFlag->userItems[n];
}

void AGOSEngine::setUserItem(Item *item, int n, int m) {
	SubUserFlag *subUserFlag;

	subUserFlag = (SubUserFlag *)findChildOfType(item, kUserFlagType);
	if (subUserFlag == nullptr) {
		subUserFlag = (SubUserFlag *)allocateChildBlock(item, kUserFlagType, sizeof(SubUserFlag));
	}

	if (n == 0)
		subUserFlag->userItems[n] = m;
}

bool AGOSEngine::isRoom(Item *item) {
	return findChildOfType(item, kRoomType) != nullptr;
}

bool AGOSEngine::isObject(Item *item) {
	return findChildOfType(item, kObjectType) != nullptr;
}

bool AGOSEngine::isPlayer(Item *item) {
	return findChildOfType(item, kPlayerType) != nullptr;
}

uint AGOSEngine::getOffsetOfChild2Param(SubObject *child, uint prop) {
	uint m = 1;
	uint offset = 0;
	while (m != prop) {
		if (child->objectFlags & m)
			offset++;
		m *= 2;
	}
	return offset;
}

Item *AGOSEngine::me() {
	if (_currentPlayer)
		return _currentPlayer;
	return _dummyItem1;
}

Item *AGOSEngine::actor() {
	error("actor: is this code ever used?");
	//if (_actorPlayer)
	//	return _actorPlayer;
	return _dummyItem1;	// for compilers that don't support NORETURN
}

Item *AGOSEngine::getNextItemPtr() {
	int a = getNextWord();
	switch (a) {
	case -1:
		return _subjectItem;
	case -3:
		return _objectItem;
	case -5:
		return me();
	case -7:
		return actor();
	case -9:
		return derefItem(me()->parent);
	default:
		return derefItem(a);
	}
}

Item *AGOSEngine::getNextItemPtrStrange() {
	int a = getNextWord();
	switch (a) {
	case -1:
		return _subjectItem;
	case -3:
		return _objectItem;
	case -5:
		return _dummyItem2;
	case -7:
		return nullptr;
	case -9:
		return _dummyItem3;
	default:
		return derefItem(a);
	}
}

uint AGOSEngine::getNextItemID() {
	int a = getNextWord();
	switch (a) {
	case -1:
		return itemPtrToID(_subjectItem);
	case -3:
		return itemPtrToID(_objectItem);
	case -5:
		return getItem1ID();
	case -7:
		return 0;
	case -9:
		return me()->parent;
	default:
		return a;
	}
}

void AGOSEngine::setItemParent(Item *item, Item *parent) {
	Item *old_parent = derefItem(item->parent);

	if (item == parent)
		error("setItemParent: Trying to set item as its own parent");

	// unlink it if it has a parent
	if (old_parent)
		unlinkItem(item);
	itemChildrenChanged(old_parent);
	linkItem(item, parent);
	itemChildrenChanged(parent);
}

void AGOSEngine::itemChildrenChanged(Item *item) {
	int i;
	WindowBlock *window;

	if (_noParentNotify)
		return;

	mouseOff();

	for (i = 0; i != 8; i++) {
		window = _windowArray[i];
		if (window && window->iconPtr && window->iconPtr->itemRef == item) {
			if (_fcsData1[i]) {
				_fcsData2[i] = true;
			} else {
				_fcsData2[i] = false;
				drawIconArray(i, item, window->iconPtr->line, window->iconPtr->classMask);
			}
		}
	}

	mouseOn();
}

void AGOSEngine::unlinkItem(Item *item) {
	Item *first, *parent, *next;

	// can't unlink item without parent
	if (item->parent == 0)
		return;

	// get parent and first child of parent
	parent = derefItem(item->parent);
	first = derefItem(parent->child);

	// the node to remove is first in the parent's children?
	if (first == item) {
		parent->child = item->next;
		item->parent = 0;
		item->next = 0;
		return;
	}

	for (;;) {
		if (!first)
			error("unlinkItem: parent empty");
		if (first->next == 0)
			error("unlinkItem: parent does not contain child");

		next = derefItem(first->next);
		if (next == item) {
			first->next = next->next;
			item->parent = 0;
			item->next = 0;
			return;
		}
		first = next;
	}
}

void AGOSEngine::linkItem(Item *item, Item *parent) {
	uint id;
	// Don't allow that an item that is already linked is relinked
	if (item->parent)
		return;

	id = itemPtrToID(parent);
	item->parent = id;

	if (parent != nullptr) {
		item->next = parent->child;
		parent->child = itemPtrToID(item);
	} else {
		item->next = 0;
	}
}

int AGOSEngine::wordMatch(Item *item, int16 a, int16 n) {
	if (getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) {
		if (a == -1 && n == -1)
			return 1;
	}
	if (a == -1 && n == item->noun)
		return 1;
	if (a == item->adjective && n == item->noun)
		return 1;

	return 0;
}

Item *AGOSEngine::derefItem(uint item) {
	if (item >= _itemArraySize)
		error("derefItem: invalid item %d", item);
	return _itemArrayPtr[item];
}

Item *AGOSEngine::findInByClass(Item *i, int16 m) {
	i = derefItem(i->child);
	while (i) {
		if (i->classFlags & m) {
			_findNextPtr = derefItem(i->next);
			return i;
		}
		if (m == 0) {
			_findNextPtr = derefItem(i->next);
			return i;
		}
		i = derefItem(i->next);
	}
	return nullptr;
}

Item *AGOSEngine::nextInByClass(Item *i, int16 m) {
	i = _findNextPtr;
	while (i) {
		if (i->classFlags & m) {
			_findNextPtr = derefItem(i->next);
			return i;
		}
		if (m == 0) {
			_findNextPtr = derefItem(i->next);
			return i;
		}
		i = derefItem(i->next);
	}
	return nullptr;
}

Item *AGOSEngine::findMaster(int16 a, int16 n) {
	uint j;

	for (j = 1; j < _itemArraySize; j++) {
		Item *item = derefItem(j);
		if (item == nullptr)
			continue;

		if (wordMatch(item, a, n))
			return item;
	}

	return nullptr;
}

Item *AGOSEngine::nextMaster(Item *i, int16 a, int16 n) {
	uint j;
	uint first = itemPtrToID(i) + 1;

	for (j = first; j < _itemArraySize; j++) {
		Item *item = derefItem(j);
		if (item == nullptr)
			continue;

		if (wordMatch(item, a, n))
			return item;
	}

	return nullptr;
}

uint AGOSEngine::itemPtrToID(Item *id) {
	uint i;
	for (i = 0; i != _itemArraySize; i++)
		if (_itemArrayPtr[i] == id)
			return i;
	error("itemPtrToID: not found");
	return 0;	// for compilers that don't support NORETURN
}

} // End of namespace AGOS

================
File: menus.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/file.h"
#include "common/system.h"
#include "common/textconsole.h"

#include "graphics/surface.h"

#include "agos/agos.h"
#include "agos/intern.h"

namespace AGOS {

void AGOSEngine::loadMenuFile() {
	Common::File in;

	in.open(getFileName(GAME_MENUFILE));
	if (in.isOpen() == false) {
		error("loadMenuFile: Can't load menus file '%s'", getFileName(GAME_MENUFILE));
	}

	uint fileSize = in.size();
	_menuBase = (byte *)malloc(fileSize);
	if (_menuBase == nullptr)
		error("loadMenuFile: Out of memory for menu data");
	in.read(_menuBase, fileSize);
	in.close();
}

// Personal Nightmare specific
void AGOSEngine::restoreMenu() {
	_wiped = false;

	_videoLockOut |= 0x80;

	clearVideoWindow(3, 0);

	uint16 oldWindowNum = _windowNum;

	setWindowImage(1, 1);
	setWindowImage(2, 2);

	drawEdging();

	_windowNum = oldWindowNum;

	_videoLockOut |= 0x20;
	_videoLockOut &= ~0x80;
}

// Elvira 1 specific
void AGOSEngine::drawMenuStrip(uint windowNum, uint menuNum) {
	WindowBlock *window = _windowArray[windowNum % 8];

	mouseOff();

	byte *srcPtr = _menuBase;
	int menu = (menuNum != 0) ? menuNum * 4 + 1 : 0;

	while (menu--) {
		if (READ_LE_UINT16(srcPtr) != 0xFFFF) {
			srcPtr += 2;
			while (*srcPtr != 0)
				srcPtr++;
			srcPtr++;
		} else {
			srcPtr += 2;
		}
	}

	clearWindow(window);

	int newline = 0;
	while (READ_LE_UINT16(srcPtr) != 0xFFFF) {
		byte *tmp = srcPtr;
		srcPtr += 2;

		if (newline != 0) {
			windowPutChar(window, 10);
		}

		uint len = 0;
		while (*srcPtr != 0 && *srcPtr != 1) {
			len++;
			srcPtr++;
		}
		if (*srcPtr == 1)
			srcPtr++;

		uint maxLen = window->textMaxLength - len;

		if (window->flags & 1)
			window->textColumnOffset += 4;

		maxLen /= 2;
		while (maxLen--)
			windowPutChar(window, 32);

		srcPtr = tmp;
		uint verb = READ_BE_UINT16(srcPtr); srcPtr += 2;

		while (*srcPtr != 0) {
			windowPutChar(window, *srcPtr++);
		}
		srcPtr++;

		if (verb != 0xFFFE) {
			HitArea *ha = findEmptyHitArea();
			ha->x = window->x * 8 + 3;
			ha->y = window->textRow * 8 + window->y;
			ha->data = menuNum;
			ha->width = window->width * 8 - 6;
			ha->height = 7;
			ha->flags = kBFBoxInUse | kBFInvertTouch;
			ha->id = 30000;
			ha->priority = 1;
			ha->verb = verb;
		}

		newline = 0xFFFF;
	}

	mouseOn();
}

void AGOSEngine::lightMenuStrip(int a) {
	mouseOff();
	unlightMenuStrip();

	for (int i = 0; i != 10; i++) {
		if (a & (1 << i)) {
			enableBox(120 + i);
			lightMenuBox(120 + i);
		}
	}

	mouseOn();
}

void AGOSEngine::unlightMenuStrip() {
	byte *src;
	int w, h, i;

	mouseOff();

	Graphics::Surface *screen = getBackendSurface();
	src = (byte *)screen->getBasePtr(272, 8);
	w = 48;
	h = 82;

	do {
		for (i = 0; i != w; ++i) {
			if (src[i] != 0)
				src[i] = 14;
		}
		src += screen->pitch;
	} while (--h);

	for (i = 120; i != 130; i++)
		disableBox(i);

	Common::Rect dirtyRect(272, 8, 320, 90);
	updateBackendSurface(&dirtyRect);

	mouseOn();
}

void AGOSEngine::lightMenuBox(uint hitarea) {
	HitArea *ha = findBox(hitarea);
	byte *src;
	int w, h, i;

	mouseOff();

	Graphics::Surface *screen = getBackendSurface();
	src = (byte *)screen->getBasePtr(ha->x, ha->y);
	w = ha->width;
	h = ha->height;

	do {
		for (i = 0; i != w; ++i) {
			if (src[i] == 14)
				src[i] = 15;
		}
		src += screen->pitch;
	} while (--h);

	Common::Rect dirtyRect(ha->x, ha->y, ha->x + w, ha->y + ha->height);
	updateBackendSurface(&dirtyRect);

	mouseOn();
}

// Elvira 2 specific
uint AGOSEngine::menuFor_e2(Item *item) {
	if (item == nullptr || item == _dummyItem2 || item == _dummyItem3)
		return 0xFFFF;

	SubObject *subObject = (SubObject *)findChildOfType(item, kObjectType);
	if (subObject != nullptr && subObject->objectFlags & kOFMenu) {
		uint offs = getOffsetOfChild2Param(subObject, kOFMenu);
		return subObject->objectFlagValue[offs];
	}

	return _agosMenu;
}

// Waxworks specific
uint AGOSEngine::menuFor_ww(Item *item, uint id) {
	if (id != 0xFFFF && id < 10 && _textMenu[id] != 0)
		return _textMenu[id];

	if (item == nullptr || item == _dummyItem2 || item == _dummyItem3)
		return _agosMenu;

	SubObject *subObject = (SubObject *)findChildOfType(item, kObjectType);
	if (subObject != nullptr && subObject->objectFlags & kOFMenu) {
		uint offs = getOffsetOfChild2Param(subObject, kOFMenu);
		return subObject->objectFlagValue[offs];
	}

	return _agosMenu;
}

void AGOSEngine::clearMenuStrip() {
	int i;

	for (i = 111; i != 115; i++)
		disableBox(i);

	if (getGameType() == GType_WW) {
		setWindowImageEx(2, 101);
	} else {
		setWindowImageEx(2, 102);
	}
}

// Elvira 2 and Waxworks specific
void AGOSEngine::doMenuStrip(uint menuNum) {
	uint i;
	const uint var = (getGameType() == GType_WW) ? 11 : 1;

	for (i = 111; i != 115; i++)
		disableBox(i);

	for (i = var; i != (var + 5); i++)
		_variableArray[i] = 0;

	byte *srcPtr = _menuBase;
	while (menuNum--) {
		while (READ_BE_UINT16(srcPtr) != 0)
			srcPtr += 2;
		srcPtr += 2;
	}

	uint id = 111;
	uint v = var;

	while (READ_BE_UINT16(srcPtr) != 0) {
		uint verb = READ_BE_UINT16(srcPtr);
		_variableArray[v] = verb;

		HitArea *ha = findBox(id);
		if (ha != nullptr) {
			ha->flags &= ~kBFBoxDead;
			ha->verb = verb;
		}

		id++;
		srcPtr += 2;
		v++;
	}

	_variableArray[var + 4] = id - 111;
	if (getGameType() == GType_WW) {
		setWindowImageEx(2, 102);
	} else {
		setWindowImageEx(2, 103);
	}
}

} // End of namespace AGOS

================
File: metaengine.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/config-manager.h"
#include "common/savefile.h"
#include "common/system.h"
#include "common/compression/installshield_cab.h"
#include "common/translation.h"

#include "backends/keymapper/action.h"
#include "backends/keymapper/keymapper.h"
#include "backends/keymapper/standard-actions.h"

#include "engines/advancedDetector.h"

#include "agos/intern.h"
#include "agos/agos.h"
#include "agos/detection.h"

namespace AGOS {

static const ADExtraGuiOptionsMap optionsList[] = {
	{
		GAMEOPTION_COPY_PROTECTION,
		{
			_s("Enable copy protection"),
			_s("Enable any copy protection that would otherwise be bypassed by default."),
			"copy_protection",
			false,
			0,
			0
		},
	},
	{
		GAMEOPTION_OPL3_MODE,
		{
			_s("AdLib OPL3 mode"),
			_s("When AdLib is selected, OPL3 features will be used. Depending on the game, this will prevent cut-off notes, add extra notes or instruments and/or add stereo."),
			"opl3_mode",
			false,
			0,
			0
		}
	},
	{
		GAMEOPTION_DOS_TEMPOS,
		{
			_s("Use DOS version music tempos"),
			_s("Selecting this option will play the music using the tempos used by the DOS version of the game. Otherwise, the faster tempos of the Windows version will be used."),
			"dos_music_tempos",
			true,
			0,
			0
		}
	},
	{
		GAMEOPTION_WINDOWS_TEMPOS,
		{
			_s("Use DOS version music tempos"),
			_s("Selecting this option will play the music using the tempos used by the DOS version of the game. Otherwise, the faster tempos of the Windows version will be used."),
			"dos_music_tempos",
			false,
			0,
			0
		}
	},
	{
		GAMEOPTION_PREFER_DIGITAL_SFX,
		{
			_s("Prefer digital sound effects"),
			_s("Prefer digital sound effects instead of synthesized ones"),
			"prefer_digitalsfx",
			true,
			0,
			0
		}
	},
	{
		GAMEOPTION_DISABLE_FADE_EFFECTS,
		{
			_s("Disable fade-out effects"),
			_s("Don't fade every screen to black when leaving a room."),
			"disable_fade_effects",
			false,
			0,
			0
		}
	},
	AD_EXTRA_GUI_OPTIONS_TERMINATOR
};

} // End of namespace AGOS

class AgosMetaEngine : public AdvancedMetaEngine<AGOS::AGOSGameDescription> {
public:
	const char *getName() const override {
		return "agos";
	}

	const ADExtraGuiOptionsMap *getAdvancedExtraGuiOptions() const override {
		return AGOS::optionsList;
	}

	bool hasFeature(MetaEngineFeature f) const override;

	Common::Error createInstance(OSystem *syst, Engine **engine, const AGOS::AGOSGameDescription *desc) const override;

	SaveStateList listSaves(const char *target) const override;
	int getMaximumSaveSlot() const override;

	Common::KeymapArray initKeymaps(const char *target) const override;
};

bool AgosMetaEngine::hasFeature(MetaEngineFeature f) const {
	return
		(f == kSupportsListSaves) ||
		(f == kSimpleSavesNames);
}

bool AGOS::AGOSEngine::hasFeature(EngineFeature f) const {
	return
		(f == kSupportsReturnToLauncher);
}

Common::Error AgosMetaEngine::createInstance(OSystem *syst, Engine **engine, const AGOS::AGOSGameDescription *gd) const {
	switch (gd->gameType) {
	case AGOS::GType_PN:
		*engine = new AGOS::AGOSEngine_PN(syst, gd);
		break;
	case AGOS::GType_ELVIRA1:
		*engine = new AGOS::AGOSEngine_Elvira1(syst, gd);
		break;
	case AGOS::GType_ELVIRA2:
		*engine = new AGOS::AGOSEngine_Elvira2(syst, gd);
		break;
	case AGOS::GType_WW:
		*engine = new AGOS::AGOSEngine_Waxworks(syst, gd);
		break;
	case AGOS::GType_SIMON1:
		*engine = new AGOS::AGOSEngine_Simon1(syst, gd);
		break;
	case AGOS::GType_SIMON2:
		*engine = new AGOS::AGOSEngine_Simon2(syst, gd);
		break;
#ifdef ENABLE_AGOS2
	case AGOS::GType_FF:
		if (gd->features & AGOS::GF_DEMO)
			*engine = new AGOS::AGOSEngine_FeebleDemo(syst, gd);
		else
			*engine = new AGOS::AGOSEngine_Feeble(syst, gd);
		break;
	case AGOS::GType_PP:
		if (gd->gameId == AGOS::GID_DIMP)
			*engine = new AGOS::AGOSEngine_DIMP(syst, gd);
		else
			*engine = new AGOS::AGOSEngine_PuzzlePack(syst, gd);
		break;
#else
	case AGOS::GType_FF:
	case AGOS::GType_PP:
		return Common::Error(Common::kUnsupportedGameidError, _s("AGOS 2 support is not compiled in"));
#endif
	default:
		return Common::kUnsupportedGameidError;
	}

	return Common::kNoError;
}

SaveStateList AgosMetaEngine::listSaves(const char *target) const {
	Common::SaveFileManager *saveFileMan = g_system->getSavefileManager();
	Common::StringArray filenames;
	Common::String saveDesc;
	Common::String pattern = target;
	pattern += ".###";

	filenames = saveFileMan->listSavefiles(pattern);

	SaveStateList saveList;
	for (Common::StringArray::const_iterator file = filenames.begin(); file != filenames.end(); ++file) {
		// Obtain the last 3 digits of the filename, since they correspond to the save slot
		int slotNum = atoi(file->c_str() + file->size() - 3);

		if (slotNum >= 0 && slotNum <= 999) {
			Common::InSaveFile *in = saveFileMan->openForLoading(*file);
			if (in) {
				saveDesc = file->c_str();
				saveList.push_back(SaveStateDescriptor(this, slotNum, saveDesc));
				delete in;
			}
		}
	}

	// Sort saves based on slot number.
	Common::sort(saveList.begin(), saveList.end(), SaveStateDescriptorSlotComparator());
	return saveList;
}

int AgosMetaEngine::getMaximumSaveSlot() const { return 999; }

Common::KeymapArray AgosMetaEngine::initKeymaps(const char *target) const {
	using namespace Common;
	using namespace AGOS;

	Common::String gameId = ConfMan.get("gameid", target);

	// I18N: "AGOS main" refers to the main keymappings for the agos engine.
	// It is never disabled and it is not game specific
	Keymap *engineKeyMap = new Keymap(Keymap::kKeymapTypeGame, "agos-main", _("AGOS main"));
	Keymap *gameKeyMap = new Keymap(Keymap::kKeymapTypeGame, "game-shortcuts", _("Game keymappings"));
	Keymap *yesNoKeymap = new Keymap(Keymap::kKeymapTypeGame, "game-Yes/No", _("Yes/No keymapping"));
	Action *act;

	act = new Action(kStandardActionLeftClick, _("Left Click"));
	act->setLeftClickEvent();
	act->addDefaultInputMapping("MOUSE_LEFT");
	act->addDefaultInputMapping("JOY_A");
	engineKeyMap->addAction(act);

	act = new Action(kStandardActionRightClick, _("Right Click"));
	act->setRightClickEvent();
	act->addDefaultInputMapping("MOUSE_RIGHT");
	act->addDefaultInputMapping("JOY_B");
	engineKeyMap->addAction(act);

	act = new Action("EXTCUTSCN", _("Exit cutscene"));
	act->setCustomEngineActionEvent(kActionExitCutscene);
	act->addDefaultInputMapping("ESCAPE");
	act->addDefaultInputMapping("JOY_Y");
	if (gameId == "simon2" || gameId == "feeble")
		act->addDefaultInputMapping("F5");
	engineKeyMap->addAction(act);

	act = new Action("PAUSE", _("Pause"));
	act->setCustomEngineActionEvent(kActionPause);
	act->addDefaultInputMapping("p");
	gameKeyMap->addAction(act);

	act = new Action("MUSICDOWN", _("Music volume down"));
	act->setCustomEngineActionEvent(kActionMusicDown);
	act->addDefaultInputMapping("MINUS");
	gameKeyMap->addAction(act);

	act = new Action("MUSICUP", _("Music volume up"));
	act->setCustomEngineActionEvent(kActionMusicUp);
	act->addDefaultInputMapping("S+EQUALS");
	act->addDefaultInputMapping("PLUS");
	gameKeyMap->addAction(act);

	act = new Action("MUTEMSC", _("Toggle music on/off"));
	act->setCustomEngineActionEvent(kActionToggleMusic);
	act->addDefaultInputMapping("m");
	gameKeyMap->addAction(act);

	act = new Action("SNDEFFECT", _("Toggle sound effects on/off"));
	act->setCustomEngineActionEvent(kActionToggleSoundEffects);
	act->addDefaultInputMapping("s");
	gameKeyMap->addAction(act);

	act = new Action("FSTMODE", _("Toggle fast mode on/off"));
	act->setCustomEngineActionEvent(kActionToggleFastMode);
	act->addDefaultInputMapping("C+f");
	gameKeyMap->addAction(act);

	if (gameId == "waxworks" ||
			gameId == "elvira1" ||
			gameId == "elvira2" ||
			gameId == "swampy" ||
			gameId == "puzzle" ||
			gameId == "jumble" ||
			gameId == "dimp") {
		act = new Action("WLKFORWARD", _("Walk forward")); // KEYCODE_UP
		act->setCustomEngineActionEvent(kActionWalkForward);
		act->addDefaultInputMapping("UP");
		act->addDefaultInputMapping("JOY_UP");
		gameKeyMap->addAction(act);

		act = new Action("TRNBACK", _("Turn backward")); // KEYCODE_DOWN
		act->setCustomEngineActionEvent(kActionTurnBack);
		act->addDefaultInputMapping("DOWN");
		act->addDefaultInputMapping("JOY_DOWN");
		gameKeyMap->addAction(act);

		act = new Action("TRNLEFT", _("Turn left")); // KEYCODE_LEFT
		act->setCustomEngineActionEvent(kActionTurnLeft);
		act->addDefaultInputMapping("LEFT");
		act->addDefaultInputMapping("JOY_LEFT");
		gameKeyMap->addAction(act);

		act = new Action("TRNRIGHT", _("Turn right")); // KEYCODE_RIGHT
		act->setCustomEngineActionEvent(kActionTurnRight);
		act->addDefaultInputMapping("RIGHT");
		act->addDefaultInputMapping("JOY_RIGHT");
		gameKeyMap->addAction(act);
	}

	if (gameId == "simon1" || gameId == "simon2") {
		act = new Action("TXTFAST", _("Text speed - Fast"));
		act->setCustomEngineActionEvent(kActionTextSpeedFast);
		act->addDefaultInputMapping("F1");
		gameKeyMap->addAction(act);

		act = new Action("TXTMEDIUM", _("Text speed - Medium"));
		act->setCustomEngineActionEvent(kActionTextSpeedMedium);
		act->addDefaultInputMapping("F2");
		gameKeyMap->addAction(act);

		act = new Action("TXTSLOW", _("Text speed - Slow"));
		act->setCustomEngineActionEvent(kActionTextSpeedSlow);
		act->addDefaultInputMapping("F3");
		gameKeyMap->addAction(act);

		act = new Action("SHOWOBJINTERACT", _("Show objects to interact"));
		act->setCustomEngineActionEvent(kActionShowObjects);
		act->addDefaultInputMapping("F10");
		act->addDefaultInputMapping("JOY_UP");
		gameKeyMap->addAction(act);

		if (gameId == "simon2") {
			act = new Action("BACKGRNDSND", _("Toggle background sounds on/off"));
			act->setCustomEngineActionEvent(kActionToggleBackgroundSound);
			act->addDefaultInputMapping("b");
			gameKeyMap->addAction(act);
		}
	}

	if (gameId == "feeble") {
		// I18N: Characters are game actors
		act = new Action("SWTCHCHARACTER", _("Switch characters"));
		act->setCustomEngineActionEvent(kActionToggleSwitchCharacter);
		act->addDefaultInputMapping("F7");
		act->addDefaultInputMapping("JOY_X");
		gameKeyMap->addAction(act);

		act = new Action("TOGGLEHITBOX", _("Toggle hitbox names on/off"));
		act->setCustomEngineActionEvent(kActionToggleHitboxName);
		act->addDefaultInputMapping("F9");
		gameKeyMap->addAction(act);
	}

	if (gameId == "feeble" || gameId == "simon2") {
		act = new Action("TOGGLESUB", _("Switches between speech only and combined speech and subtitles"));
		act->setCustomEngineActionEvent(kActionToggleSubtitle);
		act->addDefaultInputMapping("t");
		act->addDefaultInputMapping("JOY_LEFT");
		gameKeyMap->addAction(act);

		act = new Action("TOGGLESPEECH", _("Switches between subtitles only and combined speech and subtitles"));
		act->setCustomEngineActionEvent(kActionToggleSpeech);
		act->addDefaultInputMapping("v");
		act->addDefaultInputMapping("JOY_RIGHT");
		gameKeyMap->addAction(act);
	}

	if (gameId == "swampy" ||
			gameId == "puzzle" ||
			gameId == "jumble") {
		act = new Action("HIGHSPEED", _("High speed mode on/off in Swampy Adventures"));
		act->setCustomEngineActionEvent(kActionSpeed_GTYPEPP);
		act->addDefaultInputMapping("F12");
		gameKeyMap->addAction(act);
	}

	act = new Action("KEYYES", _("Press \"Yes\" key"));
	act->setCustomEngineActionEvent(kActionKeyYes);
	act->addDefaultInputMapping("JOY_A");
	yesNoKeymap->addAction(act);

	act = new Action("KEYNO", _("Press \"No\" key"));
	act->setCustomEngineActionEvent(kActionKeyNo);
	act->addDefaultInputMapping("JOY_B");
	yesNoKeymap->addAction(act);

	KeymapArray keymaps(3);
	keymaps[0] = engineKeyMap;
	keymaps[1] = gameKeyMap;
	keymaps[2] = yesNoKeymap;

	yesNoKeymap->setEnabled(false);
	return keymaps;
}

#if PLUGIN_ENABLED_DYNAMIC(AGOS)
	REGISTER_PLUGIN_DYNAMIC(AGOS, PLUGIN_TYPE_ENGINE, AgosMetaEngine);
#else
	REGISTER_PLUGIN_STATIC(AGOS, PLUGIN_TYPE_ENGINE, AgosMetaEngine);
#endif

namespace AGOS {

int AGOSEngine::getGameId() const {
	return _gameDescription->gameId;
}

int AGOSEngine::getGameType() const {
	return _gameDescription->gameType;
}

uint32 AGOSEngine::getFeatures() const {
	return _gameDescription->features;
}

const char *AGOSEngine::getExtra() const {
	return _gameDescription->desc.extra;
}

Common::Language AGOSEngine::getLanguage() const {
	return _gameDescription->desc.language;
}

Common::Platform AGOSEngine::getPlatform() const {
	return _gameDescription->desc.platform;
}

const char *AGOSEngine::getFileName(int type) const {
	// Required if the InstallShield cab is been used
	if (getGameType() == GType_PP) {
		if (type == GAME_BASEFILE)
			return gss->base_filename;
	}

	// Required if the InstallShield cab is been used
	if (getGameType() == GType_FF && getPlatform() == Common::kPlatformWindows) {
		if (type == GAME_BASEFILE)
			return gss->base_filename;
		if (type == GAME_RESTFILE)
			return gss->restore_filename;
		if (type == GAME_TBLFILE)
			return gss->tbl_filename;
	}

	for (int i = 0; _gameDescription->desc.filesDescriptions[i].fileType; i++) {
		if (_gameDescription->desc.filesDescriptions[i].fileType == type)
			return _gameDescription->desc.filesDescriptions[i].fileName;
	}
	return nullptr;
}

#ifdef ENABLE_AGOS2
void AGOSEngine::loadArchives() {
	const ADGameFileDescription *ag;

	if (getFeatures() & GF_PACKED) {
		for (ag = _gameDescription->desc.filesDescriptions; ag->fileName; ag++) {
			if (ag->fileType != GAME_CABFILE)
				continue;

			if (!SearchMan.hasArchive(ag->fileName)) {
				// Assumes the cabinet file is named data1.cab
				Common::Archive *cabinet = Common::makeInstallShieldArchive("data");
				if (cabinet)
					SearchMan.add(ag->fileName, cabinet);
			}
		}
	}
}
#endif

} // End of namespace AGOS

================
File: midi.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/config-manager.h"
#include "common/file.h"
#include "common/textconsole.h"
#include "common/memstream.h"

#include "agos/agos.h"
#include "agos/midi.h"

#include "agos/midiparser_gmf.h"
#include "agos/midiparser_simonwin.h"

#include "agos/drivers/accolade/mididriver.h"
#include "agos/drivers/accolade/adlib.h"
#include "agos/drivers/accolade/cms.h"
#include "agos/drivers/accolade/mt32.h"
#include "agos/drivers/simon1/adlib.h"
// Miles Audio for Simon 2
#include "audio/miles.h"
#include "audio/midiparser.h"

// PKWARE data compression library decompressor required for Simon 2
#include "common/compression/dcl.h"
#include "common/translation.h"

#include "gui/message.h"
#include "agos/intern_detection.h"

namespace AGOS {

// MidiParser_S1D is not considered part of the standard
// MidiParser suite, but we still try to mask its details
// and just provide a factory function.
extern MidiParser *MidiParser_createS1D(uint8 source = 0, bool monophonicChords = false);

// This instrument remapping has been constructed by checking how the GM
// instruments correspond to MT-32 instruments in other tracks (f.e. track 10-3
// is similar to track 11).
const byte MidiPlayer::SIMON2_TRACK10_GM_MT32_INSTRUMENT_REMAPPING[] {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x1D, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x56, 0x53, 0x4B, 0x00, 0x4B, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

MidiPlayer::MidiPlayer(AGOSEngine *vm) {
	_vm = vm;
	_driver = nullptr;
	_driverMsMusic = nullptr;
	_driverMsSfx = nullptr;

	_paused = false;

	_queuedTrack = 255;
	_loopQueuedTrack = 0;

	_pc98 = false;
	_deviceType = MT_NULL;
	_dataType = MT_NULL;

	_parserMusic = nullptr;
	_parserSfx = nullptr;
	_musicData = nullptr;
	_sfxData = nullptr;
	_parserSfxAccolade = nullptr;
}

MidiPlayer::~MidiPlayer() {
	stop();
	stop(true);

	// Close the drivers first before locking the mutex. Otherwise a deadlock
	// can occur where the timer thread has locked the timer mutex while
	// waiting for the MidiPlayer mutex in the callback, while the main thread
	// has locked the MidiPlayer mutex and waits for the timer mutex to remove
	// a driver callback.
	if (_driverMsSfx && _driverMsSfx != _driverMsMusic) {
		_driverMsSfx->setTimerCallback(nullptr, nullptr);
		_driverMsSfx->close();
	}
	if (_driverMsMusic) {
		_driverMsMusic->setTimerCallback(nullptr, nullptr);
		_driverMsMusic->close();
	} else if (_driver) {
		_driver->setTimerCallback(nullptr, nullptr);
		_driver->close();
	}

	Common::StackLock lock(_mutex);

	if (_parserMusic)
		delete _parserMusic;
	if (_parserSfx)
		delete _parserSfx;
	if (_parserSfxAccolade)
		delete _parserSfxAccolade;

	if (_musicData)
		delete[] _musicData;
	if (_sfxData)
		delete[] _sfxData;

	if (_driverMsSfx && _driverMsSfx != _driverMsMusic) {
		delete _driverMsSfx;
		_driverMsSfx = nullptr;
	}
	if (_driverMsMusic) {
		delete _driverMsMusic;
		_driverMsMusic = nullptr;
	} else if (_driver) {
		delete _driver;
		_driver = nullptr;
	}
}

int MidiPlayer::open() {
	// Don't call open() twice!
	assert(!_driver);

	_pc98 = _vm->getGameType() == GType_ELVIRA1 && _vm->getPlatform() == Common::kPlatformPC98;
	// All games have MT-32 data, except Simon 2, which has both GM and MT-32
	// data for DOS, or only GM for Windows. Some of the GM tracks have extra
	// instruments compared to the MT-32 tracks, so GM is preferred.
	int devFlags = MDT_MIDI | (_pc98 ? MDT_PC98 : MDT_ADLIB) |
		(_vm->getGameType() == GType_SIMON2 ? MDT_PREFER_GM : MDT_PREFER_MT32);
	if (_vm->getGameType() == GType_ELVIRA1 && _vm->getPlatform() == Common::kPlatformDOS)
		// CMS is only supported by Elvira 1 DOS.
		devFlags |= MDT_CMS;

	// Check the type of device that the user has configured.
	MidiDriver::DeviceHandle dev = MidiDriver::detectDevice(devFlags);
	_deviceType = MidiDriver::getMusicType(dev);

	// Check if a Casio device has been configured for Elvira 1 DOS.
	if (_vm->getGameType() == GType_ELVIRA1 && _vm->getPlatform() == Common::kPlatformDOS &&
			_deviceType == MT_GM && ConfMan.hasKey("midi_mode")) {
		int midiMode = ConfMan.getInt("midi_mode");
		if (midiMode == 3) {
			_deviceType = MT_MT540;
		} else if (midiMode == 4) {
			_deviceType = MT_CT460;
		}
	}

	if (_deviceType == MT_GM && ConfMan.getBool("native_mt32"))
		_deviceType = MT_MT32;

	if (_vm->getGameType() == GType_SIMON2) {
		// Simon 2 DOS version has both MT-32 and GM tracks; Windows is GM only.
		_dataType = (_vm->getPlatform() == Common::kPlatformDOS && _deviceType == MT_MT32) ? MT_MT32 : MT_GM;
	} else {
		// All the other games' MIDI data targets MT-32 (even Simon 1 Windows
		// and Acorn).
		_dataType = MT_MT32;
	}

	// Check for MT-32 playback on a GM device and show a warning.
	// Elvira 1 PC-98xx driver remaps MT-32 instruments to GM like the
	// original driver does, so no warning needed in that case.
	if (_dataType == MT_MT32 && _deviceType == MT_GM && !_pc98) {
		// Not a real MT32 / no MUNT
		::GUI::MessageDialog dialog(_(
			"You appear to be using a General MIDI device,\n"
			"but your game only supports Roland MT32 MIDI.\n"
			"We try to map the Roland MT32 instruments to\n"
			"General MIDI ones. It is still possible that\n"
			"some tracks sound incorrect."));
		dialog.runModal();
	}

	// Elvira 2, Waxworks and Simon 1 DOS floppy have MIDI SFX.
	bool usesMidiSfx = _vm->getGameType() == GType_WW || _vm->getGameType() == GType_ELVIRA2 ||
		(_vm->getGameType() == GType_SIMON1 && _vm->getPlatform() == Common::kPlatformDOS &&
			!(_vm->getFeatures() & GF_DEMO) && !(_vm->getFeatures() & GF_TALKIE));

	// OPL3 is used for Windows and Acorn versions, all Simon 2 versions and
	// if the user has set the OPL3 mode option. Otherwise OPL2 is used.
	OPL::Config::OplType oplType =
		MidiDriver_ADLIB_Multisource::detectOplType(OPL::Config::kOpl3) ? OPL::Config::kOpl3 : OPL::Config::kOpl2;
	if (oplType == OPL::Config::kOpl3) {
		oplType = (_vm->getPlatform() != Common::kPlatformDOS ||
			_vm->getGameType() == GType_SIMON2 || ConfMan.getBool("opl3_mode")) ? OPL::Config::kOpl3 : OPL::Config::kOpl2;
	}

	// Create drivers and parsers for the different versions of the games.
	if ((_vm->getGameType() == GType_ELVIRA1 && _vm->getPlatform() == Common::kPlatformDOS) ||
			_vm->getGameType() == GType_ELVIRA2 || _vm->getGameType() == GType_WW ||
			(_vm->getGameType() == GType_SIMON1 && _vm->getPlatform() == Common::kPlatformDOS &&
				 (_vm->getFeatures() & GF_DEMO) && !(_vm->getFeatures() & GF_TALKIE))) {
		// Elvira 1 DOS, Elvira 2, Waxworks and Simon 1 DOS floppy demo

		// These games use drivers used by several Accolade games.
		// Elvira 1 DOS uses an older version of the Accolade drivers which
		// uses different files.
		Common::String accoladeDriverFilename = _vm->getGameType() == GType_ELVIRA1 ? "INSTR.DAT" : "MUSIC.DRV";

		switch (_deviceType) {
		case MT_ADLIB:
			if (usesMidiSfx) {
				// Elvira 2 and Waxworks have AdLib SFX.
				_parserSfxAccolade = new SfxParser_Accolade_AdLib();
				// Sync the driver to the AdLib SFX script timer.
				_driverMsMusic = _driverMsSfx = MidiDriver_Accolade_AdLib_create(accoladeDriverFilename, oplType, SfxParser_Accolade::SCRIPT_TIMER_FREQUENCY);
			} else {
				_driverMsMusic = _driverMsSfx = MidiDriver_Accolade_AdLib_create(accoladeDriverFilename, oplType);
			}
			if (_vm->getGameType() == GType_ELVIRA1 && oplType == OPL::Config::kOpl3)
				// WORKAROUND Some Elvira 1 OPL instruments do not work
				// well in OPL3 mode and need some adjustments.
				static_cast<MidiDriver_Accolade_AdLib *>(_driverMsMusic)->patchE1Instruments();
			if (_vm->getGameType() == GType_WW) {
				// WORKAROUND Some Waxworks tracks do not set an instrument on
				// a MIDI channel. This will cause that channel to play with
				// whatever instrument was set there by a previous track.
				// This is fixed by setting default instruments on all channels
				// before starting a track.
				_driverMsMusic->setControllerDefault(MidiDriver_Multisource::CONTROLLER_DEFAULT_PROGRAM);
				if (oplType == OPL::Config::kOpl3)
					// WORKAROUND Some Waxworks OPL instruments do not work
					// well in OPL3 mode and need some adjustments.
					static_cast<MidiDriver_Accolade_AdLib *>(_driverMsMusic)->patchWwInstruments();
			}
			break;
		case MT_MT32:
		case MT_GM:
			_driverMsMusic = MidiDriver_Accolade_MT32_create(accoladeDriverFilename);
			if (_vm->getGameType() == GType_WW) {
				// WORKAROUND See above.
				int16 defaultInstruments[16];
				Common::fill(defaultInstruments, defaultInstruments + ARRAYSIZE(defaultInstruments), -1);
				Common::copy(MidiDriver_MT32GM::MT32_DEFAULT_INSTRUMENTS, MidiDriver_MT32GM::MT32_DEFAULT_INSTRUMENTS + ARRAYSIZE(MidiDriver_MT32GM::MT32_DEFAULT_INSTRUMENTS), defaultInstruments + 1);
				_driverMsMusic->setControllerDefaults(MidiDriver_Multisource::CONTROLLER_DEFAULT_PROGRAM, defaultInstruments);
			}
			if (usesMidiSfx) {
				if (ConfMan.getBool("multi_midi")) {
					// Use AdLib SFX with MT-32 music.
					_driverMsSfx = MidiDriver_Accolade_AdLib_create(accoladeDriverFilename, oplType, SfxParser_Accolade::SCRIPT_TIMER_FREQUENCY);
					_parserSfxAccolade = new SfxParser_Accolade_AdLib();
				} else {
					// Use MT-32 SFX.
					_driverMsSfx = _driverMsMusic;
					_parserSfxAccolade = new SfxParser_Accolade_MT32();
				}
			}
			break;
		case MT_MT540:
		case MT_CT460:
			// Casio devices are supported by Elvira 1 DOS only.
			_driverMsMusic = MidiDriver_Accolade_Casio_create(accoladeDriverFilename);
			break;
		case MT_CMS:
			// CMS is supported by Elvira 1 DOS only.
			if (_vm->getGameType() == GType_ELVIRA1 && _vm->getPlatform() == Common::kPlatformDOS) {
				_driver = new MidiDriver_Accolade_Cms();
				break;
			}
			// fall through
		default:
			_driverMsMusic = new MidiDriver_NULL_Multisource();
			break;
		}
		if (!_driver)
			_driver = _driverMsMusic;

		// These games use the MUS MIDI format used by several Accolade games.
		// The Elvira 2 / Waxworks version of the AdLib driver has a mechanism
		// that will only play the highest note of a chord; the Elvira 1
		// version does not have this.
		_parserMusic = MidiParser_createS1D(0, _vm->getGameType() != GType_ELVIRA1 && _deviceType == MT_ADLIB);
	} else if (_vm->getGameType() == GType_ELVIRA1 && _vm->getPlatform() == Common::kPlatformPC98) {
		// Elvira 1 PC-98

		// This version has its own drivers. It uses the same MUS format as the
		// DOS version.
		_driver = MidiDriverPC98_create(dev);
		_parserMusic = MidiParser_createS1D(0);
	} else if (_vm->getGameType() == GType_SIMON1) {
		// Simon 1 (except the DOS floppy demo)

		// The DOS versions have their own drivers. The Windows version uses
		// the standard Windows drivers.
		switch (_deviceType) {
		case MT_ADLIB:
			if (_vm->getPlatform() == Common::kPlatformDOS) {
				// The DOS version AdLib driver uses an instrument bank file.
				if (Common::File::exists("MT_FM.IBK")) {
					_driverMsMusic = createMidiDriverSimon1AdLib("MT_FM.IBK", oplType);
				} else {
					// Fallback in case AdLib instrument definitions are missing.
					GUI::MessageDialog dialog(
						Common::U32String::format(
							_("Could not find AdLib instrument definition file\n"
							  "%s. Without this file,\n"
							  "the music will not sound the same as the original game."),
							"MT_FM.IBK"),
						_("OK"));
					dialog.runModal();

					_driverMsMusic = new MidiDriver_ADLIB_Multisource(oplType);
					_driverMsMusic->setInstrumentRemapping(MidiDriver::_mt32ToGm);
				}
				if (!(_vm->getFeatures() & GF_TALKIE)) {
					// The DOS floppy version has AdLib MIDI SFX.
					_driverMsSfx = _driverMsMusic;
				}
			} else {
				// Windows and Acorn CD
				// TODO Acorn does not use an OPL chip, but ScummVM doesn't
				// have an implementation of the Acorn audio. It has the same
				// music data as the DOS CD version, but it does not have
				// the MT_FM.IBK instrument bank, so the standard AdLib MIDI
				// driver is used.
				_driverMsMusic = new MidiDriver_ADLIB_Multisource(oplType);
				// WORKAROUND These versions have the same music data as the
				// DOS versions, which target MT-32, despite Windows using GM
				// as its MIDI format. To fix this, the MT-32 instruments are
				// remapped to corresponding GM instruments.
				_driverMsMusic->setInstrumentRemapping(MidiDriver::_mt32ToGm);
			}

			// WORKAROUND The Simon 1 MIDI data does not always set a value for
			// program before it starts playing notes on a MIDI channel. This
			// can cause instruments from a previous track to be used
			// unintentionally.
			// To correct this, default instruments are set when a new track is
			// started.
			_driverMsMusic->setControllerDefault(MidiDriver_Multisource::CONTROLLER_DEFAULT_PROGRAM);

			break;
		case MT_MT32:
		case MT_GM:
			_driverMsMusic = new MidiDriver_MT32GM(_dataType);

			// WORKAROUND See above.
			int16 defaultInstruments[16];
			Common::fill(defaultInstruments, defaultInstruments + ARRAYSIZE(defaultInstruments), -1);
			Common::copy(MidiDriver_MT32GM::MT32_DEFAULT_INSTRUMENTS, MidiDriver_MT32GM::MT32_DEFAULT_INSTRUMENTS + ARRAYSIZE(MidiDriver_MT32GM::MT32_DEFAULT_INSTRUMENTS), defaultInstruments + 1);
			_driverMsMusic->setControllerDefaults(MidiDriver_Multisource::CONTROLLER_DEFAULT_PROGRAM, defaultInstruments);

			if (_vm->getPlatform() == Common::kPlatformDOS && !(_vm->getFeatures() & GF_TALKIE) &&
					ConfMan.getBool("multi_midi")) {
				// The DOS floppy version can use AdLib MIDI SFX with MT-32
				// music.
				if (Common::File::exists("MT_FM.IBK")) {
					_driverMsSfx = createMidiDriverSimon1AdLib("MT_FM.IBK", oplType);
				} else {
					// Fallback in case AdLib instrument definitions are missing.
					GUI::MessageDialog dialog(
						Common::U32String::format(
							_("Could not find AdLib instrument definition file\n"
							  "%s. Without this file,\n"
							  "the sound effects will not sound the same as the original game."),
							"MT_FM.IBK"),
						_("OK"));
					dialog.runModal();

					_driverMsSfx = new MidiDriver_ADLIB_Multisource(oplType);
					_driverMsSfx->setInstrumentRemapping(MidiDriver::_mt32ToGm);
				}
			}

			break;
		default:
			_driverMsMusic = new MidiDriver_NULL_Multisource();
			break;
		}
		_driver = _driverMsMusic;

		// WORKAROUND The Simon 1 MIDI data does not always set a value for
		// volume or panning before it starts playing notes on a MIDI channel.
		// This can cause settings for these parameters from a previous track
		// to be used unintentionally. To correct this, default values for
		// these parameters are set when a new track is started.
		_driverMsMusic->setControllerDefault(MidiDriver_Multisource::CONTROLLER_DEFAULT_VOLUME);
		_driverMsMusic->setControllerDefault(MidiDriver_Multisource::CONTROLLER_DEFAULT_PANNING);

		// The Windows version uses music tempos which are noticeably faster
		// than those used by the DOS versions. The MIDI parsers can be
		// configured to use one of both tempos. The DOS tempos will be used
		// for the DOS versions or if the user has selected the "Use DOS music
		// tempos" option. Otherwise the Windows tempos will be used.
		bool useDosTempos = ConfMan.hasKey("dos_music_tempos") ? ConfMan.getBool("dos_music_tempos") : _vm->getPlatform() == Common::kPlatformDOS;

		// Create the MIDI parser(s) for the format used by the platform.
		if (_vm->getPlatform() == Common::kPlatformWindows) {
			// The Windows version uses a slightly different SMF variant.
			_parserMusic = new MidiParser_SimonWin(0, useDosTempos);
		} else {
			// DOS floppy & CD and Acorn CD use GMF (also an SMF variant).
			_parserMusic = new MidiParser_GMF(0, useDosTempos);

			if (_driverMsSfx) {
				// DOS floppy needs a second GMF parser for AdLib SFX.
				_parserSfx = new MidiParser_GMF(1, true);
				_parserMusic->property(MidiParser::mpDisableAllNotesOffMidiEvents, true);
				_parserSfx->property(MidiParser::mpDisableAllNotesOffMidiEvents, true);
				_parserSfx->property(MidiParser::mpDisableAutoStartPlayback, true);
			}
		}
	} else if (_vm->getGameType() == GType_SIMON2) {
		// Simon 2

		// The DOS version uses MIDPAK, which is similar to Miles AIL v2.
		// The Windows version uses the standard Windows drivers.
		switch (_deviceType) {
		case MT_ADLIB:
			if (_vm->getPlatform() == Common::kPlatformDOS) {
				// DOS
				if (Common::File::exists("MIDPAK.AD")) {
					// if there is a file called MIDPAK.AD, use it directly
					warning("MidiPlayer::open - SIMON 2: using MIDPAK.AD");
					_driverMsMusic = Audio::MidiDriver_Miles_AdLib_create("MIDPAK.AD", "");
				} else if (Common::File::exists("SETUP.SHR")) {
					// if there is no file called MIDPAK.AD, try to extract it from the file SETUP.SHR
					// if we didn't do this, the user would be forced to "install" the game instead of simply
					// copying all files from CD-ROM.
					Common::SeekableReadStream *midpakAdLibStream = simon2SetupExtractFile("MIDPAK.AD");
					if (!midpakAdLibStream)
						error("MidiPlayer::open - Could not extract MIDPAK.AD from SETUP.SHR");

					// Pass this extracted data to the driver
					warning("MidiPlayer::open - SIMON 2: using MIDPAK.AD extracted from SETUP.SHR");
					_driverMsMusic = Audio::MidiDriver_Miles_AdLib_create("", "", midpakAdLibStream);
					delete midpakAdLibStream;
				} else {
					// Fallback in case AdLib instrument definitions are missing.
					GUI::MessageDialog dialog(
						Common::U32String::format(
							_("Could not find AdLib instrument definition file\n"
							  "%s or %s. Without one of these files,\n"
							  "the music will not sound the same as the original game."),
							"MIDPAK.AD", "SETUP.SHR"),
						_("OK"));
					dialog.runModal();

					_driverMsMusic = new MidiDriver_ADLIB_Multisource(oplType);
				}
			} else {
				// Windows
				_driverMsMusic = new MidiDriver_ADLIB_Multisource(oplType);
			}
			break;
		case MT_MT32:
		case MT_GM:
			if (_vm->getPlatform() == Common::kPlatformDOS) {
				// DOS
				_driverMsMusic = Audio::MidiDriver_Miles_MIDI_create(_dataType, "");
			} else {
				// Windows
				_driverMsMusic = new MidiDriver_MT32GM(_dataType);
			}
			break;
		default:
			_driverMsMusic = new MidiDriver_NULL_Multisource();
			break;
		}
		_driver = _driverMsMusic;

		// Create the MIDI parser(s) for the format used by the platform.
		if (_vm->getPlatform() == Common::kPlatformDOS || (usesMT32Data() && (_vm->getFeatures() & GF_MT32_XMIDI))) {
			// DOS uses Miles XMIDI.
			_parserMusic = MidiParser::createParser_XMIDI(MidiParser::defaultXMidiCallback, 0, 0);
		} else {
			// Windows version uses an SMF variant (same as Simon 1 Windows).
			_parserMusic = new MidiParser_SimonWin(0);
		}
	}

	// Set common properties for the drivers and music parser.
	if (_driverMsMusic)
		_driverMsMusic->property(MidiDriver::PROP_USER_VOLUME_SCALING, true);
	if (_driverMsSfx && _driverMsSfx != _driverMsMusic)
		_driverMsSfx->property(MidiDriver::PROP_USER_VOLUME_SCALING, true);

	_parserMusic->property(MidiParser::mpDisableAutoStartPlayback, true);

	// Open the MIDI driver(s).
	int returnCode = _driver->open();
	if (returnCode != 0)
		error("MidiPlayer::open - Failed to open MIDI music driver - error code %d.", returnCode);
	if (_driverMsSfx && _driverMsSfx != _driverMsMusic) {
		returnCode = _driverMsSfx->open();
		if (returnCode != 0)
			error("MidiPlayer::open - Failed to open MIDI SFX driver - error code %d.", returnCode);
	}

	syncSoundSettings();

	// Connect the driver(s) and the parser(s).
	_parserMusic->setMidiDriver(_driver);
	_parserMusic->setTimerRate(_driver->getBaseTempo());
	if (_parserSfx) {
		_parserSfx->setMidiDriver(_driverMsSfx);
	} else if (_parserSfxAccolade) {
		_parserSfxAccolade->setMidiDriver(_driverMsSfx);
	}

	// Use MidiPlayer::onTimer to trigger both parsers.
	_driver->setTimerCallback(this, &onTimer);
	if (_parserSfx) {
		_parserSfx->setTimerRate(_driver->getBaseTempo());
	} else if (_parserSfxAccolade) {
		_parserSfxAccolade->setTimerRate(_driver->getBaseTempo());
	}

	return 0;
}

void MidiPlayer::onTimer(void *data) {
	MidiPlayer *p = (MidiPlayer *)data;
	Common::StackLock lock(p->_mutex);

	if (p->_parserMusic) {
		p->_parserMusic->onTimer();
		if (!p->_parserMusic->isPlaying() && p->_queuedTrack != 255) {
			// Music is no longer playing and there is a track queued up.
			// Play the queued track.
			p->setLoop(p->_loopQueuedTrack);
			p->play(p->_queuedTrack, false, false, true);
			p->_queuedTrack = 255;
			p->_loopQueuedTrack = false;
		}
	}
	if (p->_parserSfx)
		p->_parserSfx->onTimer();

	if (p->_parserSfxAccolade)
		p->_parserSfxAccolade->onTimer();
}

bool MidiPlayer::usesMT32Data() const {
	return _dataType == MT_MT32;
}

bool MidiPlayer::hasMidiSfx() const {
	return _parserSfx != nullptr || _parserSfxAccolade != nullptr;
}

bool MidiPlayer::isPlaying(bool checkQueued) {
	Common::StackLock lock(_mutex);

	return _parserMusic->isPlaying() && (!checkQueued || _queuedTrack != 255);
}

void MidiPlayer::stop(bool sfx) {
	Common::StackLock lock(_mutex);

	if (!sfx) {
		// Clear the queued track to prevent it from starting when the current
		// track is stopped.
		_queuedTrack = 255;

		if (_parserMusic) {
			_parserMusic->stopPlaying();
			if (_driverMsMusic)
				_driverMsMusic->deinitSource(0);
		}
	} else {
		if (_parserSfx) {
			_parserSfx->stopPlaying();
			if (_driverMsSfx)
				_driverMsSfx->deinitSource(1);
		}
		if (_parserSfxAccolade) {
			_parserSfxAccolade->stopAll();
		}
	}
}

void MidiPlayer::pause(bool b) {
	if (_paused == b || !_driver)
		return;

	_paused = b;

	Common::StackLock lock(_mutex);

	if (_paused) {
		if (_parserMusic)
			_parserMusic->pausePlaying();
		if (_parserSfx)
			_parserSfx->pausePlaying();
	} else {
		if (_parserMusic)
			_parserMusic->resumePlaying();
		if (_parserSfx)
			_parserSfx->resumePlaying();
	}
	if (_parserSfxAccolade)
		_parserSfxAccolade->pauseAll(_paused);
}

void MidiPlayer::fadeOut() {
	Common::StackLock lock(_mutex);

	if (!_parserMusic->isPlaying())
		return;

	// 1 second fade-out to silence.
	_driverMsMusic->startFade(0, 1000, 0);
}

void MidiPlayer::syncSoundSettings() {
	if (_driverMsMusic)
		_driverMsMusic->syncSoundSettings();
	if (_driverMsSfx)
		_driverMsSfx->syncSoundSettings();

	if (_pc98) {
		// Sync code for non-multisource drivers.
		bool mute = false;
		if (ConfMan.hasKey("mute"))
			mute = ConfMan.getBool("mute");

		// Sync the engine with the config manager
		int soundVolumeMusic = ConfMan.getInt("music_volume");
		int soundVolumeSFX = ConfMan.getInt("sfx_volume");

		_driver->property(0x10, mute ? 0 : soundVolumeMusic);
		_driver->property(0x20, mute ? 0 : soundVolumeSFX);
	}
}

void MidiPlayer::setLoop(bool loop) {
	Common::StackLock lock(_mutex);

	if (_parserMusic)
		_parserMusic->property(MidiParser::mpAutoLoop, loop);
}

void MidiPlayer::setSimon2Remapping(bool remap) {
	if (_driverMsMusic)
		_driverMsMusic->setInstrumentRemapping(remap ? SIMON2_TRACK10_GM_MT32_INSTRUMENT_REMAPPING : nullptr);
}

void MidiPlayer::queueTrack(int track, bool loop) {
	Common::StackLock lock(_mutex);

	if (!_parserMusic->isPlaying()) {
		// There is no music playing right now, so immediately play the track.
		setLoop(loop);
		play(track);
	} else {
		// Queue up the track for playback at the end of the current track.
		_queuedTrack = track;
		_loopQueuedTrack = loop;
	}
}

void MidiPlayer::load(Common::SeekableReadStream *in, int32 size, bool sfx) {
	Common::StackLock lock(_mutex);

	if (sfx && _parserSfxAccolade) {
		_parserSfxAccolade->load(in, size);
		return;
	}

	MidiParser *parser = sfx ? _parserSfx : _parserMusic;
	if (!parser)
		return;

	if (size < 0) {
		// Use the parser to determine the size of the MIDI data.
		int64 startPos = in->pos();
		size = parser->determineDataSize(in);
		if (size < 0) {
			warning("MidiPlayer::load - Could not determine size of music data");
			return;
		}
		// determineDataSize might move the stream position, so return it to
		// the original position.
		in->seek(startPos);
	}

	parser->unloadMusic();

	// Copy the data into _musicData or _sfxData.
	byte **dataPtr = sfx ? &_sfxData : &_musicData;
	if (*dataPtr) {
		delete[] *dataPtr;
	}

	*dataPtr = new byte[size];
	in->read(*dataPtr, size);

	// Finally, load the data into the parser.
	parser->loadMusic(*dataPtr, size);
}

void MidiPlayer::play(int track, bool sfx, bool sfxUsesRhythm, bool queued) {
	Common::StackLock lock(_mutex);

	if (sfx && _parserSfxAccolade) {
		_parserSfxAccolade->play(track);
		return;
	}

	MidiParser *parser = sfx ? _parserSfx : _parserMusic;
	if (!parser)
		return;

	if (parser->setTrack(track)) {
		if (sfx && sfxUsesRhythm) {
			// This sound effect uses OPL rhythm instruments. Disable music
			// rhythm notes while this sound effect is playing to prevent
			// conflicts.
			// Note that if AdLib music is used, _driverMsMusic and
			// _driverMsSfx point to the same object. If AdLib music is not
			// used, the disableMusicRhythmNotes call will do nothing.
			MidiDriver_Simon1_AdLib *adLibSfxDriver = dynamic_cast<MidiDriver_Simon1_AdLib *>(_driverMsSfx);
			if (adLibSfxDriver)
				adLibSfxDriver->disableMusicRhythmNotes();
		}

		if (!sfx && !queued && _driverMsMusic)
			// Reset the volume to neutral (in case the previous track was
			// faded out).
			_driverMsMusic->resetSourceVolume(0);
		parser->startPlaying();
	} else {
		// Original interpreter stops playing when an invalid track is
		// requested (f.e. Simon 2 MT-32 intro).
		parser->stopPlaying();
		warning("MidiPlayer::play - Could not play %s track %i", sfx ? "SFX" : "music", track);
	}
}

#define MIDI_SETUP_BUNDLE_HEADER_SIZE 56
#define MIDI_SETUP_BUNDLE_FILEHEADER_SIZE 48
#define MIDI_SETUP_BUNDLE_FILENAME_MAX_SIZE 12

// PKWARE data compression library (called "DCL" in ScummVM) was used for storing files within SETUP.SHR
// we need it to be able to get the file MIDPAK.AD, otherwise we would have to require the user
// to "install" the game before being able to actually play it, when using AdLib.
//
// SETUP.SHR file format:
//  [bundle file header]
//    [compressed file header] [compressed file data]
//     * compressed file count
Common::SeekableReadStream *MidiPlayer::simon2SetupExtractFile(const Common::String &requestedFileName) {
	Common::File *setupBundleStream = new Common::File();
	uint32        bundleSize = 0;
	uint32        bundleBytesLeft = 0;
	byte          bundleHeader[MIDI_SETUP_BUNDLE_HEADER_SIZE];
	byte          bundleFileHeader[MIDI_SETUP_BUNDLE_FILEHEADER_SIZE];
	uint16        bundleFileCount = 0;
	uint16        bundleFileNr = 0;

	Common::String fileName;
	uint32         fileCompressedSize = 0;
	byte          *fileCompressedDataPtr = nullptr;

	Common::SeekableReadStream *extractedStream = nullptr;

	if (!setupBundleStream->open("setup.shr"))
		error("MidiPlayer: could not open setup.shr");

	bundleSize = setupBundleStream->size();
	bundleBytesLeft = bundleSize;

	if (bundleSize < MIDI_SETUP_BUNDLE_HEADER_SIZE)
		error("MidiPlayer: unexpected EOF in setup.shr");

	if (setupBundleStream->read(bundleHeader, MIDI_SETUP_BUNDLE_HEADER_SIZE) != MIDI_SETUP_BUNDLE_HEADER_SIZE)
		error("MidiPlayer: setup.shr read error");
	bundleBytesLeft -= MIDI_SETUP_BUNDLE_HEADER_SIZE;

	// Verify header byte
	if (bundleHeader[13] != 't')
		error("MidiPlayer: setup.shr bundle header data mismatch");

	bundleFileCount = READ_LE_UINT16(&bundleHeader[14]);

	// Search for requested file
	while (bundleFileNr < bundleFileCount) {
		if (bundleBytesLeft < sizeof(bundleFileHeader))
			error("MidiPlayer: unexpected EOF in setup.shr");

		if (setupBundleStream->read(bundleFileHeader, sizeof(bundleFileHeader)) != sizeof(bundleFileHeader))
			error("MidiPlayer: setup.shr read error");
		bundleBytesLeft -= MIDI_SETUP_BUNDLE_FILEHEADER_SIZE;

		// Extract filename from file-header
		fileName.clear();
		for (byte curPos = 0; curPos < MIDI_SETUP_BUNDLE_FILENAME_MAX_SIZE; curPos++) {
			if (!bundleFileHeader[curPos]) // terminating NUL
				break;
			fileName.insertChar(bundleFileHeader[curPos], curPos);
		}

		// Get compressed
		fileCompressedSize = READ_LE_UINT32(&bundleFileHeader[20]);
		if (!fileCompressedSize)
			error("MidiPlayer: compressed file is 0 bytes, data corruption?");
		if (bundleBytesLeft < fileCompressedSize)
			error("MidiPlayer: unexpected EOF in setup.shr");

		if (fileName == requestedFileName) {
			// requested file found
			fileCompressedDataPtr = new byte[fileCompressedSize];

			if (setupBundleStream->read(fileCompressedDataPtr, fileCompressedSize) != fileCompressedSize)
				error("MidiPlayer: setup.shr read error");

			Common::MemoryReadStream *compressedStream = nullptr;

			compressedStream = new Common::MemoryReadStream(fileCompressedDataPtr, fileCompressedSize);
			// we don't know the unpacked size, let decompressor figure it out
			extractedStream = Common::decompressDCL(compressedStream);
			delete compressedStream;
			break;
		}

		// skip compressed size
		setupBundleStream->skip(fileCompressedSize);
		bundleBytesLeft -= fileCompressedSize;

		bundleFileNr++;
	}
	setupBundleStream->close();
	delete setupBundleStream;

	return extractedStream;
}

} // End of namespace AGOS

================
File: midi.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_MIDI_H
#define AGOS_MIDI_H

#include "agos/sfxparser_accolade.h"

#include "audio/mididrv.h"
#include "audio/mididrv_ms.h"
#include "audio/midiparser.h"
#include "common/mutex.h"

namespace Common {
class File;
}

namespace AGOS {

class MidiPlayer {
protected:
	// Instrument map specifically for remapping the instruments of the GM
	// version of Simon 2 track 10 subtracks 2 and 3 to MT-32.
	static const byte SIMON2_TRACK10_GM_MT32_INSTRUMENT_REMAPPING[];

	AGOSEngine *_vm;

	Common::Mutex _mutex;
	// Driver used for music. This points to the same object as _driverMsMusic,
	// except if a PC-98 driver is used (these do not implement the Multisource
	// interface).
	MidiDriver *_driver;
	// Multisource driver used for music. Provides access to multisource
	// methods without casting. If this is not nullptr, it points to the same
	// object as _driver.
	MidiDriver_Multisource *_driverMsMusic;
	// Multisource driver used for sound effects. Only used for Elvira 2,
	// Waxworks and Simon The Sorcerer DOS floppy AdLib sound effects.
	// If AdLib is also used for music, this points to the same object as
	// _driverMsMusic and _driver.
	MidiDriver_Multisource *_driverMsSfx;

	// MIDI parser and data used for music.
	MidiParser *_parserMusic;
	byte *_musicData;
	// MIDI parser and data used for SFX (Simon 1 DOS floppy).
	MidiParser *_parserSfx;
	byte *_sfxData;
	// Parser used for SFX (Elvira 2 and Waxworks DOS).
	SfxParser_Accolade *_parserSfxAccolade;

	bool _paused;

	// Queued music track data (Simon 2).
	byte _queuedTrack;
	bool _loopQueuedTrack;

protected:
	static void onTimer(void *data);

public:
	MidiPlayer(AGOSEngine *vm);
	~MidiPlayer();

	// Creates and opens the relevant parsers and drivers for the game version
	// and selected sound device.
	int open();

	// Loads music or SFX data supported by the MidiParser or SfxParser used
	// for the detected version of the game. Specify sfx to indicate that this
	// is a synthesized sound effect.
	void load(Common::SeekableReadStream *in, int32 size = -1, bool sfx = false);

	/**
	 * Plays the currently loaded music or SFX data. If the loaded data has
	 * multiple tracks, specify track to select the track to play.
	 * 
	 * @param track The track to play. Default 0.
	 * @param sfx True if the SFX data should be played, otherwise the loaded
	 * music data will be played. Default false.
	 * @param sfxUsesRhythm True if the sound effect uses OPL rhythm
	 * instruments. Default false.
	 * @param queued True if this track was queued; false if it was played
	 * directly. Default false.
	 */
	void play(int track = 0, bool sfx = false, bool sfxUsesRhythm = false, bool queued = false);
	
	// Returns true if the playback device uses MT-32 MIDI data; false it it
	// uses a different data type.
	bool usesMT32Data() const;
	// Returns true if the game version and selected sound device can use MIDI
	// (or synthesized) sound effects.
	bool hasMidiSfx() const;
	void setLoop(bool loop);
	// Activates or deactivates remapping GM to MT-32 instruments for
	// Simon 2 track 10.
	void setSimon2Remapping(bool remap);
	void queueTrack(int track, bool loop);
	bool isPlaying(bool checkQueued = false);

	void stop(bool sfx = false);
	void pause(bool b);
	void fadeOut();

	void syncSoundSettings();

private:
	bool _pc98;
	// The type of the music device selected for playback.
	MusicType _deviceType;
	// The type of the MIDI data of the game (MT-32 or GM).
	MusicType _dataType;

private:
	Common::SeekableReadStream *simon2SetupExtractFile(const Common::String &requestedFileName);
};

} // End of namespace AGOS

#endif

================
File: midiparser_gmf.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "agos/midiparser_gmf.h"

#include "audio/mididrv.h"

namespace AGOS {

MidiParser_GMF::MidiParser_GMF(int8 source, bool useDosTempos) : MidiParser_SMF(source), _useDosTempos(useDosTempos) {
	memset(_tracksEndPos, 0, sizeof(_tracksEndPos));
}

void MidiParser_GMF::parseNextEvent(EventInfo &info) {
	byte *parsePos = _position._subtracks[0]._playPos;
	uint8 *start = parsePos;
	uint32 delta = readVLQ(parsePos);

	// GMF does not use end of track events, so we have to use the size of the
	// MIDI data to determine if we're at the end of the track.

	// Simon 1 CD version data has several zero bytes at the end.
	// Check for these and ignore them.
	bool containsMoreData = true;
	if (parsePos > _tracksEndPos[_activeTrack] - 5) {
		containsMoreData = false;
		byte *checkPos = parsePos;
		while (checkPos < _tracksEndPos[_activeTrack]) {
			if (*checkPos != 0) {
				containsMoreData = true;
				break;
			}
			checkPos++;
		}
		// If we're already past the end of the track, the while loop will not
		// execute and containsMoreData remains false.
	}

	if (!containsMoreData) {
		// Reached the end of the track. Generate an end-of-track event.
		info.start = start;
		info.delta = delta;
		info.event = 0xFF;
		info.ext.type = MidiDriver::MIDI_META_END_OF_TRACK;
		info.length = 0;
		info.ext.data = parsePos;
		info.noop = false;

		_position._subtracks[0]._playPos = parsePos;
		return;
	}

	// There are more MIDI events in this track.
	uint8 event = *(parsePos++);

	// Pitch bend events in the Simon 1 data are broken. They contain just the
	// command byte; no data bytes follow. We generate an empty event and set
	// the noop flag to have MidiParser process only the delta and otherwise
	// ignore the event.
	if ((event & 0xF0) == MidiDriver::MIDI_COMMAND_PITCH_BEND) {
		info.start = start;
		info.delta = delta;
		info.event = event;
		info.basic.param1 = 0;
		info.basic.param2 = 0;
		info.length = 0;
		info.noop = true;

		_position._subtracks[0]._playPos = parsePos;
	} else {
		// Processing of the other events is the same as the SMF format.
		info.noop = false;
		MidiParser_SMF::parseNextEvent(info);
	}
}

bool MidiParser_GMF::loadMusic(byte *data, uint32 size) {
	assert(size > 7);

	unloadMusic();

	// Determine start and end of the MIDI track(s) in the data, as well as
	// tempo and loop flag.
	uint8 headerTempo;
	bool headerLoop;

	// Simon 1 uses two GMF variants: a single track music file and a multiple
	// track SFX file. These are processed as a MIDI type 0 and type 2 track,
	// respectively.
	if (!memcmp(data, "GMF", 3)) {
		// Single track file.
		_numTracks = 1;

		// GMF header is GMF<majorVersion><minorVersion><tempo><loop>.
		// Version is always 1.0 for Simon 1.
		headerTempo = data[5];
		headerLoop = data[6] == 1;

		// MIDI track data starts immediately after the GMF header.
		_tracks[0][0] = data + 7;
		_tracksEndPos[0] = data + size;
	} else {
		// Assume multi-track file.

		// Each track has its own GMF header, but tempo and loop flags are all
		// the same for Simon 1.
		headerTempo = 2;
		headerLoop = false;

		// A multi-track file starts with a list of 2-byte offsets which
		// identify the starting position of each track, as well as the end of
		// the last track.
		byte *pos = data;
		// Read the start offset of the first track.
		byte *trackStart = data + READ_LE_UINT16(pos);
		pos += 2;
		// The number of offsets before the first track indicates the number of
		// tracks plus 1 because the end offset of the last track is included
		// as well.
		_numTracks = (*trackStart / 2) - 1;

		if (_numTracks > ARRAYSIZE(_tracks)) {
			warning("MidiParser_GMF::loadMusic - Can only handle %d tracks but was handed %d", (int)ARRAYSIZE(_tracks), (int)_numTracks);
			return false;
		}

		// Read all the track start offsets.
		int tracksRead = 0;
		while (tracksRead < _numTracks) {
			_tracks[tracksRead][0] = trackStart + 7; // Skip 7-byte GMF header
			trackStart = data + READ_LE_UINT16(pos);
			pos += 2;
			// Start of the next track is the end of this track.
			_tracksEndPos[tracksRead] = trackStart;
			_numSubtracks[tracksRead] = 1;

			tracksRead++;
		}
	}

	// Note that we assume the original data passed in
	// will persist beyond this call, i.e. we do NOT
	// copy the data to our own buffer. Take warning....
	_disableAutoStartPlayback = true;
	resetTracking();
	_autoLoop = headerLoop;
	_ppqn = 192;

	uint32 tempo;
	if (_useDosTempos) {
		// These translations from the GMF header tempo (2-8) to the SMF tempo have
		// been determined by measuring the tempos generated by the DOS version of
		// Simon 1 in DOSBox.
		if (headerTempo < 6) {
			tempo = 330000 + ((headerTempo - 2) * 105000);
		} else {
			tempo = 750000 + ((headerTempo - 6) * 125000);
		}
	} else {
		// These are the tempos as specified in the Windows version SMF data.
		tempo = headerTempo * 125000;
	}
	setTempo(tempo);

	setTrack(0);
	return true;
}

} // End of namespace AGOS

================
File: midiparser_gmf.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_MIDIPARSER_GMF_H
#define AGOS_MIDIPARSER_GMF_H

#include "audio/midiparser_smf.h"

namespace AGOS {

/**
 * MIDI parser for the GMF format used by the DOS (and Acorn CD) versions of
 * Simon The Sorcerer. GMF is basically SMF but with the following differences:
 * - Different header
 * - Tempo is determined by a header field
 * - Just a single track with no track header
 * - No end of track or other meta events
 */
class MidiParser_GMF : public MidiParser_SMF {
public:
	MidiParser_GMF(int8 source = -1, bool useDosTempos = false);

	bool loadMusic(byte *data, uint32 size) override;

protected:
	void parseNextEvent(EventInfo &info) override;

	// The end position of each track, exclusive
	// (i.e. 1 byte past the end of the data).
	byte *_tracksEndPos[MAXIMUM_TRACKS];

	// True if the music tempos from the DOS version should be used; false if
	// the tempos from the Windows version should be used.
	bool _useDosTempos;
};

} // End of namespace AGOS

#endif

================
File: midiparser_s1d.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/debug.h"
#include "common/util.h"
#include "common/textconsole.h"

#include "audio/mididrv.h"
#include "audio/midiparser.h"

namespace AGOS {

/**
 * Simon 1 Demo version of MidiParser.
 */
class MidiParser_S1D : public MidiParser {
private:
	byte *_data;
	bool _noDelta;

	struct Loop {
		uint16 timer;
		byte *start, *end;
		bool noDelta;
	} _loops[16];

	// Data for monophonic chords mode.
	// If this is activated, when multiple notes are played at the same time on
	// a melodic channel (0-5), only the highest note will be played.
	// This functionality is used by Elvira 2 (although there are no chords in
	// the MIDI data), Waxworks and the Simon 1 floppy demo.

	// The highest note played at _lastPlayedNoteTime for each channel.
	byte _highestNote[6];
	// The timestamp at which the last note was played at each channel.
	uint32 _lastPlayedNoteTime[6];

	// True if, for notes played at the same time, only the highest note should
	// be played. If false, all notes of a chord will be sent to the driver.
	bool _monophonicChords;

	uint32 readVLQ2(byte *&data);
protected:
	void parseNextEvent(EventInfo &info) override;
	bool processEvent(const EventInfo &info, bool fireEvents = true) override;
	void resetTracking() override;

	public:
	MidiParser_S1D(uint8 source = 0, bool monophonicChords = false) : MidiParser(source),
			_monophonicChords(monophonicChords), _data(nullptr), _noDelta(false) {
		Common::fill(_loops, _loops + ARRAYSIZE(_loops), Loop { 0, 0, 0, false });
		Common::fill(_highestNote, _highestNote + ARRAYSIZE(_highestNote), 0);
		Common::fill(_lastPlayedNoteTime, _lastPlayedNoteTime + ARRAYSIZE(_lastPlayedNoteTime), 0);
	}

	bool loadMusic(byte *data, uint32 size) override;
	int32 determineDataSize(Common::SeekableReadStream *stream) override;
};

uint32 MidiParser_S1D::readVLQ2(byte *&data) {
	uint32 delta = 0;

	// LE format VLQ, which is 2 bytes long at max.
	delta = *data++;
	if (delta & 0x80) {
		delta &= 0x7F;
		delta |= *data++ << 7;
	}

	return delta;
}

void MidiParser_S1D::parseNextEvent(EventInfo &info) {
	byte *playPos = _position._subtracks[0]._playPos;
	info.start = playPos;
	info.length = 0;
	info.delta = _noDelta ? 0 : readVLQ2(playPos);
	info.noop = false;
	_noDelta = false;

	info.event = *playPos++;
	if (!(info.event & 0x80)) {
		_noDelta = true;
		info.event |= 0x80;
	}

	if (info.event == 0xFC) {
		// This means End of Track.
		// Rewrite in SMF (MIDI transmission) form.
		info.event = 0xFF;
		info.ext.type = 0x2F;
	} else {
		switch (info.command()) {
		case 0x8: // note off
			info.basic.param1 = *playPos++;
			info.basic.param2 = 0;
			break;

		case 0x9: // note on
			info.basic.param1 = *playPos++;
			info.basic.param2 = *playPos++;
			// Rewrite note on events with velocity 0 as note off events.
			// This is the actual meaning of this, but theoretically this
			// should not need to be rewritten, since all MIDI devices should
			// interpret it like that. On the other hand all our MidiParser
			// implementations do it and there seems to be code in MidiParser
			// which relies on this for tracking active notes.
			if (info.basic.param2 == 0) {
				info.event = info.channel() | 0x80;
			}
			break;

		case 0xA: { // loop control
			// In case the stop mode(?) is set to 0x80 this will stop the
			// track over here.

			const int16 loopIterations = int8(*playPos++);
			if (!loopIterations) {
				_loops[info.channel()].start = playPos;
				_loops[info.channel()].noDelta = _noDelta;
			} else {
				if (!_loops[info.channel()].timer) {
					if (_loops[info.channel()].start) {
						_loops[info.channel()].timer = uint16(loopIterations);
						_loops[info.channel()].end = playPos;

						// Go to the start of the loop
						playPos = _loops[info.channel()].start;
						_noDelta = _loops[info.channel()].noDelta;
						info.loop = true;
					}
				} else {
					if (_loops[info.channel()].timer) {
						playPos = _loops[info.channel()].start;
						_noDelta = _loops[info.channel()].noDelta;
						info.loop = true;
					}
					--_loops[info.channel()].timer;
				}
			}
			// Event has been fully processed here.
			info.noop = true;
			} break;

		case 0xB: // auto stop marker(?)
			// In case the stop mode(?) is set to 0x80 this will stop the
			// track.

			// Event has been fully processed here.
			info.noop = true;
			break;

		case 0xC: // program change
			info.basic.param1 = *playPos++;
			info.basic.param2 = 0;
			break;

		case 0xD: // jump to loop end
			if (_loops[info.channel()].end)
				playPos = _loops[info.channel()].end;

			// Event has been fully processed here.
			info.noop = true;
			break;

		default:
			// The original called some other function from here, which seems
			// not to be MIDI related.
			warning("MidiParser_S1D: default case %d", info.channel());

			// Event has been fully processed here.
			info.noop = true;
			break;
		}
	}

	_position._subtracks[0]._playPos = playPos;
}

bool MidiParser_S1D::processEvent(const EventInfo &info, bool fireEvents) {
	byte channel = info.channel();
	if (_monophonicChords && channel < 6 && info.command() == 0x9 && info.basic.param2 > 0) {
		// In monophonic chords mode, when multiple notes are played at the
		// same time on a melodic channel (0-5), only the highest note should
		// be played.
		if (_lastPlayedNoteTime[channel] == _position._playTick && _highestNote[channel] > info.basic.param1) {
			// This note is lower than a previously played note on the same
			// channel and with the same timestamp. Ignore it.
			return true;
		} else {
			// This note either has a different timestamp (i.e. it is not
			// played at the same time), or it is higher than the previously
			// played note.
			// Update the timestamp and note registry and play this note
			// (because the channel is monophonic, a previously played lower
			// note will be cut off).
			_lastPlayedNoteTime[channel] = _position._playTick;
			_highestNote[channel] = info.basic.param1;
		}
	}

	return MidiParser::processEvent(info, fireEvents);
}

bool MidiParser_S1D::loadMusic(byte *data, uint32 size) {
	unloadMusic();

	if (!size)
		return false;

	// The original actually just ignores the first two bytes.
	byte *pos = data + 2;
	if (*pos == 0xFC) {
		// SysEx found right at the start
		// this seems to happen since Elvira 2, we ignore it
		// 3rd byte after the SysEx seems to be saved into a global

		// We expect at least 4 bytes in total
		if (size < 4)
			return false;

		byte skipOffset = pos[2]; // get second byte after the SysEx
		// pos[1] seems to have been ignored
		// pos[3] is saved into a global inside the original interpreters

		// Waxworks + Simon 1 demo typical header is:
		//  0xFC 0x29 0x07 0x01 [0x00/0x01]
		// Elvira 2 typical header is:
		//  0xFC 0x04 0x06 0x06

		if (skipOffset >= 6) {
			// should be at least 6, so that we skip over the 2 size bytes and the
			// smallest SysEx possible
			skipOffset -= 2; // 2 size bytes were already read by previous code outside of this method

			if (size <= skipOffset) // Skip to the end of file? -> something is not correct
				return false;

			// Do skip over the bytes
			pos += skipOffset;
		} else {
			warning("MidiParser_S1D: unexpected skip offset in music file");
		}
	}

	// And now we're at the actual data. Only one track.
	_numTracks = 1;
	_numSubtracks[0] = 1;
	_data = pos;
	_tracks[0][0] = pos;

	// Note that we assume the original data passed in
	// will persist beyond this call, i.e. we do NOT
	// copy the data to our own buffer. Take warning....
	resetTracking();
	setTempo(666667);
	setTrack(0);
	return true;
}

int32 MidiParser_S1D::determineDataSize(Common::SeekableReadStream* stream) {
	// Data size is stored in the first two bytes.
	return stream->readUint16LE() + 2;
}

void MidiParser_S1D::resetTracking() {
	MidiParser::resetTracking();
	// The first event never contains any delta.
	_noDelta = true;
	Common::fill(_loops, _loops + ARRAYSIZE(_loops), Loop { 0, 0, 0, false });
}

MidiParser *MidiParser_createS1D(uint8 source, bool monophonicChords) { return new MidiParser_S1D(source, monophonicChords); }

} // End of namespace AGOS

================
File: midiparser_simonwin.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/debug.h"
#include "agos/midiparser_simonwin.h"

#include "audio/mididrv.h"

namespace AGOS {

MidiParser_SimonWin::MidiParser_SimonWin(int8 source, bool useDosTempos) :
	MidiParser_SMF(source), _useDosTempos(useDosTempos) { }

void MidiParser_SimonWin::parseNextEvent(EventInfo &info) {
	byte *parsePos = _position._subtracks[info.subtrack]._playPos;
	uint8 *start = parsePos;
	uint32 delta = readVLQ(parsePos);
	uint8 event = *(parsePos++);

	// Pitch bend events in the Simon 1 data are broken. They contain just the
	// command byte; no data bytes follow. We generate an empty event and set
	// the noop flag to have MidiParser process only the delta and otherwise
	// ignore the event.
	if ((event & 0xF0) == MidiDriver::MIDI_COMMAND_PITCH_BEND) {
		info.start = start;
		info.delta = delta;
		info.event = event;
		info.basic.param1 = 0;
		info.basic.param2 = 0;
		info.length = 0;
		info.noop = true;

		_position._subtracks[info.subtrack]._playPos = parsePos;
	} else {
		// Processing of the other events is the same as the SMF format.
		info.noop = false;
		MidiParser_SMF::parseNextEvent(info);
	}
}

void MidiParser_SimonWin::setTempo(uint32 tempo) {
	uint32 newTempo = tempo;
	if (_useDosTempos && tempo < 750000) {
		// WORKAROUND The tempos set in the SMF data of Simon 1 Windows are
		// faster than the DOS version for the faster tempos. These are
		// corrected here to match the DOS version. The correct tempos have
		// been determined by measuring the tempos generated by the DOS version
		// running in DOSBox.
		newTempo = 330000 + (((tempo / 125000) - 2) * 105000);
	}
	MidiParser::setTempo(newTempo);
}

int32 MidiParser_SimonWin::determineDataSize(Common::SeekableReadStream *stream) {
	int64 startPos = stream->pos();

	// Read the number of tracks.
	byte numSongs = stream->readByte();
	if (numSongs > MAXIMUM_TRACKS) {
		warning("MidiParser_SimonWin::determineDataSize - Can only handle %d tracks but was handed %d", MAXIMUM_TRACKS, numSongs);
		return -1;
	}

	// Add up the sizes of the individual SMF tracks.
	int32 totalSize = 1;
	for (int i = 0; i < numSongs; ++i) {
		int size = MidiParser_SMF::determineDataSize(stream);
		if (size < 0)
			return -1;

		totalSize += size;
		stream->seek(startPos + totalSize, SEEK_SET);
	}

	return totalSize;
}

bool MidiParser_SimonWin::loadMusic(byte *data, uint32 size) {
	assert(size > 7);

	unloadMusic();

	// The first byte indicates the number of tracks in the MIDI data.
	byte *pos = data;
	_numTracks = *(pos++);
	if (_numTracks > MAXIMUM_TRACKS) {
		warning("MidiParser_SimonWin::loadMusic - Can only handle %d tracks but was handed %d", MAXIMUM_TRACKS, _numTracks);
		return false;
	}

	debug(2, "MidiParser_SimonWin::loadMusic: %d tracks", _numTracks);

	// Read the tracks.
	for (int i = 0; i < _numTracks; ++i) {
		// Read the track header.

		// Make sure there's a MThd.
		if (memcmp(pos, "MThd", 4) != 0) {
			warning("MidiParser_SimonWin::loadMusic - Expected MThd but found '%c%c%c%c' instead", pos[0], pos[1], pos[2], pos[3]);
			return false;
		}
		pos += 4;

		// Verify correct header length.
		uint32 len = read4high(pos);
		if (len != 6) {
			warning("MidiParser_SimonWin::loadMusic - MThd length 6 expected but found %d", len);
			return false;
		}

		// Verify that this MIDI is type 0 or 1 (it is expected to be type 1).
		uint16 numSubtracks = pos[2] << 8 | pos[3];
		assert(numSubtracks >= 1 && numSubtracks <= MAXIMUM_SUBTRACKS);
		uint8 subtrackMidiType = pos[1];
		if (subtrackMidiType >= 2) {
			warning("MidiParser_SimonWin::loadMusic - MIDI track contained a type %d subtrack", subtrackMidiType);
			return false;
		}

		_numSubtracks[i] = numSubtracks;

		// Each track could potentially have a different PPQN, but for Simon 1
		// and 2 all tracks have PPQN 192, so this is not a problem.
		_ppqn = pos[4] << 8 | pos[5];
		pos += len;

		// Now determine all the MTrk (sub)track start offsets.
		for (int j = 0; j < numSubtracks; j++) {
			if (memcmp(pos, "MTrk", 4) != 0) {
				warning("MidiParser_SimonWin::loadMusic - Could not find subtrack header at expected location");
				return false;
			}
			pos += 4;
			uint32 subtrackLength = READ_BE_UINT32(pos);
			pos += 4;

			// Note that we assume the original data passed in
			// will persist beyond this call, i.e. we do NOT
			// copy the data to our own buffer. Take warning....
			_tracks[i][j] = pos;
			pos += subtrackLength;
		}
	}

	_disableAutoStartPlayback = true;
	resetTracking();
	setTempo(500000);
	setTrack(0);
	return true;
}

} // End of namespace AGOS

================
File: midiparser_simonwin.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_MIDIPARSER_SIMONWIN_H
#define AGOS_MIDIPARSER_SIMONWIN_H

#include "audio/midiparser_smf.h"

#include "common/stream.h"

namespace AGOS {

/**
 * Parser for the MIDI data of the Windows versions of Simon The Sorcerer 1
 * and 2. This consists of 1 or more type 1 SMF files, preceded by a byte
 * indicating the number of files. The MIDI data for Simon 1 also has broken
 * pitch bend events, as well as incorrect tempos, which are corrected by this
 * parser.
 */
class MidiParser_SimonWin : public MidiParser_SMF {
protected:
	static const uint8 MAXIMUM_TRACKS = 16;

public:
	int32 determineDataSize(Common::SeekableReadStream *stream) override;

	MidiParser_SimonWin(int8 source = -1, bool useDosTempos = false);

	void setTempo(uint32 tempo) override;

	bool loadMusic(byte *data, uint32 size) override;

protected:
	void parseNextEvent(EventInfo &info) override;

	bool _useDosTempos;
};

} // End of namespace AGOS

#endif

================
File: module.mk
================
MODULE := engines/agos

MODULE_OBJS := \
	drivers/accolade/adlib.o \
	drivers/accolade/casio.o \
	drivers/accolade/cms.o \
	drivers/accolade/driverfile.o \
	drivers/accolade/pc98.o \
	drivers/accolade/mt32.o \
	drivers/simon1/adlib.o \
	agos.o \
	charset.o \
	charset-fontdata.o \
	contain.o \
	cursor.o \
	debug.o \
	debugger.o \
	draw.o \
	event.o \
	gfx.o \
	icons.o \
	input.o \
	input_pn.o \
	items.o \
	menus.o \
	metaengine.o \
	midi.o \
	midiparser_gmf.o \
	midiparser_s1d.o \
	midiparser_simonwin.o \
	pn.o \
	res.o \
	res_ami.o \
	res_snd.o \
	rooms.o \
	saveload.o \
	script.o \
	script_pn.o \
	script_e1.o \
	script_e2.o \
	script_ww.o \
	script_s1.o \
	script_s2.o \
	sfxparser_accolade.o \
	sound.o \
	string.o \
	string_pn.o \
	subroutine.o \
	verb.o \
	verb_pn.o \
	vga.o \
	vga_pn.o \
	vga_e2.o \
	vga_ww.o \
	vga_s1.o \
	vga_s2.o \
	window.o \
	zones.o

ifdef ENABLE_AGOS2
MODULE_OBJS += \
	animation.o \
	feeble.o \
	oracle.o \
	script_dp.o \
	script_ff.o \
	script_pp.o \
	vga_ff.o
endif

# This module can be built as a plugin
ifeq ($(ENABLE_AGOS), DYNAMIC_PLUGIN)
PLUGIN := 1
endif

# Include common rules
include $(srcdir)/rules.mk

# Detection objects
DETECT_OBJS += $(MODULE)/detection.o

================
File: obsolete.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_OBSOLETE_H
#define AGOS_OBSOLETE_H

static const Engines::ObsoleteGameID obsoleteGameIDsTable[] = {
	{"simon1acorn", "simon1", Common::kPlatformAcorn},
	{"simon1amiga", "simon1", Common::kPlatformAmiga},
	{"simon1cd32", "simon1", Common::kPlatformAmiga},
	{"simon1demo", "simon1", Common::kPlatformDOS},
	{"simon1dos", "simon1", Common::kPlatformDOS},
	{"simon1talkie", "simon1", Common::kPlatformDOS},
	{"simon1win", "simon1", Common::kPlatformWindows},
	{"simon2dos", "simon2", Common::kPlatformDOS},
	{"simon2talkie", "simon2", Common::kPlatformDOS},
	{"simon2mac", "simon2", Common::kPlatformMacintosh},
	{"simon2win", "simon2", Common::kPlatformWindows},
	{0, 0, Common::kPlatformUnknown}
};

#endif // AGOS_OBSOLETE_H

================
File: oracle.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */



#ifdef ENABLE_AGOS2

#include "common/savefile.h"

#include "graphics/surface.h"

#include "agos/agos.h"
#include "agos/intern.h"
#include "agos/vga.h"

namespace AGOS {

void AGOSEngine_Feeble::checkLinkBox() {	// Check for boxes spilling over to next row of text
	if (_hyperLink != 0) {
		_variableArray[52] = _textWindow->x + _textWindow->textColumn - _variableArray[50];
		if (_variableArray[52] != 0) {
			defineBox(_variableArray[53], _variableArray[50], _variableArray[51], _variableArray[52], 15, 145, 208, _dummyItem2);
			_variableArray[53]++;
		}
		_variableArray[50] = _textWindow->x;
		_variableArray[51] = _textWindow->textRow + _textWindow->y + (_oracleMaxScrollY-_textWindow->scrollY) * 15;
	}
}

void AGOSEngine_Feeble::hyperLinkOn(uint16 x) {
	if (!getBitFlag(51))
		return;

	_hyperLink = x;
	_variableArray[50] = _textWindow->textColumn + _textWindow->x;
	_variableArray[51] = _textWindow->textRow + _textWindow->y + (_oracleMaxScrollY - _textWindow->scrollY) * 15;
}


void AGOSEngine_Feeble::hyperLinkOff() {
	if (!getBitFlag(51))
		return;

	_variableArray[52] = _textWindow->x + _textWindow->textColumn - _variableArray[50];
	defineBox(_variableArray[53], _variableArray[50], _variableArray[51], _variableArray[52], 15, 145, 208, _dummyItem2);
	_variableArray[53]++;
	_hyperLink = 0;
}

void AGOSEngine_Feeble::linksUp() {	// Scroll Oracle Links
	uint16 j;
	for (j = 700; j < _variableArray[53]; j++) {
		moveBox(j, 0, -15);
	}
}

void AGOSEngine_Feeble::linksDown() {
	uint16 i;
	for (i = 700; i < _variableArray[53]; i++) {
		moveBox(i,0, 15);
	}
}

void AGOSEngine_Feeble::checkUp(WindowBlock *window) {
	uint16 j, k;

	if (((_variableArray[31] - _variableArray[30]) == 40) && (_variableArray[31] > 52)) {
		k = (((_variableArray[31] / 52) - 2) % 3);
		j = k * 6;
		if (!isBoxDead(j + 201)) {
			uint index = getWindowNum(window);
			drawIconArray(index, window->iconPtr->itemRef, 0, window->iconPtr->classMask);
			animate(4, 9, k + 34, 0, 0, 0);
		}
	}
	if ((_variableArray[31] - _variableArray[30]) == 76) {
		k = ((_variableArray[31] / 52) % 3);
		j = k * 6;
		if (isBoxDead(j + 201)) {
			animate(4, 9, k + 31, 0, 0, 0);
			undefineBox(j + 201);
			undefineBox(j + 202);
			undefineBox(j + 203);
			undefineBox(j + 204);
			undefineBox(j + 205);
			undefineBox(j + 206);
		}
		_variableArray[31] -= 52;
		_iOverflow = 1;
	}
}

void AGOSEngine_Feeble::inventoryUp(WindowBlock *window) {
	_marks = 0;
	checkUp(window);
	animate(4, 9, 21, 0 ,0, 0);
	while (_currentBoxNum == 0x7FFB && getBitFlag(89)) {
		checkUp(window);
		delay(1);
	}
	waitForMark(2);
	checkUp(window);
	sendSync(922);
	waitForMark(1);
	checkUp(window);
}


void AGOSEngine_Feeble::checkDown(WindowBlock *window) {
	uint16 j, k;

	if (((_variableArray[31] - _variableArray[30]) == 24) && (_iOverflow == 1)) {
		uint index = getWindowNum(window);
		drawIconArray(index, window->iconPtr->itemRef, 0, window->iconPtr->classMask);
		k = ((_variableArray[31] / 52) % 3);
		animate(4, 9, k + 25, 0, 0, 0);
		_variableArray[31] += 52;
	}
	if (((_variableArray[31] - _variableArray[30]) == 40) && (_variableArray[30] > 52)) {
		k = (((_variableArray[31] / 52) + 1) % 3);
		j = k * 6;
		if (isBoxDead(j + 201)) {
			animate(4, 9, k + 28, 0, 0, 0);
			undefineBox(j + 201);
			undefineBox(j + 202);
			undefineBox(j + 203);
			undefineBox(j + 204);
			undefineBox(j + 205);
			undefineBox(j + 206);
		}
	}
}

void AGOSEngine_Feeble::inventoryDown(WindowBlock *window) {
	_marks = 0;
	checkDown(window);
	animate(4, 9, 23, 0, 0, 0);
	while (_currentBoxNum == 0x7FFC && getBitFlag(89)) {
		checkDown(window);
		delay(1);
	}
	waitForMark(2);
	checkDown(window);
	sendSync(924);
	waitForMark(1);
	checkDown(window);
}

void AGOSEngine_Feeble::scrollOracle() {
	int i;

	for (i = 0; i < 5; i++)
		scrollOracleUp();
}

void AGOSEngine_Feeble::oracleTextUp() {
	Subroutine *sub;
	int i = 0;
	changeWindow(3);
	_noOracleScroll = 0;

	if (_textWindow->scrollY > _oracleMaxScrollY)		// For scroll up
		_oracleMaxScrollY = _textWindow->scrollY;
	while (!shouldQuit()) {
		if (_textWindow->scrollY == _oracleMaxScrollY)
			break;
		_textWindow->textRow = 105;
		for (i = 0; i < 5; i++) {
			_newLines = 0;
			_textWindow->textColumn = 0;
			_textWindow->textRow -= 3;
			if (i == 2) {
				_textWindow->scrollY += 1;
				_textWindow->textRow += 15;
				linksUp();
			}
			scrollOracleUp();
			setBitFlag(94, true);
			sub = getSubroutineByID(_variableArray[104]);
			if (sub)
				startSubroutineEx(sub);
			setBitFlag(94, false);
		}
		if (_currentBoxNum != 601 || !getBitFlag(89))
			break;
		delay(100);
	}
}

void AGOSEngine_Feeble::oracleTextDown() {
	Subroutine *sub;
	int i = 0;
	changeWindow(3);
	_noOracleScroll = 0;

	if (_textWindow->scrollY > _oracleMaxScrollY)		// For scroll up
		_oracleMaxScrollY = _textWindow->scrollY;
	while (!shouldQuit()) {
		if (_textWindow->scrollY == 0)
			break;

		for (i = 0; i < 5; i++) {
			_newLines = 0;
			_textWindow->textColumn = 0;
			_textWindow->textRow = (i + 1) * 3;
			if (i == 4) {
				_textWindow->scrollY -= 1;
				_textWindow->textRow = 0;
				linksDown();
			}
			scrollOracleDown();
			setBitFlag(93, true);
			sub = getSubroutineByID(_variableArray[104]);
			if (sub)
				startSubroutineEx(sub);
			setBitFlag(93, false);
		}
		if (_currentBoxNum != 600 || !getBitFlag(89))
			break;
		delay(100);
	}
}

void AGOSEngine_Feeble::scrollOracleUp() {
	byte *src, *dst;
	uint16 w, h;

	dst = getBackGround() + 103 * _backGroundBuf->pitch + 136;
	src = getBackGround() + 106 * _backGroundBuf->pitch + 136;

	for (h = 0; h < 21; h++) {
		for (w = 0; w < 360; w++) {
			if (dst[w] == 0 || dst[w] == 113 || dst[w] == 116 || dst[w] == 252)
				dst[w] = src[w];
		}
		dst += _backGroundBuf->pitch;
		src += _backGroundBuf->pitch;
	}

	for (h = 0; h < 80; h++) {
		memcpy(dst, src, 360);
		dst += _backGroundBuf->pitch;
		src += _backGroundBuf->pitch;
	}

	for (h = 0; h < 3; h++) {
		memset(dst, 0, 360);
		dst += _backGroundBuf->pitch;
		src += _backGroundBuf->pitch;
	}
}

void AGOSEngine_Feeble::scrollOracleDown() {
	byte *src, *dst;
	uint16 w, h;

	src = getBackGround() + 203 * _backGroundBuf->pitch + 136;
	dst = getBackGround() + 206 * _backGroundBuf->pitch + 136;

	for (h = 0; h < 77; h++) {
		memcpy(dst, src, 360);
		dst -= _backGroundBuf->pitch;
		src -= _backGroundBuf->pitch;
	}

	for (h = 0; h < 24; h++) {
		for (w = 0; w < 360; w++) {
			if (src[w] == 0)
				dst[w] = src[w];

			if (src[w] == 113 || src[w] == 116 || src[w] == 252) {
				dst[w] = src[w];
				src[w] = 0;
			}
		}
		dst -= _backGroundBuf->pitch;
		src -= _backGroundBuf->pitch;
	}
}

void AGOSEngine_Feeble::oracleLogo() {
	Common::Rect srcRect, dstRect;
	byte *src, *dst;
	uint16 w, h;

	dstRect.left = 16;
	dstRect.top = 16;
	dstRect.right = 58;
	dstRect.bottom = 59;

	srcRect.left = 0;
	srcRect.top = 0;
	srcRect.right = 42;
	srcRect.bottom = 43;

	src = _iconFilePtr;
	dst = getBackBuf() + _backBuf->pitch * dstRect.top + dstRect.left;

	for (h = 0; h < dstRect.height(); h++) {
		for (w = 0; w < dstRect.width(); w++) {
			if (src[w])
				dst[w] = src[w];
		}
		src += 336;
		dst += _backBuf->pitch;
	}
}

void AGOSEngine_Feeble::swapCharacterLogo() {
	Common::Rect srcRect, dstRect;
	byte *src, *dst;
	uint16 w, h;
	int x;

	dstRect.left = 64;
	dstRect.top = 16;
	dstRect.right = 106;
	dstRect.bottom = 59;

	srcRect.top = 0;
	srcRect.bottom = 43;

	x = _variableArray[91];
	if (x > _variableArray[90])
		x--;
	if (x < _variableArray[90])
		x++;
	_variableArray[91] = x;

	x++;
	x *= 42;

	srcRect.left = x;
	srcRect.right = srcRect.left + 42;

	src = _iconFilePtr + srcRect.top * 336 + srcRect.left;
	dst = getBackBuf() + _backBuf->pitch * dstRect.top + dstRect.left;

	for (h = 0; h < dstRect.height(); h++) {
		for (w = 0; w < dstRect.width(); w++) {
			if (src[w])
				dst[w] = src[w];
		}
		src += 336;
		dst += _backBuf->pitch;
	}
}

void AGOSEngine_Feeble::listSaveGamesFeeble() {
	char b[108];
	Common::InSaveFile *in;
	uint16 j, k, z, maxFiles;
	int OK;
	memset(b, 0, 108);

	maxFiles = countSaveGames() - 1;
	j = maxFiles;
	k = 1;
	z = maxFiles;
	if (getBitFlag(95)) {
		j++;
		z++;
	}

	while (!shouldQuit()) {
		OK = 1;
		if (getBitFlag(93) || getBitFlag(94)) {
			OK = 0;
			if (j > z)
				break;
		}

		if (getBitFlag(93)) {
			if (((_newLines + 1) >= _textWindow->scrollY) && ((_newLines + 1) < (_textWindow->scrollY + 3)))
				OK = 1;
		}

		if (getBitFlag(94)) {
			if ((_newLines + 1) == (_textWindow->scrollY + 7))
				OK = 1;
		}


		if (OK == 1) {
			if (j == maxFiles + 1) {
				showMessageFormat("\n");
				hyperLinkOn(j + 400);
				setTextColor(116);
				showMessageFormat(" %d. ", 1);
				hyperLinkOff();
				setTextColor(113);
				k++;
				j--;
			}

			if (!(in = _saveFileMan->openForLoading(genSaveName(j))))
				break;
			in->read(b, 100);
			delete in;
		}

		showMessageFormat("\n");
		hyperLinkOn(j + 400);
		setTextColor(116);
		if (k < 10)
			showMessageFormat(" ");
		showMessageFormat("%d. ", k);
		setTextColor(113);
		showMessageFormat("%s ", b);
		hyperLinkOff();
		j--;
		k++;
	}
}

void AGOSEngine_Feeble::saveUserGame(int slot) {
	WindowBlock *window;
	Common::InSaveFile *in;
	char name[108];
	int len;
	memset(name, 0, 108);

	window = _windowArray[3];

	window->textRow = (slot + 1 - window->scrollY) * 15;
	window->textColumn = 26;

	if ((in = _saveFileMan->openForLoading(genSaveName(readVariable(55))))) {
		in->read(name, 100);
		delete in;
	}

	len = 0;
	while (name[len]) {
		byte chr = name[len];
		window->textColumn += getFeebleFontSize(chr);
		len++;
	}

	windowPutChar(window, 0x7f);
	while (!shouldQuit()) {
		_keyPressed.reset();
		delay(1);

		if (_keyPressed.ascii == 0 || _keyPressed.ascii >= 127)
			continue;

		window->textColumn -= getFeebleFontSize(127);
		name[len] = 0;
		windowBackSpace(_windowArray[3]);

		if (_keyPressed.keycode == Common::KEYCODE_ESCAPE) {
			_variableArray[55] = 27;
			break;
		}
		if (_keyPressed.keycode == Common::KEYCODE_KP_ENTER || _keyPressed.keycode == Common::KEYCODE_RETURN) {
			if (!saveGame(readVariable(55), name))
				_variableArray[55] = (int16)0xFFFF;
			else
				_variableArray[55] = 0;
			break;
		}
		if (_keyPressed.keycode == Common::KEYCODE_BACKSPACE && len != 0) {
			len--;
			byte chr = name[len];
			window->textColumn -= getFeebleFontSize(chr);
			name[len] = 0;
			windowBackSpace(_windowArray[3]);
		}
		if (_keyPressed.ascii >= 32 && window->textColumn + 26 <= window->width) {
			name[len++] = _keyPressed.ascii;
			windowPutChar(_windowArray[3], _keyPressed.ascii);
		}

		windowPutChar(window, 0x7f);
	}
}

void AGOSEngine_Feeble::windowBackSpace(WindowBlock *window) {
	byte *dst;
	uint x, y, h, w;

	_videoLockOut |= 0x8000;

	x = window->x + window->textColumn;
	y = window->y + window->textRow;

	dst = getBackGround() + _backGroundBuf->pitch * y + x;

	for (h = 0; h < 13; h++) {
		for (w = 0; w < 8; w++) {
			if (dst[w] == 113 || dst[w] == 116 || dst[w] == 252)
				dst[w] = 0;
		}
		dst += _backGroundBuf->pitch;
	}

	_videoLockOut &= ~0x8000;
}

} // End of namespace AGOS

#endif // ENABLE_AGOS2

================
File: pn.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/config-manager.h"

#include "agos/intern.h"
#include "agos/agos.h"

namespace AGOS {

AGOSEngine_PN::AGOSEngine_PN(OSystem *system, const AGOSGameDescription *gd)
	: AGOSEngine(system, gd) {

	_stackbase = nullptr;
	_tagOfActiveDoline = 0;
	_dolineReturnVal = 0;

	_dataBase = nullptr;
	_dataBaseSize = 0;
	_textBase = nullptr;
	_textBaseSize = 0;

	memset(_buffer, 0, sizeof(_buffer));
	memset(_inputline, 0, sizeof(_inputline));
	memset(_saveFile, 0, sizeof(_saveFile));
	memset(_sb, 0, sizeof(_sb));
	memset(_wordcp, 0, sizeof(_wordcp));

	memset(_objectName1, 0, sizeof(_objectName1));
	memset(_objectName2, 0, sizeof(_objectName2));

	_dragStore = nullptr;
	_hitCalled = 0;
	_inputReady = false;
	_inputting = false;
	_intputCounter = 0;
	_inputMax = 0;
	_mousePrintFG = 0;
	_mouseString = nullptr;
	_mouseString1 = nullptr;
	memset(_inMessage, 0, sizeof(_inMessage));
	memset(_placeMessage, 0, sizeof(_placeMessage));

	memset(_quickptr, 0, sizeof(_quickptr));
	memset(_quickshort, 0, sizeof(_quickshort));

	_noScanFlag = false;
	memset(_keyboardBuffer, 0, sizeof(_keyboardBuffer));

	_objects = 0;
	_objectCountS = 0;

	_bp = 0;
	_xofs = 0;
	_havinit = 0;
	_seed = 0;

	_curwrdptr = nullptr;
	_inpp = nullptr;
	_fnst = 0;
	_linembr = 0;
	_linct = 0;
	_procnum = 0;

	_linebase = nullptr;
	_workptr = nullptr;

	_keymapEnabled = true;
}

AGOSEngine_PN::~AGOSEngine_PN() {
	free(_dataBase);
	free(_textBase);

}

const byte egaPalette[48] = {
	  0,   0,   0,
	  0,   0, 170,
	  0, 170,   0,
	  0, 170, 170,
	170,   0,   0,
	170,   0, 170,
	170,  85,   0,
	170, 170, 170,
	 85,  85,  85,
	 85,  85, 255,
	 85, 255,  85,
	 85, 255, 255,
	255,  85,  85,
	255,  85, 255,
	255, 255,  85,
	255, 255, 255
};

Common::Error AGOSEngine_PN::go() {
	loadGamePcFile();

	if (getFileName(GAME_ICONFILE) != nullptr) {
		loadIconFile();
	}

	setupBoxes();

	vc34_setMouseOff();

	addVgaEvent(_frameCount, ANIMATE_INT, nullptr, 0, 0);

	if (getFeatures() & GF_EGA) {
		// Set EGA Palette
		memcpy(_displayPalette, egaPalette, sizeof(egaPalette));
		_paletteFlag = 1;
	}

	_inputWindow = _windowArray[2] = openWindow(0, 192, 40, 1, 1, 0, 15);
	_textWindow = _windowArray[0] = openWindow(1, 136, 38, 6, 1, 0, 15);

	if (getFeatures() & GF_DEMO) {
		demoSeq();
	} else {
		introSeq();
		processor();
	}

	return Common::kNoError;
}

void AGOSEngine_PN::demoSeq() {
	while (!shouldQuit()) {
		loadZone(0);
		setWindowImage(3, 0);
		while (!shouldQuit() && _variableArray[228] != 1)
			delay(1);

		loadZone(1);
		setWindowImage(0, 0);
		while (!shouldQuit() && _variableArray[228] != 2)
			delay(1);

		loadZone(2);
		setWindowImage(0, 0);
		while (!shouldQuit() && _variableArray[228] != 3)
			delay(1);
	}
}

void AGOSEngine_PN::introSeq() {
	loadZone(25); // Zone 'I'
	setWindowImage(3, 0);

	_exitCutscene = false;
	while (!shouldQuit() && !_exitCutscene && _variableArray[228] != 1) {
		processSpecialKeys();
		delay(1);
	}

	setWindowImage(3, 3);
	delay(100);

	loadZone(27); // Zone 'K'
	setWindowImage(3, 0);

	_exitCutscene = false;
	while (!shouldQuit() && !_exitCutscene && _variableArray[228] != 2) {
		processSpecialKeys();
		delay(1);
	}
}

void AGOSEngine_PN::setupBoxes() {
	_hitAreaList = _invHitAreas;
	// Inventory box
	defineBox( 0,  11,  68, 16,  26, 25, 0, kOBFDraggable | kOBFUseEmptyLine | kOBFInventoryBox | kOBFNoShowName);
	// Room Box
	defineBox( 1,  11, 103, 16,  26, 26, 0, kOBFDraggable | kOBFUseEmptyLine | kOBFRoomBox | kOBFNoShowName);
	// Exit box
	defineBox( 2,  48,   2,  8,  28, 27, 0, kOBFUseEmptyLine | kOBFNoShowName);
	// More box
	defineBox( 3,  80,   2,  8,  26, 28, 0, kOBFUseEmptyLine | kOBFMoreBox | kOBFNoShowName);
	// Close box
	defineBox( 4, 110,   2,  8,  28, 29, 0, kOBFUseEmptyLine | kOBFNoShowName);

	// Icon boxes
	uint8 num = 5;
	for (uint8 r = 0; r < 5; r++) {
		for (uint8 i = 0; i < 7; i++) {
			defineBox(num, 96 + i * 24, 12 + r * 24, 24, 24, 0, 3, kOBFObject | kOBFDraggable);
			num++;
		}
	}

	// Mark the end of inventory boxes
	HitArea *ha = _hitAreaList + num;
	ha->id = 0xFFFF;

	_hitAreaList = _hitAreas;
	defineBox( 0,  0,    0, 200, 320, 0, 0, kOBFBoxDisabled | kOBFNoShowName);
	defineBox( 1, 273,   4,   5,  45, 1, 0, kOBFUseEmptyLine | kOBFNoShowName | kOBFInvertTouch);
	defineBox( 2, 273,  12,   5,  45, 2, 0, kOBFUseEmptyLine | kOBFNoShowName | kOBFInvertTouch);
	defineBox( 3, 273,  20,   5,  45, 3, 0, kOBFUseEmptyLine | kOBFNoShowName | kOBFInvertTouch);
	defineBox( 4, 273,  28,   5,  45, 4, 0, kOBFUseEmptyLine | kOBFNoShowName | kOBFInvertTouch);
	defineBox( 5, 273,  36,   5,  45, 5, 0, kOBFUseEmptyLine | kOBFNoShowName | kOBFInvertTouch);
	defineBox( 6, 273,  44,   5,  45, 6, 0, kOBFUseEmptyLine | kOBFNoShowName | kOBFInvertTouch);
	defineBox( 7, 273,  52,   5,  45, 7, 0, kOBFUseEmptyLine | kOBFNoShowName | kOBFInvertTouch);
	defineBox( 8, 273,  60,   5,  45, 8, 0, kOBFUseEmptyLine | kOBFNoShowName | kOBFInvertTouch);
	defineBox( 9, 273,  68,   5,  45, 9, 0, kOBFUseEmptyLine | kOBFNoShowName | kOBFInvertTouch);
	defineBox(10, 273,  76,   5,  45, 10, 0, kOBFUseEmptyLine | kOBFNoShowName | kOBFInvertTouch);
	defineBox(11, 273,  84,   5,  45, 11, 0, kOBFUseEmptyLine | kOBFNoShowName | kOBFInvertTouch);
	defineBox(12, 273,  92,   5,  45, 12, 0, kOBFUseEmptyLine | kOBFNoShowName | kOBFInvertTouch);
	defineBox(13, 273, 100,   5,  45, 13, 0, kOBFUseEmptyLine | kOBFBoxDisabled | kOBFNoShowName);
	defineBox(14, 273, 107,   5,  45, 14, 0, kOBFUseEmptyLine | kOBFNoShowName | kOBFInvertTouch);
	defineBox(15, 273, 115,   5,  45, 15, 0, kOBFUseEmptyLine | kOBFNoShowName | kOBFInvertTouch);
	defineBox(16, 273, 123,   5,  45, 16, 0, kOBFUseEmptyLine | kOBFBoxDisabled | kOBFNoShowName);
	defineBox(17,  20,   5,   7,   7, 17, 0, kOBFUseEmptyLine | kOBFNoShowName);
	defineBox(18,  28,  11,   7,  13, 18, 0, kOBFUseEmptyLine | kOBFNoShowName);
	defineBox(19,  36,  21,   7,   7, 19, 0, kOBFUseEmptyLine | kOBFNoShowName);
	defineBox(20,  27,  31,   7,  13, 20, 0, kOBFUseEmptyLine | kOBFNoShowName);
	defineBox(21,  20,  37,   7,   7, 21, 0, kOBFUseEmptyLine | kOBFNoShowName);
	defineBox(22,   5,  31,   7,  13, 22, 0, kOBFUseEmptyLine | kOBFNoShowName);
	defineBox(23,   4,  21,   7,   7, 23, 0, kOBFUseEmptyLine | kOBFNoShowName);
	defineBox(24,   5,  11,   7,  13, 24, 0, kOBFUseEmptyLine | kOBFNoShowName);
	defineBox(25,  11,  68,  16,  26, 25, 0, kOBFDraggable | kOBFUseEmptyLine | kOBFInventoryBox | kOBFNoShowName);
	defineBox(26,  11, 103,  16,  26, 26, 0, kOBFDraggable | kOBFUseEmptyLine | kOBFRoomBox | kOBFNoShowName);
}

void AGOSEngine_PN::processor() {
	setqptrs();

	_tagOfActiveDoline = 0;
	int q = 0;
	do {
		assert(_tagOfActiveDoline == 0);
		_dolineReturnVal = 0;

		_variableArray[6] = 0;

		if (getPlatform() == Common::kPlatformAtariST) {
			_variableArray[21] = 2;
		} else if (getPlatform() == Common::kPlatformAmiga) {
			_variableArray[21] = 0;
		} else {
			_variableArray[21] = 1;
		}

		_variableArray[16] = _quickshort[6];
		_variableArray[17] = _quickshort[7];
		_variableArray[19] = getptr(55L);

		// q indicates the process to run and is 0 the first time,
		// but 1 later on (i.e., when we are "called" from badload()).
		setposition(0, 0);
		q = doline(0);
	} while (q);
}

void AGOSEngine_PN::setqptrs() {
	for (int i = 0; i < 11; ++i) {
		_quickptr[i] = getlong(3 * i);
	}
	_quickptr[11] = getlong(58L);
	_quickptr[12] = getlong(61L);
	_quickshort[0] = getptr(35L);
	_quickshort[1] = getptr(37L);
	_quickshort[2] = getptr(39L);
	_quickshort[3] = getptr(41L);
	_quickshort[4] = getptr(43L);
	_quickshort[5] = getptr(45L);
	_quickshort[6] = getptr(51L);
	_quickshort[7] = getptr(53L);
}

} // End of namespace AGOS

================
File: POTFILES
================
engines/agos/saveload.cpp
engines/agos/animation.cpp
engines/agos/metaengine.cpp
engines/agos/midi.cpp

================
File: res.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Resource file routines for Simon1/Simon2


#include "common/archive.h"
#include "common/file.h"
#include "common/memstream.h"
#include "common/textconsole.h"
#include "common/util.h"

#include "agos/agos.h"
#include "agos/intern.h"

#include "common/compression/deflate.h"

namespace AGOS {

#ifdef ENABLE_AGOS2
uint16 AGOSEngine_Feeble::to16Wrapper(uint value) {
	return TO_LE_16(value);
}

uint16 AGOSEngine_Feeble::readUint16Wrapper(const void *src) {
	return READ_LE_UINT16(src);
}

uint32 AGOSEngine_Feeble::readUint32Wrapper(const void *src) {
	return READ_LE_UINT32(src);
}
#endif

uint16 AGOSEngine::to16Wrapper(uint value) {
	return TO_BE_16(value);
}

uint16 AGOSEngine::readUint16Wrapper(const void *src) {
	return READ_BE_UINT16(src);
}

uint32 AGOSEngine::readUint32Wrapper(const void *src) {
	return READ_BE_UINT32(src);
}

void AGOSEngine::decompressData(const char *srcName, byte *dst, uint32 offset, uint32 srcSize, uint32 dstSize) {
		Common::File in;
		in.open(srcName);
		if (in.isOpen() == false)
			error("decompressData: Can't load %s", srcName);

		in.seek(offset, SEEK_SET);
		if (srcSize != dstSize) {
			byte *srcBuffer = (byte *)malloc(srcSize);

			if (in.read(srcBuffer, srcSize) != srcSize)
				error("decompressData: Read failed");

			unsigned long decompressedSize = dstSize;
			if (!Common::inflateZlib(dst, &decompressedSize, srcBuffer, srcSize))
				error("decompressData: Zlib uncompress error");
			free(srcBuffer);
		} else {
			if (in.read(dst, dstSize) != dstSize)
				error("decompressData: Read failed");
		}
		in.close();
}

void AGOSEngine::loadOffsets(const char *filename, int number, uint32 &file, uint32 &offset, uint32 &srcSize, uint32 &dstSize) {
	Common::File in;

	int offsSize = (getPlatform() == Common::kPlatformAmiga) ? 16 : 12;

	/* read offsets from index */
	in.open(filename);
	if (in.isOpen() == false) {
		error("loadOffsets: Can't load index file '%s'", filename);
	}

	in.seek(number * offsSize, SEEK_SET);
	offset = in.readUint32LE();
	dstSize = in.readUint32LE();
	srcSize = in.readUint32LE();
	file = in.readUint32LE();
	in.close();
}

int AGOSEngine::allocGamePcVars(Common::SeekableReadStream *in) {
	uint32 itemArraySize, itemArrayInited, stringTableNum;
	uint32 version;
	uint32 i;

	itemArraySize = in->readUint32BE();
	version = in->readUint32BE();
	itemArrayInited = in->readUint32BE();
	stringTableNum = in->readUint32BE();

	// First two items are predefined
	if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2) {
		itemArraySize += 2;
		itemArrayInited = itemArraySize;
	} else {
		itemArrayInited += 2;
		itemArraySize += 2;
	}

	if (version != 0x80)
		error("allocGamePcVars: Not a runtime database");

	_itemArrayPtr = (Item **)calloc(itemArraySize, sizeof(Item *));
	if (_itemArrayPtr == nullptr)
		error("allocGamePcVars: Out of memory for Item array");

	_itemArraySize = itemArraySize;
	_itemArrayInited = itemArrayInited;

	for (i = 1; i < itemArrayInited; i++) {
		_itemArrayPtr[i] = (Item *)allocateItem(sizeof(Item));
	}

	// The rest is cleared automatically by calloc
	allocateStringTable(stringTableNum + 10);
	_stringTabNum = stringTableNum;

	return itemArrayInited;
}

void AGOSEngine_PN::loadGamePcFile() {
	if (getFileName(GAME_BASEFILE) != nullptr) {
		Common::File in;
		// Read dataBase
		if (!in.open(getFileName(GAME_BASEFILE))) {
			error("loadGamePcFile: Can't load database file '%s'", getFileName(GAME_BASEFILE));
		}

		_dataBaseSize = in.size();
		_dataBase = (byte *)malloc(_dataBaseSize);
		if (_dataBase == nullptr)
			error("loadGamePcFile: Out of memory for dataBase");
		in.read(_dataBase, _dataBaseSize);

		if (_dataBase[31] != 0)
			error("Later version of system requested");
	}

	if (getFileName(GAME_TEXTFILE) != nullptr) {
		Common::File in;
		// Read textBase
		if (!in.open(getFileName(GAME_TEXTFILE))) {
			error("loadGamePcFile: Can't load textbase file '%s'", getFileName(GAME_TEXTFILE));
		}

		_textBaseSize = in.size();
		_textBase = (byte *)malloc(_textBaseSize);
		if (_textBase == nullptr)
			error("loadGamePcFile: Out of memory for textBase");
		in.read(_textBase, _textBaseSize);

		if (_textBase[getlong(30L)] != 128)
			error("Unknown compression format");
	}
}

void AGOSEngine::loadGamePcFile() {
	int fileSize;

	if (getFileName(GAME_BASEFILE) != nullptr) {
		/* Read main gamexx file */
		Common::File in;
		if (!in.open(getFileName(GAME_BASEFILE))) {
			error("loadGamePcFile: Can't load gamexx file '%s'", getFileName(GAME_BASEFILE));
		}

		if (getFeatures() & GF_CRUNCHED_GAMEPC) {
			uint srcSize = in.size();
			byte *srcBuf = (byte *)malloc(srcSize);
			in.read(srcBuf, srcSize);

			uint dstSize = READ_BE_UINT32(srcBuf + srcSize - 4);
			byte *dstBuf = (byte *)malloc(dstSize);
			decrunchFile(srcBuf, dstBuf, srcSize);
			free(srcBuf);

			Common::MemoryReadStream stream(dstBuf, dstSize);
			readGamePcFile(&stream);
			free(dstBuf);
		} else {
			readGamePcFile(&in);
		}
	}

	if (getFileName(GAME_TBLFILE) != nullptr) {
		/* Read list of TABLE resources */
		Common::File in;
		if (!in.open(getFileName(GAME_TBLFILE))) {
			error("loadGamePcFile: Can't load table resources file '%s'", getFileName(GAME_TBLFILE));
		}

		fileSize = in.size();

		_tblList = (byte *)malloc(fileSize);
		if (_tblList == nullptr)
			error("loadGamePcFile: Out of memory for strip table list");
		in.read(_tblList, fileSize);

		/* Remember the current state */
		_subroutineListOrg = _subroutineList;
		_tablesHeapPtrOrg = _tablesHeapPtr;
		_tablesHeapCurPosOrg = _tablesHeapCurPos;
	}

	if (getFileName(GAME_STRFILE) != nullptr) {
		/* Read list of TEXT resources */
		Common::File in;
		if (!in.open(getFileName(GAME_STRFILE)))
			error("loadGamePcFile: Can't load text resources file '%s'", getFileName(GAME_STRFILE));

		fileSize = in.size();
		_strippedTxtMem = (byte *)malloc(fileSize);
		if (_strippedTxtMem == nullptr)
			error("loadGamePcFile: Out of memory for strip text list");
		in.read(_strippedTxtMem, fileSize);
	}

	if (getFileName(GAME_STATFILE) != nullptr) {
		/* Read list of ROOM STATE resources */
		Common::File in;
		if (!in.open(getFileName(GAME_STATFILE))) {
			error("loadGamePcFile: Can't load state resources file '%s'", getFileName(GAME_STATFILE));
		}

		_numRoomStates = in.size() / 8;

		_roomStates = (RoomState *)calloc(_numRoomStates, sizeof(RoomState));
		if (_roomStates == nullptr)
			error("loadGamePcFile: Out of memory for room state list");

		for (uint s = 0; s < _numRoomStates; s++) {
			uint16 num = in.readUint16BE() - (_itemArrayInited - 2);

			_roomStates[num].state = in.readUint16BE();
			_roomStates[num].classFlags = in.readUint16BE();
			_roomStates[num].roomExitStates = in.readUint16BE();
		}
	}

	if (getFileName(GAME_RMSLFILE) != nullptr) {
		/* Read list of ROOM ITEMS resources */
		Common::File in;
		if (!in.open(getFileName(GAME_RMSLFILE))) {
			error("loadGamePcFile: Can't load room resources file '%s'", getFileName(GAME_RMSLFILE));
		}

		fileSize = in.size();

		_roomsList = (byte *)malloc(fileSize);
		if (_roomsList == nullptr)
			error("loadGamePcFile: Out of memory for room items list");
		in.read(_roomsList, fileSize);
	}

	if (getFileName(GAME_XTBLFILE) != nullptr) {
		/* Read list of XTABLE resources */
		Common::File in;
		if (!in.open(getFileName(GAME_XTBLFILE))) {
			error("loadGamePcFile: Can't load xtable resources file '%s'", getFileName(GAME_XTBLFILE));
		}

		fileSize = in.size();

		_xtblList = (byte *)malloc(fileSize);
		if (_xtblList == nullptr)
			error("loadGamePcFile: Out of memory for strip xtable list");
		in.read(_xtblList, fileSize);

		/* Remember the current state */
		_xsubroutineListOrg = _subroutineList;
		_xtablesHeapPtrOrg = _tablesHeapPtr;
		_xtablesHeapCurPosOrg = _tablesHeapCurPos;
	}
}

void AGOSEngine::readGamePcFile(Common::SeekableReadStream *in) {
	int num_inited_objects;
	int i;

	num_inited_objects = allocGamePcVars(in);

	createPlayer();
	readGamePcText(in);

	for (i = 2; i < num_inited_objects; i++) {
		readItemFromGamePc(in, _itemArrayPtr[i]);
	}

	readSubroutineBlock(in);
}

void AGOSEngine::readGamePcText(Common::SeekableReadStream *in) {
	_textSize = in->readUint32BE();
	_textMem = (byte *)malloc(_textSize);
	if (_textMem == nullptr)
		error("readGamePcText: Out of text memory");

	in->read(_textMem, _textSize);

	setupStringTable(_textMem, _stringTabNum);
}

void AGOSEngine::readItemFromGamePc(Common::SeekableReadStream *in, Item *item) {
	uint32 type;

	if (getGameType() == GType_ELVIRA1) {
		item->itemName = (uint16)in->readUint32BE();
		item->adjective = in->readUint16BE();
		item->noun = in->readUint16BE();
		item->state = in->readUint16BE();
		in->readUint16BE();
		item->next = (uint16)fileReadItemID(in);
		item->child = (uint16)fileReadItemID(in);
		item->parent = (uint16)fileReadItemID(in);
		in->readUint16BE();
		in->readUint16BE();
		in->readUint16BE();
		item->classFlags = in->readUint16BE();
		item->children = nullptr;
	} else if (getGameType() == GType_ELVIRA2) {
		item->itemName = (uint16)in->readUint32BE();
		item->adjective = in->readUint16BE();
		item->noun = in->readUint16BE();
		item->state = in->readUint16BE();
		item->next = (uint16)fileReadItemID(in);
		item->child = (uint16)fileReadItemID(in);
		item->parent = (uint16)fileReadItemID(in);
		in->readUint16BE();
		item->classFlags = in->readUint16BE();
		item->children = nullptr;
	} else {
		item->adjective = in->readUint16BE();
		item->noun = in->readUint16BE();
		item->state = in->readUint16BE();
		item->next = (uint16)fileReadItemID(in);
		item->child = (uint16)fileReadItemID(in);
		item->parent = (uint16)fileReadItemID(in);
		in->readUint16BE();
		item->classFlags = in->readUint16BE();
		item->children = nullptr;
	}


	type = in->readUint32BE();
	while (type) {
		type = in->readUint16BE();
		if (type != 0)
			readItemChildren(in, item, type);
	}
}

void AGOSEngine::readItemChildren(Common::SeekableReadStream *in, Item *item, uint type) {
	if (type == kRoomType) {
		SubRoom *subRoom = (SubRoom *)allocateChildBlock(item, kRoomType, sizeof(SubRoom));
		subRoom->roomShort = in->readUint32BE();
		subRoom->roomLong = in->readUint32BE();
		subRoom->flags = in->readUint16BE();
	} else if (type == kObjectType) {
		SubObject *subObject = (SubObject *)allocateChildBlock(item, kObjectType, sizeof(SubObject));
		in->readUint32BE();
		in->readUint32BE();
		in->readUint32BE();
		subObject->objectName = in->readUint32BE();
		subObject->objectSize = in->readUint16BE();
		subObject->objectWeight = in->readUint16BE();
		subObject->objectFlags = in->readUint16BE();
	} else if (type == kGenExitType) {
		SubGenExit *genExit = (SubGenExit *)allocateChildBlock(item, kGenExitType, sizeof(SubGenExit));
		genExit->dest[0] = (uint16)fileReadItemID(in);
		genExit->dest[1] = (uint16)fileReadItemID(in);
		genExit->dest[2] = (uint16)fileReadItemID(in);
		genExit->dest[3] = (uint16)fileReadItemID(in);
		genExit->dest[4] = (uint16)fileReadItemID(in);
		genExit->dest[5] = (uint16)fileReadItemID(in);
		fileReadItemID(in);
		fileReadItemID(in);
		fileReadItemID(in);
		fileReadItemID(in);
		fileReadItemID(in);
		fileReadItemID(in);
	} else if (type == kContainerType) {
		SubContainer *container = (SubContainer *)allocateChildBlock(item, kContainerType, sizeof(SubContainer));
		container->volume = in->readUint16BE();
		container->flags = in->readUint16BE();
	} else if (type == kChainType) {
		SubChain *chain = (SubChain *)allocateChildBlock(item, kChainType, sizeof(SubChain));
		chain->chChained = (uint16)fileReadItemID(in);
	} else if (type == kUserFlagType) {
		setUserFlag(item, 0, in->readUint16BE());
		setUserFlag(item, 1, in->readUint16BE());
		setUserFlag(item, 2, in->readUint16BE());
		setUserFlag(item, 3, in->readUint16BE());
		setUserFlag(item, 4, in->readUint16BE());
		setUserFlag(item, 5, in->readUint16BE());
		setUserFlag(item, 6, in->readUint16BE());
		setUserFlag(item, 7, in->readUint16BE());
		SubUserFlag *subUserFlag = (SubUserFlag *)findChildOfType(item, kUserFlagType);
		subUserFlag->userItems[0] = (uint16)fileReadItemID(in);
		fileReadItemID(in);
		fileReadItemID(in);
		fileReadItemID(in);
	} else if (type == kInheritType) {
		SubInherit *inherit = (SubInherit *)allocateChildBlock(item, kInheritType, sizeof(SubInherit));
		inherit->inMaster = (uint16)fileReadItemID(in);
	} else {
		error("readItemChildren: invalid type %d", type);
	}
}

void AGOSEngine_Elvira2::readItemChildren(Common::SeekableReadStream *in, Item *item, uint type) {
	if (type == kRoomType) {
		uint fr1 = in->readUint16BE();
		uint fr2 = in->readUint16BE();
		uint i, size;
		uint j, k;
		SubRoom *subRoom;

		size = SubRoom_SIZE;
		for (i = 0, j = fr2; i != 6; i++, j >>= 2)
			if (j & 3)
				size += sizeof(subRoom->roomExit[0]);

		subRoom = (SubRoom *)allocateChildBlock(item, kRoomType, size);
		subRoom->subroutine_id = fr1;
		subRoom->roomExitStates = fr2;

		for (i = k = 0, j = fr2; i != 6; i++, j >>= 2)
			if (j & 3)
				subRoom->roomExit[k++] = (uint16)fileReadItemID(in);
	} else if (type == kObjectType) {
		uint32 fr = in->readUint32BE();
		uint i, k, size;
		SubObject *subObject;

		size = SubObject_SIZE;
		for (i = 0; i != 16; i++)
			if (fr & (1 << i))
				size += sizeof(subObject->objectFlagValue[0]);

		subObject = (SubObject *)allocateChildBlock(item, kObjectType, size);
		subObject->objectFlags = fr;

		k = 0;
		if (fr & 1) {
			subObject->objectFlagValue[k++] = (uint16)in->readUint32BE();
		}
		for (i = 1; i != 16; i++)
			if (fr & (1 << i))
				subObject->objectFlagValue[k++] = in->readUint16BE();

		if (getGameType() != GType_ELVIRA2)
			subObject->objectName = (uint16)in->readUint32BE();
	} else if (type == kSuperRoomType) {
		assert(getGameType() == GType_ELVIRA2);

		uint i, j, k, size;
		uint id, x, y, z;
		SubSuperRoom *subSuperRoom;

		id = in->readUint16BE();
		x = in->readUint16BE();
		y = in->readUint16BE();
		z = in->readUint16BE();

		j = x * y * z;
		size = SubSuperRoom_SIZE;
		for (i = 0; i != j; i++)
			size += sizeof(subSuperRoom->roomExitStates[0]);

		subSuperRoom = (SubSuperRoom *)allocateChildBlock(item, kSuperRoomType, size);
		subSuperRoom->subroutine_id = id;
		subSuperRoom->roomX = x;
		subSuperRoom->roomY = y;
		subSuperRoom->roomZ = z;

		for (i = k = 0; i != j; i++)
			subSuperRoom->roomExitStates[k++] = in->readUint16BE();
	} else if (type == kContainerType) {
		SubContainer *container = (SubContainer *)allocateChildBlock(item, kContainerType, sizeof(SubContainer));
		container->volume = in->readUint16BE();
		container->flags = in->readUint16BE();
	} else if (type == kChainType) {
		SubChain *chain = (SubChain *)allocateChildBlock(item, kChainType, sizeof(SubChain));
		chain->chChained = (uint16)fileReadItemID(in);
	} else if (type == kUserFlagType) {
		setUserFlag(item, 0, in->readUint16BE());
		setUserFlag(item, 1, in->readUint16BE());
		setUserFlag(item, 2, in->readUint16BE());
		setUserFlag(item, 3, in->readUint16BE());
	} else if (type == kInheritType) {
		SubInherit *inherit = (SubInherit *)allocateChildBlock(item, kInheritType, sizeof(SubInherit));
		inherit->inMaster = (uint16)fileReadItemID(in);
	} else {
		error("readItemChildren: invalid type %d", type);
	}
}

uint fileReadItemID(Common::SeekableReadStream *in) {
	uint32 val = in->readUint32BE();
	if (val == 0xFFFFFFFF)
		return 0;
	return val + 2;
}

void AGOSEngine::openGameFile() {
	_gameFile = new Common::File();
	_gameFile->open(getFileName(GAME_GMEFILE));

	if (!_gameFile->isOpen())
		error("openGameFile: Can't load game file '%s'", getFileName(GAME_GMEFILE));

	uint32 size = _gameFile->readUint32LE();

	_gameOffsetsPtr = (uint32 *)malloc(size);
	if (_gameOffsetsPtr == nullptr)
		error("openGameFile: Out of memory, game offsets");

	_gameFile->seek(0, SEEK_SET);

	for (uint r = 0; r < size / 4; r++)
		_gameOffsetsPtr[r] = _gameFile->readUint32LE();
}

void AGOSEngine::readGameFile(void *dst, uint32 offs, uint32 size) {
	_gameFile->seek(offs, SEEK_SET);
	if (_gameFile->read(dst, size) != size)
		error("readGameFile: Read failed (%d,%d)", offs, size);
}

// Thanks to Stuart Caie for providing the original
// C conversion upon which this decruncher is based.

#define SD_GETBIT(var) do {     \
	if (!bits--) {              \
		s -= 4;                 \
		if (s < src)            \
			return false;       \
		bb = READ_BE_UINT32(s); \
		bits = 31;              \
	}                           \
	(var) = bb & 1;             \
	bb >>= 1;                   \
}while (0)

#define SD_GETBITS(var, nbits) do { \
	bc = (nbits);                   \
	(var) = 0;                      \
	while (bc--) {                   \
		(var) <<= 1;                \
		SD_GETBIT(bit);             \
		(var) |= bit;               \
	}                               \
}while (0)

#define SD_TYPE_LITERAL (0)
#define SD_TYPE_MATCH   (1)

bool AGOSEngine::decrunchFile(byte *src, byte *dst, uint32 size) {
	byte *s = src + size - 4;
	uint32 destlen = READ_BE_UINT32 (s);
	uint32 bb, x, y;
	byte *d = dst + destlen;
	byte bc, bit, bits, type;

	// Initialize bit buffer.
	s -= 4;
	bb = x = READ_BE_UINT32 (s);
	bits = 0;
	do {
		x >>= 1;
		bits++;
	} while (x);
	bits--;

	while (d > dst) {
		SD_GETBIT(x);
		if (x) {
			SD_GETBITS(x, 2);
			switch (x) {
			case 0:
				type = SD_TYPE_MATCH;
				x = 9;
				y = 2;
				break;

			case 1:
				type = SD_TYPE_MATCH;
				x = 10;
				y = 3;
				break;

			case 2:
				type = SD_TYPE_MATCH;
				x = 12;
				SD_GETBITS(y, 8);
				break;

			default:
				type = SD_TYPE_LITERAL;
				x = 8;
				y = 8;
			}
		} else {
			SD_GETBIT(x);
			if (x) {
				type = SD_TYPE_MATCH;
				x = 8;
				y = 1;
			} else {
				type = SD_TYPE_LITERAL;
				x = 3;
				y = 0;
			}
		}

		if (type == SD_TYPE_LITERAL) {
			SD_GETBITS(x, x);
			y += x;
			if ((int)(y + 1) > (d - dst))
				return false; // Overflow?
			do {
				SD_GETBITS(x, 8);
				*--d = x;
			} while (y-- > 0);
		} else {
			if ((int)(y + 1) > (d - dst))
				return false; // Overflow?
			SD_GETBITS(x, x);
			if ((d + x) > (dst + destlen))
				return false; // Offset overflow?
			do {
				d--;
				*d = d[x];
			} while (y-- > 0);
		}
	}

	// Successful decrunch.
	return true;
}

#undef SD_GETBIT
#undef SD_GETBITS
#undef SD_TYPE_LITERAL
#undef SD_TYPE_MATCH

static bool getBit(Common::Stack<uint32> &dataList, uint32 &srcVal) {
	bool result = srcVal & 1;
	srcVal >>= 1;
	if (srcVal == 0) {
		srcVal = dataList.pop();

		result = srcVal & 1;
		srcVal = (srcVal >> 1) | 0x80000000L;
	}

	return result;
}

static uint32 copyBits(Common::Stack<uint32> &dataList, uint32 &srcVal, int numBits) {
	uint32 destVal = 0;

	for (int i = 0; i < numBits; ++i) {
		bool f = getBit(dataList, srcVal);
		destVal = (destVal << 1) | (f ? 1 : 0);
	}

	return destVal;
}

static void transferLoop(uint8 *dataOut, int &outIndex, uint32 destVal, int max) {
	assert(outIndex > max - 1);
	byte *pDest = dataOut + outIndex;

	 for (int i = 0; (i <= max) && (outIndex > 0); ++i) {
		pDest = dataOut + --outIndex;
		*pDest = pDest[destVal];
	 }
}

void AGOSEngine::decompressPN(Common::Stack<uint32> &dataList, uint8 *&dataOut, int &dataOutSize) {
	// Set up the output data area
	dataOutSize = dataList.pop();
	dataOut = new uint8[dataOutSize];
	int outIndex = dataOutSize;

	// Decompression routine
	uint32 srcVal = dataList.pop();
	uint32 destVal;

	while (outIndex > 0) {
		uint32 numBits = 0;
		int count = 0;

		if (getBit(dataList, srcVal)) {
			destVal = copyBits(dataList, srcVal, 2);

			if (destVal < 2) {
				count = destVal + 2;
				destVal = copyBits(dataList, srcVal, destVal + 9);
				transferLoop(dataOut, outIndex, destVal, count);
				continue;
			} else if (destVal != 3) {
				count = copyBits(dataList, srcVal, 8);
				destVal = copyBits(dataList, srcVal, 8);
				transferLoop(dataOut, outIndex, destVal, count);
				continue;
			} else {
				numBits = 8;
				count = 8;
			}
		} else if (getBit(dataList, srcVal)) {
			destVal = copyBits(dataList, srcVal, 8);
			transferLoop(dataOut, outIndex, destVal, 1);
			continue;
		} else {
			numBits = 3;
			count = 0;
		}

		destVal = copyBits(dataList, srcVal, numBits);
		count += destVal;

		// Loop through extracting specified number of bytes
		for (int i = 0; i <= count; ++i) {
			// Shift 8 bits from the source to the destination
			for (int bitCtr = 0; bitCtr < 8; ++bitCtr) {
				bool flag = getBit(dataList, srcVal);
				destVal = (destVal << 1) | (flag ? 1 : 0);
			}

			dataOut[--outIndex] = destVal & 0xff;
		}
	}
}

void AGOSEngine::loadVGABeardFile(uint16 id) {
	uint32 offs, size;

	if (getFeatures() & GF_OLD_BUNDLE) {
		Common::File in;
		char filename[15];
		if (id == 23)
			id = 112;
		else if (id == 328)
			id = 119;

		if (getPlatform() == Common::kPlatformAmiga) {
			if (getFeatures() & GF_TALKIE)
				Common::sprintf_s(filename, "0%d.out", id);
			else
				Common::sprintf_s(filename, "0%d.pkd", id);
		} else if (getPlatform() == Common::kPlatformAcorn) {
			Common::sprintf_s(filename, "%.2d/0%d", id / 100, id);
		} else {
			Common::sprintf_s(filename, "0%d.VGA", id);
		}

		if (!in.open(filename))
			error("loadSimonVGAFile: Can't load %s", filename);

		size = in.size();
		if (getFeatures() & GF_CRUNCHED) {
			byte *srcBuffer = (byte *)malloc(size);
			if (in.read(srcBuffer, size) != size)
				error("loadSimonVGAFile: Read failed");
			decrunchFile(srcBuffer, _vgaBufferPointers[11].vgaFile2, size);
			free(srcBuffer);
		} else {
			if (in.read(_vgaBufferPointers[11].vgaFile2, size) != size)
				error("loadSimonVGAFile: Read failed");
		}
	} else {
		offs = _gameOffsetsPtr[id];
		size = _gameOffsetsPtr[id + 1] - offs;
		readGameFile(_vgaBufferPointers[11].vgaFile2, offs, size);
	}
}

uint8 safeReadByte(const uint8 *&src, const uint8 *end) {
	if (src < end)
		return (*src++);
	error("decodePak98(): invalid data");
	return 0;
}

uint16 safeReadWord(const uint8 *&src, const uint8 *end) {
	uint8 lo = safeReadByte(src, end);
	return (safeReadByte(src, end) << 8) | lo;
}

#define S_NEXTBYTE safeReadByte(src, endSrc)
#define S_NEXTWORD safeReadWord(src, endSrc)

void decodePak98(uint8 *dst, uint32 outSize, const uint8 *src, uint32 inSize) {
	const uint8 *end = dst + outSize;
	const uint8 *endSrc = src + inSize;
	uint8 state = 0x80;
	uint8 flg = S_NEXTBYTE;

	for (uint32 srcBytesLeft = inSize - 1; srcBytesLeft; ) {
		if (state & flg) {
			if (dst < end)
				*dst++ = S_NEXTBYTE;
			--srcBytesLeft;
		} else {
			srcBytesLeft -= 2;
			uint16 cmd2 = S_NEXTWORD;
			uint8 cmd3 = cmd2 & 0x0F;
			cmd2 >>= 4;

			if (cmd2 == 0) {
				uint16 count = cmd3 + 4;
				--srcBytesLeft;
				if (cmd3 == 0x0F) {
					count = S_NEXTWORD;
					srcBytesLeft -= 2;
				} else if (cmd3 == 0x0E) {
					count = 18 + (S_NEXTBYTE);
					--srcBytesLeft;
				}

				uint8 destVal = S_NEXTBYTE;
				while (count-- && dst < end)
					*dst++ = destVal;

			} else if (cmd2 == 1) {
				uint16 count = cmd3 + 3;
				if (cmd3 == 0x0F) {
					count = S_NEXTWORD;
					srcBytesLeft -= 2;
				} else if (cmd3 == 0x0E) {
					count = 17 + (S_NEXTBYTE);
					--srcBytesLeft;
				}

				dst += count;

			} else if (cmd2 == 2) {
				uint16 count = cmd3 + 16;
				if (cmd3 == 0x0F) {
					count = S_NEXTWORD;
					srcBytesLeft -= 2;
				} else if (cmd3 == 0x0E) {
					count = 30 + (S_NEXTBYTE);
					--srcBytesLeft;
				}

				srcBytesLeft -= count;
				while (count-- && dst < end)
					*dst++ = S_NEXTBYTE;

			} else {
				uint16 count = cmd3 + 3;
				if (cmd3 == 0x0F) {
					count = 18 + (S_NEXTBYTE);
					--srcBytesLeft;
				}

				const uint8 *src2 = dst - cmd2;
				while (count-- && dst < end)
					*dst++ = *src2++;
			}
		}

		if (!(state >>= 1)) {
			state = 0x80;
			if (srcBytesLeft) {
				flg = S_NEXTBYTE;
				srcBytesLeft--;
			}
		}
	}
}

#undef S_NEXTBYTE
#undef S_NEXTWORD

void AGOSEngine::loadVGAVideoFile(uint16 id, uint8 type, bool useError) {
	Common::File in;
	char filename[15];
	byte *dst;
	uint32 file, offs, srcSize, dstSize;
	uint extraBuffer = 0;

	if ((getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) &&
		id == 2 && type == 2) {
		// WORKAROUND: For the extra long strings in foreign languages
		// Allocate more space for text to cope with foreign languages that use
		// up more space than English. I hope 6400 bytes are enough. This number
		// is base on: 2 (lines) * 320 (screen width) * 10 (textheight) -- olki
		extraBuffer += 6400;
	}

	if (getFeatures() & GF_ZLIBCOMP) {
		loadOffsets(getFileName(GAME_GFXIDXFILE), id * 3 + type, file, offs, srcSize, dstSize);

		if (getPlatform() == Common::kPlatformAmiga)
			Common::sprintf_s(filename, "GFX%d.VGA", file);
		else
			Common::sprintf_s(filename, "graphics.vga");

		dst = allocBlock(dstSize + extraBuffer);
		decompressData(filename, dst, offs, srcSize, dstSize);
	} else if (getFeatures() & GF_OLD_BUNDLE) {
		if (getPlatform() == Common::kPlatformAcorn) {
			Common::sprintf_s(filename, "%.2d/%.3d%d", id / 10, id, type);
		} else if (getPlatform() == Common::kPlatformAmiga || getPlatform() == Common::kPlatformAtariST) {
			if (getFeatures() & GF_TALKIE) {
				Common::sprintf_s(filename, "%.3d%d.out", id, type);
			} else if (getGameType() == GType_ELVIRA1 && getFeatures() & GF_DEMO) {
				if (getPlatform() == Common::kPlatformAtariST)
					Common::sprintf_s(filename, "%.2d%d.out", id, type);
				else
					Common::sprintf_s(filename, "%c%d.out", 48 + id, type);
			} else if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2) {
				Common::sprintf_s(filename, "%.2d%d.pkd", id, type);
			} else if (getGameType() == GType_PN) {
				Common::sprintf_s(filename, "%c%d.in", id + 48, type);
			} else {
				Common::sprintf_s(filename, "%.3d%d.pkd", id, type);
			}
		} else {
			if (getGameType() == GType_ELVIRA1 && getPlatform() == Common::kPlatformPC98) {
				Common::sprintf_s(filename, "%.2d.GR2", id);
			} else if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) {
				Common::sprintf_s(filename, "%.2d%d.VGA", id, type);
			} else if (getGameType() == GType_PN) {
				Common::sprintf_s(filename, "%c%d.out", id + 48, type);
			} else {
				Common::sprintf_s(filename, "%.3d%d.VGA", id, type);
			}
		}

		if (!in.open(filename)) {
			if (useError)
				error("loadVGAVideoFile: Can't load %s", filename);

			_block = _blockEnd = nullptr;
			return;
		}

		dstSize = srcSize = in.size();
		if (getGameType() == GType_PN && getPlatform() == Common::kPlatformDOS && id == 17 && type == 2) {
			// The A2.out file isn't compressed in PC version of Personal Nightmare
			dst = allocBlock(dstSize + extraBuffer);
			if (in.read(dst, dstSize) != dstSize)
				error("loadVGAVideoFile: Read failed");
		} else if (getGameType() == GType_PN && (getFeatures() & GF_CRUNCHED)) {
			Common::Stack<uint32> data;
			byte *dataOut = nullptr;
			int dataOutSize = 0;

			for (uint i = 0; i < srcSize / 4; ++i) {
				uint32 dataVal = in.readUint32BE();
				// Correct incorrect byte, in corrupt 72.out file, included in some PC versions.
				if (dataVal == 168042714)
					data.push(168050906);
				else
					data.push(dataVal);
			}

			decompressPN(data, dataOut, dataOutSize);
			dst = allocBlock (dataOutSize + extraBuffer);
			memcpy(dst, dataOut, dataOutSize);
			delete[] dataOut;
		} else if (getFeatures() & GF_CRUNCHED) {
			byte *srcBuffer = (byte *)malloc(srcSize);
			if (in.read(srcBuffer, srcSize) != srcSize)
				error("loadVGAVideoFile: Read failed");

			dstSize = READ_BE_UINT32(srcBuffer + srcSize - 4);
			dst = allocBlock (dstSize + extraBuffer);
			decrunchFile(srcBuffer, dst, srcSize);
			free(srcBuffer);
		} else if (getPlatform() == Common::kPlatformPC98) {
			bool compressed = (in.readUint16LE() == 1);
			srcSize = in.readUint32LE();
			if (type == 1) {
				if (compressed)
					srcSize = in.readUint32LE() + 2;
				in.seek(srcSize, SEEK_CUR);
				compressed = (in.readUint16LE() == 1);
				srcSize = in.readUint32LE();
			}

			if (compressed) {
				dstSize = srcSize;
				srcSize = in.readUint32LE();
				uint16 fill = in.readUint16LE();
				dst = allocBlock(dstSize);

				Common::fill<uint16*, uint16>((uint16*)dst, (uint16*)(dst + (dstSize & ~1)), TO_LE_16(fill));
				if (dstSize & 1)
					*(dst + dstSize - 1) = fill & 0xff;

				if (srcSize) {
					uint8 *srcBuffer = new uint8[srcSize];
					if (in.read(srcBuffer, srcSize) != srcSize)
						error("loadVGAVideoFile: Read failed");
					decodePak98(dst, dstSize, srcBuffer, srcSize);
					delete[] srcBuffer;
				}
			} else {
				dstSize = srcSize;
				dst = allocBlock(dstSize + extraBuffer);
				if (in.read(dst, dstSize) != dstSize)
					error("loadVGAVideoFile: Read failed");
			}
		} else {
			dst = allocBlock(dstSize + extraBuffer);
			if (in.read(dst, dstSize) != dstSize)
				error("loadVGAVideoFile: Read failed");
		}
	} else {
		id = id * 2 + (type - 1);
		offs = _gameOffsetsPtr[id];
		dstSize = _gameOffsetsPtr[id + 1] - offs;

		if (!dstSize) {
			if (useError)
				error("loadVGAVideoFile: Can't load id %d type %d", id, type);

			_block = _blockEnd = nullptr;
			return;
		}

		dst = allocBlock(dstSize + extraBuffer);
		readGameFile(dst, offs, dstSize);
	}
}

Common::SeekableReadStream *AGOSEngine::createPak98FileStream(const char *filename) {
	Common::File in;
	if (!in.open(filename))
		return nullptr;

	/*uint16 cmpType = */in.readUint16LE();
	uint32 outSize = in.readUint32LE();
	uint32 inSize = in.readUint32LE();
	uint16 fill = in.readUint16LE();

	uint8 *decBuffer = (uint8*)malloc(outSize);
	Common::fill<uint16*, uint16>((uint16*)decBuffer, (uint16*)(decBuffer + (outSize & ~1)), TO_LE_16(fill));
	if (outSize & 1)
		*(decBuffer + outSize - 1) = fill & 0xff;

	if (inSize) {
		uint8 *tempBuffer = new uint8[inSize];
		in.read(tempBuffer, inSize);
		decodePak98(decBuffer, outSize, tempBuffer, inSize);
		delete[] tempBuffer;
	}

	return new Common::MemoryReadStream(decBuffer, outSize, DisposeAfterUse::YES);
}

void AGOSEngine::convertPC98Image(VC10_state &state) {
	if (state.flags & (kDFCompressedFlip | kDFCompressed)) {
		const byte *src = state.srcPtr;
		uint32 outSize = READ_LE_UINT32(src + 2);
		assert(outSize >= (uint32)((state.width << 3) * state.height));
		uint32 inSize = READ_LE_UINT32(src + 6);
		uint16 fill = READ_LE_UINT16(src + 10);
		delete[] _pak98Buf;
		byte *decBuffer = new uint8[outSize];
		Common::fill<uint16*, uint16>((uint16*)decBuffer, (uint16*)(decBuffer + (outSize & ~1)), TO_LE_16(fill));
		if (outSize & 1)
			*(decBuffer + outSize - 1) = fill & 0xff;
		if (inSize)
			decodePak98(decBuffer, outSize, src + 12, inSize);
		_pak98Buf = state.srcPtr = decBuffer;
		_paletteModNext = 0;
	}

	// The PC-98 images are in a planar format, but slightly different from the Amiga format. It does
	// not make much sense to set the GF_PLANAR flag, since the Amiga code can't be used anyway.
	free(_planarBuf);
	uint16 planeLW = state.width << 1;
	uint16 planePitch = planeLW * 3;

	_planarBuf = (byte*)malloc((state.width << 3) * state.height);

	const byte *src[4];
	memset(src, 0, sizeof(src));
	for (int i = 0; i < 4; ++i)
		src[i] = state.srcPtr + i * planeLW;
	byte *dst = _planarBuf;

	for (int y = 0; y < state.height; ++y) {
		for (int x = 0; x < planeLW; ++x) {
			for (int i = 0; i <= 6; i += 2) {
				byte col = 0;
				for (int ii = 0; ii < 4; ++ii) {
					col |= ((*src[ii] >> (7 - i)) & 1) << (ii + 4);
					col |= ((*src[ii] >> (6 - i)) & 1) << ii;
				}
				*dst++ = col;
			}
			for (int ii = 0; ii < 4; ++ii)
				++src[ii];
		}
		for (int ii = 0; ii < 4; ++ii)
			src[ii] += planePitch;
	}

	state.srcPtr = _planarBuf;
	if (state.flags & kDFCompressedFlip)
		state.flags |= kDFFlip;
	state.flags &= ~(kDFCompressedFlip | kDFCompressed);
}

} // End of namespace AGOS

================
File: res_ami.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Conversion routines for planar graphics in Amiga versions


#include "agos/agos.h"
#include "agos/intern.h"

#include "common/endian.h"

namespace AGOS {

enum {
	kMaxColorDepth = 5
};

static void uncompressPlane(const byte *plane, byte *outptr, int length) {
	while (length != 0) {
		int wordlen;
		signed char x = *plane++;
		if (x >= 0) {
			wordlen = MIN<int>(x + 1, length);
			uint16 w = READ_UINT16(plane); plane += 2;
			for (int i = 0; i < wordlen; ++i) {
				WRITE_UINT16(outptr, w); outptr += 2;
			}
		} else {
			wordlen = MIN<int>(-x, length);
			memcpy(outptr, plane, wordlen * 2);
			outptr += wordlen * 2;
			plane += wordlen * 2;
		}
		length -= wordlen;
	}
}

static void bitplaneToChunky(uint16 *w, uint8 colorDepth, uint8 *&dst) {
	for (int j = 0; j < 8; j++) {
		byte color1 = 0;
		byte color2 = 0;
		for (int p = 0; p < colorDepth; ++p) {
			if (w[p] & 0x8000) {
				color1 |= 1 << p;
			}
			if (w[p] & 0x4000) {
				color2 |= 1 << p;
			}
			w[p] <<= 2;
		}
		if (colorDepth > 4) {
			*dst++ = color1;
			*dst++ = color2;
		} else {
			*dst++ = (color1 << 4) | color2;
		}
	}
}

static void bitplaneToChunkyText(uint16 *w, uint8 colorDepth, uint8 *&dst) {
	for (int j = 0; j < 16; j++) {
		byte color = 0;
		for (int p = 0; p < colorDepth; ++p) {
			if (w[p] & 0x8000) {
				color |= 1 << p;
			}
			w[p] <<= 1;
		}
		if (color)
			color |= 0xC0;
		*dst++ = color;
	}
}

static void convertCompressedImage(const byte *src, byte *dst, uint8 colorDepth, int height, int width, bool horizontal = true) {
	const byte *plane[kMaxColorDepth];
	byte *uncptr[kMaxColorDepth];
	int length, i, j;

	byte *uncbfrout = (byte *)malloc(width * height);

	length = (width + 15) / 16 * height;

	for (i = 0; i < colorDepth; ++i) {
		plane[i] = src + READ_BE_UINT16(src + i * 4) + READ_BE_UINT16(src + i * 4 + 2);
		uncptr[i] = (uint8 *)malloc(length * 2);
		uncompressPlane(plane[i], uncptr[i], length);
		plane[i] = uncptr[i];
	}

	byte *uncbfroutptr = uncbfrout;
	for (i = 0; i < length; ++i) {
		uint16 w[kMaxColorDepth];
		for (j = 0; j < colorDepth; ++j) {
			w[j] = READ_BE_UINT16(plane[j]); plane[j] += 2;
		}
		bitplaneToChunky(w, colorDepth, uncbfroutptr);
	}

	uncbfroutptr = uncbfrout;
	const int chunkSize = colorDepth > 4 ? 16 : 8;
	if (horizontal) {
		for (j = 0; j < height; ++j) {
			for (i = 0; i < width / 16; ++i) {
				memcpy(dst + width * chunkSize / 16 * j + chunkSize * i, uncbfroutptr, chunkSize);
				uncbfroutptr += chunkSize;
			}
		}
	} else {
		for (i = 0; i < width / 16; ++i) {
			for (j = 0; j < height; ++j) {
				memcpy(dst + width * chunkSize / 16 * j + chunkSize * i, uncbfroutptr, chunkSize);
				uncbfroutptr += chunkSize;
			}
		}
	}

	free(uncbfrout);
	for (i = 0; i < colorDepth; ++i) {
		free(uncptr[i]);
	}
}

byte *AGOSEngine::convertAmigaImage(VC10_state *state, bool compressed) {
	int length, i, j;

	uint8 colorDepth = 4;
	if (getGameType() == GType_SIMON1) {
		if (((_videoLockOut & 0x20) && !state->palette) || ((getFeatures() & GF_32COLOR) &&
			state->palette != 0xC0)) {
			colorDepth = 5;
		}
	}

	const byte *src = state->srcPtr;
	int width = state->width * 16;
	int height = state->height;

	free(_planarBuf);
	_planarBuf = (byte *)malloc(width * height);
	byte *dst = _planarBuf;

	if (compressed) {
		convertCompressedImage(src, dst, colorDepth, height, width, (getGameType() == GType_PN));
	} else {
		length = (width + 15) / 16 * height;
		for (i = 0; i < length; i++) {
			uint16 w[kMaxColorDepth];
			if (getGameType() == GType_SIMON1 && colorDepth == 4) {
				for (j = 0; j < colorDepth; ++j) {
					w[j] = READ_BE_UINT16(src + j * length * 2);
				}
				if (state->palette == 0xC0) {
					bitplaneToChunkyText(w, colorDepth, dst);
				} else {
					bitplaneToChunky(w, colorDepth, dst);
				}
				src += 2;
			} else {
				for (j = 0; j < colorDepth; ++j) {
					w[j] = READ_BE_UINT16(src); src += 2;
				}
				bitplaneToChunky(w, colorDepth, dst);
			}
		}
	}

	return _planarBuf;
}

} // End of namespace AGOS

================
File: res_snd.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/config-manager.h"
#include "common/file.h"
#include "common/memstream.h"
#include "common/textconsole.h"

#include "agos/intern.h"
#include "agos/agos.h"
#include "agos/midi.h"
#include "agos/sound.h"
#include "agos/vga.h"

#include "backends/audiocd/audiocd.h"

#include "audio/audiostream.h"
#include "audio/mods/protracker.h"

namespace AGOS {

// This data is hardcoded in the executable.
const int AGOSEngine_Simon1::SIMON1_GMF_SIZE[] = {
	8900, 12166,  2848,  3442,  4034,  4508,  7064,  9730,  6014,  4742,
	3138,  6570,  5384,  8909,  6457, 16321,  2742,  8968,  4804,  8442,
	7717,  9444,  5800,  1381,  5660,  6684,  2456,  4744,  2455,  1177,
	1232, 17256,  5103,  8794,  4884,    16
};

// High nibble is the file ID (STINGSx.MUS), low nibble is the SFX number
// in the file (0 based).
const byte AGOSEngine::SIMON1_RHYTHM_SFX[] = {
	0x15, 0x16, 0x2C, 0x31, 0x37, 0x3A, 0x42, 0x43, 0x44,
	0x51, 0x55, 0x61, 0x68, 0x74, 0x78, 0x83, 0x89, 0x90
};

void AGOSEngine_Simon1::playSpeech(uint16 speech_id, uint16 vgaSpriteId) {
	if (speech_id == 9999) {
		if (_subtitles)
			return;
		if (!getBitFlag(14) && !getBitFlag(28)) {
			setBitFlag(14, true);
			_variableArray[100] = 15;
			animate(4, 1, 130, 0, 0, 0);
			waitForSync(130);
		}
		_skipVgaWait = true;
	} else {
		if (_subtitles && _scriptVar2) {
			animate(4, 2, 204, 0, 0, 0);
			waitForSync(204);
			stopAnimate(204);
		}
		if (vgaSpriteId < 100)
			stopAnimate(201 + vgaSpriteId);

		loadVoice(speech_id);

		if (vgaSpriteId < 100)
			animate(4, 2, 201 + vgaSpriteId, 0, 0, 0);
	}
}

void AGOSEngine_Simon2::playSpeech(uint16 speech_id, uint16 vgaSpriteId) {
	if (speech_id == 0xFFFF) {
		if (_subtitles)
			return;
		if (!getBitFlag(14) && !getBitFlag(28)) {
			setBitFlag(14, true);
			_variableArray[100] = 5;
			animate(4, 1, 30, 0, 0, 0);
			waitForSync(130);
		}
		_skipVgaWait = true;
	} else {
		if (getGameType() == GType_SIMON2 && _subtitles && _language != Common::HE_ISR) {
			loadVoice(speech_id);
			return;
		}

		if (_subtitles && _scriptVar2) {
			animate(4, 2, 5, 0, 0, 0);
			waitForSync(205);
			stopAnimateSimon2(2,5);
		}

		stopAnimateSimon2(2, vgaSpriteId + 2);
		loadVoice(speech_id);
		animate(4, 2, vgaSpriteId + 2, 0, 0, 0);
	}
}

void AGOSEngine::skipSpeech() {
	_sound->stopVoice();
	if (!getBitFlag(28)) {
		setBitFlag(14, true);
		if (getGameType() == GType_FF) {
			_variableArray[103] = 5;
			animate(4, 2, 13, 0, 0, 0);
			waitForSync(213);
			stopAnimateSimon2(2, 1);
		} else if (getGameType() == GType_SIMON2) {
			_variableArray[100] = 5;
			animate(4, 1, 30, 0, 0, 0);
			waitForSync(130);
			stopAnimateSimon2(2, 1);
		} else {
			_variableArray[100] = 15;
			animate(4, 1, 130, 0, 0, 0);
			waitForSync(130);
			stopAnimate(1);
		}
	}
}

void AGOSEngine::loadMusic(uint16 music, bool forceSimon2GmData, bool useSimon2Remapping) {
	stopMusic();

	debug(1, "AGOSEngine::loadMusic(music=%d, forceSimon2GmData=%d, useSimon2Remapping=%d)", music, forceSimon2GmData, useSimon2Remapping);

	uint16 indexBase = forceSimon2GmData ? MUSIC_INDEX_BASE_SIMON2_GM : _musicIndexBase;

	_gameFile->seek(_gameOffsetsPtr[indexBase + music - 1], SEEK_SET);
	_midi->load(_gameFile);

	// Activate Simon 2 GM to MT-32 remapping if we force GM, otherwise
	// deactivate it (in case it was previously activated).
	_midi->setSimon2Remapping(useSimon2Remapping);

	_lastMusicPlayed = music;
	_nextMusicToPlay = -1;
}

struct ModuleOffs {
	uint8 tune;
	uint8 fileNum;
	uint32 offs;
};

static const ModuleOffs amigaWaxworksOffs[20] = {
	// Pyramid
	{2,   2, 0,   },
	{3,   2, 50980},
	{4,   2, 56160},
	{5,   2, 62364},
	{6,   2, 73688},

	// Zombie
	{8,   8, 0},
	{11,  8, 51156},
	{12,  8, 56336},
	{13,  8, 65612},
	{14,  8, 68744},

	// Mine
	{9,   9, 0},
	{15,  9, 47244},
	{16,  9, 52424},
	{17,  9, 59652},
	{18,  9, 62784},

	// Jack
	{10, 10, 0},
	{19, 10, 42054},
	{20, 10, 47234},
	{21, 10, 49342},
	{22, 10, 51450},
};

void AGOSEngine::playModule(uint16 music) {
	char filename[15];
	Common::File f;
	uint32 offs = 0;

	if (getPlatform() == Common::kPlatformAmiga && getGameType() == GType_WW) {
		// Multiple tunes are stored in music files for main locations
		for (uint i = 0; i < 20; i++) {
			if (amigaWaxworksOffs[i].tune == music) {
				music = amigaWaxworksOffs[i].fileNum;
				offs = amigaWaxworksOffs[i].offs;
			}
		}
	}

	if (getGameType() == GType_ELVIRA1 && getFeatures() & GF_DEMO)
		Common::sprintf_s(filename, "elvira2");
	else
		Common::sprintf_s(filename, "%dtune", music);

	f.open(filename);
	if (f.isOpen() == false) {
		error("playModule: Can't load module from '%s'", filename);
	}

	Audio::AudioStream *audioStream;
	if (!(getGameType() == GType_ELVIRA1 && getFeatures() & GF_DEMO) &&
		getFeatures() & GF_CRUNCHED) {

		uint32 srcSize = f.size();
		byte *srcBuf = (byte *)malloc(srcSize);
		if (f.read(srcBuf, srcSize) != srcSize)
			error("playModule: Read failed");

		uint32 dstSize = READ_BE_UINT32(srcBuf + srcSize - 4);
		byte *dstBuf = (byte *)malloc(dstSize);
		decrunchFile(srcBuf, dstBuf, srcSize);
		free(srcBuf);

		Common::MemoryReadStream stream(dstBuf, dstSize);
		audioStream = Audio::makeProtrackerStream(&stream, offs);
		free(dstBuf);
	} else {
		audioStream = Audio::makeProtrackerStream(&f);
	}

	_mixer->playStream(Audio::Mixer::kMusicSoundType, &_modHandle, audioStream);
}

void AGOSEngine_Simon2::playMusic(uint16 music, uint16 track) {
	debug(1, "AGOSEngine_Simon2::loadMusic(music=%d, track=%d)", music, track);

	if (_lastMusicPlayed == 10 && getPlatform() == Common::kPlatformDOS && _midi->usesMT32Data()) {
		// WORKAROUND Simon 2 track 10 (played during the first intro scene)
		// consist of 3 subtracks. Subtracks 2 and 3 are missing from the MT-32
		// MIDI data. The original interpreter just stops playing after track 1
		// and does not restart until the next scene.
		// We fix this by loading the GM version of track 10 and remapping the
		// instruments to MT-32.
		// The 25th Anniversary Editions of the game attempted to fix this
		// problem by replacing the track 10 MT-32 data with the track 10 GM
		// data. For these versions, we can just load the MT-32 data. However,
		// we now have to remap instruments for all subtracks.

		// Reload track 10 using GM data (if necessary) and activate instrument
		// remapping.
		bool track10Fix = getFeatures() & GF_MT32_TRACK10_FIX;
		loadMusic(10, !track10Fix && track > 0, track10Fix || track > 0);
	}

#ifdef USE_VORBIS
		Common::String trackName;

		if (track)
			Common::String::format("OGG/track%02d-%d", _lastMusicPlayed, track);
		else
			Common::String::format("OGG/track%02d", _lastMusicPlayed);

		_digitalMusicStream = Audio::SeekableAudioStream::openStreamFile(trackName.c_str());
		if (_digitalMusicStream) {
			_mixer->playStream(Audio::Mixer::kMusicSoundType, &_digitalMusicHandle, _digitalMusicStream);

			debug(1, "AGOSEngine_Simon2::playMusic(): Playing %s", trackName.c_str());

			return;
		}
#endif
	_midi->play(track);
}

void AGOSEngine_Simon1::playMusic(uint16 music, uint16 track) {
	stopMusic();

	if (getPlatform() != Common::kPlatformAmiga && (getFeatures() & GF_TALKIE) && music == 35) {
		// WORKAROUND: For a script bug in the CD versions
		// We skip this music resource, as it was replaced by
		// a sound effect, and the script was never updated.
		return;
	}

	// Support for compressed music from the ScummVM Music Enhancement Project
	_system->getAudioCDManager()->stop();
	_system->getAudioCDManager()->play(music + 1, -1, 0, 0, true);
	if (_system->getAudioCDManager()->isPlaying())
		return;

	if (getPlatform() == Common::kPlatformAmiga) {
		playModule(music);
	} else if ((getPlatform() == Common::kPlatformDOS || getPlatform() == Common::kPlatformAcorn) &&
			getFeatures() & GF_TALKIE) {
		// DOS CD and Acorn CD use the same music data.

		// Data is stored in one large data file and the GMF format does not
		// have an indication of size or end of data, so the data size has to
		// be supplied from a hardcoded list.
		int size = SIMON1_GMF_SIZE[music];

		_gameFile->seek(_gameOffsetsPtr[_musicIndexBase + music], SEEK_SET);
		_midi->load(_gameFile, size);
		_midi->play();
	} else if (getPlatform() == Common::kPlatformDOS) {
		// DOS floppy version.

		// GMF music data is in separate MODxx.MUS files.
		char filename[15];
		Common::File f;
		Common::sprintf_s(filename, "MOD%d.MUS", music);
		f.open(filename);
		if (f.isOpen() == false)
			error("playMusic: Can't load music from '%s'", filename);

		_midi->load(&f, f.size());
		if (getFeatures() & GF_DEMO) {
			// Full version music data has a loop flag in the file header, but
			// the demo needs to have this set manually.
			_midi->setLoop(true);
		}

		_midi->play();
	} else if (getPlatform() == Common::kPlatformWindows) {
		// Windows version uses SMF data in one large data file.
		_gameFile->seek(_gameOffsetsPtr[_musicIndexBase + music], SEEK_SET);

		_midi->load(_gameFile);
		_midi->setLoop(true);

		_midi->play();
	} else if (getPlatform() == Common::kPlatformAcorn) {
		// Acorn floppy version.

		// TODO: Add support for Desktop Tracker format in Acorn disk version
	}
}

void AGOSEngine_Simon1::playMidiSfx(uint16 sound) {
	// The sound effects in floppy disk version of
	// Simon the Sorcerer 1 are only meant for AdLib
	if (!_midi->hasMidiSfx())
		return;

	// AdLib SFX use GMF data bundled in 9 STINGSx.MUS files.
	char filename[16];
	Common::File mus_file;

	Common::sprintf_s(filename, "STINGS%i.MUS", _soundFileId);
	mus_file.open(filename);
	if (!mus_file.isOpen())
		error("playSting: Can't load sound effect from '%s'", filename);

	// WORKAROUND Some Simon 1 DOS floppy SFX use the OPL rhythm instruments.
	// This can conflict with the music using the rhythm instruments, so the
	// original interpreter disables the music rhythm notes while a sound
	// effect is playing. However, only some sound effects use rhythm notes, so
	// in many cases this is not needed and leads to the music drums needlessly
	// being disabled.
	// To improve this, the sound effect number is checked against a list of
	// SFX using rhythm notes, and only if it is in the list the music drums
	// will be disabled while it plays.
	bool rhythmSfx = false;
	// Search for the file ID / SFX ID combination in the list of SFX that use
	// rhythm notes.
	byte sfxId = (_soundFileId << 4) | sound;
	for (int i = 0; i < ARRAYSIZE(SIMON1_RHYTHM_SFX); i++) {
		if (SIMON1_RHYTHM_SFX[i] == sfxId) {
			rhythmSfx = true;
			break;
		}
	}

	_midi->stop(true);

	_midi->load(&mus_file, mus_file.size(), true);
	_midi->play(sound, true, rhythmSfx);
}

void AGOSEngine::playMusic(uint16 music, uint16 track) {
	stopMusic();

	if (getPlatform() == Common::kPlatformAmiga) {
		playModule(music);
	} else if (getPlatform() == Common::kPlatformAtariST) {
		// TODO: Add support for music formats used
	} else {
		_midi->setLoop(true); // Must do this BEFORE loading music.

		Common::SeekableReadStream *str = nullptr;
		if (getPlatform() == Common::kPlatformPC98) {
			str = createPak98FileStream(Common::String::format("MOD%d.PAK", music).c_str());
			if (!str)
				error("playMusic: Can't load music from 'MOD%d.PAK'", music);
		} else {
			Common::File *file = new Common::File();
			if (!file->open(Common::Path(Common::String::format("MOD%d.MUS", music))))
				error("playMusic: Can't load music from 'MOD%d.MUS'", music);
			str = file;
		}

		//warning("Playing track %d", music);
		_midi->load(str);
		_midi->play();
		delete str;
	}
}

void AGOSEngine::stopMusic() {
	if (_midiEnabled) {
		_midi->stop();
	}
	_mixer->stopHandle(_modHandle);
	_mixer->stopHandle(_digitalMusicHandle);

	debug(1, "AGOSEngine::stopMusic()");
}

static const byte elvira1_soundTable[100] = {
	0, 2, 0, 1, 0, 0, 0, 0, 0, 3,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 6, 4, 0, 0, 9, 0,
	0, 2, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 8, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 0, 0, 5, 0, 6, 6, 0, 0,
	0, 5, 0, 0, 6, 0, 0, 0, 0, 8,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
};

bool AGOSEngine::loadVGASoundFile(uint16 id, uint8 type) {
	Common::File in;
	char filename[15];
	byte *dst;
	uint32 srcSize, dstSize;

	if (getPlatform() == Common::kPlatformAmiga || getPlatform() == Common::kPlatformAtariST) {
		if (getGameType() == GType_ELVIRA1 && (getFeatures() & GF_DEMO) &&
			getPlatform() == Common::kPlatformAmiga) {
			Common::sprintf_s(filename, "%c%d.out", 48 + id, type);
		} else if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2) {
			Common::sprintf_s(filename, "%.2d%d.out", id, type);
		} else if (getGameType() == GType_PN) {
			Common::sprintf_s(filename, "%c%d.in", id + 48, type);
		} else {
			Common::sprintf_s(filename, "%.3d%d.out", id, type);
		}
	} else {
		if (getGameType() == GType_ELVIRA1) {
			if (elvira1_soundTable[id] == 0)
				return false;

			Common::sprintf_s(filename, "%.2d.SND", elvira1_soundTable[id]);
		} else if (getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) {
			Common::sprintf_s(filename, "%.2d%d.VGA", id, type);
		} else if (getGameType() == GType_PN) {
			Common::sprintf_s(filename, "%c%d.out", id + 48, type);
		} else {
			Common::sprintf_s(filename, "%.3d%d.VGA", id, type);
		}
	}

	in.open(filename);
	if (in.isOpen() == false || in.size() == 0) {
		return false;
	}

	dstSize = srcSize = in.size();
	if (getGameType() == GType_PN && (getFeatures() & GF_CRUNCHED)) {
		Common::Stack<uint32> data;
		byte *dataOut = nullptr;
		int dataOutSize = 0;

		for (uint i = 0; i < srcSize / 4; ++i)
			data.push(in.readUint32BE());

		decompressPN(data, dataOut, dataOutSize);
		dst = allocBlock (dataOutSize);
		memcpy(dst, dataOut, dataOutSize);
		delete[] dataOut;
	} else if (getGameType() == GType_ELVIRA1 && getFeatures() & GF_DEMO) {
		byte *srcBuffer = (byte *)malloc(srcSize);
		if (in.read(srcBuffer, srcSize) != srcSize)
			error("loadVGASoundFile: Read failed");

		dstSize = READ_BE_UINT32(srcBuffer + srcSize - 4);
		dst = allocBlock (dstSize);
		decrunchFile(srcBuffer, dst, srcSize);
		free(srcBuffer);
	} else {
		dst = allocBlock(dstSize);
		if (in.read(dst, dstSize) != dstSize)
			error("loadVGASoundFile: Read failed");
	}
	in.close();

	return true;
}

static const char *const dimpSoundList[32] = {
	"Beep",
	"Birth",
	"Boiling",
	"Burp",
	"Cough",
	"Die1",
	"Die2",
	"Fart",
	"Inject",
	"Killchik",
	"Puke",
	"Lights",
	"Shock",
	"Snore",
	"Snotty",
	"Whip",
	"Whistle",
	"Work1",
	"Work2",
	"Yawn",
	"And0w",
	"And0x",
	"And0y",
	"And0z",
	"And10",
	"And11",
	"And12",
	"And13",
	"And14",
	"And15",
	"And16",
	"And17",
};


void AGOSEngine::loadSoundFile(const char* filename) {
	Common::File in;
	if (!in.open(filename))
		error("loadSound: Can't load %s", filename);

	uint32 dstSize = in.size();
	byte *dst = (byte *)malloc(dstSize);
	if (in.read(dst, dstSize) != dstSize)
		error("loadSound: Read failed");

	_sound->playSfxData(dst, 0, 0, 0);
}

void AGOSEngine::loadSound(uint16 sound, int16 pan, int16 vol, uint16 type) {
	byte *dst;

	if (getGameId() == GID_DIMP) {
		Common::File in;
		char filename[15];

		assert(sound >= 1 && sound <= 32);
		Common::sprintf_s(filename, "%s.wav", dimpSoundList[sound - 1]);

		if (!in.open(filename))
			error("loadSound: Can't load %s", filename);

		uint32 dstSize = in.size();
		dst = (byte *)malloc(dstSize);
		if (in.read(dst, dstSize) != dstSize)
			error("loadSound: Read failed");
	} else if (getFeatures() & GF_ZLIBCOMP) {
		char filename[15];

		uint32 file, offset, srcSize, dstSize;
		if (getPlatform() == Common::kPlatformAmiga) {
			loadOffsets((const char*)"sfxindex.dat", _zoneNumber * 22 + sound, file, offset, srcSize, dstSize);
		} else {
			loadOffsets((const char*)"effects.wav", _zoneNumber * 22 + sound, file, offset, srcSize, dstSize);
		}

		if (getPlatform() == Common::kPlatformAmiga)
			Common::sprintf_s(filename, "sfx%u.wav", file);
		else
			Common::sprintf_s(filename, "effects.wav");

		dst = (byte *)malloc(dstSize);
		decompressData(filename, dst, offset, srcSize, dstSize);
	} else {
		if (_curSfxFile == nullptr)
			return;

		dst = _curSfxFile + READ_LE_UINT32(_curSfxFile + sound * 4);
	}

	if (type == Sound::TYPE_AMBIENT)
		_sound->playAmbientData(dst, sound, pan, vol);
	else if (type == Sound::TYPE_SFX)
		_sound->playSfxData(dst, sound, pan, vol);
	else if (type == Sound::TYPE_SFX5)
		_sound->playSfx5Data(dst, sound, pan, vol);
}

void AGOSEngine::playSfx(uint16 sound, uint16 freq, uint16 flags, bool digitalOnly, bool midiOnly) {
	if (_useDigitalSfx && !midiOnly) {
		loadSound(sound, freq, flags);
	} else if (!_useDigitalSfx && !digitalOnly) {
		playMidiSfx(sound);
	}
}

void AGOSEngine::loadSound(uint16 sound, uint16 freq, uint16 flags) {
	byte *dst;
	uint32 offs, size = 0;
	uint32 rate = 8000;

	if (_curSfxFile == nullptr)
		return;

	dst = _curSfxFile;
	if (getGameType() == GType_WW) {
		uint16 tmp = sound;

		while (tmp--) {
			size += READ_LE_UINT16(dst) + 4;
			dst += READ_LE_UINT16(dst) + 4;

			if (size > _curSfxFileSize)
				error("loadSound: Reading beyond EOF (%d, %d)", size, _curSfxFileSize);
		}

		size = READ_LE_UINT16(dst);
		offs = 4;
	} else if (getGameType() == GType_ELVIRA2) {
		while (READ_BE_UINT32(dst + 4) != sound) {
			size += 12;
			dst += 12;

			if (size > _curSfxFileSize)
				error("loadSound: Reading beyond EOF (%d, %d)", size, _curSfxFileSize);
		}

		size = READ_BE_UINT32(dst);
		offs = READ_BE_UINT32(dst + 8);
	} else {
		while (READ_BE_UINT16(dst + 6) != sound) {
			size += 12;
			dst += 12;

			if (size > _curSfxFileSize)
				error("loadSound: Reading beyond EOF (%d, %d)", size, _curSfxFileSize);
		}

		size = READ_BE_UINT16(dst + 2);
		offs = READ_BE_UINT32(dst + 8);
	}

	if (getGameType() == GType_PN) {
		if (freq == 0) {
			rate = 4600;
		} else if (freq == 1) {
			rate = 7400;
		} else {
			rate = 9400;
		}
	}

	// TODO: Handle other sound flags in Amiga/AtariST versions
	if (flags == 2 && _sound->isSfxActive()) {
		_sound->queueSound(dst + offs, sound, size, rate);
	} else {
		if (flags == 0)
			_sound->stopSfx();
		_sound->playRawData(dst + offs, sound, size, rate);
	}
}

void AGOSEngine::loadMidiSfx() {
	if (!_midi->hasMidiSfx())
		return;

	Common::File fxb_file;

	Common::String filename = getGameType() == GType_ELVIRA2 ? "MYLIB.FXB" : "WAX.FXB";
	fxb_file.open(Common::Path(filename));
	if (!fxb_file.isOpen())
		error("loadMidiSfx: Can't open sound effect bank '%s'", filename.c_str());

	_midi->load(&fxb_file, fxb_file.size(), true);

	fxb_file.close();
}

void AGOSEngine::playMidiSfx(uint16 sound) {
	if (!_midi->hasMidiSfx())
		return;

	_midi->play(sound, true);
}

void AGOSEngine::loadVoice(uint speechId) {
	if (getGameType() == GType_PP && speechId == 99) {
		_sound->stopVoice();
		return;
	}

	if (getFeatures() & GF_ZLIBCOMP) {
		char filename[15];

		uint32 file, offset, srcSize, dstSize;
		if (getPlatform() == Common::kPlatformAmiga) {
			loadOffsets((const char*)"spindex.dat", speechId, file, offset, srcSize, dstSize);
		} else {
			loadOffsets((const char*)"speech.wav", speechId, file, offset, srcSize, dstSize);
		}

		// Voice segment doesn't exist
		if (offset == 0xFFFFFFFF && srcSize == 0xFFFFFFFF && dstSize == 0xFFFFFFFF) {
			debug(0, "loadVoice: speechId %d removed", speechId);
			return;
		}

		if (getPlatform() == Common::kPlatformAmiga)
			Common::sprintf_s(filename, "sp%u.wav", file);
		else
			Common::sprintf_s(filename, "speech.wav");

		byte *dst = (byte *)malloc(dstSize);
		decompressData(filename, dst, offset, srcSize, dstSize);
		_sound->playVoiceData(dst, speechId);
	} else {
		_sound->playVoice(speechId);
	}
}

void AGOSEngine::stopAllSfx() {
	_sound->stopAllSfx();
	if (_midi->hasMidiSfx())
		_midi->stop(true);
}

} // End of namespace AGOS

================
File: rooms.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */



#include "common/file.h"
#include "common/textconsole.h"

#include "agos/agos.h"
#include "agos/intern.h"

namespace AGOS {

uint16 AGOSEngine::getBackExit(int n) {
	switch (n) {
	case 0:
		return 2;
	case 1:
		return 3;
	case 2:
		return 0;
	case 3:
		return 1;
	case 4:
		return 5;
	case 5:
		return 4;
	default:
		break;
	}

	return 0;
}

uint16 AGOSEngine::getDoorState(Item *item, uint16 d) {
	uint16 mask = 3;
	uint16 n;

	SubRoom *subRoom = (SubRoom *)findChildOfType(item, kRoomType);
	if (subRoom == nullptr)
		return 0;

	d <<= 1;
	mask <<= d;
	n = subRoom->roomExitStates & mask;
	n >>= d;

	return n;
}

uint16 AGOSEngine::getExitOf(Item *item, uint16 d) {
	SubRoom *subRoom;
	uint16 x;
	uint16 y = 0;

	subRoom = (SubRoom *)findChildOfType(item, kRoomType);
	if (subRoom == nullptr)
		return 0;
	x = d;
	while (x > y) {
		if (getDoorState(item, y) == 0)
			d--;
		y++;
	}
	return subRoom->roomExit[d];
}

void AGOSEngine::changeDoorState(SubRoom *r, uint16 d, uint16 n) {
	uint16 mask=3;
	d <<= 1;
	mask <<= d;
	n <<= d;
	r->roomExitStates &= ~mask;
	r->roomExitStates |= n;
}

void AGOSEngine::setDoorState(Item *i, uint16 d, uint16 n) {
	Item *j;
	SubRoom *r, *r1;
	uint16 d1;
	uint16 y = 0;

	r = (SubRoom *)findChildOfType(i, kRoomType);
	if (r == nullptr)
		return;
	d1 = d;
	while (d > y) {
		if (getDoorState(i, y) == 0)
			d1--;
		y++;
	}
	changeDoorState(r, d, n);

	j = derefItem(r->roomExit[d1]);
	if (j == nullptr)
		return;
	r1 = (SubRoom *)findChildOfType(j, kRoomType);
	if (r1 == nullptr)
		return;
	d = getBackExit(d);
	d1 = d;
	y = 0;
	while (d > y) {
		if (getDoorState(j, y) == 0)
			d1--;
		y++;
	}
	/* Check are a complete exit pair */
	if (derefItem(r1->roomExit[d1]) != i)
		return;
	/* Change state of exit coming back */
	changeDoorState(r1, d, n);
}

// Elvira 1 specific
Item *AGOSEngine::getDoorOf(Item *i, uint16 d) {
	SubGenExit *g;
	Item *x;

	g = (SubGenExit *)findChildOfType(i, kGenExitType);
	if (g == nullptr)
		return nullptr;

	x = derefItem(g->dest[d]);
	if (x == nullptr)
		return nullptr;
	if (isRoom(x))
		return nullptr;
	return x;
}

Item *AGOSEngine::getExitOf_e1(Item *item, uint16 d) {
	SubGenExit *g;
	Item *x;

	g = (SubGenExit *)findChildOfType(item, kGenExitType);
	if (g == nullptr)
		return nullptr;

	x = derefItem(g->dest[d]);
	if (x == nullptr)
		return nullptr;
	if (isRoom(x))
		return x;
	if (x->state != 0)
		return nullptr;
	return derefItem(x->parent);
}

void AGOSEngine_Waxworks::moveDirn(Item *i, uint x) {
	Item *d;
	uint16 n;

	if (i->parent == 0)
		return;

	n = getExitOf(derefItem(i->parent), x);
	if (derefItem(n) == nullptr) {
		loadRoomItems(n);
		n = getExitOf(derefItem(i->parent), x);
	}

	d = derefItem(n);
	if (d) {
		n = getDoorState(derefItem(i->parent), x);
		if (n == 1) {
			if (!canPlace(i, d))
				setItemParent(i, d);
		}
	}
}

void AGOSEngine_Elvira2::moveDirn(Item *i, uint x) {
	SubSuperRoom *sr;
	Item *d, *p;
	uint16 a, n;

	if (i->parent == 0)
		return;

	p = derefItem(i->parent);
	if (findChildOfType(p, kSuperRoomType)) {
		n = getExitState(p, _superRoomNumber,x);
		if (n == 1) {
			sr = (SubSuperRoom *)findChildOfType(p, kSuperRoomType);
			switch (x) {
			case 0: a = -(sr->roomX); break;
			case 1: a = 1; break;
			case 2: a = sr->roomX; break;
			case 3: a = 0xFFFF; break;
			case 4: a = -(sr->roomX * sr->roomY); break;
			case 5: a = (sr->roomX * sr->roomY); break;
			default: return;
			}
			_superRoomNumber += a;
		}
		return;
	}

	n = getExitOf(derefItem(i->parent), x);

	d = derefItem(n);
	if (d) {
		n = getDoorState(derefItem(i->parent), x);
		if (n == 1) {
			if (!canPlace(i, d))
				setItemParent(i, d);
		}
	}
}

void AGOSEngine::moveDirn(Item *i, uint x) {
	Item *d, *p;

	p = derefItem(i->parent);
	if (p == nullptr)
		return;


	d = getExitOf_e1(p, x);
	if (d) {
		if (canPlace(i, d))
			return;

		setItemParent(i, d);
		return;
	}

	d = getDoorOf(p, x);
	if (d) {
		const byte *name = getStringPtrByID(d->itemName, true);
		if (d->state == 1)
			showMessageFormat("%s is closed.\n", name);
		else
			showMessageFormat("%s is locked.\n", name);
		return;
	}

	showMessageFormat("You can't go that way.\n");
}

// Elvira 2 specific
int AGOSEngine_Elvira2::changeExitStates(SubSuperRoom *sr, int n, int d, uint16 s) {
	int b, bd;
	uint16 mask;

	switch (d) {
	case 0:
		b = -(sr->roomX);
		bd = 2;
		if (((n % (sr->roomX * sr->roomY)) / sr->roomX) == 0)
			return 0;
		else
			break;
	case 1:
		b = 1;
		bd = 3;
		if (((n % (sr->roomX * sr->roomY)) % sr->roomX) == 0)
			return 0;
		else
			break;
	case 2:
		b = sr->roomX;
		bd = 0;
		if (((n % (sr->roomX * sr->roomY)) / sr->roomX) == (sr->roomY - 1))
			return 0;
		else
			break;
	case 3:
		b = -1;
		bd = 1;
		if (((n % (sr->roomX * sr->roomY)) % sr->roomX) == 1)
			return 0;
		else
			break;
	case 4:
		b = -(sr->roomX * sr->roomY);
		bd = 5;
		if (n < (sr->roomX * sr->roomY))
			return 0;
		else
			break;
	case 5:
		b = sr->roomX * sr->roomY;
		bd = 4;
		if (n > (sr->roomX * sr->roomY * (sr->roomZ - 1)))
			return 0;
		else
			break;
	default:
		return 0;
	}

	n--;
	d <<= 1;
	mask = (3 << d);
	sr->roomExitStates[n] &= ~mask;
	sr->roomExitStates[n] |= (s << d);

	bd <<= 1;
	mask = (3 << bd);
	sr->roomExitStates[n + b] &= ~mask;
	sr->roomExitStates[n + b] |= (s << bd);
	return 1;
}

uint16 AGOSEngine_Elvira2::getExitState(Item *i, uint16 x, uint16 d) {
	SubSuperRoom *sr;
	uint16 mask = 3;
	uint16 n;

	sr = (SubSuperRoom *)findChildOfType(i, kSuperRoomType);
	if (sr == nullptr)
		return 0;

	d <<= 1;
	mask <<= d;
	n = sr->roomExitStates[x - 1] & mask;
	n >>= d;
	return n;
}

void AGOSEngine_Elvira2::setExitState(Item *i, uint16 n, uint16 d, uint16 s) {
	SubSuperRoom *sr = (SubSuperRoom *)findChildOfType(i, kSuperRoomType);
	if (sr)
		changeExitStates(sr, n, d, s);
}

void AGOSEngine_Elvira2::setSRExit(Item *i, int n, int d, uint16 s) {
	uint16 mask = 3;

	SubSuperRoom *sr = (SubSuperRoom *)findChildOfType(i, kSuperRoomType);
	if (sr) {
		n--;
		d <<= 1;
		mask <<= d;
		s <<= d;
		sr->roomExitStates[n] &= ~mask;
		sr->roomExitStates[n] |= s;
	}
}

// Waxworks specific
bool AGOSEngine::loadRoomItems(uint16 room) {
	byte *p;
	uint i, minNum, maxNum;
	char filename[30];
	Common::File in;
	Item *item, *itemTmp;

	if (_roomsList == nullptr)
		return 0;

	_currentRoom = room;
	room -= 2;

	if (_roomsListPtr) {
		p = _roomsListPtr;
		for (;;) {
			minNum = READ_BE_UINT16(p); p += 2;
			if (minNum == 0)
				break;

			maxNum = READ_BE_UINT16(p); p += 2;

			 for (uint16 z = minNum; z <= maxNum; z++) {
				uint16 itemNum = z + 2;
				item = derefItem(itemNum);
				_itemArrayPtr[itemNum] = nullptr;

				uint16 num = (itemNum - _itemArrayInited);
				_roomStates[num].state = item->state;
				_roomStates[num].classFlags = item->classFlags;
				SubRoom *subRoom = (SubRoom *)findChildOfType(item, kRoomType);
				_roomStates[num].roomExitStates = subRoom->roomExitStates;
			}
		}
	}

	p = _roomsList;
	while (*p) {
		for (i = 0; *p; p++, i++)
			filename[i] = *p;
		filename[i] = 0;
		p++;

		_roomsListPtr = p;

		for (;;) {
			minNum = READ_BE_UINT16(p); p += 2;
			if (minNum == 0)
				break;

			maxNum = READ_BE_UINT16(p); p += 2;

			if (room >= minNum && room <= maxNum) {
				in.open(filename);
				if (in.isOpen() == false) {
					error("loadRoomItems: Can't load rooms file '%s'", filename);
				}

				while ((i = in.readUint16BE()) != 0) {
					uint16 itemNum = i + 2;

					_itemArrayPtr[itemNum] = (Item *)allocateItem(sizeof(Item));
					readItemFromGamePc(&in, _itemArrayPtr[itemNum]);

					item = derefItem(itemNum);
					item->parent = 0;
					item->child = 0;

					 for (uint16 z = _itemArrayInited; z; z--) {
						itemTmp = derefItem(z);

						if (!itemTmp)
							continue;
						if (itemTmp->parent != itemNum)
							continue;
						if (item->child == 0) {
							item->child = z;
							continue;
						}
						uint16 child = item->child;
						while (itemTmp->next != 0) {
							if (itemTmp->next == child) {
								item->child = z;
								break;
							}

							itemTmp = derefItem(itemTmp->next);
						}
					}

					uint16 num = (itemNum - _itemArrayInited);
					item->state = _roomStates[num].state;
					item->classFlags = _roomStates[num].classFlags;
					SubRoom *subRoom = (SubRoom *)findChildOfType(item, kRoomType);
					subRoom->roomExitStates = _roomStates[num].roomExitStates;

				}
				in.close();

				return 1;
			}
		}
	}

	debug(1,"loadRoomItems: didn't find %d", room);
	return 0;
}

} // End of namespace AGOS

================
File: saveload.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/file.h"
#include "common/savefile.h"
#include "common/textconsole.h"
#include "common/translation.h"

#include "gui/message.h"

#include "agos/agos.h"
#include "agos/intern.h"

namespace AGOS {


// FIXME: This code counts savegames, but callers in many cases assume
// that the return value + 1 indicates an empty slot.
int AGOSEngine::countSaveGames() {
	Common::StringArray filenames;
	uint s, numSaveGames = 1;
	int slotNum;
	bool marks[256];

	// Get the name of (possibly non-existent) savegame slot 998, and replace
	// the extension by * to get a pattern.
	Common::String tmp = genSaveName(998);
	assert(tmp.size() >= 4 && tmp[tmp.size()-4] == '.');
	Common::String prefix = Common::String(tmp.c_str(), tmp.size()-3) + "*";

	memset(marks, false, 256 * sizeof(bool));	//assume no savegames for this title
	filenames = _saveFileMan->listSavefiles(prefix);

	for (Common::StringArray::const_iterator file = filenames.begin(); file != filenames.end(); ++file){
		//Obtain the last 3 digits of the filename, since they correspond to the save slot
		assert(file->size() >= 4);
		slotNum = atoi(file->c_str() + file->size() - 3);
		if (slotNum >= 0 && slotNum < 256)
			marks[slotNum] = true;	//mark this slot as valid
	}

	// locate first empty slot
	for (s = 1; s < 256; s++) {
		if (marks[s])
			numSaveGames++;
	}

	return numSaveGames;
}

#ifdef ENABLE_AGOS2
Common::String AGOSEngine_PuzzlePack::genSaveName(int slot) const {
	if (getGameId() == GID_DIMP)
		return "dimp.sav";
	else
		return "swampy.sav";
}

Common::String AGOSEngine_Feeble::genSaveName(int slot) const {
	return Common::String::format("feeble.%.3d", slot);
}
#endif

Common::String AGOSEngine_Simon2::genSaveName(int slot) const {
	return Common::String::format("simon2.%.3d", slot);
}

Common::String AGOSEngine_Simon1::genSaveName(int slot) const {
	if (_gameDescription->desc.flags & ADGF_DEMO)
		return Common::String::format("simon1-demo.%.3d", slot);
	else
		return Common::String::format("simon1.%.3d", slot);
}

Common::String AGOSEngine_Waxworks::genSaveName(int slot) const {
	if (getPlatform() == Common::kPlatformDOS)
		return Common::String::format("waxworks-pc.%.3d", slot);
	else
		return Common::String::format("waxworks.%.3d", slot);
}

Common::String AGOSEngine_Elvira2::genSaveName(int slot) const {
	if (getPlatform() == Common::kPlatformDOS)
		return Common::String::format("elvira2-pc.%.3d", slot);
	else
		return Common::String::format("elvira2.%.3d", slot);
}

Common::String AGOSEngine_Elvira1::genSaveName(int slot) const {
	return Common::String::format("elvira1.%.3d", slot);
}

Common::String AGOSEngine::genSaveName(int slot) const {
	return Common::String::format("pn.%.3d", slot);
}

#ifdef ENABLE_AGOS2
void AGOSEngine_Feeble::quickLoadOrSave() {
	// Quick loading and saving isn't possible in The Feeble Files or Puzzle Pack.
}
#endif

// The function uses segments of code from the original game scripts
// to allow quick loading and saving, but isn't perfect.
//
// Unfortuntely this allows loading and saving in locations,
// which aren't supported, and will not restore correctly:
// Various locations in Elvira 1/2 and Waxworks where saving
// was disabled
void AGOSEngine::quickLoadOrSave() {
	bool success;
	Common::U32String buf;

	// Disable loading and saving when it was not possible in the original:
	// In overhead maps areas in Simon the Sorcerer 2
	// In the floppy disk demo of Simon the Sorcerer 1
	// In copy protection, conversations and cut scenes
	if ((getGameType() == GType_SIMON2 && _boxStarHeight == 200) ||
		(getGameType() == GType_SIMON1 && (getFeatures() & GF_DEMO)) ||
		_mouseHideCount || _showPreposition) {
		buf = _("Quick load or save game isn't supported in this location");
		GUI::MessageDialog dialog(buf);
		dialog.runModal();
		return;
	}

	// Check if Simon is walking, and stop when required
	if (getGameType() == GType_SIMON1 && getBitFlag(11)) {
		vcStopAnimation(11, 1122);
		animate(4, 11, 1122, 0, 0, 2);
		waitForSync(1122);
	} else if (getGameType() == GType_SIMON2 && getBitFlag(11)) {
		vcStopAnimation(11, 232);
		animate(4, 11, 232, 0, 0, 2);
		waitForSync(1122);
	}

	Common::String filename = genSaveName(_saveLoadSlot);
	if (_saveLoadType == 2) {
		Subroutine *sub;
		success = loadGame(genSaveName(_saveLoadSlot));
		if (!success) {
			buf = Common::U32String::format(_("Failed to load saved game from file:\n\n%s"), filename.c_str());
		} else if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
			drawIconArray(2, me(), 0, 0);
			setBitFlag(97, true);
			sub = getSubroutineByID(100);
			startSubroutine(sub);
		} else if (getGameType() == GType_WW) {
			sub = getSubroutineByID(66);
			startSubroutine(sub);
		} else if (getGameType() == GType_ELVIRA2) {
			sub = getSubroutineByID(87);
			startSubroutine(sub);
			setBitFlag(7, false);
			sub = getSubroutineByID(19);
			startSubroutine(sub);
			printStats();
			sub = getSubroutineByID(28);
			startSubroutine(sub);
			setBitFlag(17, false);
			sub = getSubroutineByID(207);
			startSubroutine(sub);
			sub = getSubroutineByID(71);
			startSubroutine(sub);
		} else if (getGameType() == GType_ELVIRA1) {
			drawIconArray(2, me(), 0, 0);
			sub = getSubroutineByID(265);
			startSubroutine(sub);
			sub = getSubroutineByID(129);
			startSubroutine(sub);
			sub = getSubroutineByID(131);
			startSubroutine(sub);
		}
	} else {
		success = saveGame(_saveLoadSlot, _saveLoadName);
		if (!success)
			buf = Common::U32String::format(_("Failed to save game to file:\n\n%s"), filename.c_str());
	}

	if (!success) {
		GUI::MessageDialog dialog(buf);
		dialog.runModal();

	} else if (_saveLoadType == 1) {
		buf = Common::U32String::format(_("Successfully saved game in file:\n\n%s"), filename.c_str());
		GUI::TimedMessageDialog dialog(buf, 1500);
		dialog.runModal();

	}

	_saveLoadType = 0;
}

bool AGOSEngine_Waxworks::confirmOverWrite(WindowBlock *window) {
	Subroutine *sub = getSubroutineByID(80);
	if (sub != nullptr)
		startSubroutineEx(sub);

	if (_variableArray[253] == 0)
		return true;

	return false;
}

bool AGOSEngine_Elvira2::confirmOverWrite(WindowBlock *window) {
	// Original version never confirmed
	return true;
}

bool AGOSEngine::confirmOverWrite(WindowBlock *window) {
	const char *message1, *message2, *message3;

	switch (_language) {
	case Common::FR_FRA:
		message1 = "\rFichier d/j; existant.\r\r";
		message2 = "  Ecrire pardessus ?\r\r";
		message3 = "     Oui      Non";
		break;
	case Common::DE_DEU:
		message1 = "\rDatei existiert bereits.\r\r";
		message2 = "   Ueberschreiben ?\r\r";
		message3 = "     Ja        Nein";
		break;
	case Common::JA_JPN:
		message1 = "\r   ""\x82\xbb\x82\xcc\x83""t""\x83""@""\x83""C""\x83\x8b\x82\xcd\x82\xb7\x82\xc5\x82\xc9\x91\xb6\x8d\xdd\x82\xb5\x82\xdc\x82\xb7""\r\r";
		message2 = "     ""\x8f\xe3\x8f\x91\x82\xab\x82\xb5\x82\xc4\x82\xe6\x82\xeb\x82\xb5\x82\xa2\x82\xc5\x82\xb7\x82\xa9\x81""H\r\r";
		message3 = "       ""\x82\xcd\x82\xa2""           ""\x82\xa2\x82\xa2\x82\xa6";
		break;
	default:
		message1 = "\r File already exists.\r\r";
		message2 = "    Overwrite it ?\r\r";
		message3 = "     Yes       No";
		break;
	}

	printScroll();
	window->textColumn = 0;
	window->textRow = 0;
	window->textColumnOffset = 0;
	window->textLength = 0;		// Difference

	for (; *message1; message1++)
		windowPutChar(window, *message1);
	for (; *message2; message2++)
		windowPutChar(window, *message2);
	for (; *message3; message3++)
		windowPutChar(window, *message3);

	if (confirmYesOrNo(120, 78) == 0x7FFF)
		return true;

	return false;
}

int16 AGOSEngine::matchSaveGame(const char *name, uint16 max) {
	Common::InSaveFile *in;
	char dst[10];
	uint16 slot;

	memset(dst, 0, sizeof(dst));
	for (slot = 0; slot < max; slot++) {
		if ((in = _saveFileMan->openForLoading(genSaveName(slot)))) {
			in->read(dst, 8);
			delete in;

			if (!scumm_stricmp(name, dst)) {
				return slot;
			}
		}
	}

	return -1;
}

void AGOSEngine::userGame(bool load) {
	WindowBlock *window = _windowArray[4];
	const char *message1;
	int i = 0, numSaveGames;
	char *name;
	memset(_saveBuf, 0, sizeof(_saveBuf));

	numSaveGames = countSaveGames();

	uint32 saveTime = getTime();
	haltAnimation();

restart:
	printScroll();
	window->textColumn = 0;
	window->textRow = 0;
	window->textColumnOffset = 0;
	window->textLength = 0;		// Difference

	switch (_language) {
	case Common::FR_FRA:
		message1 = "\rIns/rez disquette de\rsauvegarde de jeux &\rentrez nom de fichier:\r\r   ";
		break;
	case Common::DE_DEU:
		message1 = "\rLege Spielstandsdiskette ein. Dateinamen eingeben:\r\r   ";
		break;
	case Common::JA_JPN:
		message1 = "\r  ""\x83""t""\x83""@""\x83""C""\x83\x8b\x96\xbc\x82\xf0\x93\xfc\x97\xcd\x82\xb5\x82\xc4\x82\xad\x82\xbe\x82\xb3\x82\xa2\x81""F\r\r\r   ";
		break;
	default:
		message1 = "\r Insert savegame data disk & enter filename:\r\r   ";
		break;
	}

	clearHiResTextLayer();
	for (; *message1; message1++)
		windowPutChar(window, *message1);

	memset(_saveBuf, 0, 10);
	name = _saveBuf;
	_saveGameNameLen = 0;
	_forceAscii = true;

	while (!shouldQuit()) {
		windowPutChar(window, 128);
		_keyPressed.reset();

		while (!shouldQuit()) {
			delay(10);
			if (_keyPressed.ascii && _keyPressed.ascii < 128) {
				i = _keyPressed.ascii;
				break;
			}
		}

		userGameBackSpace(_windowArray[4], 8);
		if (i == 10 || i == 13) {
			break;
		} else if (i == 8) {
			// do_backspace
			if (_saveGameNameLen) {
				_saveGameNameLen--;
				name[_saveGameNameLen] = 0;
				userGameBackSpace(_windowArray[4], 8);
			}
		} else if (i >= 32 && _saveGameNameLen != 8) {
			name[_saveGameNameLen++] = i;
			windowPutChar(_windowArray[4], i);
		}
	}

	_forceAscii = false;

	if (_saveGameNameLen != 0) {
		int16 slot = matchSaveGame(name, numSaveGames);
		if (!load) {
			if (slot >= 0 && !confirmOverWrite(window))
				goto restart;

			if (slot < 0)
				slot = numSaveGames;

			if (!saveGame(slot, name))
				fileError(_windowArray[4], true);
		} else {
			if (slot < 0) {
				fileError(_windowArray[4], false);
			} else {
				if (!loadGame(genSaveName(slot)))
					fileError(_windowArray[4], false);
			}
		}

		printStats();
	}

	clearHiResTextLayer();
	restartAnimation();
	_gameStoppedClock = getTime() - saveTime + _gameStoppedClock;
}

void AGOSEngine_Elvira2::listSaveGames() {
	Common::InSaveFile *in;
	uint y, slot;
	char *dst = _saveBuf;

	const uint8 num = (getGameType() == GType_WW) ? 3 : 4;

	disableFileBoxes();

	WindowBlock *window = _windowArray[num];
	window->textRow = 0;
	window->textColumn = 0;
	window->textColumnOffset = 4;

	windowPutChar(window, 12);

	memset(dst, 0, 200);

	slot = _saveLoadRowCurPos;
	for (y = 0; y < 8; y++) {
		window->textColumn = 0;
		window->textColumnOffset = (getGameType() == GType_ELVIRA2) ? 4 : 0;
		window->textLength = 0;
		if ((in = _saveFileMan->openForLoading(genSaveName(slot++)))) {
			in->read(dst, 8);
			delete in;

			const char *name = dst;
			for (; *name; name++)
				windowPutChar(window, *name);

			enableBox(200 + y * 3 + 0);
		}
		dst+= 8;

		if (getGameType() == GType_WW) {
			window->textColumn = 7;
			window->textColumnOffset = 4;
		} else if (getGameType() == GType_ELVIRA2) {
			window->textColumn = 8;
			window->textColumnOffset = 0;
		}
		window->textLength = 0;
		if ((in = _saveFileMan->openForLoading(genSaveName(slot++)))) {
			in->read(dst, 8);
			delete in;

			const char *name = dst;
			for (; *name; name++)
				windowPutChar(window, *name);

			enableBox(200 + y * 3 + 1);
		}
		dst+= 8;

		window->textColumn = 15;
		window->textColumnOffset = (getGameType() == GType_ELVIRA2) ? 4 : 0;
		window->textLength = 0;
		if ((in = _saveFileMan->openForLoading(genSaveName(slot++)))) {
			in->read(dst, 8);
			delete in;

			const char *name = dst;
			for (; *name; name++)
				windowPutChar(window, *name);

			enableBox(200 + y * 3 + 2);
		}
		dst+= 8;

		windowPutChar(window, 13);
	}

	window->textRow = 9;
	window->textColumn = 0;
	window->textColumnOffset = 4;
	window->textLength = 0;

	_saveGameNameLen = 0;
}

void AGOSEngine_Elvira2::userGame(bool load) {
	uint32 saveTime;
	int i, numSaveGames;
	char *name;
	bool b;
	memset(_saveBuf, 0, sizeof(_saveBuf));

	_saveOrLoad = load;

	saveTime = getTime();

	if (getGameType() == GType_ELVIRA2)
		haltAnimation();

	numSaveGames = countSaveGames();
	_numSaveGameRows = numSaveGames;
	_saveLoadRowCurPos = 1;
	_saveLoadEdit = false;

	const uint8 num = (getGameType() == GType_WW) ? 3 : 4;

	listSaveGames();

	Common::Keymapper *keymapper = AGOSEngine::getEventManager()->getKeymapper();
	keymapper->getKeymap("game-shortcuts")->setEnabled(false);

	if (!load) {
		WindowBlock *window = _windowArray[num];
		int16 slot = -1;

		name = _saveBuf + 192;

		while (!shouldQuit()) {
			windowPutChar(window, 128);

			_saveLoadEdit = true;

			i = userGameGetKey(&b, 128);
			if (b) {
				if (i <= 23) {
					if (!confirmOverWrite(window)) {
						listSaveGames();
						continue;
					}

					if (!saveGame(_saveLoadRowCurPos + i, _saveBuf + i * 8))
						fileError(_windowArray[num], true);
				}

				goto get_out;
			}

			userGameBackSpace(_windowArray[num], 8);
			if (i == 10 || i == 13) {
				slot = matchSaveGame(name, numSaveGames);
				if (slot >= 0) {
					if (!confirmOverWrite(window)) {
						listSaveGames();
						continue;
					}
				}
				break;
			} else if (i == 8) {
				// do_backspace
				if (_saveGameNameLen) {
					_saveGameNameLen--;
					name[_saveGameNameLen] = 0;
					userGameBackSpace(_windowArray[num], 8);
				}
			} else if (i >= 32 && _saveGameNameLen != 8) {
				name[_saveGameNameLen++] = i;
				windowPutChar(_windowArray[num], i);
			}
		}

		if (_saveGameNameLen != 0) {
			if (slot < 0)
				slot = numSaveGames;

			if (!saveGame(slot, _saveBuf + 192))
				fileError(_windowArray[num], true);
		}
	} else {
		i = userGameGetKey(&b, 128);
		if (i != 225) {
			if (!loadGame(genSaveName(_saveLoadRowCurPos + i)))
				fileError(_windowArray[num], false);
		}
	}

get_out:;
	disableFileBoxes();

	_gameStoppedClock = getTime() - saveTime + _gameStoppedClock;

	if (getGameType() == GType_ELVIRA2)
		restartAnimation();

	keymapper->getKeymap("game-shortcuts")->setEnabled(true);
}

int AGOSEngine_Elvira2::userGameGetKey(bool *b, uint maxChar) {
	HitArea *ha;
	*b = true;

	_keyPressed.reset();

	while (!shouldQuit()) {
		_lastHitArea = nullptr;
		_lastHitArea3 = nullptr;

		do {
			if (_saveLoadEdit && _keyPressed.ascii && _keyPressed.ascii < maxChar) {
				*b = false;
				return _keyPressed.ascii;
			}
			delay(10);
		} while (_lastHitArea3 == nullptr && !shouldQuit());

		ha = _lastHitArea;
		if (ha == nullptr || ha->id < 200) {
		} else if (ha->id == 225) {
			return ha->id;
		} else if (ha->id == 224) {
			_saveGameNameLen = 0;
			_saveLoadRowCurPos += 24;
			if (_saveLoadRowCurPos >= _numSaveGameRows)
				_saveLoadRowCurPos = 1;

			listSaveGames();
		} else if (ha->id < 224) {
			return ha->id - 200;
		}
	}

	return 225;
}

void AGOSEngine_Simon1::listSaveGames() {
	Common::InSaveFile *in;
	uint16 i, slot, lastSlot;
	char *dst = _saveBuf;

	disableFileBoxes();

	showMessageFormat("\xC");

	memset(dst, 0, 108);

	slot = _saveLoadRowCurPos;
	while (_saveLoadRowCurPos + 6 > slot) {
		if (!(in = _saveFileMan->openForLoading(genSaveName(slot))))
			break;

		in->read(dst, 18);
		delete in;

		lastSlot = slot;
		if (slot < 10) {
			showMessageFormat(" ");
		} else if (_language == Common::HE_ISR) {
			lastSlot = (slot % 10) * 10;
			lastSlot += slot / 10;
		}

		showMessageFormat("%d", lastSlot);
		if (_language == Common::HE_ISR && !(slot % 10))
			showMessageFormat("0");
		showMessageFormat(".%s\n", dst);
		dst += 18;
		slot++;
	}

	if (!_saveOrLoad) {
		if (_saveLoadRowCurPos + 6 == slot) {
			slot++;
		} else {
			if (slot < 10)
				showMessageFormat(" ");
			showMessageFormat("%d.\n", slot);
		}
	} else {
		if (_saveLoadRowCurPos + 6 == slot) {
			if ((in = _saveFileMan->openForLoading(genSaveName(slot)))) {
				slot++;
				delete in;
			}
		}
	}

	_saveDialogFlag = true;

	i = slot - _saveLoadRowCurPos;
	if (i != 7) {
		i++;
		if (!_saveOrLoad)
			i++;
		_saveDialogFlag = false;
	}

	if (!--i)
		return;

	do {
		enableBox(208 + i - 1);
	} while (--i);
}

const byte hebrewKeyTable[96] = {
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 90, 45, 85, 47, 48, 49, 50,
	51, 52, 53, 54, 55, 56, 57, 83, 83, 90, 61, 85, 63, 35, 89, 80, 65, 66, 87,
	75, 82, 73, 79, 71, 76, 74, 86, 78, 77, 84, 47, 88, 67, 64, 69, 68, 44, 81,
	72, 70, 91, 92, 93, 94, 95, 96, 89, 80, 65, 66, 87, 75, 82, 73, 79, 71, 76,
	74, 86, 78, 77, 84, 47, 88, 67, 64, 69, 68, 44, 81, 72, 70,
	123, 124, 125, 126, 127,
};

void AGOSEngine_Simon1::userGame(bool load) {
	uint32 saveTime;
	int i, numSaveGames, result;
	WindowBlock *window;
	char *name;
	bool b;
	memset(_saveBuf, 0, sizeof(_saveBuf));
	int maxChar = (_language == Common::HE_ISR) ? 155: 128;

	_saveOrLoad = load;

	saveTime = getTime();

	numSaveGames = countSaveGames();
	if (!load)
		numSaveGames++;
	numSaveGames -= 6;
	if (numSaveGames < 0)
		numSaveGames = 0;
	numSaveGames++;
	_numSaveGameRows = numSaveGames;

	_saveLoadRowCurPos = 1;
	if (!load)
		_saveLoadRowCurPos = numSaveGames;

	_saveLoadEdit = false;

restart:;
	i = userGameGetKey(&b, maxChar);

	Common::Keymapper *keymapper = AGOSEngine::getEventManager()->getKeymapper();
	keymapper->getKeymap("game-shortcuts")->setEnabled(false);

	if (i == 205)
		goto get_out;
	if (!load) {
		// if_1
	if_1:;
		result = i;

		disableBox(208 + i);
		leaveHitAreaById(208 + i);

		window = _windowArray[5];

		window->textRow = result;

		// init x offset with a 2 character savegame number + a period (18 pix)
		if (_language == Common::HE_ISR) {
			window->textColumn = 3;
			window->textColumnOffset = 6;
		} else {
			window->textColumn = 2;
			window->textColumnOffset = 2;
		}
		window->textLength = 3;

		name = _saveBuf + i * 18;

		// now process entire savegame name to get correct x offset for cursor
		_saveGameNameLen = 0;
		while (name[_saveGameNameLen]) {
			if (_language == Common::HE_ISR) {
				byte width = 6;
				if (name[_saveGameNameLen] >= 64 && name[_saveGameNameLen] < 91)
					width = _hebrewCharWidths [name[_saveGameNameLen] - 64];
				window->textLength++;
				window->textColumnOffset -= width;
				if (window->textColumnOffset < width) {
					window->textColumnOffset += 8;
					window->textColumn++;
				}
			} else {
				window->textLength++;
				window->textColumnOffset += 6;
				if (name[_saveGameNameLen] == 'i' || name[_saveGameNameLen] == 'l')
					window->textColumnOffset -= 2;
				if (window->textColumnOffset >= 8) {
					window->textColumnOffset -= 8;
					window->textColumn++;
				}
			}
			_saveGameNameLen++;
		}

		while (!shouldQuit()) {
			windowPutChar(window, 127);

			_saveLoadEdit = true;

			i = userGameGetKey(&b, maxChar);

			if (b) {
				if (i == 205)
					goto get_out;
				enableBox(208 + result);
				if (_saveLoadEdit) {
					userGameBackSpace(_windowArray[5], 8);
				}
				goto if_1;
			}

			if (!_saveLoadEdit) {
				enableBox(208 + result);
				goto restart;
			}

			if (_language == Common::HE_ISR) {
				if (i >= 128)
					i -= 64;
				else if (i >= 32)
					i = hebrewKeyTable[i - 32];
			}

			userGameBackSpace(_windowArray[5], 8);
			if (i == 10 || i == 13) {
				break;
			} else if (i == 8) {
				// do_backspace
				if (_saveGameNameLen) {
					byte m, x;

					_saveGameNameLen--;
					m = name[_saveGameNameLen];

					if (_language == Common::HE_ISR)
						x = 8;
					else
						x = (name[_saveGameNameLen] == 'i' || name[_saveGameNameLen] == 'l') ? 1 : 8;

					name[_saveGameNameLen] = 0;

					userGameBackSpace(_windowArray[5], x, m);
				}
			} else if (i >= 32 && _saveGameNameLen != 17) {
				name[_saveGameNameLen++] = i;

				windowPutChar(_windowArray[5], i);
			}
		}

		if (!saveGame(_saveLoadRowCurPos + result, _saveBuf + result * 18))
			fileError(_windowArray[5], true);
	} else {
		if (!loadGame(genSaveName(_saveLoadRowCurPos + i)))
			fileError(_windowArray[5], false);
	}

get_out:;
	disableFileBoxes();

	_gameStoppedClock = getTime() - saveTime + _gameStoppedClock;

	keymapper->getKeymap("game-shortcuts")->setEnabled(true);
}

int AGOSEngine_Simon1::userGameGetKey(bool *b, uint maxChar) {
	HitArea *ha;
	*b = true;

	if (!_saveLoadEdit) {
		listSaveGames();
	}

	_keyPressed.reset();

	while (!shouldQuit()) {
		_lastHitArea = nullptr;
		_lastHitArea3 = nullptr;

		do {
			if (_saveLoadEdit && _keyPressed.ascii && _keyPressed.ascii < maxChar) {
				*b = false;
				return _keyPressed.ascii;
			}
			delay(10);
		} while (_lastHitArea3 == nullptr && !shouldQuit());

		ha = _lastHitArea;
		if (ha == nullptr || ha->id < 205) {
		} else if (ha->id == 205) {
			return ha->id;
		} else if (ha->id == 206) {
			if (_saveLoadRowCurPos != 1) {
				if (_saveLoadRowCurPos < 7)
					_saveLoadRowCurPos = 1;
				else
					_saveLoadRowCurPos -= 6;

				_saveLoadEdit = false;
				listSaveGames();
			}
		} else if (ha->id == 207) {
			if (_saveDialogFlag) {
				_saveLoadRowCurPos += 6;
				if (_saveLoadRowCurPos >= _numSaveGameRows)
					_saveLoadRowCurPos = _numSaveGameRows;

				_saveLoadEdit = false;
				listSaveGames();
			}
		} else if (ha->id < 214) {
			return ha->id - 208;
		}
	}

	return 205;
}

void AGOSEngine::disableFileBoxes() {
	int i;

	if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
		for (i = 208; i != 214; i++)
			disableBox(i);
	} else {
		for (i = 200; i != 224; i++)
			disableBox(i);
	}
}

void AGOSEngine::userGameBackSpace(WindowBlock *window, int x, byte b) {
	byte oldTextColor;

	windowPutChar(window, x, b);
	oldTextColor = window->textColor;
	window->textColor = window->fillColor;

	if (_language == Common::HE_ISR) {
		x = 128;
	} else {
		x += 120;
		if (x != 128)
			x = 129;
	}

	windowPutChar(window, x);

	window->textColor = oldTextColor;
	windowPutChar(window, 8);
}

void AGOSEngine::fileError(WindowBlock *window, bool saveError) {
	const char *message1, *message2;

	if (saveError) {
		switch (_language) {
		case Common::RU_RUS:
			if (getGameType() == GType_SIMON2) {
				message1 = "\r   Mf sowrap+fts+.";
				message2 = "\r  Nzjb#a ejs#a.";
			} else {
				message1 = "\r   Mf sowrap]fts].";
				message2 = "\r   Nzjb_a ejs_a.";
			}
			break;
		case Common::PL_POL:
			message1 = "\r      Blad zapisu.    ";
			message2 = "\rBlad dysku.                       ";
			break;
		case Common::ES_ESP:
			message1 = "\r     Error al salvar";
			message2 = "\r  Intenta con otro disco";
			break;
		case Common::IT_ITA:
			message1 = "\r  Salvataggio non riuscito";
			message2 = "\r    Prova un""\x27""altro disco";
			break;
		case Common::FR_FRA:
			message1 = "\r    Echec sauvegarde";
			message2 = "\rEssayez une autre disquette";
			break;
		case Common::DE_DEU:
			message1 = "\r  Sicherung erfolglos.";
			message2 = "\rVersuche eine andere     Diskette.";
			break;
		case Common::JA_JPN:
			message1 = "\r       ""\x83""Z""\x81""[""\x83""u""\x82\xc9\x8e\xb8\x94""s""\x82\xb5\x82\xdc\x82\xb5\x82\xbd";
			message2 = "\r   ""\x95\xca\x82\xcc\x83""f""\x83""B""\x83""X""\x83""N""\x82\xf0\x8e""g""\x97""p""\x82\xb5\x82\xc4\x82\xad\x82\xbe\x82\xb3\x82\xa2";
			break;
		default:
			message1 = "\r       Save failed.";
			message2 = "\r       Disk error.";
			break;
		}
	} else {
		switch (_language) {
		case Common::RU_RUS:
			if (getGameType() == GType_SIMON2) {
				message1 = "\r  Mf ^adruhafts+.";
				message2 = "\r   Takm pf pakefp.";
			} else {
				message1 = "\r   Mf ^adruhafts].";
				message2 = "\r   Takm pf pakefp.";
			}
			break;
		case Common::PL_POL:
			message1 = "\r   Blad odczytu.    ";
			message2 = "\r  Nie znaleziono pliku.";
			break;
		case Common::ES_ESP:
			message1 = "\r     Error al cargar";
			message2 = "\r  Archivo no encontrado";
			break;
		case Common::IT_ITA:
			message1 = "\r  Caricamento non riuscito";
			message2 = "\r      File non trovato";
			break;
		case Common::FR_FRA:
			message1 = "\r    Echec chargement";
			message2 = "\r  Fichier introuvable";
			break;
		case Common::DE_DEU:
			message1 = "\r    Laden erfolglos.";
			message2 = "\r  Datei nicht gefunden.";
			break;
		case Common::JA_JPN:
			message1 = "\r       ""\x83\x8d\x81""[""\x83""h""\x82\xc9\x8e\xb8\x94""s""\x82\xb5\x82\xdc\x82\xb5\x82\xbd";
			message2 = "\r     ""\x83""t""\x83""@""\x83""C""\x83\x8b\x82\xaa\x8c\xa9\x82\xc2\x82\xa9\x82\xe8\x82\xdc\x82\xb9\x82\xf1";
			break;
		default:
			message1 = "\r       Load failed.";
			message2 = "\r     File not found.";
			break;
		}
	}

	if (getGameType() == GType_ELVIRA1) {
		printScroll();
		window->textColumn = 0;
		window->textRow = 0;
		window->textColumnOffset = 0;
		window->textLength = 0;		// Difference
	} else {
		windowPutChar(window, 12);
	}

	for (; *message1; message1++)
		windowPutChar(window, *message1);
	for (; *message2; message2++)
		windowPutChar(window, *message2);

	waitWindow(window);
}

uint16 readItemID(Common::SeekableReadStream *f) {
	uint32 val = f->readUint32BE();
	if (val == 0xFFFFFFFF)
		return 0;
	return val + 1;
}

void writeItemID(Common::WriteStream *f, uint16 val) {
	if (val == 0)
		f->writeUint32BE(0xFFFFFFFF);
	else
		f->writeUint32BE(val - 1);
}

bool AGOSEngine::loadGame(const Common::String &filename, bool restartMode) {
	char ident[100];
	Common::SeekableReadStream *f = nullptr;
	uint num, item_index, i;

	_videoLockOut |= 0x100;

	if (restartMode) {
		// Load restart state
		if (getPlatform() == Common::kPlatformPC98 && !filename.compareToIgnoreCase("start")) {
			f = createPak98FileStream("START.PAK");
		} else {
			Common::File *file = new Common::File();
			if (!file->open(Common::Path(filename))) {
				delete file;
				file = nullptr;
			}
			f = file;
		}
	} else {
		f = _saveFileMan->openForLoading(filename);
	}

	if (f == nullptr) {
		_videoLockOut &= ~0x100;
		return false;
	}

	if (!restartMode) {
		f->read(ident, 8);
	}

	num = f->readUint32BE();

	if (f->readUint32BE() != 0xFFFFFFFF || num != _itemArrayInited - 1) {
		delete f;
		_videoLockOut &= ~0x100;
		return false;
	}

	f->readUint32BE();
	f->readUint32BE();
	_noParentNotify = true;

	// add all timers
	killAllTimers();
	for (num = f->readUint32BE(); num; num--) {
		// See comment below inAGOSEngine_Elvira2::loadGame(): The timers are just as broken for Elvira as for the other games.
		int32 timeout = (int16)f->readSint32BE();
		uint16 subroutine_id = f->readUint16BE();
		addTimeEvent(timeout, subroutine_id);
	}

	item_index = 1;
	for (num = _itemArrayInited - 1; num; num--) {
		Item *item = _itemArrayPtr[item_index++], *parent_item;

		parent_item = derefItem(readItemID(f));
		setItemParent(item, parent_item);

		item->state = f->readUint16BE();
		item->classFlags = f->readUint16BE();

		SubObject *o = (SubObject *)findChildOfType(item, kObjectType);
		if (o) {
			o->objectSize = f->readUint16BE();
			o->objectWeight = f->readUint16BE();
		}

		SubPlayer *p = (SubPlayer *)findChildOfType(item, kPlayerType);
		if (p) {
			p->score = f->readUint32BE();
			p->level = f->readUint16BE();
			p->size = f->readUint16BE();
			p->weight = f->readUint16BE();
			p->strength = f->readUint16BE();
		}

		SubUserFlag *u = (SubUserFlag *)findChildOfType(item, kUserFlagType);
		if (u) {
			for (i = 0; i != 8; i++) {
				u->userFlags[i] = f->readUint16BE();
			}
			u->userItems[0] = readItemID(f);
		}
	}

	// read the variables
	for (i = 0; i != _numVars; i++) {
		writeVariable(i, f->readUint16BE());
	}

	if (f->err()) {
		error("load failed");
	}

	delete f;

	_noParentNotify = false;

	_videoLockOut &= ~0x100;

	return true;
}

bool AGOSEngine::saveGame(uint slot, const char *caption) {
	Common::OutSaveFile *f;
	uint item_index, num_item, i;
	TimeEvent *te;
	uint32 curTime = getTime();
	uint32 gsc = _gameStoppedClock;

	_videoLockOut |= 0x100;

	f = _saveFileMan->openForSaving(genSaveName(slot));
	if (f == nullptr) {
		_videoLockOut &= ~0x100;
		return false;
	}

	f->write(caption, 8);

	f->writeUint32BE(_itemArrayInited - 1);
	f->writeUint32BE(0xFFFFFFFF);
	f->writeUint32BE(curTime);
	f->writeUint32BE(0);

	i = 0;
	for (te = _firstTimeStruct; te; te = te->next)
		i++;
	f->writeUint32BE(i);

	for (te = _firstTimeStruct; te; te = te->next) {
		f->writeUint32BE(te->time - curTime + gsc);
		f->writeUint16BE(te->subroutine_id);
	}

	item_index = 1;
	for (num_item = _itemArrayInited - 1; num_item; num_item--) {
		Item *item = _itemArrayPtr[item_index++];

		writeItemID(f, item->parent);

		f->writeUint16BE(item->state);
		f->writeUint16BE(item->classFlags);

		SubObject *o = (SubObject *)findChildOfType(item, kObjectType);
		if (o) {
			f->writeUint16BE(o->objectSize);
			f->writeUint16BE(o->objectWeight);
		}

		SubPlayer *p = (SubPlayer *)findChildOfType(item, kPlayerType);
		if (p) {
			f->writeUint32BE(p->score);
			f->writeUint16BE(p->level);
			f->writeUint16BE(p->size);
			f->writeUint16BE(p->weight);
			f->writeUint16BE(p->strength);
		}

		SubUserFlag *u = (SubUserFlag *)findChildOfType(item, kUserFlagType);
		if (u) {
			for (i = 0; i != 8; i++) {
				f->writeUint16BE(u->userFlags[i]);
			}
			writeItemID(f, u->userItems[0]);
		}
	}

	// write the variables
	for (i = 0; i != _numVars; i++) {
		f->writeUint16BE(readVariable(i));
	}

	f->finalize();
	bool result = !f->err();

	delete f;
	_videoLockOut &= ~0x100;

	return result;
}

bool AGOSEngine_Elvira2::loadGame(const Common::String &filename, bool restartMode) {
	char ident[100];
	Common::SeekableReadStream *f = nullptr;
	uint num, item_index, i, j;

	_videoLockOut |= 0x100;

	if (restartMode) {
		// Load restart state
		Common::File *file = new Common::File();
		if (!file->open(Common::Path(filename))) {
			delete file;
			file = nullptr;
		}
		f = file;
	} else {
		f = _saveFileMan->openForLoading(filename);
	}

	if (f == nullptr) {
		_videoLockOut &= ~0x100;
		return false;
	}

	if (getGameType() == GType_PP) {
		// No caption
	} else if (getGameType() == GType_FF) {
		f->read(ident, 100);
	} else if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
		f->read(ident, 18);
	} else if (!restartMode) {
		f->read(ident, 8);
	}

	num = f->readUint32BE();

	if (f->readUint32BE() != 0xFFFFFFFF || num != _itemArrayInited - 1) {
		delete f;
		_videoLockOut &= ~0x100;
		return false;
	}

	f->readUint32BE();
	f->readUint32BE();
	_noParentNotify = true;

	// add all timers
	killAllTimers();
	for (num = f->readUint32BE(); num; num--) {
		// WORKAROUND for older (corrupt) savegames. Games with short timer intervals may write negative timeouts into the save files. The
		// original interpreter does that, too. I have checked it in the DOSBox debugger. We didn't handle this well, treating the negative
		// values as very large positive values. This effectively disabled the timers. In most cases this seems to have gone unnoticed, but
		// it also caused bug #14886 ("Waxworks crashing at Egypt Level 3, corrupting save file"). Waxworks runs a timer every 10 seconds
		// that cleans up the items chain and failure to do so causes that bug. The design of the timers in the original interpreter is poor,
		// but at least it somehow survives. Now, unfortunately, we don't have savegame versioning in this engine, so I can't simply limit
		// a fix to old savegames. However, it is so highly unlikely that a valid timer would exceed 32767 seconds (= 9 hours) that I
		// consider this safe.
		int32 timeout = (int16)f->readSint32BE();
		uint16 subroutine_id = f->readUint16BE();
		addTimeEvent(timeout, subroutine_id);
	}

	if (getGameType() == GType_WW && getPlatform() == Common::kPlatformDOS) {
		for (uint s = 0; s < _numRoomStates; s++) {
			_roomStates[s].state = f->readUint16BE();
			_roomStates[s].classFlags = f->readUint16BE();
			_roomStates[s].roomExitStates = f->readUint16BE();
		}
		f->readUint16BE();

		uint16 room = _currentRoom;
		_currentRoom = f->readUint16BE();
		if (_roomsListPtr) {
			byte *p = _roomsListPtr;
			if (room == _currentRoom) {
				for (;;) {
					uint16 minNum = READ_BE_UINT16(p); p += 2;
					if (minNum == 0)
						break;

					uint16 maxNum = READ_BE_UINT16(p); p += 2;

					 for (uint16 z = minNum; z <= maxNum; z++) {
						uint16 itemNum = z + 2;
						Item *item = derefItem(itemNum);

						num = (itemNum - _itemArrayInited);
						item->state = _roomStates[num].state;
						item->classFlags = _roomStates[num].classFlags;
						SubRoom *subRoom = (SubRoom *)findChildOfType(item, kRoomType);
						subRoom->roomExitStates = _roomStates[num].roomExitStates;
					}
				}
			} else {
				for (;;) {
					uint16 minNum = READ_BE_UINT16(p); p += 2;
					if (minNum == 0)
						break;

					uint16 maxNum = READ_BE_UINT16(p); p += 2;

					 for (uint16 z = minNum; z <= maxNum; z++) {
						uint16 itemNum = z + 2;
						_itemArrayPtr[itemNum] = nullptr;
					}
				}
			}
		}

		if (room != _currentRoom) {
			_roomsListPtr = nullptr;
			loadRoomItems(_currentRoom);
		}
	}

	item_index = 1;
	for (num = _itemArrayInited - 1; num; num--) {
		Item *item = _itemArrayPtr[item_index++], *parent_item;

		if ((getGameType() == GType_WW && getPlatform() == Common::kPlatformAmiga) ||
			getGameType() == GType_ELVIRA2) {
			parent_item = derefItem(readItemID(f));
			setItemParent(item, parent_item);
		} else {
			uint parent = f->readUint16BE();
			uint next = f->readUint16BE();

			if (getGameType() == GType_WW && getPlatform() == Common::kPlatformDOS && derefItem(item->parent) == nullptr)
				item->parent = 0;

			parent_item = derefItem(parent);
			setItemParent(item, parent_item);

			if (parent_item == nullptr) {
				item->parent = parent;
				item->next = next;
			}
		}

		item->state = f->readUint16BE();
		item->classFlags = f->readUint16BE();

		SubRoom *r = (SubRoom *)findChildOfType(item, kRoomType);
		if (r) {
			r->roomExitStates = f->readUint16BE();
		}

		SubSuperRoom *sr = (SubSuperRoom *)findChildOfType(item, kSuperRoomType);
		if (sr) {
			uint16 n = sr->roomX * sr->roomY * sr->roomZ;
			for (i = j = 0; i != n; i++)
				sr->roomExitStates[j++] = f->readUint16BE();
		}

		SubObject *o = (SubObject *)findChildOfType(item, kObjectType);
		if (o) {
			o->objectFlags = f->readUint32BE();
			i = o->objectFlags & 1;

			for (j = 1; j < 16; j++) {
				if (o->objectFlags & (1 << j)) {
					o->objectFlagValue[i++] = f->readUint16BE();
				}
			}
		}

		SubUserFlag *u = (SubUserFlag *)findChildOfType(item, kUserFlagType);
		if (u) {
			for (i = 0; i != 4; i++) {
				u->userFlags[i] = f->readUint16BE();
			}
		}
	}

	// read the variables
	for (i = 0; i != _numVars; i++) {
		writeVariable(i, f->readUint16BE());
	}

	// read the items in item store
	for (i = 0; i != _numItemStore; i++) {
		if (getGameType() == GType_WW && getPlatform() == Common::kPlatformAmiga) {
			_itemStore[i] = derefItem(f->readUint16BE() / 16);
		} else if (getGameType() == GType_ELVIRA2) {
			if (getPlatform() == Common::kPlatformDOS) {
				_itemStore[i] = derefItem(readItemID(f));
			} else {
				_itemStore[i] = derefItem(f->readUint16BE() / 18);
			}
		} else {
			_itemStore[i] = derefItem(f->readUint16BE());
		}
	}

	// Read the bits in array 1
	for (i = 0; i != _numBitArray1; i++)
		_bitArray[i] = f->readUint16BE();

	// Read the bits in array 2
	for (i = 0; i != _numBitArray2; i++)
		_bitArrayTwo[i] = f->readUint16BE();

	// Read the bits in array 3
	for (i = 0; i != _numBitArray3; i++)
		_bitArrayThree[i] = f->readUint16BE();

	if (getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) {
		_superRoomNumber = f->readUint16BE();
	}

	if (f->err()) {
		error("load failed");
	}

	delete f;

	_noParentNotify = false;

	_videoLockOut &= ~0x100;

	// The floppy disk versions of Simon the Sorcerer 2 block changing
	// to scrolling rooms, if the copy protection fails. But the copy
	// protection flags are never set in the CD version.
	// Setting this copy protection flag, allows saved games to be shared
	// between all versions of Simon the Sorcerer 2.
	if (getGameType() == GType_SIMON2) {
		setBitFlag(135, 1);
	}

	return true;
}

bool AGOSEngine_Elvira2::saveGame(uint slot, const char *caption) {
	Common::OutSaveFile *f;
	uint item_index, num_item, i, j;
	TimeEvent *te;
	uint32 curTime = getTime();
	uint32 gsc = _gameStoppedClock;

	_videoLockOut |= 0x100;

	f = _saveFileMan->openForSaving(genSaveName(slot));
	if (f == nullptr) {
		_videoLockOut &= ~0x100;
		return false;
	}

	if (getGameType() == GType_PP) {
		// No caption
	} else if (getGameType() == GType_FF) {
		f->write(caption, 100);
	} else if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
		f->write(caption, 18);
	} else {
		f->write(caption, 8);
	}

	f->writeUint32BE(_itemArrayInited - 1);
	f->writeUint32BE(0xFFFFFFFF);
	f->writeUint32BE(curTime);
	f->writeUint32BE(0);

	i = 0;
	for (te = _firstTimeStruct; te; te = te->next)
		i++;
	f->writeUint32BE(i);

	if (getGameType() == GType_FF && _clockStopped)
		gsc += (getTime() - _clockStopped);
	for (te = _firstTimeStruct; te; te = te->next) {
		f->writeUint32BE(te->time - curTime + gsc);
		f->writeUint16BE(te->subroutine_id);
	}

	if (getGameType() == GType_WW && getPlatform() == Common::kPlatformDOS) {
		if (_roomsListPtr) {
			byte *p = _roomsListPtr;
			for (;;) {
				uint16 minNum = READ_BE_UINT16(p); p += 2;
				if (minNum == 0)
					break;

				uint16 maxNum = READ_BE_UINT16(p); p += 2;

				 for (uint16 z = minNum; z <= maxNum; z++) {
					uint16 itemNum = z + 2;
					Item *item = derefItem(itemNum);

					uint16 num = (itemNum - _itemArrayInited);
					_roomStates[num].state = item->state;
					_roomStates[num].classFlags = item->classFlags;
					SubRoom *subRoom = (SubRoom *)findChildOfType(item, kRoomType);
					_roomStates[num].roomExitStates = subRoom->roomExitStates;
				}
			}
		}

		for (uint s = 0; s < _numRoomStates; s++) {
			f->writeUint16BE(_roomStates[s].state);
			f->writeUint16BE(_roomStates[s].classFlags);
			f->writeUint16BE(_roomStates[s].roomExitStates);
		}
		f->writeUint16BE(0);
		f->writeUint16BE(_currentRoom);
	}

	item_index = 1;
	for (num_item = _itemArrayInited - 1; num_item; num_item--) {
		Item *item = _itemArrayPtr[item_index++];

		if ((getGameType() == GType_WW && getPlatform() == Common::kPlatformAmiga) ||
			getGameType() == GType_ELVIRA2) {
			writeItemID(f, item->parent);
		} else {
			f->writeUint16BE(item->parent);
			f->writeUint16BE(item->next);
		}

		f->writeUint16BE(item->state);
		f->writeUint16BE(item->classFlags);

		SubRoom *r = (SubRoom *)findChildOfType(item, kRoomType);
		if (r) {
			f->writeUint16BE(r->roomExitStates);
		}

		SubSuperRoom *sr = (SubSuperRoom *)findChildOfType(item, kSuperRoomType);
		if (sr) {
			uint16 n = sr->roomX * sr->roomY * sr->roomZ;
			for (i = j = 0; i != n; i++)
				f->writeUint16BE(sr->roomExitStates[j++]);
		}

		SubObject *o = (SubObject *)findChildOfType(item, kObjectType);
		if (o) {
			f->writeUint32BE(o->objectFlags);
			i = o->objectFlags & 1;

			for (j = 1; j < 16; j++) {
				if (o->objectFlags & (1 << j)) {
					f->writeUint16BE(o->objectFlagValue[i++]);
				}
			}
		}

		SubUserFlag *u = (SubUserFlag *)findChildOfType(item, kUserFlagType);
		if (u) {
			for (i = 0; i != 4; i++) {
				f->writeUint16BE(u->userFlags[i]);
			}
		}
	}

	// write the variables
	for (i = 0; i != _numVars; i++) {
		f->writeUint16BE(readVariable(i));
	}

	// write the items in item store
	for (i = 0; i != _numItemStore; i++) {
		if (getGameType() == GType_WW && getPlatform() == Common::kPlatformAmiga) {
			f->writeUint16BE(itemPtrToID(_itemStore[i]) * 16);
		} else if (getGameType() == GType_ELVIRA2) {
			if (getPlatform() == Common::kPlatformDOS) {
				writeItemID(f, itemPtrToID(_itemStore[i]));
			} else {
				f->writeUint16BE(itemPtrToID(_itemStore[i]) * 18);
			}
		} else {
			f->writeUint16BE(itemPtrToID(_itemStore[i]));
		}
	}

	// Write the bits in array 1
	for (i = 0; i != _numBitArray1; i++)
		f->writeUint16BE(_bitArray[i]);

	// Write the bits in array 2
	for (i = 0; i != _numBitArray2; i++)
		f->writeUint16BE(_bitArrayTwo[i]);

	// Write the bits in array 3
	for (i = 0; i != _numBitArray3; i++)
		f->writeUint16BE(_bitArrayThree[i]);

	if (getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) {
		f->writeUint16BE(_superRoomNumber);
	}

	f->finalize();
	bool result = !f->err();

	delete f;
	_videoLockOut &= ~0x100;

	return result;
}

// Personal Nightmare specific
bool AGOSEngine_PN::badload(int8 errorNum) {
	if (errorNum == -2)
		return 0;
	// Load error recovery routine

	// Clear any stack
	while (_stackbase != nullptr) {
		dumpstack();
	}

	// Restart from process 1
	_tagOfActiveDoline = 1;
	_dolineReturnVal = 3;
	return 1;
}

void AGOSEngine_PN::getFilename() {
	_noScanFlag = 1;
	clearInputLine();

	memset(_saveFile, 0, sizeof(_saveFile));
	while (!shouldQuit() && !strlen(_saveFile)) {
		const char *msg = "File name : ";
		pcf((unsigned char)'\n');
		while (*msg)
			pcf((unsigned char)*msg++);

		interact(_saveFile, 8);
		pcf((unsigned char)'\n');
		_noScanFlag = 0;
	}
}

int AGOSEngine_PN::loadFile(const Common::String &name) {
	Common::InSaveFile *f;
	haltAnimation();

	f = _saveFileMan->openForLoading(name);
	if (f == nullptr) {
		restartAnimation();
		return -2;
	}
	f->read(_saveFile, 8);

	if (f->readByte() != 41) {
		restartAnimation();
		delete f;
		return -2;
	}
	if (f->readByte() != 33) {
		restartAnimation();
		delete f;
		return -2;
	}
	// TODO: Make endian safe
	if (!f->read(_dataBase + _quickptr[2], (int)(_quickptr[6] - _quickptr[2]))) {
		restartAnimation();
		delete f;
		return -1;
	}
	delete f;
	restartAnimation();
	dbtosysf();
	return 0;
}

int AGOSEngine_PN::saveFile(const Common::String &name) {
	Common::OutSaveFile *f;
	sysftodb();
	haltAnimation();

	f = _saveFileMan->openForSaving(name);
	if (f == nullptr) {
		restartAnimation();

		const char *msg = "Couldn't save. ";
		pcf((unsigned char)'\n');
		while (*msg)
			pcf((unsigned char)*msg++);

		return 0;
	}
	f->write(_saveFile, 8);

	f->writeByte(41);
	f->writeByte(33);
	// TODO: Make endian safe
	if (!f->write(_dataBase + _quickptr[2], (int)(_quickptr[6] - _quickptr[2]))) {
		delete f;
		restartAnimation();
		error("Couldn't save ");
		return 0;	// for compilers that don't support NORETURN
	}
	f->finalize();
	delete f;

	restartAnimation();
	return 1;
}

void AGOSEngine_PN::sysftodb() {
	uint32 pos = _quickptr[2];
	int ct = 0;

	while (ct < (getptr(49L) / 2)) {
		_dataBase[pos] = (uint8)(_variableArray[ct] % 256);
		_dataBase[pos + 1] = (uint8)(_variableArray[ct] / 256);
		pos+=2;
		ct++;
	}
}

void AGOSEngine_PN::dbtosysf() {
	uint32 pos = _quickptr[2];
	int ct = 0;

	while (ct < (getptr(49L) / 2)) {
		_variableArray[ct] = _dataBase[pos] + 256 * _dataBase[pos + 1];
		pos += 2;
		ct++;
	}
}

} // End of namespace AGOS

================
File: script.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Item script opcodes for Simon1/Simon2

#include "common/debug-channels.h"
#include "common/endian.h"
#include "common/system.h"
#include "common/textconsole.h"

#include "agos/agos.h"
#include "agos/intern.h"

namespace AGOS {

void AGOSEngine::setupOpcodes() {
	error("setupOpcodes: Unknown game");
}

void AGOSEngine::setScriptCondition(bool cond) {
	_runScriptCondition[_recursionDepth] = cond;
}

bool AGOSEngine::getScriptCondition() {
	return _runScriptCondition[_recursionDepth];
}

void AGOSEngine::setScriptReturn(int ret) {
	_runScriptReturn[_recursionDepth] = ret;
}

int AGOSEngine::getScriptReturn() {
	return _runScriptReturn[_recursionDepth];
}

// -----------------------------------------------------------------------
// Common Opcodes
// -----------------------------------------------------------------------

void AGOSEngine::o_invalid() {
	error("Invalid opcode %d", _opcode);
}

void AGOSEngine::o_at() {
	// 1: ptrA parent is
	setScriptCondition(me()->parent == getNextItemID());
}

void AGOSEngine::o_notAt() {
	// 2: ptrA parent is not
	setScriptCondition(me()->parent != getNextItemID());
}

void AGOSEngine::o_carried() {
	// 5: parent is 1
	setScriptCondition(getNextItemPtr()->parent == getItem1ID());
}

void AGOSEngine::o_notCarried() {
	// 6: parent isnot 1
	setScriptCondition(getNextItemPtr()->parent != getItem1ID());
}

void AGOSEngine::o_isAt() {
	// 7: parent is
	Item *item = getNextItemPtr();
	setScriptCondition(item->parent == getNextItemID());
}

void AGOSEngine::o_zero() {
	// 11: is zero
	setScriptCondition(getNextVarContents() == 0);
}

void AGOSEngine::o_notZero() {
	// 12: isnot zero
	setScriptCondition(getNextVarContents() != 0);
}

void AGOSEngine::o_eq() {
	// 13: equal
	uint tmp = getNextVarContents();
	uint tmp2 = getVarOrWord();

#ifdef __DS__
	// HACK: Skip attempt to read Calypso's letter manually,
	// due to speech segment been too large to fit into memory
	if (getGameType() == GType_SIMON1 && (getFeatures() & GF_TALKIE) &&
		getPlatform() == Common::kPlatformWindows && _currentTable) {
		if (_currentTable->id == 71 && tmp == 1 && tmp2 == 1) {
			setScriptCondition(false);
			return;
		}
	}
#endif
	setScriptCondition(tmp == tmp2);
}

void AGOSEngine::o_notEq() {
	// 14: not equal
	uint tmp = getNextVarContents();
	setScriptCondition(tmp != getVarOrWord());
}

void AGOSEngine::o_gt() {
	// 15: is greater
	int16 tmp1 = getNextVarContents();
	int16 tmp2 = getVarOrWord();
	setScriptCondition(tmp1 > tmp2);
}

void AGOSEngine::o_lt() {
	// 16: is less
	int16 tmp1 = getNextVarContents();
	int16 tmp2 = getVarOrWord();
	setScriptCondition(tmp1 < tmp2);
}

void AGOSEngine::o_eqf() {
	// 17: is eq f
	uint tmp = getNextVarContents();
	setScriptCondition(tmp == getNextVarContents());
}

void AGOSEngine::o_notEqf() {
	// 18: is not equal f
	uint tmp = getNextVarContents();
	setScriptCondition(tmp != getNextVarContents());
}

void AGOSEngine::o_ltf() {
	// 19: is greater f
	int16 tmp1 = getNextVarContents();
	int16 tmp2 = getNextVarContents();
	setScriptCondition(tmp1 < tmp2);
}

void AGOSEngine::o_gtf() {
	// 20: is less f
	int16 tmp1 = getNextVarContents();
	int16 tmp2 = getNextVarContents();
	setScriptCondition(tmp1 > tmp2);
}

void AGOSEngine::o_chance() {
	// 23: chance
	int16 a = getVarOrWord();

	if (a == 0) {
		setScriptCondition(false);
		return;
	}

	if (a == 100) {
		setScriptCondition(true);
		return;
	}

	a += _chanceModifier;

	if (a <= 0) {
		_chanceModifier = 0;
		setScriptCondition(false);
	} else if ((int16)_rnd.getRandomNumber(99) < a) {
		if (_chanceModifier <= 0)
			_chanceModifier -= 5;
		else
			_chanceModifier = 0;
		setScriptCondition(true);
	} else {
		if (_chanceModifier >= 0)
			_chanceModifier += 5;
		else
			_chanceModifier = 0;
		setScriptCondition(false);
	}
}

void AGOSEngine::o_isRoom() {
	// 25: is room
	setScriptCondition(isRoom(getNextItemPtr()));
}

void AGOSEngine::o_isObject() {
	// 26: is object
	setScriptCondition(isObject(getNextItemPtr()));
}

void AGOSEngine::o_state() {
	// 27: item state is
	Item *item = getNextItemPtr();
	setScriptCondition((uint) item->state == getVarOrWord());
}

void AGOSEngine::o_oflag() {
	// 28: item has prop
	SubObject *subObject = (SubObject *)findChildOfType(getNextItemPtr(), kObjectType);
	uint num = getVarOrByte();
	setScriptCondition(subObject != nullptr && (subObject->objectFlags & (1 << num)) != 0);
}

void AGOSEngine::o_destroy() {
	// 31: set no parent
	setItemParent(getNextItemPtr(), nullptr);
}

void AGOSEngine::o_place() {
	// 33: set item parent
	Item *item = getNextItemPtr();
	setItemParent(item, getNextItemPtr());
}

void AGOSEngine::o_copyff() {
	// 36: copy var
	uint value = getNextVarContents();
	writeNextVarContents(value);
}

void AGOSEngine::o_clear() {
	// 41: zero var
	writeNextVarContents(0);
}

void AGOSEngine::o_let() {
	// 42: set var
	uint var = getVarWrapper();
	uint value = getVarOrWord();

	if (getGameType() == GType_FF && _currentTable) {
		// WORKAROUND: When the repair man comes to fix the car, the game doesn't
		// wait long enough for the screen to completely scroll to the left side.
		if (_currentTable->id == 20438 && var == 103 && value == 60) {
			value = 71;
		}
	}

	writeVariable(var, value);
}

void AGOSEngine::o_add() {
	// 43: add
	uint var = getVarWrapper();
	writeVariable(var, readVariable(var) + getVarOrWord());

	// WORKAROUND: The conversation of the male in Vid-Phone Booth at Dave's Space Bar
	// is based on variable 116, but stops due to a missing option (37).
	if (getGameType() == GType_FF && _currentTable->id == 10538 && readVariable(116) == 37)
			writeVariable(116, 38);
}

void AGOSEngine::o_sub() {
	// 44: sub
	uint var = getVarWrapper();
	writeVariable(var, readVariable(var) - getVarOrWord());
}

void AGOSEngine::o_addf() {
	// 45: add f
	uint var = getVarWrapper();
	writeVariable(var, readVariable(var) + getNextVarContents());
}

void AGOSEngine::o_subf() {
	// 46: sub f
	uint var = getVarWrapper();
	writeVariable(var, readVariable(var) - getNextVarContents());
}

void AGOSEngine::o_mul() {
	// 47: mul
	uint var = getVarWrapper();
	writeVariable(var, readVariable(var) * getVarOrWord());
}

void AGOSEngine::o_div() {
	// 48: div
	uint var = getVarWrapper();
	int value = getVarOrWord();
	if (value == 0)
		error("o_div: Division by zero");
	writeVariable(var, readVariable(var) / value);
}

void AGOSEngine::o_mulf() {
	// 49: mul f
	uint var = getVarWrapper();
	writeVariable(var, readVariable(var) * getNextVarContents());
}

void AGOSEngine::o_divf() {
	// 50: div f
	uint var = getVarWrapper();
	int value = getNextVarContents();
	if (value == 0)
		error("o_divf: Division by zero");
	writeVariable(var, readVariable(var) / value);
}

void AGOSEngine::o_mod() {
	// 51: mod
	uint var = getVarWrapper();
	int value = getVarOrWord();
	if (value == 0)
		error("o_mod: Division by zero");
	writeVariable(var, readVariable(var) % value);
}

void AGOSEngine::o_modf() {
	// 52: mod f
	uint var = getVarWrapper();
	int value = getNextVarContents();
	if (value == 0)
		error("o_modf: Division by zero");
	writeVariable(var, readVariable(var) % value);
}

void AGOSEngine::o_random() {
	// 53: random
	uint var = getVarWrapper();
	uint value = (uint16)getVarOrWord();
	writeVariable(var, _rnd.getRandomNumber(value - 1));
}

void AGOSEngine::o_goto() {
	// 55: set itemA parent
	uint item = getNextItemID();
	setItemParent(me(), _itemArrayPtr[item]);
}

void AGOSEngine::o_oset() {
	// 56: set child2 fr bit
	SubObject *subObject = (SubObject *)findChildOfType(getNextItemPtr(), kObjectType);
	int value = getVarOrByte();
	if (subObject != nullptr && value >= 16)
		subObject->objectFlags |= (1 << value);
}

void AGOSEngine::o_oclear() {
	// 57: clear child2 fr bit
	SubObject *subObject = (SubObject *)findChildOfType(getNextItemPtr(), kObjectType);
	int value = getVarOrByte();
	if (subObject != nullptr && value >= 16)
		subObject->objectFlags &= ~(1 << value);
}

void AGOSEngine::o_putBy() {
	// 58: make siblings
	Item *item = getNextItemPtr();
	setItemParent(item, derefItem(getNextItemPtr()->parent));
}

void AGOSEngine::o_inc() {
	// 59: item inc state
	Item *item = getNextItemPtr();
	if (item->state <= 30000) {
		setItemState(item, item->state + 1);
		synchChain(item);
	}
}

void AGOSEngine::o_dec() {
	// 60: item dec state
	Item *item = getNextItemPtr();
	if (item->state >= 0) {
		setItemState(item, item->state - 1);
		synchChain(item);
	}
}

void AGOSEngine::o_setState() {
	// 61: item set state
	Item *item = getNextItemPtr();
	int value = getVarOrWord();
	if (value < 0)
		value = 0;
	if (value > 30000)
		value = 30000;
	setItemState(item, value);
	synchChain(item);
}

void AGOSEngine::o_print() {
	// 62: show int
	showMessageFormat("%d", getNextVarContents());
}

void AGOSEngine::o_message() {
	// 63: show string nl
	showMessageFormat("%s\n", getStringPtrByID(getNextStringID()));
}

void AGOSEngine::o_msg() {
	// 64: show string
	showMessageFormat("%s", getStringPtrByID(getNextStringID()));
}

void AGOSEngine::o_end() {
	// 68: exit interpreter
	quitGame();
	// Make sure the quit event is processed immediately.
	delay(0);
}

void AGOSEngine::o_done() {
	// 69: return 1
	setScriptReturn(1);
}

void AGOSEngine::o_process() {
	// 71: start subroutine
	uint16 id = getVarOrWord();

	if (!_copyProtection && getGameType() == GType_WW && id == 71) {
		// Copy protection was disabled in Good Old Games release
		return;
	}

	Subroutine *sub = getSubroutineByID(id);
	if (sub != nullptr) {
#ifdef __DS__
		// HACK: Skip scene of Simon reading letter from Calypso
		// due to speech segment been too large to fit into memory
		if (getGameType() == GType_SIMON1 && (getFeatures() & GF_TALKIE) &&
			getPlatform() == Common::kPlatformWindows && sub->id == 2922) {
			// set parent special
			_noParentNotify = true;
			setItemParent(derefItem(16), me());
			_noParentNotify = false;

			// set parent special
			_noParentNotify = true;
			setItemParent(derefItem(14), me());
			_noParentNotify = false;

			// set item parent
			setItemParent(derefItem(12), me());

			return;
		}
#endif
		startSubroutine(sub);
	}
}

void AGOSEngine::o_when() {
	// 76: add timeout
	uint16 timeout = getVarOrWord();
	addTimeEvent(timeout, getVarOrWord());
}

void AGOSEngine::o_if1() {
	// 77: has item minus 1
	setScriptCondition(_subjectItem != nullptr);
}

void AGOSEngine::o_if2() {
	// 78: has item minus 3
	setScriptCondition(_objectItem != nullptr);
}

void AGOSEngine::o_isCalled() {
	// 79: childstruct fr2 is
	SubObject *subObject = (SubObject *)findChildOfType(getNextItemPtr(), kObjectType);
	uint stringId = getNextStringID();
	setScriptCondition((subObject != nullptr) && subObject->objectName == stringId);
}

void AGOSEngine::o_is() {
	// 80: item equal
	setScriptCondition(getNextItemPtr() == getNextItemPtr());
}

void AGOSEngine::o_debug() {
	// 82: debug opcode
	getVarOrByte();
}

void AGOSEngine::o_comment() {
	// 87: comment
	getNextStringID();
}

void AGOSEngine::o_haltAnimation() {
	// 88: stop animation
	_videoLockOut |= 0x10;

	if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
		VgaTimerEntry *vte = _vgaTimerList;
		while (vte->delay) {
			if (vte->type == ANIMATE_EVENT)
				vte->delay += 10;
			vte++;
		}

		_scrollCount = 0;
		_scrollFlag = 0;
	}
}

void AGOSEngine::o_restartAnimation() {
	// 89: restart animation
	_videoLockOut &= ~0x10;
}

void AGOSEngine::o_getParent() {
	// 90: set minusitem to parent
	Item *i = getNextItemPtr();
	if (getVarOrByte() == 1)
		_subjectItem = derefItem(i->parent);
	else
		_objectItem = derefItem(i->parent);
}

void AGOSEngine::o_getNext() {
	// 91: set minusitem to next
	Item *i = getNextItemPtr();
	if (getVarOrByte() == 1)
		_subjectItem = derefItem(i->next);
	else
		_objectItem = derefItem(i->next);
}

void AGOSEngine::o_getChildren() {
	// 92: set minusitem to child
	Item *i = getNextItemPtr();
	if (getVarOrByte() == 1)
		_subjectItem = derefItem(i->child);
	else
		_objectItem = derefItem(i->child);
}

void AGOSEngine::o_picture() {
	// 96
	uint vga_res = getVarOrWord();
	uint mode = getVarOrByte();

	// WORKAROUND: For a script bug in the Amiga AGA/CD32 versions
	// When selecting locations on the magical map, the script looks
	// for vga_res 12701, but only vga_res 12700 exists.
	if (getGameType() == GType_SIMON1 && getPlatform() == Common::kPlatformAmiga &&
		vga_res == 12701) {
		return;
	}

	if (getGameType() == GType_PP && getGameId() != GID_DIMP) {
		if (vga_res == 8700 && getBitFlag(107)) {
			_vgaPeriod = 30;
		}

		_picture8600 = (vga_res == 8600);
	}

	setWindowImageEx(mode, vga_res);
}

void AGOSEngine::o_loadZone() {
	// 97: load zone
	uint vga_res = getVarOrWord();

	_videoLockOut |= 0x80;

	if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2 ||
		getGameType() == GType_WW) {
		vc27_resetSprite();
		vc29_stopAllSounds();
	}

	loadZone(vga_res);

	if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2 ||
		getGameType() == GType_WW) {
		_copyScnFlag = 0;
		_vgaSpriteChanged = 0;
	}

	_videoLockOut &= ~0x80;
}

void AGOSEngine::o_killAnimate() {
	// 100: kill animations
	_videoLockOut |= 0x8000;
	vc27_resetSprite();
	_videoLockOut &= ~0x8000;
}

void AGOSEngine::o_defWindow() {
	// 101: define window
	uint num = getVarOrByte();
	uint x = getVarOrWord();
	uint y = getVarOrWord();
	uint w = getVarOrWord();
	uint h = getVarOrWord();
	uint flags = getVarOrWord();
	uint color = getVarOrWord();

	uint fillColor, textColor;
	if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2 ||
		getGameType() == GType_WW) {
		fillColor = color % 100;
		textColor = color / 100;
	} else {
		fillColor = color;
		textColor = 0;
	}

	num &= 7;

	if (_windowArray[num])
		closeWindow(num);

	_windowArray[num] = openWindow(x, y, w, h, flags, fillColor, textColor);

	if (num == _curWindow) {
		_textWindow = _windowArray[num];
		justifyStart();
	}
}

void AGOSEngine::o_window() {
	// 102
	changeWindow(getVarOrByte() & 7);
}

void AGOSEngine::o_cls() {
	// 103
	mouseOff();
	removeIconArray(_curWindow);
	showMessageFormat("\x0C");
	_oracleMaxScrollY = 0;
	_noOracleScroll = 0;
	mouseOn();
}

void AGOSEngine::o_closeWindow() {
	// 104
	closeWindow(getVarOrByte() & 7);
}

void AGOSEngine::o_addBox() {
	// 107: add item box
	uint flags = 0;
	uint id = getVarOrWord();
	uint params = id / 1000;
	uint x, y, w, h, verb;
	Item *item;

	id = id % 1000;

	if (params & 1)
		flags |= kBFInvertTouch;
	if (params & 2)
		flags |= kBFNoTouchName;
	if (params & 4)
		flags |= kBFBoxItem;
	if (params & 8)
		flags |= kBFTextBox;
	if (params & 16)
		flags |= kBFDragBox;

	x = getVarOrWord();
	y = getVarOrWord();
	w = getVarOrWord();
	h = getVarOrWord();
	item = getNextItemPtrStrange();
	verb = getVarOrWord();
	if (x >= 1000) {
		verb += 0x4000;
		x -= 1000;
	}
	defineBox(id, x, y, w, h, flags, verb, item);
}

void AGOSEngine::o_delBox() {
	// 108: delete box
	undefineBox(getVarOrWord());
}

void AGOSEngine::o_enableBox() {
	// 109: enable box
	enableBox(getVarOrWord());
}

void AGOSEngine::o_disableBox() {
	// 110: set hitarea bit 0x40
	disableBox(getVarOrWord());
}

void AGOSEngine::o_moveBox() {
	// 111: set hitarea xy
	uint hitarea_id = getVarOrWord();
	uint x = getVarOrWord();
	uint y = getVarOrWord();
	moveBox(hitarea_id, x, y);
}

void AGOSEngine::o_doIcons() {
	// 114
	Item *item = getNextItemPtr();
	uint num = getVarOrByte();
	mouseOff();
	drawIconArray(num, item, 0, 0);
	mouseOn();
}

void AGOSEngine::o_isClass() {
	// 115: item has flag
	Item *item = getNextItemPtr();
	setScriptCondition((item->classFlags & (1 << getVarOrByte())) != 0);
}

void AGOSEngine::o_setClass() {
	// 116: item set flag
	Item *item = getNextItemPtr();
	item->classFlags |= (1 << getVarOrByte());
}

void AGOSEngine::o_unsetClass() {
	// 117: item clear flag
	Item *item = getNextItemPtr();
	item->classFlags &= ~(1 << getVarOrByte());
}

void AGOSEngine::o_waitSync() {
	// 119: wait vga
	uint var = getVarOrWord();
	_scriptVar2 = (var == 200);

	if (var != 200 || !_skipVgaWait)
		waitForSync(var);
	_skipVgaWait = false;
}

void AGOSEngine::o_sync() {
	// 120: sync
	sendSync(getVarOrWord());
}

void AGOSEngine::o_defObj() {
	// 121: set vga item
	uint slot = getVarOrByte();
	_objectArray[slot] = getNextItemPtr();
}

void AGOSEngine::o_here() {
	// 125: item is sibling with item 1
	Item *item = getNextItemPtr();
	setScriptCondition(me()->parent == item->parent);
}

void AGOSEngine::o_doClassIcons() {
	// 126: do class icons
	Item *item = getNextItemPtr();
	uint num = getVarOrByte();
	uint a = getVarOrByte();

	mouseOff();
	if (getGameType() == GType_ELVIRA1)
		drawIconArray(num, item, 0, a);
	else
		drawIconArray(num, item, 0, 1 << a);
	mouseOn();
}

void AGOSEngine::o_playTune() {
	// 127: play tune
	uint16 music = getVarOrWord();
	uint16 track = getVarOrWord();

	if (music != _lastMusicPlayed) {
		_lastMusicPlayed = music;
		playMusic(music, track);
	}
}

void AGOSEngine::o_setAdjNoun() {
	// 130: set adj noun
	uint var = getVarOrByte();
	if (var == 1) {
		_scriptAdj1 = getNextWord();
		_scriptNoun1 = getNextWord();
	} else {
		_scriptAdj2 = getNextWord();
		_scriptNoun2 = getNextWord();
	}
}

void AGOSEngine::o_saveUserGame() {
	// 132: save user game
	if (getGameId() == GID_SIMON1CD32) {
		// The Amiga CD32 version of Simon the Sorcerer 1 uses a single slot
		if (!saveGame(0, "Default Saved Game")) {
			vc33_setMouseOn();
			fileError(_windowArray[5], true);
		}
	} else {
		_system->setFeatureState(OSystem::kFeatureVirtualKeyboard, true);
		userGame(false);
		_system->setFeatureState(OSystem::kFeatureVirtualKeyboard, false);
	}
}

void AGOSEngine::o_loadUserGame() {
	// 133: load user game
	if (getGameId() == GID_SIMON1CD32) {
		// The Amiga CD32 version of Simon the Sorcerer 1 uses a single slot
		if (!loadGame(genSaveName(0))) {
			vc33_setMouseOn();
			fileError(_windowArray[5], false);
		}
	} else {
		_system->setFeatureState(OSystem::kFeatureVirtualKeyboard, true);
		userGame(true);
		_system->setFeatureState(OSystem::kFeatureVirtualKeyboard, false);
	}
}

void AGOSEngine::o_copysf() {
	// 136: set var to item unk3
	Item *item = getNextItemPtr();
	writeNextVarContents(item->state);
}

void AGOSEngine::o_restoreIcons() {
	// 137
	uint num = getVarOrByte();
	WindowBlock *window = _windowArray[num & 7];
	if (window->iconPtr)
		drawIconArray(num, window->iconPtr->itemRef, window->iconPtr->line, window->iconPtr->classMask);
}

void AGOSEngine::o_freezeZones() {
	// 138: freeze zones
	freezeBottom();

	if (!_copyProtection && !(getFeatures() & GF_TALKIE) && _currentTable) {
		if ((getGameType() == GType_SIMON1 && _currentTable->id == 2924) ||
			(getGameType() == GType_SIMON2 && _currentTable->id == 1322)) {
			_variableArray[134] = 3;
			_variableArray[135] = 3;
			setBitFlag(135, 1);
			setScriptCondition(0);
		}
	}
}

void AGOSEngine::o_placeNoIcons() {
	// 139: set parent special
	Item *item = getNextItemPtr();
	_noParentNotify = true;
	setItemParent(item, getNextItemPtr());
	_noParentNotify = false;
}

void AGOSEngine::o_clearTimers() {
	// 140: clear timers
	killAllTimers();

	if (getGameType() == GType_SIMON1)
		addTimeEvent(3, 160);
}

void AGOSEngine::o_setDollar() {
	// 141: set m1 to m3
	uint which = getVarOrByte();
	Item *item = getNextItemPtr();
	if (which == 1) {
		_subjectItem = item;
	} else {
		_objectItem = item;
	}
}

void AGOSEngine::o_isBox() {
	// 142: is box dead
	setScriptCondition(isBoxDead(getVarOrWord()));
}

// -----------------------------------------------------------------------

byte AGOSEngine::getByte() {
	return *_codePtr++;
}

int AGOSEngine::getNextWord() {
	int16 a = (int16)READ_BE_UINT16(_codePtr);
	_codePtr += 2;
	return a;
}

uint AGOSEngine::getNextStringID() {
	return (uint16)getNextWord();
}

uint AGOSEngine::getVarOrByte() {
	if (getGameType() == GType_ELVIRA1) {
		return getVarOrWord();
	} else {
		uint a = *_codePtr++;
		if (a != 255)
			return a;
		return readVariable(*_codePtr++);
	}
}

uint AGOSEngine::getVarOrWord() {
	uint a = READ_BE_UINT16(_codePtr);
	_codePtr += 2;
	if (getGameType() == GType_PP) {
		if (a >= 60000 && a < 62048) {
			return readVariable(a - 60000);
		}
	} else {
		if (a >= 30000 && a < 30512) {
			return readVariable(a - 30000);
		}
	}
	return a;
}

uint AGOSEngine::getVarWrapper() {
	if (getGameType() == GType_ELVIRA1 || getGameType() == GType_PP)
		return getVarOrWord();
	else
		return getVarOrByte();
}

uint AGOSEngine::getNextVarContents() {
	return (uint16)readVariable(getVarWrapper());
}

uint AGOSEngine::readVariable(uint16 variable) {
	if (variable >= _numVars)
		error("readVariable: Variable %d out of range", variable);

	if (getGameType() == GType_PP) {
		return (uint16)_variableArray[variable];
	} else if (getGameType() == GType_FF) {
		if (getBitFlag(83))
			return (uint16)_variableArray2[variable];
		else
			return (uint16)_variableArray[variable];
	} else {
			return _variableArray[variable];
	}
}

void AGOSEngine::writeNextVarContents(uint16 contents) {
	writeVariable(getVarWrapper(), contents);
}

void AGOSEngine::writeVariable(uint16 variable, uint16 contents) {
	if (variable >= _numVars)
		error("writeVariable: Variable %d out of range", variable);

	if (getGameType() == GType_FF && getBitFlag(83))
		_variableArray2[variable] = contents;
	else
		_variableArray[variable] = contents;
}

int AGOSEngine::runScript() {
	bool flag;

	if (shouldQuit())
		return 1;

	do {
		if (DebugMan.isDebugChannelEnabled(kDebugOpcode))
			dumpOpcode(_codePtr);

		if (getGameType() == GType_ELVIRA1) {
			_opcode = getVarOrWord();
			if (_opcode == 10000)
				return 0;
		} else {
			_opcode = getByte();
			if (_opcode == 0xFF)
				return 0;
		}

		if (_runScriptReturn1)
			return 1;

		/* Invert condition? */
		flag = false;
		if (getGameType() == GType_ELVIRA1) {
			if (_opcode == 203) {
				flag = true;
				_opcode = getVarOrWord();
				if (_opcode == 10000)
					return 0;
			}
		} else {
			if (_opcode == 0) {
				flag = true;
				_opcode = getByte();
				if (_opcode == 0xFF)
					return 0;
			}
		}

		setScriptCondition(true);
		setScriptReturn(0);

		if (_opcode > _numOpcodes)
			error("Invalid opcode '%d' encountered", _opcode);

		executeOpcode(_opcode);
	} while (getScriptCondition() != flag && !getScriptReturn() && !shouldQuit());

	return (shouldQuit()) ? 1 : getScriptReturn();
}

Child *nextSub(Child *sub, int16 key) {
	Child *a = sub->next;
	while (a) {
		if (a->type == key)
			return a;
		a = a->next;
	}
	return nullptr;
}

void AGOSEngine::synchChain(Item *i) {
	SubChain *c = (SubChain *)findChildOfType(i, kChainType);
	while (c) {
		setItemState(derefItem(c->chChained), i->state);
		c = (SubChain *)nextSub((Child *)c, kChainType);
	}
}

void AGOSEngine::sendSync(uint a) {
	uint16 id = to16Wrapper(a);
	_videoLockOut |= 0x8000;
	_vcPtr = (byte *)&id;
	vc15_sync();
	_videoLockOut &= ~0x8000;
}

void AGOSEngine::stopAnimate(uint16 a) {
	uint16 b = to16Wrapper(a);
	_videoLockOut |= 0x8000;
	_vcPtr = (byte *)&b;
	vc60_stopAnimation();
	_videoLockOut &= ~0x8000;
}

void AGOSEngine::waitForSync(uint a) {
	const uint maxCount = (getGameType() == GType_SIMON1) ? 1000 : 2500;

	if (getGameType() == GType_SIMON1 && (getFeatures() & GF_TALKIE)) {
		if (a != 200) {
			uint16 tmp = _lastVgaWaitFor;
			_lastVgaWaitFor = 0;
			if (tmp == a)
				return;
		}
	}

	_vgaWaitFor = a;
	_syncCount = 0;
	_exitCutscene = false;
	_rightButtonDown = false;

	while (_vgaWaitFor != 0 && !shouldQuit()) {
		if (_rightButtonDown) {
			if (_vgaWaitFor == 200 && (getGameType() == GType_FF || !getBitFlag(14))) {
				skipSpeech();
				break;
			}
		}
		if (_exitCutscene) {
			if (getGameType() == GType_ELVIRA1) {
				if (_variableArray[105] == 0) {
					_variableArray[105] = 255;
					break;
				}
			} else if (getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) {
				if (_vgaWaitFor == 51) {
					setBitFlag(244, 1);
					break;
				}
			} else {
				if (getBitFlag(9)) {
					endCutscene();
					break;
				}
			}
		}
		processSpecialKeys();

		if (_syncCount >= maxCount) {
			warning("waitForSync: wait timed out");
			break;
		}

		delay(1);
	}
}

} // End of namespace AGOS

================
File: script_dp.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */



#ifdef ENABLE_AGOS2

#include "agos/agos.h"

namespace AGOS {

#define OPCODE(x)	_OPCODE(AGOSEngine_DIMP, x)

void AGOSEngine_DIMP::setupOpcodes() {
	static const OpcodeEntryDIMP opcodes[] = {
		/* 00 */
		OPCODE(o_invalid),
		OPCODE(o_at),
		OPCODE(o_notAt),
		OPCODE(o_invalid),
		/* 04 */
		OPCODE(o_invalid),
		OPCODE(o_carried),
		OPCODE(o_notCarried),
		OPCODE(o_isAt),
		/* 08 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_zero),
		/* 12 */
		OPCODE(o_notZero),
		OPCODE(o_eq),
		OPCODE(o_notEq),
		OPCODE(o_gt),
		/* 16 */
		OPCODE(o_lt),
		OPCODE(o_eqf),
		OPCODE(o_notEqf),
		OPCODE(o_ltf),
		/* 20 */
		OPCODE(o_gtf),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(off_chance),
		/* 24 */
		OPCODE(o_invalid),
		OPCODE(o_isRoom),
		OPCODE(o_isObject),
		OPCODE(o_state),
		/* 28 */
		OPCODE(o_oflag),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_destroy),
		/* 32 */
		OPCODE(o_invalid),
		OPCODE(o_place),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 36 */
		OPCODE(o_copyff),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 40 */
		OPCODE(o_invalid),
		OPCODE(o_clear),
		OPCODE(o_let),
		OPCODE(o_add),
		/* 44 */
		OPCODE(o_sub),
		OPCODE(o_addf),
		OPCODE(o_subf),
		OPCODE(o_mul),
		/* 48 */
		OPCODE(o_div),
		OPCODE(o_mulf),
		OPCODE(o_divf),
		OPCODE(o_mod),
		/* 52 */
		OPCODE(o_modf),
		OPCODE(o_random),
		OPCODE(o_invalid),
		OPCODE(o_goto),
		/* 56 */
		OPCODE(o_oset),
		OPCODE(o_oclear),
		OPCODE(o_putBy),
		OPCODE(o_inc),
		/* 60 */
		OPCODE(o_dec),
		OPCODE(o_setState),
		OPCODE(o_print),
		OPCODE(o_message),
		/* 64 */
		OPCODE(o_msg),
		OPCODE(off_addTextBox),
		OPCODE(opp_setShortText),
		OPCODE(oww_setLongText),
		/* 68 */
		OPCODE(o_end),
		OPCODE(o_done),
		OPCODE(off_printLongText),
		OPCODE(o_process),
		/* 72 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 76 */
		OPCODE(o_when),
		OPCODE(o_if1),
		OPCODE(o_if2),
		OPCODE(o_isCalled),
		/* 80 */
		OPCODE(o_is),
		OPCODE(o_invalid),
		OPCODE(o_debug),
		OPCODE(os2_rescan),
		/* 84 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_comment),
		/* 88 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_getParent),
		OPCODE(o_getNext),
		/* 92 */
		OPCODE(o_getChildren),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 96 */
		OPCODE(o_picture),
		OPCODE(o_loadZone),
		OPCODE(os2_animate),
		OPCODE(os2_stopAnimate),
		/* 100 */
		OPCODE(o_killAnimate),
		OPCODE(o_defWindow),
		OPCODE(o_window),
		OPCODE(o_cls),
		/* 104 */
		OPCODE(o_closeWindow),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(off_addBox),
		/* 108 */
		OPCODE(o_delBox),
		OPCODE(o_enableBox),
		OPCODE(o_disableBox),
		OPCODE(o_moveBox),
		/* 112 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_doIcons),
		OPCODE(o_isClass),
		/* 116 */
		OPCODE(o_setClass),
		OPCODE(o_unsetClass),
		OPCODE(o_invalid),
		OPCODE(o_waitSync),
		/* 120 */
		OPCODE(o_sync),
		OPCODE(o_defObj),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 124 */
		OPCODE(off_ifTime),
		OPCODE(o_here),
		OPCODE(o_doClassIcons),
		OPCODE(o_invalid),
		/* 128 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_setAdjNoun),
		OPCODE(off_setTime),
		/* 132 */
		OPCODE(odp_saveUserGame),
		OPCODE(odp_loadUserGame),
		OPCODE(off_listSaveGames),
		OPCODE(o_invalid),
		/* 136 */
		OPCODE(o_copysf),
		OPCODE(o_restoreIcons),
		OPCODE(o_freezeZones),
		OPCODE(o_placeNoIcons),
		/* 140 */
		OPCODE(o_clearTimers),
		OPCODE(o_setDollar),
		OPCODE(o_isBox),
		OPCODE(oe2_doTable),
		/* 144 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 148 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(oe2_storeItem),
		/* 152 */
		OPCODE(oe2_getItem),
		OPCODE(oe2_bSet),
		OPCODE(oe2_bClear),
		OPCODE(oe2_bZero),
		/* 156 */
		OPCODE(oe2_bNotZero),
		OPCODE(oe2_getOValue),
		OPCODE(oe2_setOValue),
		OPCODE(o_invalid),
		/* 160 */
		OPCODE(oe2_ink),
		OPCODE(off_screenTextBox),
		OPCODE(opp_playTune),
		OPCODE(o_invalid),
		/* 164 */
		OPCODE(oe2_getDollar2),
		OPCODE(off_isAdjNoun),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 168 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 172 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(oww_lockZones),
		/* 176 */
		OPCODE(oww_unlockZones),
		OPCODE(off_screenTextPObj),
		OPCODE(os1_getPathPosn),
		OPCODE(os1_scnTxtLongText),
		/* 180 */
		OPCODE(os1_mouseOn),
		OPCODE(off_mouseOff),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 184 */
		OPCODE(os1_unloadZone),
		OPCODE(o_invalid),
		OPCODE(os1_unfreezeZones),
		OPCODE(off_centerScroll),
		/* 188 */
		OPCODE(os2_isShortText),
		OPCODE(os2_clearMarks),
		OPCODE(os2_waitMark),
		OPCODE(opp_resetPVCount),
		/* 192 */
		OPCODE(opp_setPathValues),
		OPCODE(off_stopClock),
		OPCODE(off_restartClock),
		OPCODE(off_setColor),
	};

	_opcodesDIMP = opcodes;
	_numOpcodes = 196;
}

void AGOSEngine_DIMP::executeOpcode(int opcode) {
	OpcodeProcDIMP op = _opcodesDIMP[opcode].proc;
	(this->*op) ();
}

// -----------------------------------------------------------------------
// DIMP Opcodes
// -----------------------------------------------------------------------


void AGOSEngine_DIMP::odp_saveUserGame() {
	// 132: save game
	saveGame(1, NULL);
}

void AGOSEngine_DIMP::odp_loadUserGame() {
	// 133: load usergame
	loadGame(genSaveName(1));
}

} // End of namespace AGOS

#endif // ENABLE_AGOS2

================
File: script_e1.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */


#include "agos/agos.h"
#include "agos/intern.h"
#include "agos/vga.h"

namespace AGOS {

#define OPCODE(x)	_OPCODE(AGOSEngine_Elvira1, x)

void AGOSEngine_Elvira1::setupOpcodes() {
	static const OpcodeEntryElvira1 opcodes[] = {
		/* 00 */
		OPCODE(o_at),
		OPCODE(o_notAt),
		OPCODE(oe1_present),
		OPCODE(oe1_notPresent),
		/* 04 */
		OPCODE(oe1_worn),
		OPCODE(oe1_notWorn),
		OPCODE(o_carried),
		OPCODE(o_notCarried),
		/* 08 */
		OPCODE(o_isAt),
		OPCODE(oe1_isNotAt),
		OPCODE(oe1_sibling),
		OPCODE(oe1_notSibling),
		/* 12 */
		OPCODE(o_zero),
		OPCODE(o_notZero),
		OPCODE(o_eq),
		OPCODE(o_notEq),
		/* 16 */
		OPCODE(o_gt),
		OPCODE(o_lt),
		OPCODE(o_eqf),
		OPCODE(o_notEqf),
		/* 20 */
		OPCODE(o_ltf),
		OPCODE(o_gtf),
		OPCODE(oe1_isIn),
		OPCODE(oe1_isNotIn),
		/* 24 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 28 */
		OPCODE(o_invalid),
		OPCODE(o_chance),
		OPCODE(oe1_isPlayer),
		OPCODE(o_invalid),
		/* 32 */
		OPCODE(o_isRoom),
		OPCODE(o_isObject),
		OPCODE(o_state),
		OPCODE(o_invalid),
		/* 36 */
		OPCODE(o_oflag),
		OPCODE(oe1_canPut),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 40 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 44 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(oe1_create),
		/* 48 */
		OPCODE(o_destroy),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_place),
		/* 52 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(oe1_copyof),
		OPCODE(oe1_copyfo),
		/* 56 */
		OPCODE(o_copyff),
		OPCODE(oe1_whatO),
		OPCODE(o_invalid),
		OPCODE(oe1_weigh),
		/* 60 */
		OPCODE(oe1_setFF),
		OPCODE(o_clear),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 64 */
		OPCODE(o_let),
		OPCODE(o_add),
		OPCODE(o_sub),
		OPCODE(o_addf),
		/* 68 */
		OPCODE(o_subf),
		OPCODE(o_mul),
		OPCODE(o_div),
		OPCODE(o_mulf),
		/* 72 */
		OPCODE(o_divf),
		OPCODE(o_mod),
		OPCODE(o_modf),
		OPCODE(o_random),
		/* 76 */
		OPCODE(oe1_moveDirn),
		OPCODE(o_goto),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 80 */
		OPCODE(o_oset),
		OPCODE(o_oclear),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 84 */
		OPCODE(o_putBy),
		OPCODE(o_inc),
		OPCODE(o_dec),
		OPCODE(o_setState),
		/* 88 */
		OPCODE(o_invalid),
		OPCODE(o_print),
		OPCODE(oe1_score),
		OPCODE(o_message),
		/* 92 */
		OPCODE(o_msg),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 96 */
		OPCODE(oe1_look),
		OPCODE(o_end),
		OPCODE(o_done),
		OPCODE(o_invalid),
		/* 100 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 104 */
		OPCODE(o_invalid),
		OPCODE(o_process),
		OPCODE(oe1_doClass),
		OPCODE(o_invalid),
		/* 108 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 112*/
		OPCODE(oe1_pObj),
		OPCODE(o_invalid),
		OPCODE(oe1_pName),
		OPCODE(oe1_pcName),
		/* 116 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_when),
		/* 120 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 124 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 128 */
		OPCODE(o_if1),
		OPCODE(o_if2),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 132 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(oe1_isCalled),
		/* 136 */
		OPCODE(o_is),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 140 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 144 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 148 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 152 */
		OPCODE(o_debug),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 156 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 160 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(oe1_cFlag),
		OPCODE(o_invalid),
		/* 164 */
		OPCODE(oe1_rescan),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 168 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 172 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 176 */
		OPCODE(oe1_setUserItem),
		OPCODE(oe1_getUserItem),
		OPCODE(oe1_clearUserItem),
		OPCODE(o_invalid),
		/* 180 */
		OPCODE(oe1_whereTo),
		OPCODE(oe1_doorExit),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 184 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 188 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 192 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 196 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_comment),
		OPCODE(o_invalid),
		/* 200 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(oe1_loadGame),
		OPCODE(o_invalid),
		/* 204 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_getParent),
		OPCODE(o_getNext),
		/* 208 */
		OPCODE(o_getChildren),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 212 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 216 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(oe1_findMaster),
		/* 220 */
		OPCODE(oe1_nextMaster),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 224 */
		OPCODE(o_picture),
		OPCODE(o_loadZone),
		OPCODE(oe1_animate),
		OPCODE(oe1_stopAnimate),
		/* 228 */
		OPCODE(o_killAnimate),
		OPCODE(o_defWindow),
		OPCODE(o_window),
		OPCODE(o_cls),
		/* 232 */
		OPCODE(o_closeWindow),
		OPCODE(oe1_menu),
		OPCODE(o_invalid),
		OPCODE(oe1_addBox),
		/* 236 */
		OPCODE(o_delBox),
		OPCODE(o_enableBox),
		OPCODE(o_disableBox),
		OPCODE(o_moveBox),
		/* 240 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_doIcons),
		OPCODE(o_isClass),
		/* 244 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 248 */
		OPCODE(o_invalid),
		OPCODE(o_setClass),
		OPCODE(o_unsetClass),
		OPCODE(oe1_bitClear),
		/* 252 */
		OPCODE(oe1_bitSet),
		OPCODE(oe1_bitTest),
		OPCODE(o_invalid),
		OPCODE(o_waitSync),
		/* 256 */
		OPCODE(o_sync),
		OPCODE(o_defObj),
		OPCODE(oe1_enableInput),
		OPCODE(oe1_setTime),
		/* 260 */
		OPCODE(oe1_ifTime),
		OPCODE(o_here),
		OPCODE(o_doClassIcons),
		OPCODE(oe1_playTune),
		/* 264 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_setAdjNoun),
		OPCODE(oe1_zoneDisk),
		/* 268 */
		OPCODE(o_saveUserGame),
		OPCODE(o_loadUserGame),
		OPCODE(oe1_printStats),
		OPCODE(oe1_stopTune),
		/* 272 */
		OPCODE(oe1_printPlayerDamage),
		OPCODE(oe1_printMonsterDamage),
		OPCODE(oe1_pauseGame),
		OPCODE(o_copysf),
		/* 276 */
		OPCODE(o_restoreIcons),
		OPCODE(oe1_printPlayerHit),
		OPCODE(oe1_printMonsterHit),
		OPCODE(o_freezeZones),
		/* 280 */
		OPCODE(o_placeNoIcons),
		OPCODE(o_clearTimers),
		OPCODE(o_setDollar),
		OPCODE(o_isBox)
	};

	_opcodesElvira1 = opcodes;
	_numOpcodes = 284;
}

void AGOSEngine_Elvira1::executeOpcode(int opcode) {
	OpcodeProcElvira1 op = _opcodesElvira1[opcode].proc;
	(this->*op) ();
}

// -----------------------------------------------------------------------
// Elvira 1 Opcodes
// -----------------------------------------------------------------------

void AGOSEngine_Elvira1::oe1_present() {
	// 2: present (here or carried)
	Item *item = getNextItemPtr();
	setScriptCondition(item->parent == getItem1ID() || item->parent == me()->parent);
}

void AGOSEngine_Elvira1::oe1_notPresent() {
	// 3: not present (neither here nor carried)
	Item *item = getNextItemPtr();
	setScriptCondition(item->parent != getItem1ID() && item->parent != me()->parent);
}

void AGOSEngine_Elvira1::oe1_worn() {
	// 4: worn
	Item *item = getNextItemPtr();
	SubObject *subObject = (SubObject *)findChildOfType(item, kObjectType);

	if (item->parent != getItem1ID() || subObject == nullptr)
		setScriptCondition(false);
	else
		setScriptCondition((subObject->objectFlags & kOFWorn) != 0);
}

void AGOSEngine_Elvira1::oe1_notWorn() {
	// 5: not worn
	Item *item = getNextItemPtr();
	SubObject *subObject = (SubObject *)findChildOfType(item, kObjectType);

	if (item->parent != getItem1ID() || subObject == nullptr)
		setScriptCondition(false);
	else
		setScriptCondition((subObject->objectFlags & kOFWorn) == 0);
}

void AGOSEngine_Elvira1::oe1_isNotAt() {
	// 9: parent is not
	Item *item = getNextItemPtr();
	setScriptCondition(item->parent != getNextItemID());
}

void AGOSEngine_Elvira1::oe1_sibling() {
	// 10: sibling
	Item *item1 = getNextItemPtr();
	Item *item2 = getNextItemPtr();
	setScriptCondition(item1->parent == item2->parent);
}

void AGOSEngine_Elvira1::oe1_notSibling() {
	// 11: not sibling
	Item *item1 = getNextItemPtr();
	Item *item2 = getNextItemPtr();
	setScriptCondition(item1->parent != item2->parent);
}

void AGOSEngine_Elvira1::oe1_isIn() {
	// 22: is in
	Item *item1 = getNextItemPtr();
	Item *item2 = getNextItemPtr();
	setScriptCondition(contains(item1, item2) != 0);
}

void AGOSEngine_Elvira1::oe1_isNotIn() {
	// 23: is not in
	Item *item1 = getNextItemPtr();
	Item *item2 = getNextItemPtr();
	setScriptCondition(contains(item1, item2) == 0);
}

void AGOSEngine_Elvira1::oe1_isPlayer() {
	// 30: is player
	setScriptCondition(isPlayer(getNextItemPtr()));
}

void AGOSEngine_Elvira1::oe1_canPut() {
	// 37: can put
	Item *item1 = getNextItemPtr();
	Item *item2 = getNextItemPtr();
	setScriptCondition(canPlace(item1, item2) == 0);
}

void AGOSEngine_Elvira1::oe1_create() {
	// 47: create
	setItemParent(getNextItemPtr(), derefItem(me()->parent));
}

void AGOSEngine_Elvira1::oe1_copyof() {
	// 54: copy of
	Item *item = getNextItemPtr();
	uint tmp = getVarOrByte();
	writeNextVarContents(getUserFlag(item, tmp));
}

void AGOSEngine_Elvira1::oe1_copyfo() {
	// 55: copy fo
	uint tmp = getNextVarContents();
	Item *item = getNextItemPtr();
	setUserFlag(item, getVarOrByte(), tmp);
}

void AGOSEngine_Elvira1::oe1_whatO() {
	// 57: what o
	int a = getVarOrWord();

	if (a == 1)
		_subjectItem = findMaster(_scriptAdj1,_scriptNoun1);
	else
		_objectItem = findMaster(_scriptAdj2, _scriptNoun2);
}

void AGOSEngine_Elvira1::oe1_weigh() {
	// 59: weight
	Item *item = getNextItemPtr();
	writeNextVarContents(weighUp(item));
}

void AGOSEngine_Elvira1::oe1_setFF() {
	// 60: set FF
	writeNextVarContents(255);
}

void AGOSEngine_Elvira1::oe1_moveDirn() {
	// 54: move direction
	int16 d = readVariable(getVarOrWord());
	moveDirn(me(), d);
}

void AGOSEngine_Elvira1::oe1_score() {
	// 90: score
	SubPlayer *p = (SubPlayer *)findChildOfType(me(), kPlayerType);
	showMessageFormat("Your score is %d.\n", p->score);
}

void AGOSEngine_Elvira1::oe1_look() {
	// 96: look
	Item *i = derefItem(me()->parent);
	if (i == nullptr)
		return;

	SubRoom *r = (SubRoom *)findChildOfType(i, kRoomType);
	SubObject *o = (SubObject *)findChildOfType(i, kObjectType);
	SubPlayer *p = (SubPlayer *)findChildOfType(i, kPlayerType);
	if (p == nullptr)
		return;

	if ((o) && (!r)) {
		showMessageFormat("In the %s\n", (const char *)getStringPtrByID(i->itemName));
	} else if (p) {
		showMessageFormat("Carried by %s\n", (const char *)getStringPtrByID(i->itemName));
	}

	if (r) {
		showMessageFormat("%s", (const char *)getStringPtrByID(r->roomLong));
	}

	showMessageFormat("\n");

	Item *l = derefItem(i->child);
	if (l) {
		lobjFunc(l, "You can see ");	/* Show objects */
	}
}

void AGOSEngine_Elvira1::oe1_doClass() {
	// 106: do class
	Item *i = getNextItemPtr();
	int16 cm = getVarOrWord();
	int16 num = getVarOrWord();

	_classMask = (cm != -1) ? 1 << cm : 0;
	_classLine = (SubroutineLine *)((byte *)_currentTable + _currentLine->next);
	if (num == 1) {
		_subjectItem = findInByClass(i, (1 << cm));
		if (_subjectItem)
			_classMode1 = 1;
		else
			_classMode1 = 0;
	} else {
		_objectItem = findInByClass(i, (1 << cm));
		if (_objectItem)
			_classMode2 = 1;
		else
			_classMode2 = 0;
	}
}

void AGOSEngine_Elvira1::oe1_pObj() {
	// 112: print object name
	SubObject *subObject = (SubObject *)findChildOfType(getNextItemPtr(), kObjectType);
	getVarOrWord();

	if (subObject != nullptr)
		showMessageFormat("%s", (const char *)getStringPtrByID(subObject->objectName));
}

void AGOSEngine_Elvira1::oe1_pName() {
	// 114: print item name
	Item *i = getNextItemPtr();
	showMessageFormat("%s", (const char *)getStringPtrByID(i->itemName));
}

void AGOSEngine_Elvira1::oe1_pcName() {
	// 115: print item case (and change first letter to upper case)
	Item *i = getNextItemPtr();
	showMessageFormat("%s", (const byte *)getStringPtrByID(i->itemName, true));
}

void AGOSEngine_Elvira1::oe1_isCalled() {
	// 135: childstruct fr2 is
	Item *item = getNextItemPtr();
	uint stringId = getNextStringID();
	setScriptCondition(!scumm_stricmp((const char *)getStringPtrByID(item->itemName), (const char *)getStringPtrByID(stringId)));
}

void AGOSEngine_Elvira1::oe1_cFlag() {
	// 162: check container flag
	SubContainer *c = (SubContainer *)findChildOfType(getNextItemPtr(), kContainerType);
	uint bit = getVarOrWord();

	if (c == nullptr)
		setScriptCondition(false);
	else
		setScriptCondition((c->flags & (1 << bit)) != 0);
}

void AGOSEngine_Elvira1::oe1_rescan() {
	// 164: restart subroutine
	setScriptReturn(-10);
}

void AGOSEngine_Elvira1::oe1_setUserItem() {
	// 176: set user item
	Item *i = getNextItemPtr();
	uint tmp = getVarOrWord();
	setUserItem(i, tmp, getNextItemID());
}

void AGOSEngine_Elvira1::oe1_getUserItem() {
	// 177: get user item
	Item *i = getNextItemPtr();
	int n = getVarOrWord();

	if (getVarOrWord() == 1)
		_subjectItem = derefItem(getUserItem(i, n));
	else
		_objectItem = derefItem(getUserItem(i, n));
}

void AGOSEngine_Elvira1::oe1_whereTo() {
	// 180: where to
	Item *i = getNextItemPtr();
	int16 d = getVarOrWord();
	int16 f = getVarOrWord();

	if (f == 1)
		_subjectItem = getExitOf_e1(i, d);
	else
		_objectItem = getExitOf_e1(i, d);
}

void AGOSEngine_Elvira1::oe1_doorExit() {
	// 181: door exit
	Item *x;
	Item *a = (Item *)-1;
	SubChain *c;
	Item *i = getNextItemPtr();
	Item *d = getNextItemPtr();
	int16 f = getVarOrWord();
	int16 ct = 0;

	c = (SubChain *)findChildOfType(d, kChainType);
	if (c)
		a = derefItem(c->chChained);
	while (ct < 6) {
		x = getDoorOf(i, ct);
		if ((x == d) | (x == a)) {
			writeVariable(f, ct);
			return;
		}
		ct++;
	}
	writeVariable(f, 255);
}

void AGOSEngine_Elvira1::oe1_loadGame() {
	// 202: load restart state
	uint16 stringId = getNextStringID();
	loadGame((const char *)getStringPtrByID(stringId), true);
}

void AGOSEngine_Elvira1::oe1_clearUserItem() {
	// 178: clear user item
	Item *i = getNextItemPtr();
	uint tmp = getVarOrWord();
	setUserItem(i, tmp, 0);
}

void AGOSEngine_Elvira1::oe1_findMaster() {
	// 219: find master
	int16 ad, no;
	int16 d = getVarOrByte();

	ad = (d == 1) ? _scriptAdj1 : _scriptAdj2;
	no = (d == 1) ? _scriptNoun1 : _scriptNoun2;

	d = getVarOrByte();
	if (d == 1)
		_subjectItem = findMaster(ad, no);
	else
		_objectItem = findMaster(ad, no);
}

void AGOSEngine_Elvira1::oe1_nextMaster() {
	// 220: next master
	int16 ad, no;
	Item *item = getNextItemPtr();
	int16 d = getVarOrByte();

	ad = (d == 1) ? _scriptAdj1 : _scriptAdj2;
	no = (d == 1) ? _scriptNoun1 : _scriptNoun2;

	d = getVarOrByte();
	if (d == 1)
		_subjectItem = nextMaster(item, ad, no);
	else
		_objectItem = nextMaster(item, ad, no);
}

void AGOSEngine_Elvira1::oe1_animate() {
	// 226: animate
	uint16 vgaSpriteId = getVarOrWord();
	uint16 windowNum = getVarOrByte();
	int16 x = getVarOrWord();
	int16 y = getVarOrWord();
	uint16 palette = getVarOrWord();

	_videoLockOut |= 0x40;
	animate(windowNum, vgaSpriteId / 100, vgaSpriteId, x, y, palette);
	_videoLockOut &= ~0x40;
}

void AGOSEngine_Elvira1::oe1_stopAnimate() {
	// 227: stop animate
	stopAnimate(getVarOrWord());
}

void AGOSEngine_Elvira1::oe1_menu() {
	// 233: agos menu
	uint b = getVarOrWord();
	uint a = getVarOrWord();
	drawMenuStrip(a, b);
}

void AGOSEngine_Elvira1::oe1_addBox() {
	// 235: add item box
	uint flags = 0;
	uint id = getVarOrWord();
	uint params = id / 1000;
	uint x, y, w, h, verb;
	Item *item;

	id = id % 1000;

	if (params & 1)
		flags |= kBFInvertTouch;
	if (params & 2)
		flags |= kBFInvertSelect;
	if (params & 4)
		flags |= kBFBoxItem;
	if (params & 8)
		flags |= kBFToggleBox;
	if (params & 16)
		flags |= kBFDragBox;

	x = getVarOrWord();
	y = getVarOrWord();
	w = getVarOrWord();
	h = getVarOrWord();
	item = getNextItemPtrStrange();
	verb = getVarOrWord();
	if (x >= 1000) {
		verb += 0x4000;
		x -= 1000;
	}
	defineBox(id, x, y, w, h, flags, verb, item);
}

void AGOSEngine_Elvira1::oe1_bitClear() {
	// 251: set bit off
	int var = getVarOrWord();
	int bit = getVarOrWord();

	writeVariable(var, _variableArray[var] & ~(1 << bit));
}

void AGOSEngine_Elvira1::oe1_bitSet() {
	// 252: set bit on
	int var = getVarOrWord();
	int bit = getVarOrWord();

	writeVariable(var, _variableArray[var] | (1 << bit));
}

void AGOSEngine_Elvira1::oe1_bitTest() {
	// 253: bit test
	int var = getVarOrWord();
	int bit = getVarOrWord();

	setScriptCondition((_variableArray[var] & (1 << bit)) != 0);
}

void AGOSEngine_Elvira1::oe1_enableInput() {
	// 258: enable input
	_variableArray[500] = 0;

	for (int i = 120; i != 130; i++)
		disableBox(i);

	_verbHitArea = 0;
	_hitAreaSubjectItem = nullptr;
	_hitAreaObjectItem = nullptr;

	_dragFlag = false;
	_dragAccept = false;
	_dragCount = 0;
	_dragMode = false;

	_lastHitArea3 = nullptr;
	_lastHitArea = nullptr;

	_clickOnly = true;
}

void AGOSEngine_Elvira1::oe1_setTime() {
	// 259: set time
	_timeStore = getTime();
}

void AGOSEngine_Elvira1::oe1_ifTime() {
	// 260: if time
	uint a = getVarOrWord();
	uint32 t = getTime() - a;
	if (t >= _timeStore)
		setScriptCondition(true);
	else
		setScriptCondition(false);
}

void AGOSEngine_Elvira1::oe1_playTune() {
	// 264: play tune
	uint16 music = getVarOrWord();
	uint16 track = getVarOrWord();

	if (music != _lastMusicPlayed) {
		_lastMusicPlayed = music;
		// No tune under water
		if (music == 4) {
			stopMusic();
		} else {
			playMusic(music, track);
		}
	}
}

void AGOSEngine_Elvira1::oe1_zoneDisk() {
	// 267: set disk number of each zone
	getVarOrWord();
	getVarOrWord();
}

void AGOSEngine_Elvira1::oe1_printStats() {
	// 270: print stats
	printStats();
}

void AGOSEngine_Elvira1::oe1_stopTune() {
	// 271: stop tune
}

void AGOSEngine_Elvira1::oe1_printPlayerDamage() {
	// 272: print player damage
	WindowBlock *window = _dummyWindow;
	window->flags = 1;

	mouseOff();
	writeChar(window, 36, 38, 2, _variableArray[241]);
	mouseOn();
}

void AGOSEngine_Elvira1::oe1_printMonsterDamage() {
	// 273: print monster damage
	WindowBlock *window = _dummyWindow;
	window->flags = 1;

	mouseOff();
	writeChar(window, 36, 88, 2, _variableArray[242]);
	mouseOn();
}

void AGOSEngine_Elvira1::oe1_pauseGame() {
	// 274: pause game
	WindowBlock *window = _windowArray[4];
	const char *message1, *message2;

	uint32 pauseTime = getTime();
	haltAnimation();

restart:
	printScroll();
	window->textColumn = 0;
	window->textRow = 0;
	window->textColumnOffset = 0;
	window->textLength = 0;		// Difference

	switch (_language) {
	case Common::FR_FRA:
		message1 = "    Jeu interrompu.\r\r\r";
		message2 = " Reprendre    Quitter";
		break;
	case Common::DE_DEU:
		message1 = "         Pause.\r\r\r";
		message2 = "   Weiter      Ende";
		break;
	case Common::ES_ESP:
		message1 = "   Juego en Pausa\r\r\r";
		message2 = "Continuar      Salir";
		break;
	case Common::JA_JPN:
		message1 = "             ""\x83""Q""\x81""[""\x83\x80\x92\x86\x92""f\r\r\r";
		message2 = "        ""\x91\xb1\x82\xaf\x82\xe9""         ""\x82\xe2\x82\xdf\x82\xe9";
		break;
	default:
		message1 = "     Game Paused\r\r\r";
		message2 = " Continue      Quit";
		break;
	}

	for (; *message1; message1++)
		windowPutChar(window, *message1);
	for (; *message2; message2++)
		windowPutChar(window, *message2);

	if (continueOrQuit() == 0x7FFE) {
		printScroll();
		window->textColumn = 0;
		window->textRow = 0;
		window->textColumnOffset = 0;
		window->textLength = 0;		// Difference

		switch (_language) {
		case Common::FR_FRA:
			message1 = "    Etes-vous s<r ?\r\r\r";
			message2 = "     Oui      Non";
			break;
		case Common::DE_DEU:
			message1 = "    Bist Du sicher ?\r\r\r";
			message2 = "     Ja        Nein";
			break;
		case Common::ES_ESP:
			message1 = "    Estas seguro ?\r\r\r";
			message2 = "    Si          No";
			break;
		case Common::JA_JPN:
			message1 = "           ""\x82\xe6\x82\xeb\x82\xb5\x82\xa2\x82\xc5\x82\xb7\x82\xa9\x81""H\r\r\r";
			message2 = "         ""\x82\xcd\x82\xa2""          ""\x82\xa2\x82\xa2\x82\xa6";
			break;
		default:
			message1 = "    Are you sure ?\r\r\r";
			message2 = "     Yes       No";
			break;
		}

		for (; *message1; message1++)
			windowPutChar(window, *message1);
		for (; *message2; message2++)
			windowPutChar(window, *message2);

		if (confirmYesOrNo(120, 62) == 0x7FFF) {
			quitGame();
			// Make sure the quit event is processed immediately.
			delay(0);
		} else {
			goto restart;
		}
	}

	clearHiResTextLayer();
	restartAnimation();
	_gameStoppedClock = getTime() - pauseTime + _gameStoppedClock;
}

void AGOSEngine_Elvira1::oe1_printPlayerHit() {
	// 277: print player hit
	WindowBlock *window = _dummyWindow;
	window->flags = 1;

	mouseOff();
	writeChar(window, 3, 166, 0, _variableArray[414]);
	mouseOn();
}

void AGOSEngine_Elvira1::oe1_printMonsterHit() {
	// 278: print monster hit
	WindowBlock *window = _dummyWindow;
	window->flags = 1;

	mouseOff();
	writeChar(window, 35, 166, 4, _variableArray[415]);
	mouseOn();
}

int16 AGOSEngine::moreText(Item *i) {
	SubObject *o;
	i = derefItem(i->next);

	while (i) {
		o = (SubObject *)findChildOfType(i, kObjectType);
		if ((o) && (o->objectFlags & 1))
			goto l1;
		if (i != me())
			return 1;
	l1:	i = derefItem(i->next);
	}

	return 0;
}

void AGOSEngine::lobjFunc(Item *i, const char *f) {
	int n = 0;
	SubObject *o;

	while (i) {
		o = (SubObject *)findChildOfType(i, kObjectType);
		if ((o) && (o->objectFlags & 1))
			goto l1;
		if (i == me())
			goto l1;
		if (n == 0) {
			if (f)
				showMessageFormat("%s", f);
			n = 1;
		} else {
			if (moreText(i))
				showMessageFormat(", ");
			else
				showMessageFormat(" and ");
		}
		showMessageFormat("%s", (const char *)getStringPtrByID(i->itemName));
l1:		i = derefItem(i->next);
	}
	if (f) {
		if (n == 1)
			showMessageFormat(".\n");
	} else {
		if (n == 0)
			showMessageFormat("nothing");
	}
}

uint AGOSEngine::confirmYesOrNo(uint16 x, uint16 y) {
	HitArea *ha;

	ha = findEmptyHitArea();
	ha->x = x;
	ha->y = y;
	ha->width = 30;
	ha->height = 12;
	ha->flags = kBFBoxInUse;
	ha->id = 0x7FFF;
	ha->priority = 999;
	ha->window = nullptr;

	ha = findEmptyHitArea();
	ha->x = x + 60;
	ha->y = y;
	ha->width = 24;
	ha->height = 12;
	ha->flags = kBFBoxInUse;
	ha->id = 0x7FFE;
	ha->priority = 999;
	ha->window = nullptr;

	while (!shouldQuit()) {
		_lastHitArea = nullptr;
		_lastHitArea3 = nullptr;

		while (!shouldQuit()) {
			if (_lastHitArea3 != nullptr)
				break;
			delay(1);
		}

		ha = _lastHitArea;

		if (ha == nullptr) {
		} else if (ha->id == 0x7FFE) {
			break;
		} else if (ha->id == 0x7FFF) {
			break;
		}
	}

	undefineBox(0x7FFF);
	undefineBox(0x7FFE);

	return ha->id;
}

uint AGOSEngine::continueOrQuit() {
	HitArea *ha;

	ha = findEmptyHitArea();
	ha->x = 96;
	ha->y = 62;
	ha->width = 60;
	ha->height = 12;
	ha->flags = kBFBoxInUse;
	ha->id = 0x7FFF;
	ha->priority = 999;
	ha->window = nullptr;

	ha = findEmptyHitArea();
	ha->x = 180;
	ha->y = 62;
	ha->width = 36;
	ha->height = 12;
	ha->flags = kBFBoxInUse;
	ha->id = 0x7FFE;
	ha->priority = 999;
	ha->window = nullptr;

	while (!shouldQuit()) {
		_lastHitArea = nullptr;
		_lastHitArea3 = nullptr;

		while (!shouldQuit()) {
			if (_lastHitArea3 != nullptr)
				break;
			delay(1);
		}

		ha = _lastHitArea;

		if (ha == nullptr) {
		} else if (ha->id == 0x7FFE) {
			break;
		} else if (ha->id == 0x7FFF) {
			break;
		}
	}

	undefineBox(0x7FFF);
	undefineBox(0x7FFE);

	return ha->id;
}

void AGOSEngine::printScroll() {
	VgaPointersEntry *vpe = &_vgaBufferPointers[1];
	byte *curVgaFile2Orig = _curVgaFile2;

	_windowNum = 3;
	_curVgaFile2 = vpe->vgaFile2;
	clearHiResTextLayer();
	drawImage_init(9, 0, 10, 32, 0);

	_curVgaFile2 = curVgaFile2Orig;
}

void AGOSEngine::printStats() {
	WindowBlock *window = _dummyWindow;
	int val;

	window->flags = 1;

	mouseOff();

	// Strength
	val = _variableArray[0];
	if (val < -99)
		val = -99;
	if (val > 99)
		val = 99;
	writeChar(window, 5, 133, 6, val);

	// Resolution
	val = _variableArray[1];
	if (val < -99)
		val = -99;
	if (val > 99)
		val = 99;
	writeChar(window, 11, 133, 6, val);

	// Dexterity
	val = _variableArray[2];
	if (val < -99)
		val = -99;
	if (val > 99)
		val = 99;
	writeChar(window, 18, 133, 0, val);

	// Skill
	val = _variableArray[3];
	if (val < -99)
		val = -99;
	if (val > 99)
		val = 99;
	writeChar(window, 24, 133, 0, val);

	// Life
	val = _variableArray[5];
	if (val < -99)
		val = -99;
	if (val > 99)
		val = 99;
	writeChar(window, 30, 133, 2, val);

	// Experience
	val = _variableArray[6];
	if (val < -99)
		val = -99;
	if (val > 99)
		val = 99;
	writeChar(window, 36, 133, 4, val);

	mouseOn();
}

} // End of namespace AGOS

================
File: script_e2.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */



#include "agos/agos.h"
#include "agos/intern.h"

namespace AGOS {

#define OPCODE(x)	_OPCODE(AGOSEngine_Elvira2, x)

void AGOSEngine_Elvira2::setupOpcodes() {
	static const OpcodeEntryElvira2 opcodes[] = {
		/* 00 */
		OPCODE(o_invalid),
		OPCODE(o_at),
		OPCODE(o_notAt),
		OPCODE(o_invalid),
		/* 04 */
		OPCODE(o_invalid),
		OPCODE(o_carried),
		OPCODE(o_notCarried),
		OPCODE(o_isAt),
		/* 08 */
		OPCODE(oe1_isNotAt),
		OPCODE(oe1_sibling),
		OPCODE(oe1_notSibling),
		OPCODE(o_zero),
		/* 12 */
		OPCODE(o_notZero),
		OPCODE(o_eq),
		OPCODE(o_notEq),
		OPCODE(o_gt),
		/* 16 */
		OPCODE(o_lt),
		OPCODE(o_eqf),
		OPCODE(o_notEqf),
		OPCODE(o_ltf),
		/* 20 */
		OPCODE(o_gtf),
		OPCODE(oe1_isIn),
		OPCODE(oe1_isNotIn),
		OPCODE(o_chance),
		/* 24 */
		OPCODE(oe1_isPlayer),
		OPCODE(o_isRoom),
		OPCODE(o_isObject),
		OPCODE(o_state),
		/* 28 */
		OPCODE(o_oflag),
		OPCODE(oe1_canPut),
		OPCODE(o_invalid),
		OPCODE(o_destroy),
		/* 32 */
		OPCODE(o_invalid),
		OPCODE(o_place),
		OPCODE(oe1_copyof),
		OPCODE(oe1_copyfo),
		/* 36 */
		OPCODE(o_copyff),
		OPCODE(oe1_whatO),
		OPCODE(o_invalid),
		OPCODE(oe1_weigh),
		/* 40 */
		OPCODE(o_invalid),
		OPCODE(o_clear),
		OPCODE(o_let),
		OPCODE(o_add),
		/* 44 */
		OPCODE(o_sub),
		OPCODE(o_addf),
		OPCODE(o_subf),
		OPCODE(o_mul),
		/* 48 */
		OPCODE(o_div),
		OPCODE(o_mulf),
		OPCODE(o_divf),
		OPCODE(o_mod),
		/* 52 */
		OPCODE(o_modf),
		OPCODE(o_random),
		OPCODE(oe2_moveDirn),
		OPCODE(o_goto),
		/* 56 */
		OPCODE(o_oset),
		OPCODE(o_oclear),
		OPCODE(o_putBy),
		OPCODE(o_inc),
		/* 60 */
		OPCODE(o_dec),
		OPCODE(o_setState),
		OPCODE(o_print),
		OPCODE(o_message),
		/* 64 */
		OPCODE(o_msg),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 68 */
		OPCODE(o_end),
		OPCODE(o_done),
		OPCODE(o_invalid),
		OPCODE(o_process),
		/* 72 */
		OPCODE(oe2_doClass),
		OPCODE(oe2_pObj),
		OPCODE(oe1_pName),
		OPCODE(oe1_pcName),
		/* 76 */
		OPCODE(o_when),
		OPCODE(o_if1),
		OPCODE(o_if2),
		OPCODE(oe2_isCalled),
		/* 80 */
		OPCODE(o_is),
		OPCODE(o_invalid),
		OPCODE(o_debug),
		OPCODE(oe1_rescan),
		/* 84 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_comment),
		/* 88 */
		OPCODE(o_invalid),
		OPCODE(oe1_loadGame),
		OPCODE(o_getParent),
		OPCODE(o_getNext),
		/* 92 */
		OPCODE(o_getChildren),
		OPCODE(o_invalid),
		OPCODE(oe1_findMaster),
		OPCODE(oe1_nextMaster),
		/* 96 */
		OPCODE(o_picture),
		OPCODE(o_loadZone),
		OPCODE(oe1_animate),
		OPCODE(oe1_stopAnimate),
		/* 100 */
		OPCODE(o_killAnimate),
		OPCODE(o_defWindow),
		OPCODE(o_window),
		OPCODE(o_cls),
		/* 104 */
		OPCODE(o_closeWindow),
		OPCODE(oe2_menu),
		OPCODE(o_invalid),
		OPCODE(o_addBox),
		/* 108 */
		OPCODE(o_delBox),
		OPCODE(o_enableBox),
		OPCODE(o_disableBox),
		OPCODE(o_moveBox),
		/* 112 */
		OPCODE(o_invalid),
		OPCODE(oe2_drawItem),
		OPCODE(o_doIcons),
		OPCODE(o_isClass),
		/* 116 */
		OPCODE(o_setClass),
		OPCODE(o_unsetClass),
		OPCODE(o_invalid),
		OPCODE(o_waitSync),
		/* 120*/
		OPCODE(o_sync),
		OPCODE(o_defObj),
		OPCODE(o_invalid),
		OPCODE(oe1_setTime),
		/* 124 */
		OPCODE(oe1_ifTime),
		OPCODE(o_here),
		OPCODE(o_doClassIcons),
		OPCODE(o_playTune),
		/* 128 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_setAdjNoun),
		OPCODE(o_invalid),
		/* 132 */
		OPCODE(o_saveUserGame),
		OPCODE(o_loadUserGame),
		OPCODE(o_invalid),
		OPCODE(oe2_pauseGame),
		/* 136 */
		OPCODE(o_copysf),
		OPCODE(o_restoreIcons),
		OPCODE(o_freezeZones),
		OPCODE(o_placeNoIcons),
		/* 140 */
		OPCODE(o_clearTimers),
		OPCODE(o_setDollar),
		OPCODE(o_isBox),
		OPCODE(oe2_doTable),
		/* 144 */
		OPCODE(oe2_setDoorOpen),
		OPCODE(oe2_setDoorClosed),
		OPCODE(oe2_setDoorLocked),
		OPCODE(oe2_setDoorClosed),
		/* 148 */
		OPCODE(oe2_ifDoorOpen),
		OPCODE(oe2_ifDoorClosed),
		OPCODE(oe2_ifDoorLocked),
		OPCODE(oe2_storeItem),
		/* 152 */
		OPCODE(oe2_getItem),
		OPCODE(oe2_bSet),
		OPCODE(oe2_bClear),
		OPCODE(oe2_bZero),
		/* 156 */
		OPCODE(oe2_bNotZero),
		OPCODE(oe2_getOValue),
		OPCODE(oe2_setOValue),
		OPCODE(o_invalid),
		/* 160 */
		OPCODE(oe2_ink),
		OPCODE(oe2_printStats),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 164 */
		OPCODE(o_invalid),
		OPCODE(oe2_setSuperRoom),
		OPCODE(oe2_getSuperRoom),
		OPCODE(oe2_setExitOpen),
		/* 168 */
		OPCODE(oe2_setExitClosed),
		OPCODE(oe2_setExitLocked),
		OPCODE(oe2_setExitClosed),
		OPCODE(oe2_ifExitOpen),
		/* 172 */
		OPCODE(oe2_ifExitClosed),
		OPCODE(oe2_ifExitLocked),
		OPCODE(oe2_playEffect),
		OPCODE(oe2_getDollar2),
		/* 176 */
		OPCODE(oe2_setSRExit),
		OPCODE(oe2_printPlayerDamage),
		OPCODE(oe2_printMonsterDamage),
		OPCODE(oe2_isAdjNoun),
		/* 180 */
		OPCODE(oe2_b2Set),
		OPCODE(oe2_b2Clear),
		OPCODE(oe2_b2Zero),
		OPCODE(oe2_b2NotZero)
	};

	_opcodesElvira2 = opcodes;
	_numOpcodes = 184;
}

void AGOSEngine_Elvira2::executeOpcode(int opcode) {
	OpcodeProcElvira2 op = _opcodesElvira2[opcode].proc;
	(this->*op) ();
}

// -----------------------------------------------------------------------
// Elvira 2 Opcodes
// -----------------------------------------------------------------------

void AGOSEngine_Elvira2::oe2_moveDirn() {
	// 54: move direction
	int16 d = getVarOrByte();
	moveDirn(me(), d);
}

void AGOSEngine_Elvira2::oe2_doClass() {
	// 72: do class
	Item *i = getNextItemPtr();
	byte cm = getByte();
	int16 num = getVarOrWord();

	_classMask = (cm != 0xFF) ? 1 << cm : 0;
	_classLine = (SubroutineLine *)((byte *)_currentTable + _currentLine->next);
	if (num == 1) {
		_subjectItem = findInByClass(i, (1 << cm));
		if (_subjectItem)
			_classMode1 = 1;
		else
			_classMode1 = 0;
	} else {
		_objectItem = findInByClass(i, (1 << cm));
		if (_objectItem)
			_classMode2 = 1;
		else
			_classMode2 = 0;
	}
}

void AGOSEngine_Elvira2::oe2_pObj() {
	// 73: print object
	SubObject *subObject = (SubObject *)findChildOfType(getNextItemPtr(), kObjectType);

	if (subObject != nullptr && subObject->objectFlags & kOFText)
		showMessageFormat("%s", (const char *)getStringPtrByID(subObject->objectFlagValue[0]));
}

void AGOSEngine_Elvira2::oe2_isCalled() {
	// 79: childstruct fr2 is
	Item *i = getNextItemPtr();
	uint stringId = getNextStringID();
	setScriptCondition(i->itemName == stringId);
}

void AGOSEngine_Elvira2::oe2_menu() {
	// 105: set agos menu
	_agosMenu = getVarOrByte();
}

void AGOSEngine_Elvira2::oe2_drawItem() {
	// 113: draw item
	Item *i = getNextItemPtr();
	int a = getVarOrByte();
	int x = getVarOrWord();
	int y = getVarOrWord();
	mouseOff();
	drawIcon(_windowArray[a % 8], itemGetIconNumber(i), x, y);
	mouseOn();
}

void AGOSEngine_Elvira2::oe2_doTable() {
	// 143: start item sub
	Item *i = getNextItemPtr();

	SubRoom *r = (SubRoom *)findChildOfType(i, kRoomType);
	if (r != nullptr) {
		Subroutine *sub = getSubroutineByID(r->subroutine_id);
		if (sub) {
			startSubroutine(sub);
			return;
		}
	}

	if (getGameType() == GType_ELVIRA2) {
		SubSuperRoom *sr = (SubSuperRoom *)findChildOfType(i, kSuperRoomType);
		if (sr != nullptr) {
			Subroutine *sub = getSubroutineByID(sr->subroutine_id);
			if (sub) {
				startSubroutine(sub);
				return;
			}
		}
	}
}

void AGOSEngine_Elvira2::oe2_pauseGame() {
	// 135: pause game
	HitArea *ha;

	uint32 pauseTime = getTime();
	haltAnimation();

	while (!shouldQuit()) {
		_lastHitArea = nullptr;
		_lastHitArea3 = nullptr;

		while (!shouldQuit()) {
			if (processSpecialKeys() != 0 || _lastHitArea3 != nullptr)
				break;
			delay(1);
		}

		ha = _lastHitArea;

		if (ha == nullptr) {
		} else if (ha->id == 201) {
			break;
		}
	}

	restartAnimation();
	_gameStoppedClock = getTime() - pauseTime + _gameStoppedClock;
}

void AGOSEngine_Elvira2::oe2_setDoorOpen() {
	// 144: set door open
	Item *i = getNextItemPtr();
	setDoorState(i, getVarOrByte(), 1);
}

void AGOSEngine_Elvira2::oe2_setDoorClosed() {
	// 145: set door closed
	Item *i = getNextItemPtr();
	setDoorState(i, getVarOrByte(), 2);
}

void AGOSEngine_Elvira2::oe2_setDoorLocked() {
	// 146: set door locked
	Item *i = getNextItemPtr();
	setDoorState(i, getVarOrByte(), 3);
}

void AGOSEngine_Elvira2::oe2_ifDoorOpen() {
	// 148: if door open
	Item *i = getNextItemPtr();
	uint16 d = getVarOrByte();

	if (getGameType() == GType_WW) {
		// WORKAROUND bug #4229: A NULL item can occur when
		// walking through Jack the Ripper scene
		if (i == nullptr) {
			setScriptCondition(false);
			return;
		}
	}

	setScriptCondition(getDoorState(i, d) == 1);
}

void AGOSEngine_Elvira2::oe2_ifDoorClosed() {
	// 149: if door closed
	Item *i = getNextItemPtr();
	uint16 d = getVarOrByte();
	setScriptCondition(getDoorState(i, d) == 2);
}

void AGOSEngine_Elvira2::oe2_ifDoorLocked() {
	// 150: if door locked
	Item *i=getNextItemPtr();
	uint16 d = getVarOrByte();
	setScriptCondition(getDoorState(i, d) == 3);
}

void AGOSEngine_Elvira2::oe2_storeItem() {
	// 151: set array6 to item
	uint var = getVarOrByte();
	Item *item = getNextItemPtr();
	_itemStore[var] = item;
}

void AGOSEngine_Elvira2::oe2_getItem() {
	// 152: set m1 to m3 to array 6
	Item *item = _itemStore[getVarOrByte()];
	uint var = getVarOrByte();
	if (var == 1) {
		_subjectItem = item;
	} else {
		_objectItem = item;
	}
}

void AGOSEngine_Elvira2::oe2_bSet() {
	// 153: set bit
	setBitFlag(getVarWrapper(), true);
}

void AGOSEngine_Elvira2::oe2_bClear() {
	// 154: clear bit
	setBitFlag(getVarWrapper(), false);
}

void AGOSEngine_Elvira2::oe2_bZero() {
	// 155: is bit clear
	setScriptCondition(!getBitFlag(getVarWrapper()));
}

void AGOSEngine_Elvira2::oe2_bNotZero() {
	// 156: is bit set
	uint bit = getVarWrapper();

	// WORKAROUND: Enable copy protection again, in cracked version.
	if (getGameType() == GType_SIMON1 && _currentTable && _currentTable->id == 2962 && bit == 63) {
		bit = 50;
	}

	setScriptCondition(getBitFlag(bit));
}

void AGOSEngine_Elvira2::oe2_getOValue() {
	// 157: get item int prop
	Item *item = getNextItemPtr();
	SubObject *subObject = (SubObject *)findChildOfType(item, kObjectType);
	uint prop = getVarOrByte();

	if (subObject != nullptr && subObject->objectFlags & (1 << prop) && prop < 16) {
		uint offs = getOffsetOfChild2Param(subObject, 1 << prop);
		writeNextVarContents(subObject->objectFlagValue[offs]);
	} else {
		writeNextVarContents(0);
	}
}

void AGOSEngine_Elvira2::oe2_setOValue() {
	// 158: set item prop
	Item *item = getNextItemPtr();
	SubObject *subObject = (SubObject *)findChildOfType(item, kObjectType);
	uint prop = getVarOrByte();
	int value = getVarOrWord();

	if (subObject != nullptr && subObject->objectFlags & (1 << prop) && prop < 16) {
		uint offs = getOffsetOfChild2Param(subObject, 1 << prop);
		subObject->objectFlagValue[offs] = value;
	}
}

void AGOSEngine_Elvira2::oe2_ink() {
	// 160
	setTextColor(getVarOrByte());
}

void AGOSEngine_Elvira2::oe2_printStats() {
	// 161: print stats
	printStats();
}

void AGOSEngine_Elvira2::oe2_setSuperRoom() {
	// 165: set super room
	_superRoomNumber = getVarOrWord();
}

void AGOSEngine_Elvira2::oe2_getSuperRoom() {
	// 166: get super room
	writeNextVarContents(_superRoomNumber);
}

void AGOSEngine_Elvira2::oe2_setExitOpen() {
	// 167: set exit open
	Item *i = getNextItemPtr();
	uint16 n = getVarOrWord();
	uint16 d = getVarOrByte();
	setExitState(i, n, d, 1);
}

void AGOSEngine_Elvira2::oe2_setExitClosed() {
	// 168: set exit closed
	Item *i = getNextItemPtr();
	uint16 n = getVarOrWord();
	uint16 d = getVarOrByte();
	setExitState(i, n, d, 2);
}

void AGOSEngine_Elvira2::oe2_setExitLocked() {
	// 169: set exit locked
	Item *i = getNextItemPtr();
	uint16 n = getVarOrWord();
	uint16 d = getVarOrByte();
	setExitState(i, n, d, 3);
}

void AGOSEngine_Elvira2::oe2_ifExitOpen() {
	// 171: if exit open
	Item *i = getNextItemPtr();
	uint16 n = getVarOrWord();
	uint16 d = getVarOrByte();
	setScriptCondition(getExitState(i, n, d) == 1);
}

void AGOSEngine_Elvira2::oe2_ifExitClosed() {
	// 172: if exit closed
	Item *i = getNextItemPtr();
	uint16 n = getVarOrWord();
	uint16 d = getVarOrByte();
	setScriptCondition(getExitState(i, n, d) == 2);
}

void AGOSEngine_Elvira2::oe2_ifExitLocked() {
	// 173: if exit locked
	Item *i = getNextItemPtr();
	uint16 n = getVarOrWord();
	uint16 d = getVarOrByte();
	setScriptCondition(getExitState(i, n, d) == 3);
}

void AGOSEngine_Elvira2::oe2_playEffect() {
	// 174: play sound
	uint soundId = getVarOrWord();
	playSfx(soundId, 0, 0);
}

void AGOSEngine_Elvira2::oe2_getDollar2() {
	// 175
	_showPreposition = true;

	setup_cond_c_helper();

	_objectItem = _hitAreaObjectItem;

	if (_objectItem == _dummyItem2)
		_objectItem = me();

	if (_objectItem == _dummyItem3)
		_objectItem = derefItem(me()->parent);

	if (_objectItem != nullptr) {
		_scriptNoun2 = _objectItem->noun;
		_scriptAdj2 = _objectItem->adjective;
	} else {
		_scriptNoun2 = -1;
		_scriptAdj2 = -1;
	}

	_showPreposition = false;
}

void AGOSEngine_Elvira2::oe2_setSRExit() {
	// 176: set super room exit
	Item *i = getNextItemPtr();
	uint n = getVarOrWord();
	uint d = getVarOrByte();
	uint s = getVarOrByte();
	setSRExit(i, n, d, s);
}

void AGOSEngine_Elvira2::oe2_printPlayerDamage() {
	// 177: set player damage event
	uint a = getVarOrByte();
	if (_opcode177Var1 && !_opcode177Var2 && a != 0 && a <= 10) {
		addVgaEvent(_vgaBaseDelay, PLAYER_DAMAGE_EVENT, nullptr, 0, a);
		_opcode177Var2 = 0;
		_opcode177Var1 = 0;
	}
}

void AGOSEngine_Elvira2::oe2_printMonsterDamage() {
	// 178: set monster damage event
	uint a = getVarOrByte();
	if (_opcode178Var1 && !_opcode178Var2 && a != 0 && a <= 10) {
		addVgaEvent(_vgaBaseDelay, MONSTER_DAMAGE_EVENT, nullptr, 0, a);
		_opcode178Var2 = 0;
		_opcode178Var1 = 0;
	}
}

void AGOSEngine_Elvira2::oe2_isAdjNoun() {
	// 179: item unk1 unk2 is
	Item *item = getNextItemPtr();
	int16 a = getNextWord();
	int16 n = getNextWord();

	if (getGameType() == GType_ELVIRA2 && item == nullptr) {
		// WORKAROUND bug #3281: A NULL item can occur when
		// interacting with items in the dinning room
		setScriptCondition(false);
		return;
	}

	assert(item);
	setScriptCondition(item->adjective == a && item->noun == n);
}

void AGOSEngine_Elvira2::oe2_b2Set() {
	// 180: set bit2
	uint bit = getVarOrByte();
	_bitArrayTwo[bit / 16] |= (1 << (bit & 15));
}

void AGOSEngine_Elvira2::oe2_b2Clear() {
	// 181: clear bit2
	uint bit = getVarOrByte();
	_bitArrayTwo[bit / 16] &= ~(1 << (bit & 15));
}

void AGOSEngine_Elvira2::oe2_b2Zero() {
	// 182: is bit2 clear
	uint bit = getVarOrByte();
	setScriptCondition((_bitArrayTwo[bit / 16] & (1 << (bit & 15))) == 0);
}

void AGOSEngine_Elvira2::oe2_b2NotZero() {
	// 183: is bit2 set
	uint bit = getVarOrByte();
	setScriptCondition((_bitArrayTwo[bit / 16] & (1 << (bit & 15))) != 0);
}

void AGOSEngine_Elvira2::printStats() {
	WindowBlock *window = _dummyWindow;
	int val;
	const uint8 y = (getPlatform() == Common::kPlatformAtariST) ? 132 : 134;

	window->flags = 1;

	mouseOff();

	// Level
	val = _variableArray[20];
	if (val < -99)
		val = -99;
	if (val > 99)
		val = 99;
	writeChar(window, 10, y, 0, val);

	// PP
	val = _variableArray[22];
	if (val < -99)
		val = -99;
	if (val > 99)
		val = 99;
	writeChar(window, 16, y, 6, val);

	// HP
	val = _variableArray[23];
	if (val < -99)
		val = -99;
	if (val > 99)
		val = 99;
	writeChar(window, 23, y, 4, val);

	// Experience
	val = _variableArray[21];
	if (val < -99)
		val = -99;
	if (val > 9999)
		val = 9999;
	writeChar(window, 30, y, 6, val / 100);
	writeChar(window, 32, y, 2, val % 100);

	mouseOn();
}

} // End of namespace AGOS

================
File: script_ff.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */



#ifdef ENABLE_AGOS2

#include "common/system.h"

#include "agos/animation.h"
#include "agos/agos.h"
#include "agos/intern.h"
#include "agos/sound.h"

namespace AGOS {

#define OPCODE(x)	_OPCODE(AGOSEngine_Feeble, x)

void AGOSEngine_Feeble::setupOpcodes() {
	static const OpcodeEntryFeeble opcodes[] = {
		/* 00 */
		OPCODE(o_invalid),
		OPCODE(o_at),
		OPCODE(o_notAt),
		OPCODE(o_invalid),
		/* 04 */
		OPCODE(o_invalid),
		OPCODE(o_carried),
		OPCODE(o_notCarried),
		OPCODE(o_isAt),
		/* 08 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_zero),
		/* 12 */
		OPCODE(o_notZero),
		OPCODE(o_eq),
		OPCODE(o_notEq),
		OPCODE(o_gt),
		/* 16 */
		OPCODE(o_lt),
		OPCODE(o_eqf),
		OPCODE(o_notEqf),
		OPCODE(o_ltf),
		/* 20 */
		OPCODE(o_gtf),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(off_chance),
		/* 24 */
		OPCODE(o_invalid),
		OPCODE(o_isRoom),
		OPCODE(o_isObject),
		OPCODE(o_state),
		/* 28 */
		OPCODE(o_oflag),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_destroy),
		/* 32 */
		OPCODE(o_invalid),
		OPCODE(o_place),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 36 */
		OPCODE(o_copyff),
		OPCODE(off_jumpOut),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 40 */
		OPCODE(o_invalid),
		OPCODE(o_clear),
		OPCODE(o_let),
		OPCODE(o_add),
		/* 44 */
		OPCODE(o_sub),
		OPCODE(o_addf),
		OPCODE(o_subf),
		OPCODE(o_mul),
		/* 48 */
		OPCODE(o_div),
		OPCODE(o_mulf),
		OPCODE(o_divf),
		OPCODE(o_mod),
		/* 52 */
		OPCODE(o_modf),
		OPCODE(o_random),
		OPCODE(o_invalid),
		OPCODE(o_goto),
		/* 56 */
		OPCODE(o_oset),
		OPCODE(o_oclear),
		OPCODE(o_putBy),
		OPCODE(o_inc),
		/* 60 */
		OPCODE(o_dec),
		OPCODE(o_setState),
		OPCODE(o_print),
		OPCODE(o_message),
		/* 64 */
		OPCODE(o_msg),
		OPCODE(off_addTextBox),
		OPCODE(oww_setShortText),
		OPCODE(oww_setLongText),
		/* 68 */
		OPCODE(o_end),
		OPCODE(o_done),
		OPCODE(off_printLongText),
		OPCODE(o_process),
		/* 72 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 76 */
		OPCODE(o_when),
		OPCODE(o_if1),
		OPCODE(o_if2),
		OPCODE(o_isCalled),
		/* 80 */
		OPCODE(o_is),
		OPCODE(o_invalid),
		OPCODE(o_debug),
		OPCODE(os2_rescan),
		/* 84 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_comment),
		/* 88 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_getParent),
		OPCODE(o_getNext),
		/* 92 */
		OPCODE(o_getChildren),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 96 */
		OPCODE(o_picture),
		OPCODE(o_loadZone),
		OPCODE(os2_animate),
		OPCODE(os2_stopAnimate),
		/* 100 */
		OPCODE(o_killAnimate),
		OPCODE(o_defWindow),
		OPCODE(o_window),
		OPCODE(o_cls),
		/* 104 */
		OPCODE(o_closeWindow),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(off_addBox),
		/* 108 */
		OPCODE(o_delBox),
		OPCODE(o_enableBox),
		OPCODE(o_disableBox),
		OPCODE(o_moveBox),
		/* 112 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_doIcons),
		OPCODE(o_isClass),
		/* 116 */
		OPCODE(o_setClass),
		OPCODE(o_unsetClass),
		OPCODE(o_invalid),
		OPCODE(o_waitSync),
		/* 120 */
		OPCODE(o_sync),
		OPCODE(o_defObj),
		OPCODE(off_oracleTextDown),
		OPCODE(off_oracleTextUp),
		/* 124 */
		OPCODE(off_ifTime),
		OPCODE(o_here),
		OPCODE(o_doClassIcons),
		OPCODE(o_invalid),
		/* 128 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_setAdjNoun),
		OPCODE(off_setTime),
		/* 132 */
		OPCODE(off_saveUserGame),
		OPCODE(off_loadUserGame),
		OPCODE(off_listSaveGames),
		OPCODE(off_checkCD),
		/* 136 */
		OPCODE(o_copysf),
		OPCODE(o_restoreIcons),
		OPCODE(o_freezeZones),
		OPCODE(o_placeNoIcons),
		/* 140 */
		OPCODE(o_clearTimers),
		OPCODE(o_setDollar),
		OPCODE(o_isBox),
		OPCODE(oe2_doTable),
		/* 144 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 148 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(oe2_storeItem),
		/* 152 */
		OPCODE(oe2_getItem),
		OPCODE(oe2_bSet),
		OPCODE(oe2_bClear),
		OPCODE(oe2_bZero),
		/* 156 */
		OPCODE(oe2_bNotZero),
		OPCODE(oe2_getOValue),
		OPCODE(oe2_setOValue),
		OPCODE(o_invalid),
		/* 160 */
		OPCODE(oe2_ink),
		OPCODE(off_screenTextBox),
		OPCODE(os1_screenTextMsg),
		OPCODE(o_invalid),
		/* 164 */
		OPCODE(oe2_getDollar2),
		OPCODE(off_isAdjNoun),
		OPCODE(off_b2Set),
		OPCODE(oe2_b2Clear),
		/* 168 */
		OPCODE(oe2_b2Zero),
		OPCODE(oe2_b2NotZero),
		OPCODE(o_invalid),
		OPCODE(off_hyperLinkOn),
		/* 172 */
		OPCODE(off_hyperLinkOff),
		OPCODE(off_checkPaths),
		OPCODE(o_invalid),
		OPCODE(oww_lockZones),
		/* 176 */
		OPCODE(oww_unlockZones),
		OPCODE(off_screenTextPObj),
		OPCODE(os1_getPathPosn),
		OPCODE(os1_scnTxtLongText),
		/* 180 */
		OPCODE(off_mouseOn),
		OPCODE(off_mouseOff),
		OPCODE(off_loadVideo),
		OPCODE(off_playVideo),
		/* 184 */
		OPCODE(os1_unloadZone),
		OPCODE(o_invalid),
		OPCODE(os1_unfreezeZones),
		OPCODE(off_centerScroll),
		/* 188 */
		OPCODE(os2_isShortText),
		OPCODE(os2_clearMarks),
		OPCODE(os2_waitMark),
		OPCODE(off_resetPVCount),
		/* 192 */
		OPCODE(off_setPathValues),
		OPCODE(off_stopClock),
		OPCODE(off_restartClock),
		OPCODE(off_setColor),
		/* 196 */
		OPCODE(off_b3Set),
		OPCODE(off_b3Clear),
		OPCODE(off_b3Zero),
		OPCODE(off_b3NotZero)
	};

	_opcodesFeeble = opcodes;
	_numOpcodes = 200;
}

void AGOSEngine_Feeble::executeOpcode(int opcode) {
	OpcodeProcFeeble op = _opcodesFeeble[opcode].proc;
	(this->*op) ();
}

void AGOSEngine_Feeble::setLoyaltyRating(byte rating) {
	// WORKAROUND: The 4CD version of The Feeble File is missing the parts
	// of the script that set the loyalty rating. This approximates the
	// script from the 2CD version. See bug #6525.

	switch (rating) {
	case 1:
		// Kicking vending machine: Possibility of Undesirable Character Flaws
		writeVariable(120, 1);
		break;
	case 2:
		// Confessing: Confirmed Minor Character Flaws
		writeVariable(120, 2);
		break;
	case 3:
		// Being sent to Cygnus Alpha: Suspected Subversive Activity
		writeVariable(120, 3);
		break;
	case 4:
		// Escaping from Cygnus Alpha: Confirmed Subversive Activity
		writeVariable(120, 4);
		break;
	case 5:
		// Being brought before Filbert: Confirmed Treasonous Activity
		writeVariable(120, 5);
		break;
	case 6:
		// Arriving at rebel base: Freedom Fighters Operative
		writeVariable(120, 6);
		break;
	default:
		break;
	}
}

// -----------------------------------------------------------------------
// Feeble Files Opcodes
// -----------------------------------------------------------------------

void AGOSEngine_Feeble::off_chance() {
	// 23
	uint16 a = getVarOrWord();

	if (a == 0) {
		setScriptCondition(false);
		return;
	}

	if (a == 100) {
		setScriptCondition(true);
		return;
	}

	if (_rnd.getRandomNumber(99) < a)
		setScriptCondition(true);
	else
		setScriptCondition(false);
}

void AGOSEngine_Feeble::off_jumpOut() {
	// 37
	getVarOrByte();
	setScriptReturn(1);
}

void AGOSEngine_Feeble::off_addTextBox() {
	// 65: add hit area
	uint flags = kBFTextBox | kBFBoxItem;
	uint id = getVarOrWord();
	uint params = id / 1000;
	uint x, y, w, h, num;

	id %= 1000;

	if (params & 1)
		flags |= kBFInvertTouch;

	x = getVarOrWord();
	y = getVarOrWord();
	w = getVarOrWord();
	h = getVarOrWord();
	num = getVarOrByte();
	if (num < _numTextBoxes)
		defineBox(id, x, y, w, h, flags + (num << 8), 208, _dummyItem2);
}

void AGOSEngine_Feeble::off_printLongText() {
	// 70: show string from array
	int num = getVarOrByte();
	const char *str = (const char *)getStringPtrByID(_longText[num]);
	sendInteractText(num, "%d. %s\n", num, str);
}

void AGOSEngine_Feeble::off_addBox() {
	// 107: add item hitarea
	uint flags = 0;
	uint id = getVarOrWord();
	uint params = id / 1000;
	uint x, y, w, h, verb;
	Item *item;

	id = id % 1000;

	if (params & 1)
		flags |= kBFInvertTouch;
	if (params & 2)
		flags |= kBFNoTouchName;
	if (params & 4)
		flags |= kBFBoxItem;
	if (params & 8)
		flags |= kBFTextBox;
	if (params & 16)
		flags |= kBFHyperBox;

	x = getVarOrWord();
	y = getVarOrWord();
	w = getVarOrWord();
	h = getVarOrWord();
	item = getNextItemPtrStrange();
	verb = getVarOrWord();
	defineBox(id, x, y, w, h, flags, verb, item);
}

void AGOSEngine_Feeble::off_oracleTextDown() {
	// 122: oracle text down
	oracleTextDown();
}

void AGOSEngine_Feeble::off_oracleTextUp() {
	// 123: oracle text up
	oracleTextUp();
}

void AGOSEngine_Feeble::off_ifTime() {
	// 124: if time
	uint a = getVarOrWord();
	uint32 t = getTime() - _gameStoppedClock - a;
	if (t >= _timeStore)
		setScriptCondition(true);
	else
		setScriptCondition(false);
}

void AGOSEngine_Feeble::off_setTime() {
	// 131
	_timeStore = getTime() - _gameStoppedClock;
}

void AGOSEngine_Feeble::off_saveUserGame() {
	// 132: save game
	_noOracleScroll = 0;
	_system->setFeatureState(OSystem::kFeatureVirtualKeyboard, true);
	saveUserGame(countSaveGames() + 1 - readVariable(55));
	_system->setFeatureState(OSystem::kFeatureVirtualKeyboard, false);
}

void AGOSEngine_Feeble::off_loadUserGame() {
	// 133: load game
	if (readVariable(55) == 999) {
		loadGame(getFileName(GAME_RESTFILE), true);
	} else {
		loadGame(genSaveName(readVariable(55)));
	}
}

void AGOSEngine_Feeble::off_listSaveGames() {
	listSaveGamesFeeble();
}

void AGOSEngine_Feeble::off_checkCD() {
	// 135: switch CD
	uint16 disc = readVariable(97);

	if (!strcmp(getExtra(), "4CD")) {
		_sound->switchVoiceFile(gss, disc);
	} else if (!strcmp(getExtra(), "2CD")) {
		if (disc == 1 || disc == 2)
			_sound->switchVoiceFile(gss, 1);
		else if (disc == 3 || disc == 4)
			_sound->switchVoiceFile(gss, 2);
	}

	debug(0, "Switch to CD number %d", disc);
}

void AGOSEngine_Feeble::off_screenTextBox() {
	// 161: setup text
	TextLocation *tl = getTextLocation(getVarOrByte());

	tl->x = getVarOrWord();
	tl->y = getVarOrWord();
	tl->width = getVarOrWord();
}

void AGOSEngine_Feeble::off_isAdjNoun() {
	// 165: item unk1 unk2 is
	Item *item = getNextItemPtr();
	int16 a = getNextWord(), b = getNextWord();
	if (item->adjective == a && item->noun == b)
		setScriptCondition(true);
	else if (a == -1 && item->noun == b)
		setScriptCondition(true);
	else
		setScriptCondition(false);
}

void AGOSEngine_Feeble::off_b2Set() {
	// 166: set bit2
	uint bit = getVarOrByte();
	_bitArrayTwo[bit / 16] |= (1 << (bit & 15));

	if (getFeatures() & GF_BROKEN_FF_RATING) {
		switch (bit) {
		case 152:
			setLoyaltyRating(1);
			break;
		case 153:
			setLoyaltyRating(2);
			break;
		case 240:
			setLoyaltyRating(3);
			break;
		case 251:
			setLoyaltyRating(4);
			break;
		case 253:
			setLoyaltyRating(6);
			break;
		default:
			break;
		}
	}
}

void AGOSEngine_Feeble::off_hyperLinkOn() {
	// 171: oracle hyperlink on
	hyperLinkOn(getVarOrWord());
}

void AGOSEngine_Feeble::off_hyperLinkOff() {
	// 172: oracle hyperlink off
	hyperLinkOff();
}

void AGOSEngine_Feeble::off_checkPaths() {
	// 173 check paths
	int i, count;
	const uint8 *pathVal1 = _pathValues1;
	bool result = false;

	count = _variableArray2[38];
	for (i = 0; i < count; i++) {
		uint8 val = pathVal1[2];
		if (val == _variableArray2[50] ||
			val == _variableArray2[51] ||
			val == _variableArray2[201] ||
			val == _variableArray2[203] ||
			val == _variableArray2[205] ||
			val == _variableArray2[207] ||
			val == _variableArray2[209] ||
			val == _variableArray2[211] ||
			val == _variableArray2[213] ||
			val == _variableArray2[215] ||
			val == _variableArray2[219] ||
			val == _variableArray2[220] ||
			val == _variableArray2[221] ||
			val == _variableArray2[222] ||
			val == _variableArray2[223] ||
			val == _variableArray2[224] ||
			val == _variableArray2[225] ||
			val == _variableArray2[226]) {
				result = true;
				break;
		}
		pathVal1 += 4;
	}

	_variableArray2[52] = result;
}

void AGOSEngine_Feeble::off_screenTextPObj() {
	// 177: inventory descriptions
	uint vgaSpriteId = getVarOrByte();
	uint color = getVarOrByte();
	const char *string_ptr = NULL;
	TextLocation *tl = NULL;
	char buf[256];

	SubObject *subObject = (SubObject *)findChildOfType(getNextItemPtr(), kObjectType);
	if (subObject != NULL && subObject->objectFlags & kOFText) {
		string_ptr = (const char *)getStringPtrByID(subObject->objectFlagValue[0]);
		tl = getTextLocation(vgaSpriteId);
	}

	if (subObject != NULL && subObject->objectFlags & kOFVoice) {
		uint offs = getOffsetOfChild2Param(subObject, kOFVoice);
		playSpeech(subObject->objectFlagValue[offs], vgaSpriteId);
	}

	if (subObject != NULL && (subObject->objectFlags & kOFText) && _subtitles) {
		if (subObject->objectFlags & kOFNumber) {
			Common::sprintf_s(buf, "%d%s", subObject->objectFlagValue[getOffsetOfChild2Param(subObject, kOFNumber)], string_ptr);
			string_ptr = buf;
		}
		if (string_ptr != NULL)
			printScreenText(vgaSpriteId, color, string_ptr, tl->x, tl->y, tl->width);
	}
}

void AGOSEngine_Feeble::off_mouseOn() {
	// 180: force mouseOn
	if (_mouseCursor != 5) {
		resetVerbs();
		_noRightClick = 0;
	}
	_mouseHideCount = 0;
}

void AGOSEngine_Feeble::off_mouseOff() {
	// 181: force mouseOff
	scriptMouseOff();
	clearName();
}

void AGOSEngine_Feeble::off_loadVideo() {
	// 182: load video file
	const byte *filename = getStringPtrByID(getNextStringID());

	_moviePlayer = makeMoviePlayer(this, (const char *)filename);

	assert(_moviePlayer);
	_moviePlayer->load();

	if (getFeatures() & GF_BROKEN_FF_RATING) {
		if (strcmp((const char *)filename, "Statue1.smk") == 0) {
			setLoyaltyRating(5);
		}
	}
}

void AGOSEngine_Feeble::off_playVideo() {
	// 183: play video
	if (getBitFlag(40)) {
		// Omni TV controls
		if (_moviePlayer) {
			setBitFlag(42, false);
			_interactiveVideo = MoviePlayer::TYPE_OMNITV;
			_moviePlayer->play();
		} else {
			_variableArray[254] = 6747;
		}
	} else {
		assert(_moviePlayer);
		_moviePlayer->play();

		delete _moviePlayer;
		_moviePlayer = NULL;
	}
}

void AGOSEngine_Feeble::off_centerScroll() {
	// 187
	centerScroll();
}

void AGOSEngine_Feeble::off_resetPVCount() {
	// 191
	if (getBitFlag(83)) {
		_PVCount1 = 0;
		_GPVCount1 = 0;
	} else {
		_PVCount = 0;
		_GPVCount = 0;
	}
}

void AGOSEngine_Feeble::off_setPathValues() {
	// 192
	uint8 a = getVarOrByte();
	uint8 b = getVarOrByte();
	uint8 c = getVarOrByte();
	uint8 d = getVarOrByte();
	if (getBitFlag(83)) {
		_pathValues1[_PVCount1++] = a;
		_pathValues1[_PVCount1++] = b;
		_pathValues1[_PVCount1++] = c;
		_pathValues1[_PVCount1++] = d;
	} else {
		_pathValues[_PVCount++] = a;
		_pathValues[_PVCount++] = b;
		_pathValues[_PVCount++] = c;
		_pathValues[_PVCount++] = d;
	}
}

void AGOSEngine_Feeble::off_stopClock() {
	// 193: pause clock
	_clockStopped = getTime();
}

void AGOSEngine_Feeble::off_restartClock() {
	// 194: resume clock
	if (_clockStopped != 0)
		_gameStoppedClock += getTime() - _clockStopped;
	_clockStopped = 0;
}

void AGOSEngine_Feeble::off_setColor() {
	// 195: set palette color
	uint16 c = getVarOrByte() * 3;
	uint8 r = getVarOrByte();
	uint8 g = getVarOrByte();
	uint8 b = getVarOrByte();

	_displayPalette[c + 0] = r;
	_displayPalette[c + 1] = g;
	_displayPalette[c + 2] = b;

	_paletteFlag = 2;
}

void AGOSEngine_Feeble::off_b3Set() {
	// 196: set bit3
	uint8 bit = getVarOrByte();
	_bitArrayThree[bit / 16] |= (1 << (bit & 15));
}

void AGOSEngine_Feeble::off_b3Clear() {
	// 197: clear bit3
	uint8 bit = getVarOrByte();
	_bitArrayThree[bit / 16] &= ~(1 << (bit & 15));
}

void AGOSEngine_Feeble::off_b3Zero() {
	// 198: is bit3 clear
	uint8 bit = getVarOrByte();
	setScriptCondition((_bitArrayThree[bit / 16] & (1 << (bit & 15))) == 0);
}

void AGOSEngine_Feeble::off_b3NotZero() {
	// 199: is bit3 set
	uint8 bit = getVarOrByte();
	setScriptCondition((_bitArrayThree[bit / 16] & (1 << (bit & 15))) != 0);
}

} // End of namespace AGOS

#endif // ENABLE_AGOS2

================
File: script_pn.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "agos/agos.h"
#include "agos/intern.h"
#include "agos/vga.h"

#include "common/endian.h"
#include "common/textconsole.h"

namespace AGOS {

enum {
	kJmpClassNum = -1
};

#define OPCODE(x)	_OPCODE(AGOSEngine_PN, x)

void AGOSEngine_PN::setupOpcodes() {
	static const OpcodeEntryPN opcodes[] = {
		/* 00 */
		OPCODE(opn_opcode00),
		OPCODE(opn_add),
		OPCODE(opn_sub),
		OPCODE(opn_mul),
		/* 04 */
		OPCODE(opn_div),
		OPCODE(opn_opcode05),
		OPCODE(opn_opcode06),
		OPCODE(opn_opcode07),
		/* 08 */
		OPCODE(opn_opcode08),
		OPCODE(opn_opcode09),
		OPCODE(opn_opcode10),
		OPCODE(opn_opcode11),
		/* 12 */
		OPCODE(opn_opcode12),
		OPCODE(opn_opcode13),
		OPCODE(opn_opcode14),
		OPCODE(opn_opcode15),
		/* 16 */
		OPCODE(opn_opcode16),
		OPCODE(opn_lt),
		OPCODE(opn_gt),
		OPCODE(opn_eq),
		/* 20 */
		OPCODE(opn_neq),
		OPCODE(opn_opcode21),
		OPCODE(opn_opcode22),
		OPCODE(opn_opcode23),
		/* 24 */
		OPCODE(opn_opcode24),
		OPCODE(opn_opcode25),
		OPCODE(opn_opcode26),
		OPCODE(opn_opcode27),
		/* 28 */
		OPCODE(opn_opcode28),
		OPCODE(opn_opcode29),
		OPCODE(opn_opcode30),
		OPCODE(opn_opcode31),
		/* 32 */
		OPCODE(opn_opcode32),
		OPCODE(opn_opcode33),
		OPCODE(opn_opcode34),
		OPCODE(opn_opcode35),
		/* 36 */
		OPCODE(opn_opcode36),
		OPCODE(opn_opcode37),
		OPCODE(opn_opcode38),
		OPCODE(opn_opcode39),
		/* 40 */
		OPCODE(opn_opcode40),
		OPCODE(opn_opcode41),
		OPCODE(opn_opcode42),
		OPCODE(opn_opcode43),
		/* 44 */
		OPCODE(opn_opcode44),
		OPCODE(opn_opcode45),
		OPCODE(opn_opcode46),
		OPCODE(opn_opcode47),
		/* 48 */
		OPCODE(opn_opcode48),
		OPCODE(opn_opcode49),
		OPCODE(opn_opcode50),
		OPCODE(opn_opcode51),
		/* 52 */
		OPCODE(opn_opcode52),
		OPCODE(opn_opcode53),
		OPCODE(opn_opcode54),
		OPCODE(opn_opcode55),
		/* 56 */
		OPCODE(opn_opcode56),
		OPCODE(opn_opcode57),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 60 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(opn_opcode62),
		OPCODE(opn_opcode63),
	};

	_opcodesPN = opcodes;
	_numOpcodes = 64;
}

void AGOSEngine_PN::executeOpcode(int opcode) {
	OpcodeProcPN op = _opcodesPN[opcode].proc;
	(this->*op)();
}

int AGOSEngine_PN::readfromline() {
	if (!_linct)
		error("readfromline: Internal Error - Line Over-run");
	_linct--;
	return *_workptr++;
}

// -----------------------------------------------------------------------
// Personal Nightmare Opcodes
// -----------------------------------------------------------------------

void AGOSEngine_PN::opn_opcode00() {
	uint8 *str = _workptr;
	varval();
	writeval(str, varval());
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_add() {
	uint8 *str = _workptr;
	int32 sp = varval() + varval();
	_variableArray[12] = sp % 65536;
	_variableArray[13] = sp / 65536;
	if (sp > 65535)
		sp = 65535;
	writeval(str, (int)sp);
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_sub() {
	uint8 *str = _workptr;
	int32 sp = varval();
	sp -= varval();
	_variableArray[12] = sp % 65536;
	_variableArray[13] = sp / 65536;
	if (sp < 0)
		sp = 0;
	writeval(str, (int)sp);
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_mul() {
	uint8 *str = _workptr;
	int32 sp = varval() * varval();
	_variableArray[12] = sp % 65536;
	_variableArray[13] = sp / 65536;
	if (sp > 65535)
		sp = 65535;
	writeval(str, (int)sp);
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_div() {
	uint8 *str = _workptr;
	int32 sp = varval();
	int32 sp2 = varval();
	if (sp2 == 0)
		error("opn_div: Division by 0");
	sp = sp / sp2;
	_variableArray[12] = sp % 65536;
	_variableArray[13] = sp / 65536;
	writeval(str, (int)sp);
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode05() {
	pcf((uint8)'\n');
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode06() {
	pmesd(varval());
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode07() {
	int32 sp = varval();
	plocd((int)sp, varval());
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode08() {
	int32 sp = varval();
	pobjd((int)sp, varval());
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode09() {
	pmesd(varval());
	pcf((uint8)'\n');
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode10() {
	int32 sp = varval();
	plocd((int)sp, varval());
	pcf((uint8)'\n');
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode11() {
	int32 sp = varval();
	pobjd((int)sp, varval());
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode12() {
	char bf[8];
	int a = 0;
	Common::sprintf_s(bf,"%d", varval());
	while (bf[a])
		pcf(bf[a++]);
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode13() {
	char bf[8];
	int a = 0;
	Common::sprintf_s(bf,"%d", varval());
	while (bf[a])
		pcf(bf[a++]);
	pcf((uint8)'\n');
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode14() {
	clearWindow(_windowArray[_curWindow]);
	pcf((uint8)255);
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode15() {
	int32 x = varval();
	if ((x < 0) || (x > 4))
		x = 0;

	pcf((unsigned char)254);
	_curWindow = x;
	_xofs = (8 * _windowArray[_curWindow]->textLength) / 6 + 1;
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode16() {
	int32 sp = varval();
	setScriptReturn((sp >= 0 && sp <= 4));
}

void AGOSEngine_PN::opn_lt() {
	int16 v1 = varval();
	int16 v2 = varval();
	setScriptReturn(v1 < v2);
}

void AGOSEngine_PN::opn_gt() {
	int16 v1 = varval();
	int16 v2 = varval();
	setScriptReturn(v1 > v2);
}

void AGOSEngine_PN::opn_eq() {
	int16 v1 = varval();
	int16 v2 = varval();
	setScriptReturn(v1 == v2);
}

void AGOSEngine_PN::opn_neq() {
	int16 v1 = varval();
	int16 v2 = varval();
	setScriptReturn(v1 != v2);
}

void AGOSEngine_PN::opn_opcode21() {
	setposition(_procnum, varval());
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode22() {
	int pf[8];
	int n = varval();
	funcentry(pf, n);
	funccpy(pf);
	setposition(n, 0);
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode23() {
	setScriptReturn(actCallD(varval()));
}

void AGOSEngine_PN::opn_opcode24() {
	popstack(kJmpClassNum);
	// Jump back to the last doline, which will return 2-1=1.
	// That value then is returned to actCallD, which once again
	// returns it. In the end, this amounts to a setScriptReturn(true)
	// (but possibly in a different level than the current one).
	_dolineReturnVal = 2;
	_tagOfActiveDoline = _stackbase->tagOfParentDoline;
}

void AGOSEngine_PN::opn_opcode25() {
	popstack(kJmpClassNum);
	// Jump back to the last doline, which will return 1-1=0.
	// That value then is returned to actCallD, which once again
	// returns it. In the end, this amounts to a setScriptReturn(false)
	// (but possibly in a different level than the current one).
	_dolineReturnVal = 1;
	_tagOfActiveDoline = _stackbase->tagOfParentDoline;
}

void AGOSEngine_PN::opn_opcode26() {
	while ((_stackbase != nullptr) && (_stackbase->classnum != kJmpClassNum))
		dumpstack();
	dumpstack();
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode27() {
	quitGame();
	// Make sure the quit event is processed immediately.
	delay(0);
}

void AGOSEngine_PN::opn_opcode28() {
	addstack(varval());
	_stackbase->tagOfParentDoline = _tagOfActiveDoline;
	setScriptReturn(false);
}

void AGOSEngine_PN::opn_opcode29() {
	popstack(varval());
	// Jump back to the last doline indicated by the top stackframe.
	// The -1 tells it to simply go on with its business.
	_dolineReturnVal = -1;
	_tagOfActiveDoline = _stackbase->tagOfParentDoline;
}

void AGOSEngine_PN::opn_opcode30() {
	_variableArray[1] = varval();
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode31() {
	int a, slot = 0;
	Common::String bf;

	if ((a = varval()) > 2) {
		setScriptReturn(false);
		return;
	}

	switch (a) {
		case 0:
			getFilename();
			slot = matchSaveGame(_saveFile, countSaveGames());
			bf = genSaveName(slot);
			break;
		case 1:
			bf = "pn.sav";
			break;
		case 2:
			// NOTE: Is this case ever used?
			error("opn_opcode31: case 2");
			break;
		default:
			break;
	}

	if (slot == -1) {
		setScriptReturn(false);
	} else {
		a = loadFile(bf);
		if (a)
			setScriptReturn(badload(a));
		else
			setScriptReturn(true);
	}
}

void AGOSEngine_PN::opn_opcode32() {
	Common::String bf;
	int a, slot;

	a = varval();
	if (a > 2) {
		setScriptReturn(true);
		return;
	}

	uint16 curSlot = countSaveGames();
	switch (a) {
		case 0:
			getFilename();
			slot = matchSaveGame(_saveFile, curSlot);
			if (slot != -1)
				bf = genSaveName(slot);
			else
				bf = genSaveName(curSlot);
			break;
		case 1:
			bf = "pn.sav";
			break;
		case 2:
			// NOTE: Is this case ever used?
			error("opn_opcode32: case 2");
			break;
		default:
			break;
	}

	a = saveFile(bf);
	setScriptReturn(a);
}

void AGOSEngine_PN::opn_opcode33() {
	setScriptReturn((varval() < 3) ? 1 : 0);
}

void AGOSEngine_PN::opn_opcode34() {
	uint16 msgNum1, msgNum2;
	varval();
	getResponse((int)_variableArray[166], (int)_variableArray[167], msgNum1, msgNum2);
	_variableArray[168]= msgNum1;
	_variableArray[169]= msgNum2;
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode35() {
	int a;
	uint8 *sav = _workptr;
	varval();
	a = varval();
	if ((a = gvwrd((uint8 *)_wordcp, a)) == -1) {
		setScriptReturn(false);
		return;
	}

	writeval(sav, a);
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode36() {
	for (int i = 0; i < _dataBase[57] + 1; ++i)
		_wordcp[i] = 0;
	if (Common::isSpace(*_inpp))
		while ((*_inpp) && (Common::isSpace(*_inpp)))
			_inpp++;
	if (*_inpp == 0) {
		setScriptReturn(false);
		return;
	}
	_curwrdptr = _inpp;
	_wordcp[0] = *_inpp++;
	if ((_wordcp[0] == '.') || (_wordcp[0] == ',') || (_wordcp[0] == '"')) {
		setScriptReturn(true);
		return;
	}

	int ct = 1;
	while ((*_inpp != '.') && (*_inpp != ',') && (!Common::isSpace(*_inpp)) && (*_inpp != '\0') &&
		(*_inpp!='"')) {
		if (ct < _dataBase[57])
			_wordcp[ct++] = *_inpp;
		_inpp++;
	}
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode37() {
	_curwrdptr = nullptr;

	_inputReady = true;
	interact(_inputline, 49);

	if ((_inpp = strchr(_inputline,'\n')) != nullptr)
		*_inpp = '\0';
	_inpp = _inputline;
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode38() {
	_noScanFlag = 1;
	clearInputLine();
	writeval(_workptr, _keyPressed.ascii);
	_keyPressed.reset();
	_noScanFlag = 0;
	varval();
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode39() {
	pcf((uint8)varval());
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode40() {
	int a = doaction();
	if (_dolineReturnVal != 0)
		return;
	int b = doaction();
	setScriptReturn(a | b);
}

void AGOSEngine_PN::opn_opcode41() {
	int a = doaction();
	if (_dolineReturnVal != 0)
		return;
	int b = doaction();
	setScriptReturn(a & b);
}

void AGOSEngine_PN::opn_opcode42() {
	int a = doaction();
	if (_dolineReturnVal != 0)
		return;
	int b = doaction();
	setScriptReturn(a ^ b);
}

void AGOSEngine_PN::opn_opcode43() {
	int a = doaction();
	setScriptReturn(!a);
}

void AGOSEngine_PN::opn_opcode44() {
	pcf((uint8)254);
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode45() {
	uint8 *myptr;
	int x;

	if (_havinit == 0) {
		_seed = (int16)getTime();
		_havinit = 1;
	}
	_seed = 1 + (75 * (_seed + 1) - 1) % 65537;
	myptr = _workptr;
	varval();
	x = varval();
	if (x == 0)
		error("Illegal range specified for RANDOM");
	writeval(myptr, (_seed % x));
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode46() {
	char *x = _curwrdptr;
	if (x == nullptr) {
		setScriptReturn(true);
		return;
	}
	pcf(*x);
	if ((*x == '.') || (*x == '"') || (*x == ',')) {
		setScriptReturn(true);
		return;
	}
	x++;
	while ((*x != '.') && (*x != ',') && (*x != '"') && (!Common::isSpace(*x)) && (*x != '\0'))
		pcf(*x++);
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode47() {
	pmesd(varval() * 256 + varval());
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode48() {
	pmesd(varval() * 256 + varval());
	pcf((uint8)'\n');
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode49() {
	setScriptReturn(findentry());
}

void AGOSEngine_PN::opn_opcode50() {
	_fnst = 0;
	setScriptReturn(findset());
}

void AGOSEngine_PN::opn_opcode51() {
	_fnst = varval();
	setScriptReturn(findset());
}

void AGOSEngine_PN::opn_opcode52() {
	int32 mode = varval();
	if (mode == 1) {
		setWindowImage(mode, varval(), true);
	} else {
		setWindowImageEx(mode, varval());
	}

	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode53() {
	vc27_resetSprite();
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode54() {
	stopAnimate(varval());
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode55() {
	varval();
	varval();
	varval();
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode56() {
	varval();
	varval();
	varval();
	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode57() {
	uint16 windowNum = varval();
	uint16 vgaSpriteId = varval();
	int16 x = varval();
	int16 y = varval();
	uint16 palette = varval();

	_videoLockOut |= 0x40;
	animate(windowNum, 0, vgaSpriteId, x, y, palette);
	_videoLockOut &= ~0x40;

	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode62() {
	int32 zoneNum = varval();

	_videoLockOut |= 0x80;

	vc29_stopAllSounds();

	_hitCalled = 0;
	_oneClick = 0;

	loadZone(zoneNum);

	setWindowImage(2, 2);

	_copyScnFlag = 0;
	_vgaSpriteChanged = 0;

	_videoLockOut &= ~0x80;

	setScriptReturn(true);
}

void AGOSEngine_PN::opn_opcode63() {
	int a = readfromline();
	switch (a) {
		case 65:
			setScriptReturn(inventoryOn(varval()));
			break;
		case 64:
			setScriptReturn((_videoLockOut & 0x10) != 0);
			break;
		case 63:
			setScriptReturn(inventoryOff());
			break;
		default:
			error("opn_opcode63: unknown code %d", a);
	}
}

int AGOSEngine_PN::inventoryOn(int val) {
	writeVariable(210, val);
	if (_videoLockOut & 0x10) {
		iconPage();
	} else {
		_videoLockOut |= 0x10;
		_hitAreaList = _invHitAreas;

		_windowArray[2]->textColor = 0;
		windowPutChar(_windowArray[2], 13);

		clearVideoWindow(4, 0);
		drawIconHitBar();

		_objects = _variableArray[211];
		_objectCountS = -1;
		iconPage();
	}
	return 1;
}

int AGOSEngine_PN::inventoryOff() {
	if (_videoLockOut & 0x10) {
		_windowArray[2]->textColor = 15;

		restoreBlock(48, 2, 272, 130);

		_hitAreaList = _hitAreas;
		_videoLockOut &= ~0x10;
		_vgaSpriteChanged++;
	}
	return 1;
}

// -----------------------------------------------------------------------
// Personal Nightmare Script Code
// -----------------------------------------------------------------------


int AGOSEngine_PN::bitextract(uint32 ptr, int offs) {
	const byte mask = 0x80 >> (offs % 8);
	return ((mask & _dataBase[ptr + offs / 8]) != 0);
}

uint16 AGOSEngine_PN::getptr(uint32 pos) {
	if (pos > _dataBaseSize)
		error("getptr: Read beyond EOF (%d)", pos);
	return (int)READ_LE_UINT16(_dataBase + pos);
}

uint32 AGOSEngine_PN::getlong(uint32 pos) {
	// Only actually reads 24bit though
	if (pos > _dataBaseSize)
		error("getlong: Read beyond EOF (%d)", pos);
	return (uint32)READ_LE_UINT24(_dataBase + pos);
}

int AGOSEngine_PN::varval() {
	int a;
	int b;

	a = readfromline();
	if (a < 247) {
		return a;
	}

	switch (a) {
		case 249:
			b = readfromline();
			return (int)(b + 256 * readfromline());
		case 250:
			return readfromline();
		case 251:
			return (int)_variableArray[varval()];
		case 252:
			b = varval();
			return (int)_dataBase[_quickptr[0] + b * _quickshort[0] + varval()];
		case 254:
			b = varval();
			return (int)_dataBase[_quickptr[3] + b * _quickshort[2] + varval()];
		case 247:
			b = varval();
			return (int)getptr(_quickptr[11] + (b * _quickshort[4]) + (2 * varval()));
		case 248:
			b = varval();
			return (int)getptr(_quickptr[12] + (b * _quickshort[5]) + (2 * varval()));
		case 253:
			b = varval();
			return bitextract((int32)_quickptr[1] + b * _quickshort[1], varval());
		case 255:
			b = varval();
			return bitextract((int32)_quickptr[4] + b * _quickshort[3], varval());
		default:
			error("VARVAL : Illegal code %d encountered", a);
	}
}

void AGOSEngine_PN::writeval(uint8 *ptr, int val) {
	uint8 *savpt = _workptr;
	int lsav = _linct, a, b, x;
	_workptr = ptr;
	_linct = 255;

	if ((a = readfromline()) < 247)
		error("writeval: Write to constant (%d)", a);

	switch (a) {
		case 249:
			error("writeval: Write to constant (%d)", a);
			break;
		case 250:
			error("writeval: Write to constant (%d)", a);
			break;
		case 251:
			_variableArray[varval()] = val;
			break;
		case 252:
			b = varval();
			_dataBase[_quickptr[0] + b * _quickshort[0] + varval()] = val;
			break;
		case 254:
			b = varval();
			_dataBase[_quickptr[3] + b * _quickshort[2] + varval()] = val;
			break;
		case 247:
			b = varval();
			x = _quickptr[11] + b * _quickshort[4] + varval() * 2;
			WRITE_LE_UINT16(_dataBase + x, val);
			break;
		case 248:
			b = varval();
			x = _quickptr[12] + b * _quickshort[5] + varval() * 2;
			WRITE_LE_UINT16(_dataBase + x, val);
			break;
		case 253:
			b = varval();
			setbitf((uint32)_quickptr[1] + b * _quickshort[1], varval(), val);
			break;
		case 255:
			b = varval();
			setbitf((uint32)_quickptr[4] + b * _quickshort[3], varval(), val);
			break;
		default:
			error("WRITEVAL : undefined evaluation %d", a);
	}
	_linct = lsav;
	_workptr = savpt;
}

void AGOSEngine_PN::setbitf(uint32 ptr, int offs, int val) {
	ptr += offs / 8;
	const byte mask = 0x80 >> (offs % 8);
	if (val != 0)
		_dataBase[ptr] |= mask;
	else
		_dataBase[ptr] &= ~mask;
}

int AGOSEngine_PN::actCallD(int n) {
	int pf[8];
	funcentry(pf, n);
	addstack(kJmpClassNum);
	funccpy(pf);
	setposition(n, 0);
	return doline(1);
}

int AGOSEngine_PN::doaction() {
	if (_linct == 0)
		return 0;

	_opcode = readfromline();

	if (_opcode > 63) {
		return (actCallD(_opcode - 64));
	}

	setScriptReturn(0);
	executeOpcode(_opcode);
	delay(0);

	return getScriptReturn();
}

int AGOSEngine_PN::doline(int needsave) {
	assert(!_stackbase == !needsave);

	int x;
	int myTag = ++_tagOfActiveDoline;	// Obtain a unique tag for this doline invocation
	_dolineReturnVal = 0;

	if (_stackbase && needsave)
		_stackbase->tagOfParentDoline = myTag;

	do {
		_linct = ((*_linebase) & 127) - 1;
		_workptr = _linebase + 1;
		if (*_linebase > 127) {
			x = varval();
			if (x != (int)_variableArray[1])
				goto skipln;
		}

		do {
			x = doaction();

			if (_dolineReturnVal != 0) {
				if (_tagOfActiveDoline != myTag)
					return 0;

				x = _dolineReturnVal;
				_dolineReturnVal = 0;

				if (x > 0) {
					if (x != 3)
						dumpstack();
					// Restore the active jmpbuf to its previous value,
					// then return _dolineReturnVal-1 (will be 2-1=1 or 1-1=0).
					_tagOfActiveDoline = myTag - 1;
					return (x - 1);
				}
			}

		} while (x && !shouldQuit());

skipln:
		_linebase += 127 & *_linebase;
		_linembr++;
	} while (!shouldQuit());

	return 0;
}

int AGOSEngine_PN::findentry() {
	int stepmt;
	int curObj = 0;
	uint32 ofs = _quickptr[11];
	int c1, c2;

	c1 = varval();
	c2 = varval();
	stepmt = _quickshort[4];

	while (curObj < _quickshort[6]) {
		if (((c1 == 255) || (c1 == getptr(ofs))) &&
			(c2 == getptr(ofs + 2))) {
				_variableArray[23] = curObj;
				return 1;
		}
		curObj++;
		ofs += stepmt;
	}
	return 0;
}

int AGOSEngine_PN::findset() {
	int curObj = _fnst;
	int c1, c2, c3, c4;
	int stepmt = _quickshort[4];
	uint32 ofs = _quickptr[11] + stepmt * curObj;
	c1 = varval();
	c2 = varval();
	c3 = varval();
	c4 = varval();
	while (curObj < _quickshort[6]) {
		if (((c1 ==255) || (c1 == getptr(ofs))) &&
			((c2 == 255) || (c2 == getptr(ofs + 2))) &&
			((c3 == 255) || (c3 == getptr(ofs + 4))) &&
			((c4 == 255) || (c4 == getptr(ofs + 6)))) {
				_variableArray[23] = curObj;
				_fnst = curObj + 1;
				return 1;
		}
		curObj++;
		ofs += stepmt;
	}
	return 0;
}

void AGOSEngine_PN::funccpy(int *store) {
	for (int i = 24; i < 32; ++i) {
		_variableArray[i] = *store++;
	}
}

void AGOSEngine_PN::funcentry(int *store, int procn) {
	int numParams = _dataBase[getlong(_quickptr[6] + 3 * procn)];
	for (int i = 0; i < numParams; ++i) {
		*store++ = varval();
	}
}

int AGOSEngine_PN::gvwrd(uint8 *wptr, int mask) {
	int val = 0, code = 0, q = _dataBase[57];
	uint8 *vocbase = _dataBase + getlong(15);
	while (*vocbase != 255) {
		if (*vocbase < 0x80) {
			val = vocbase[q] + 256 * vocbase[q + 1];
			code = vocbase[q + 2];
		}
		if (wrdmatch(vocbase, mask, wptr, code))
			return val;
		vocbase += (*vocbase > 127) ? q : q + 3;
	}
	return -1;
}


int AGOSEngine_PN::setposition(int process, int line) {
	uint8 *ourptr;
	int np;
	int ct;

	ourptr = _dataBase + getlong(_quickptr[6] + 3 * process);
	np = *ourptr++;
	for (ct = 0; ct < line; ++ct) {
		ourptr += (127 & *ourptr);
	}

	while (true) {
		_linebase = ourptr;
		_linct = (127 & *ourptr) - 1;
		if (*ourptr++ <= 127)
			break;

		ct = varval();
		if (ct == (int)_variableArray[1])
			break;

		ourptr += _linct - 1;
		line++;
	}

	_linembr = line;
	_procnum = process;
	_variableArray[0] = process;
	_workptr = ourptr;
	return np;
}

int AGOSEngine_PN::wrdmatch(uint8 *word1, int mask1, uint8 *word2, int mask2) {
	uint8 sv;

	if ((mask1 & mask2) == 0)
		return 0;

	sv = *word1;
	*word1 &= 127;
	if (scumm_strnicmp((const char *)word1, (const char *)word2, _dataBase[57])) {
		*word1 = sv;
		return 0;
	}
	*word1 = sv;
	return 1;
}

// -----------------------------------------------------------------------
// Personal Nightmare Stack Code
// -----------------------------------------------------------------------

void AGOSEngine_PN::addstack(int type) {
	StackFrame *a;
	int i;

	a = (StackFrame *)calloc(1, sizeof(StackFrame));
	if (a == nullptr)
		error("addstack: Out of memory - stack overflow");

	a->nextframe = _stackbase;
	_stackbase = a;

	for (i = 0; i < 6; ++i)
		a->flag[i] = _variableArray[i];
	for (i = 0; i < 8; ++i)
		a->param[i] = _variableArray[24 + i];
	a->classnum = type;
	a->ll = _linct;
	a->linenum = _linembr;
	a->linpos = _workptr;
	a->lbase = _linebase;
	a->process = _procnum;
}

void AGOSEngine_PN::dumpstack() {
	StackFrame *a;

	if (_stackbase == nullptr)
		error("dumpstack: Stack underflow or unknown longjmp");

	a = _stackbase->nextframe;
	free((char *)_stackbase);
	_stackbase = a;
}

void AGOSEngine_PN::popstack(int type) {
	int i = 0;

	while ((_stackbase != nullptr) && (_stackbase->classnum != type)) {
		dumpstack();
		++i;
	}

	if (_stackbase == nullptr)
		error("popstack: Stack underflow or unknown longjmp");

	_linct = _stackbase->ll;
	_linebase = _stackbase->lbase;
	_workptr = _stackbase->linpos;
	_procnum = _stackbase->process;
	_linembr = _stackbase->linenum;
	for (i = 0; i < 6; ++i)
		_variableArray[i] = _stackbase->flag[i];
	for (i = 0; i < 8; ++i)
		_variableArray[24 + i] = _stackbase->param[i];
}

} // End of namespace AGOS

================
File: script_pp.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */



#ifdef ENABLE_AGOS2

#include "common/system.h"

#include "agos/agos.h"

namespace AGOS {

#define OPCODE(x)	_OPCODE(AGOSEngine_PuzzlePack, x)

void AGOSEngine_PuzzlePack::setupOpcodes() {
	static const OpcodeEntryPuzzlePack opcodes[] = {
		/* 00 */
		OPCODE(o_invalid),
		OPCODE(o_at),
		OPCODE(o_notAt),
		OPCODE(o_invalid),
		/* 04 */
		OPCODE(o_invalid),
		OPCODE(o_carried),
		OPCODE(o_notCarried),
		OPCODE(o_isAt),
		/* 08 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_zero),
		/* 12 */
		OPCODE(o_notZero),
		OPCODE(o_eq),
		OPCODE(o_notEq),
		OPCODE(o_gt),
		/* 16 */
		OPCODE(o_lt),
		OPCODE(o_eqf),
		OPCODE(o_notEqf),
		OPCODE(o_ltf),
		/* 20 */
		OPCODE(o_gtf),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(off_chance),
		/* 24 */
		OPCODE(o_invalid),
		OPCODE(o_isRoom),
		OPCODE(o_isObject),
		OPCODE(o_state),
		/* 28 */
		OPCODE(o_oflag),
		OPCODE(o_invalid),
		OPCODE(opp_iconifyWindow),
		OPCODE(o_destroy),
		/* 32 */
		OPCODE(opp_restoreOopsPosition),
		OPCODE(o_place),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 36 */
		OPCODE(o_copyff),
		OPCODE(o_invalid),
		OPCODE(opp_loadMouseImage),
		OPCODE(o_invalid),
		/* 40 */
		OPCODE(o_invalid),
		OPCODE(o_clear),
		OPCODE(o_let),
		OPCODE(o_add),
		/* 44 */
		OPCODE(o_sub),
		OPCODE(o_addf),
		OPCODE(o_subf),
		OPCODE(o_mul),
		/* 48 */
		OPCODE(o_div),
		OPCODE(o_mulf),
		OPCODE(o_divf),
		OPCODE(o_mod),
		/* 52 */
		OPCODE(o_modf),
		OPCODE(o_random),
		OPCODE(o_invalid),
		OPCODE(o_goto),
		/* 56 */
		OPCODE(o_oset),
		OPCODE(o_oclear),
		OPCODE(o_putBy),
		OPCODE(o_inc),
		/* 60 */
		OPCODE(o_dec),
		OPCODE(o_setState),
		OPCODE(o_print),
		OPCODE(opp_message),
		/* 64 */
		OPCODE(o_msg),
		OPCODE(off_addTextBox),
		OPCODE(opp_setShortText),
		OPCODE(oww_setLongText),
		/* 68 */
		OPCODE(o_end),
		OPCODE(o_done),
		OPCODE(off_printLongText),
		OPCODE(o_process),
		/* 72 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 76 */
		OPCODE(o_when),
		OPCODE(o_if1),
		OPCODE(o_if2),
		OPCODE(o_isCalled),
		/* 80 */
		OPCODE(o_is),
		OPCODE(o_invalid),
		OPCODE(o_debug),
		OPCODE(os2_rescan),
		/* 84 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_comment),
		/* 88 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_getParent),
		OPCODE(o_getNext),
		/* 92 */
		OPCODE(o_getChildren),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 96 */
		OPCODE(o_picture),
		OPCODE(o_loadZone),
		OPCODE(os2_animate),
		OPCODE(os2_stopAnimate),
		/* 100 */
		OPCODE(o_killAnimate),
		OPCODE(o_defWindow),
		OPCODE(o_window),
		OPCODE(o_cls),
		/* 104 */
		OPCODE(o_closeWindow),
		OPCODE(opp_loadHiScores),
		OPCODE(opp_checkHiScores),
		OPCODE(off_addBox),
		/* 108 */
		OPCODE(o_delBox),
		OPCODE(o_enableBox),
		OPCODE(o_disableBox),
		OPCODE(o_moveBox),
		/* 112 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_doIcons),
		OPCODE(o_isClass),
		/* 116 */
		OPCODE(o_setClass),
		OPCODE(o_unsetClass),
		OPCODE(o_invalid),
		OPCODE(o_waitSync),
		/* 120 */
		OPCODE(opp_sync),
		OPCODE(o_defObj),
		OPCODE(off_oracleTextDown),
		OPCODE(off_oracleTextUp),
		/* 124 */
		OPCODE(off_ifTime),
		OPCODE(o_here),
		OPCODE(o_doClassIcons),
		OPCODE(o_invalid),
		/* 128 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_setAdjNoun),
		OPCODE(off_setTime),
		/* 132 */
		OPCODE(opp_saveUserGame),
		OPCODE(opp_loadUserGame),
		OPCODE(off_listSaveGames),
		OPCODE(o_invalid),
		/* 136 */
		OPCODE(o_copysf),
		OPCODE(o_restoreIcons),
		OPCODE(o_freezeZones),
		OPCODE(o_placeNoIcons),
		/* 140 */
		OPCODE(o_clearTimers),
		OPCODE(o_setDollar),
		OPCODE(o_isBox),
		OPCODE(oe2_doTable),
		/* 144 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 148 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(oe2_storeItem),
		/* 152 */
		OPCODE(oe2_getItem),
		OPCODE(oe2_bSet),
		OPCODE(oe2_bClear),
		OPCODE(oe2_bZero),
		/* 156 */
		OPCODE(oe2_bNotZero),
		OPCODE(oe2_getOValue),
		OPCODE(oe2_setOValue),
		OPCODE(o_invalid),
		/* 160 */
		OPCODE(oe2_ink),
		OPCODE(off_screenTextBox),
		OPCODE(opp_playTune),
		OPCODE(o_invalid),
		/* 164 */
		OPCODE(oe2_getDollar2),
		OPCODE(off_isAdjNoun),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 168 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(off_hyperLinkOn),
		/* 172 */
		OPCODE(off_hyperLinkOff),
		OPCODE(opp_saveOopsPosition),
		OPCODE(o_invalid),
		OPCODE(oww_lockZones),
		/* 176 */
		OPCODE(oww_unlockZones),
		OPCODE(off_screenTextPObj),
		OPCODE(os1_getPathPosn),
		OPCODE(os1_scnTxtLongText),
		/* 180 */
		OPCODE(os1_mouseOn),
		OPCODE(off_mouseOff),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 184 */
		OPCODE(os1_unloadZone),
		OPCODE(o_invalid),
		OPCODE(os1_unfreezeZones),
		OPCODE(opp_resetGameTime),
		/* 188 */
		OPCODE(os2_isShortText),
		OPCODE(os2_clearMarks),
		OPCODE(os2_waitMark),
		OPCODE(opp_resetPVCount),
		/* 192 */
		OPCODE(opp_setPathValues),
		OPCODE(off_restartClock),
		OPCODE(opp_pauseClock),
		OPCODE(off_setColor),
	};

	_opcodesPuzzlePack = opcodes;
	_numOpcodes = 196;
}

void AGOSEngine_PuzzlePack::executeOpcode(int opcode) {
	OpcodeProcPuzzlePack op = _opcodesPuzzlePack[opcode].proc;
	(this->*op) ();
}

// -----------------------------------------------------------------------
// Puzzle Pack Opcodes
// -----------------------------------------------------------------------

void AGOSEngine_PuzzlePack::opp_iconifyWindow() {
	// 30
	getNextWord();
	if (_clockStopped != 0)
		_gameTime += getTime() - _clockStopped;
	_clockStopped = 0;
	_system->setFeatureState(OSystem::kFeatureIconifyWindow, true);
}

void AGOSEngine_PuzzlePack::opp_restoreOopsPosition() {
	// 32: restore oops position
	uint i;

	getNextWord();
	getNextWord();

	if (_oopsValid) {
		for (i = 0; i < _numVars; i++) {
			_variableArray[i] = _variableArray2[i];
		}
		i = _variableArray[999] * 100 + 11;
		setWindowImage(4,i);
		_gameTime += 10;
		// Swampy adventures
		if (!getBitFlag(110))
			_gameTime += 20;
		_oopsValid = false;
	}
}

void AGOSEngine_PuzzlePack::opp_loadMouseImage() {
	// 38: load mouse image
	getNextWord();
	getVarOrByte();
	loadMouseImage();
}

void AGOSEngine_PuzzlePack::opp_message() {
	// 63: show string nl
	const byte *stringPtr = getStringPtrByID(getNextStringID());
	if (getBitFlag(105)) {
		// Swampy adventures
		printInfoText((const char *)stringPtr);
	} else {
		showMessageFormat("%s\n", stringPtr);
	}
}

void AGOSEngine_PuzzlePack::opp_setShortText() {
	// 66: set item name
	uint var = getVarOrByte();
	uint stringId = getNextStringID();
	if (var < _numTextBoxes) {
		_shortText[var] = stringId;
		_shortTextX[var] = getVarOrWord();
		_shortTextY[var] = getVarOrWord();
	}
}

void AGOSEngine_PuzzlePack::opp_loadHiScores() {
	// 105: load high scores
	getVarOrByte();
	//loadHiScores();
}

void AGOSEngine_PuzzlePack::opp_checkHiScores() {
	// 106: check high scores
	getVarOrByte();
	getVarOrByte();
	//checkHiScores();
}

void AGOSEngine_PuzzlePack::opp_sync() {
	// 120: sync
	uint a = getVarOrWord();
	if (a == 8001 || a == 8101 || a == 8201 || a == 8301 || a == 8401) {
		_marks &= ~(1 << 2);
	}
	sendSync(a);
}

void AGOSEngine_PuzzlePack::opp_saveUserGame() {
	// 132: save game
	if (_clockStopped != 0)
		_gameTime += getTime() - _clockStopped;
	_clockStopped = 0;

	if (!getBitFlag(110)) {
		// Swampy adventures
		saveGame(1, NULL);
	}
	//saveHiScores()
}

void AGOSEngine_PuzzlePack::opp_loadUserGame() {
	// 133: load usergame

	// NoPatience or Jumble
	if (getBitFlag(110)) {
		//getHiScoreName();
		return;
	}

	// XXX
	loadGame(genSaveName(1));
}

void AGOSEngine_PuzzlePack::opp_playTune() {
	// 162: play tune
	getVarOrByte();
	getVarOrByte();
	getNextWord();

	uint16 music = (uint16)getVarOrWord();
	if (music != _lastMusicPlayed) {
		_lastMusicPlayed = music;
		playSpeech(music, 1);
	}
}

void AGOSEngine_PuzzlePack::opp_saveOopsPosition() {
	// 173: save oops position
	if (!isVgaQueueEmpty()) {
		_oopsValid = true;
		for (uint i = 0; i < _numVars; i++) {
			_variableArray2[i] = _variableArray[i];
		}
	} else {
		_oopsValid = false;
	}
}

void AGOSEngine_PuzzlePack::opp_resetGameTime() {
	// 187: reset game time
	_gameTime = 0;
}

void AGOSEngine_PuzzlePack::opp_resetPVCount() {
	// 191
	_PVCount = 0;
	_GPVCount = 0;
}

void AGOSEngine_PuzzlePack::opp_setPathValues() {
	// 192
	_pathValues[_PVCount++] = getVarOrByte();
	_pathValues[_PVCount++] = getVarOrByte();
	_pathValues[_PVCount++] = getVarOrByte();
	_pathValues[_PVCount++] = getVarOrByte();
}

void AGOSEngine_PuzzlePack::opp_pauseClock() {
	// 194: pause clock
	if (_clockStopped == 0)
		_clockStopped = getTime();
}

} // End of namespace AGOS

#endif // ENABLE_AGOS2

================
File: script_s1.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/system.h"
#include "common/localization.h"

#include "graphics/paletteman.h"

#include "agos/agos.h"
#include "agos/intern.h"
#include "agos/sound.h"

namespace AGOS {

#define OPCODE(x)	_OPCODE(AGOSEngine_Simon1, x)

void AGOSEngine_Simon1::setupOpcodes() {
	static const OpcodeEntrySimon1 opcodes[] = {
		/* 00 */
		OPCODE(o_invalid),
		OPCODE(o_at),
		OPCODE(o_notAt),
		OPCODE(o_invalid),
		/* 04 */
		OPCODE(o_invalid),
		OPCODE(o_carried),
		OPCODE(o_notCarried),
		OPCODE(o_isAt),
		/* 08 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_zero),
		/* 12 */
		OPCODE(o_notZero),
		OPCODE(o_eq),
		OPCODE(o_notEq),
		OPCODE(o_gt),
		/* 16 */
		OPCODE(o_lt),
		OPCODE(o_eqf),
		OPCODE(o_notEqf),
		OPCODE(o_ltf),
		/* 20 */
		OPCODE(o_gtf),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_chance),
		/* 24 */
		OPCODE(o_invalid),
		OPCODE(o_isRoom),
		OPCODE(o_isObject),
		OPCODE(o_state),
		/* 28 */
		OPCODE(o_oflag),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_destroy),
		/* 32 */
		OPCODE(o_invalid),
		OPCODE(o_place),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 36 */
		OPCODE(o_copyff),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 40 */
		OPCODE(o_invalid),
		OPCODE(o_clear),
		OPCODE(o_let),
		OPCODE(o_add),
		/* 44 */
		OPCODE(o_sub),
		OPCODE(o_addf),
		OPCODE(o_subf),
		OPCODE(o_mul),
		/* 48 */
		OPCODE(o_div),
		OPCODE(o_mulf),
		OPCODE(o_divf),
		OPCODE(o_mod),
		/* 52 */
		OPCODE(o_modf),
		OPCODE(o_random),
		OPCODE(o_invalid),
		OPCODE(o_goto),
		/* 56 */
		OPCODE(o_oset),
		OPCODE(o_oclear),
		OPCODE(o_putBy),
		OPCODE(o_inc),
		/* 60 */
		OPCODE(o_dec),
		OPCODE(o_setState),
		OPCODE(o_print),
		OPCODE(o_message),
		/* 64 */
		OPCODE(o_msg),
		OPCODE(oww_addTextBox),
		OPCODE(oww_setShortText),
		OPCODE(oww_setLongText),
		/* 68 */
		OPCODE(o_end),
		OPCODE(o_done),
		OPCODE(oww_printLongText),
		OPCODE(o_process),
		/* 72 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 76 */
		OPCODE(o_when),
		OPCODE(o_if1),
		OPCODE(o_if2),
		OPCODE(o_isCalled),
		/* 80 */
		OPCODE(o_is),
		OPCODE(o_invalid),
		OPCODE(o_debug),
		OPCODE(oe1_rescan),
		/* 84 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_comment),
		/* 88 */
		OPCODE(o_haltAnimation),
		OPCODE(o_restartAnimation),
		OPCODE(o_getParent),
		OPCODE(o_getNext),
		/* 92 */
		OPCODE(o_getChildren),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 96 */
		OPCODE(o_picture),
		OPCODE(o_loadZone),
		OPCODE(os1_animate),
		OPCODE(oe1_stopAnimate),
		/* 100 */
		OPCODE(o_killAnimate),
		OPCODE(o_defWindow),
		OPCODE(o_window),
		OPCODE(o_cls),
		/* 104 */
		OPCODE(o_closeWindow),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_addBox),
		/* 108 */
		OPCODE(o_delBox),
		OPCODE(o_enableBox),
		OPCODE(o_disableBox),
		OPCODE(o_moveBox),
		/* 112 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_doIcons),
		OPCODE(o_isClass),
		/* 116 */
		OPCODE(o_setClass),
		OPCODE(o_unsetClass),
		OPCODE(o_invalid),
		OPCODE(o_waitSync),
		/* 120 */
		OPCODE(o_sync),
		OPCODE(o_defObj),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 124 */
		OPCODE(o_invalid),
		OPCODE(o_here),
		OPCODE(o_doClassIcons),
		OPCODE(o_playTune),
		/* 128 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_setAdjNoun),
		OPCODE(o_invalid),
		/* 132 */
		OPCODE(o_saveUserGame),
		OPCODE(o_loadUserGame),
		OPCODE(o_invalid),
		OPCODE(os1_pauseGame),
		/* 136 */
		OPCODE(o_copysf),
		OPCODE(o_restoreIcons),
		OPCODE(o_freezeZones),
		OPCODE(o_placeNoIcons),
		/* 140 */
		OPCODE(o_clearTimers),
		OPCODE(o_setDollar),
		OPCODE(o_isBox),
		OPCODE(oe2_doTable),
		/* 144 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 148 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(oe2_storeItem),
		/* 152 */
		OPCODE(oe2_getItem),
		OPCODE(oe2_bSet),
		OPCODE(oe2_bClear),
		OPCODE(oe2_bZero),
		/* 156 */
		OPCODE(oe2_bNotZero),
		OPCODE(oe2_getOValue),
		OPCODE(oe2_setOValue),
		OPCODE(o_invalid),
		/* 160 */
		OPCODE(oe2_ink),
		OPCODE(os1_screenTextBox),
		OPCODE(os1_screenTextMsg),
		OPCODE(os1_playEffect),
		/* 164 */
		OPCODE(oe2_getDollar2),
		OPCODE(oe2_isAdjNoun),
		OPCODE(oe2_b2Set),
		OPCODE(oe2_b2Clear),
		/* 168 */
		OPCODE(oe2_b2Zero),
		OPCODE(oe2_b2NotZero),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 172 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(oww_lockZones),
		/* 176 */
		OPCODE(oww_unlockZones),
		OPCODE(os1_screenTextPObj),
		OPCODE(os1_getPathPosn),
		OPCODE(os1_scnTxtLongText),
		/* 180 */
		OPCODE(os1_mouseOn),
		OPCODE(os1_mouseOff),
		OPCODE(os1_loadBeard),
		OPCODE(os1_unloadBeard),
		/* 184 */
		OPCODE(os1_unloadZone),
		OPCODE(os1_loadStrings),
		OPCODE(os1_unfreezeZones),
		OPCODE(os1_specialFade),
	};

	_opcodesSimon1 = opcodes;
	_numOpcodes = 188;
}

void AGOSEngine_Simon1::executeOpcode(int opcode) {
	OpcodeProcSimon1 op = _opcodesSimon1[opcode].proc;
	(this->*op) ();
}

// -----------------------------------------------------------------------
// Simon 1 Opcodes
// -----------------------------------------------------------------------

void AGOSEngine_Simon1::os1_animate() {
	// 98: animate
	uint16 vgaSpriteId = getVarOrWord();
	uint16 windowNum = getVarOrByte();
	int16 x = getVarOrWord();
	int16 y = getVarOrWord();
	uint16 palette = (getVarOrWord() & 15);

	if (getFeatures() & GF_TALKIE && vgaSpriteId >= 400) {
		_lastVgaWaitFor = 0;
	}

	_videoLockOut |= 0x40;
	animate(windowNum, vgaSpriteId / 100, vgaSpriteId, x, y, palette);
	_videoLockOut &= ~0x40;
}

void AGOSEngine_Simon1::os1_pauseGame() {
	// 135: pause game
	_system->setFeatureState(OSystem::kFeatureVirtualKeyboard, true);

	Common::KeyCode keyYes, keyNo;

	Common::getLanguageYesNo(_language, keyYes, keyNo);

	Common::Keymapper *keymapper = AGOSEngine::getEventManager()->getKeymapper();
	keymapper->getKeymap("game-Yes/No")->setEnabled(true);

	while (!shouldQuit()) {
		delay(1);
		if (_keyPressed.keycode == keyYes || _action == kActionKeyYes)
			quitGame();
		else if (_keyPressed.keycode == keyNo || _action == kActionKeyNo)
			break;
	}

	_action = kActionNone;
	keymapper->getKeymap("game-Yes/No")->setEnabled(false);

	_system->setFeatureState(OSystem::kFeatureVirtualKeyboard, false);
}

void AGOSEngine_Simon1::os1_screenTextBox() {
	// 161: setup text
	TextLocation *tl = getTextLocation(getVarOrByte());

	tl->x = getVarOrWord();
	tl->y = getVarOrByte();
	tl->width = getVarOrWord();
}

void AGOSEngine_Simon1::os1_screenTextMsg() {
	// 162: print string
	uint vgaSpriteId = getVarOrByte();
	uint color = getVarOrByte();
	uint stringId = getNextStringID();
	const byte *stringPtr = nullptr;
	uint speechId = 0;
	TextLocation *tl;

	if (stringId != 0xFFFF)
		stringPtr = getStringPtrByID(stringId);

	if (getFeatures() & GF_TALKIE) {
		if (getGameType() == GType_FF || getGameType() == GType_PP)
			speechId = (uint16)getVarOrWord();
		else
			speechId = (uint16)getNextWord();
	}

	if (getGameType() == GType_FF || getGameType() == GType_PP)
		vgaSpriteId = 1;

	tl = getTextLocation(vgaSpriteId);
	if (_speech && speechId != 0)
		playSpeech(speechId, vgaSpriteId);
	if (((getGameType() == GType_SIMON2 && (getFeatures() & GF_TALKIE)) || getGameType() == GType_FF) &&
		speechId == 0) {
		stopAnimateSimon2(2, vgaSpriteId + 2);
	}

	// WORKAROUND: Several strings in the French version of Simon the Sorcerer 1 set the incorrect width,
	// causing crashes, or glitches in subtitles. See bug #6014 for example.
	if (getGameType() == GType_SIMON1 && _language == Common::FR_FRA) {
		if ((getFeatures() & GF_TALKIE) && stringId == 33219)
			tl->width = 96;
		if (!(getFeatures() & GF_TALKIE) && stringId == 33245)
			tl->width = 96;
	}

	if (stringPtr != nullptr && stringPtr[0] != 0 && (speechId == 0 || _subtitles))
		printScreenText(vgaSpriteId, color, (const char *)stringPtr, tl->x, tl->y, tl->width);

}

void AGOSEngine_Simon1::os1_playEffect() {
	// 163: play sound
	uint16 soundId = getVarOrWord();

	if (getGameId() == GID_SIMON1DOS)
		playSfx(soundId, 0, 0);
	else
		_sound->playEffects(soundId);
}

void AGOSEngine_Simon1::os1_screenTextPObj() {
	// 177: inventory descriptions
	uint vgaSpriteId = getVarOrByte();
	uint color = getVarOrByte();

	SubObject *subObject = (SubObject *)findChildOfType(getNextItemPtr(), kObjectType);
	if (getFeatures() & GF_TALKIE) {
		if (subObject != nullptr && subObject->objectFlags & kOFVoice) {
			uint offs = getOffsetOfChild2Param(subObject, kOFVoice);
			playSpeech(subObject->objectFlagValue[offs], vgaSpriteId);
		} else if (subObject != nullptr && subObject->objectFlags & kOFNumber) {
			uint offs = getOffsetOfChild2Param(subObject, kOFNumber);
			playSpeech(subObject->objectFlagValue[offs] + 3550, vgaSpriteId);
		}
	}

	if (subObject != nullptr && subObject->objectFlags & kOFText && _subtitles) {
		const char *stringPtr = (const char *)getStringPtrByID(subObject->objectFlagValue[0]);
		TextLocation *tl = getTextLocation(vgaSpriteId);
		char buf[256];
		int j, k;

		if (subObject->objectFlags & kOFNumber) {
			if (_language == Common::HE_ISR) {
				j = subObject->objectFlagValue[getOffsetOfChild2Param(subObject, kOFNumber)];
				k = (j % 10) * 10;
				k += j / 10;
				if (!(j % 10))
					Common::sprintf_s(buf,"0%d%s", k, stringPtr);
				else
					Common::sprintf_s(buf,"%d%s", k, stringPtr);
			} else {
				Common::sprintf_s(buf,"%d%s", subObject->objectFlagValue[getOffsetOfChild2Param(subObject, kOFNumber)], stringPtr);
			}
			stringPtr = buf;
		}
		if (stringPtr != nullptr && stringPtr[0] != 0)
			printScreenText(vgaSpriteId, color, stringPtr, tl->x, tl->y, tl->width);
	}
}

void AGOSEngine_Simon1::os1_getPathPosn() {
	// 178: path find
	uint x = getVarOrWord();
	uint y = getVarOrWord();
	uint var_1 = getVarOrByte();
	uint var_2 = getVarOrByte();

	const uint16 *p;
	uint i, j;
	uint prev_i;
	uint x_diff, y_diff;
	uint best_i = 0, best_j = 0, best_dist = 0xFFFFFFFF;
	uint maxPath = (getGameType() == GType_FF || getGameType() == GType_PP) ? 100 : 20;

	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		x += _scrollX;
		y += _scrollY;
	} else if (getGameType() == GType_SIMON2) {
		x += _scrollX * 8;
	}

	int end = (getGameType() == GType_FF) ? 9999 : 999;
	prev_i = maxPath + 1 - readVariable(12);
	for (i = maxPath; i != 0; --i) {
		p = (const uint16 *)_pathFindArray[maxPath - i];
		if (!p)
			continue;
		for (j = 0; readUint16Wrapper(&p[0]) != end; j++, p += 2) {
			x_diff = ABS((int16)(readUint16Wrapper(&p[0]) - x));
			y_diff = ABS((int16)(readUint16Wrapper(&p[1]) - 12 - y));

			if (x_diff < y_diff) {
				x_diff /= 4;
				y_diff *= 4;
			}
			x_diff += y_diff /= 4;

			if ((x_diff < best_dist) || ((x_diff == best_dist) && (prev_i == i))) {
				best_dist = x_diff;
				best_i = maxPath + 1 - i;
				best_j = j;
			}
		}
	}

	writeVariable(var_1, best_i);
	writeVariable(var_2, best_j);
}

void AGOSEngine_Simon1::os1_scnTxtLongText() {
	// 179: conversation responses and room descriptions
	uint vgaSpriteId = getVarOrByte();
	uint color = getVarOrByte();
	uint stringId = getVarOrByte();
	uint speechId = 0;
	TextLocation *tl;

	const char *stringPtr = (const char *)getStringPtrByID(_longText[stringId]);
	if (getFeatures() & GF_TALKIE)
		speechId = _longSound[stringId];

	if (getGameType() == GType_FF || getGameType() == GType_PP)
		vgaSpriteId = 1;
	tl = getTextLocation(vgaSpriteId);

	if (_speech && speechId != 0)
		playSpeech(speechId, vgaSpriteId);
	if (stringPtr != nullptr && stringPtr[0] != 0 && _subtitles)
		printScreenText(vgaSpriteId, color, stringPtr, tl->x, tl->y, tl->width);
}

void AGOSEngine_Simon1::os1_mouseOn() {
	// 180: force mouseOn
	_mouseHideCount = 0;
}

void AGOSEngine_Simon1::os1_mouseOff() {
	// 181: force mouseOff
	scriptMouseOff();
}

void AGOSEngine_Simon1::os1_loadBeard() {
	// 182: load beard
	if (_beardLoaded == false) {
		_beardLoaded = true;
		_videoLockOut |= 0x8000;
		loadVGABeardFile(328);
		_videoLockOut &= ~0x8000;
	}
}

void AGOSEngine_Simon1::os1_unloadBeard() {
	// 183: unload beard
	if (_beardLoaded == true) {
		_beardLoaded = false;
		_videoLockOut |= 0x8000;
		loadVGABeardFile(23);
		_videoLockOut &= ~0x8000;
	}
}

void AGOSEngine_Simon1::os1_unloadZone() {
	// 184: unload zone
	uint a = getVarOrWord();
	VgaPointersEntry *vpe = &_vgaBufferPointers[a];

	vpe->sfxFile = nullptr;
	vpe->vgaFile1 = nullptr;
	vpe->vgaFile2 = nullptr;
}

void AGOSEngine_Simon1::os1_loadStrings() {
	// 185: load sound files
	_soundFileId = getVarOrWord();
	if (getPlatform() == Common::kPlatformAmiga && (getFeatures() & GF_TALKIE)) {
		char buf[13];
		Common::sprintf_s(buf, "%d%s", _soundFileId, "Effects");
		_sound->readSfxFile(buf);
		Common::sprintf_s(buf, "%d%s", _soundFileId, "simon");
		_sound->readVoiceFile(buf);
	}
}

void AGOSEngine_Simon1::os1_unfreezeZones() {
	// 186: freeze zone
	unfreezeBottom();
}

void AGOSEngine_Simon1::os1_specialFade() {
	// 187: fade to black
	uint i;

	for (i = 32; i != 0; --i) {
		paletteFadeOut(_currentPalette, 32, 8);
		paletteFadeOut(_currentPalette + 3 * 48, 144, 8);
		paletteFadeOut(_currentPalette + 3 * 208, 48, 8);
		_system->getPaletteManager()->setPalette(_currentPalette, 0, 256);
		delay(5);
	}

	memcpy(_displayPalette, _currentPalette, sizeof(_currentPalette));
}

void AGOSEngine::scriptMouseOff() {
	_videoLockOut |= 0x8000;
	vc34_setMouseOff();
	_videoLockOut &= ~0x8000;
}

} // End of namespace AGOS

================
File: script_s2.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */



#include "agos/agos.h"
#include "agos/intern.h"
#include "agos/midi.h"

#include "common/textconsole.h"

namespace AGOS {

#define OPCODE(x)	_OPCODE(AGOSEngine_Simon2, x)

void AGOSEngine_Simon2::setupOpcodes() {
	static const OpcodeEntrySimon2 opcodes[] = {
		/* 00 */
		OPCODE(o_invalid),
		OPCODE(o_at),
		OPCODE(o_notAt),
		OPCODE(o_invalid),
		/* 04 */
		OPCODE(o_invalid),
		OPCODE(o_carried),
		OPCODE(o_notCarried),
		OPCODE(o_isAt),
		/* 08 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_zero),
		/* 12 */
		OPCODE(o_notZero),
		OPCODE(o_eq),
		OPCODE(o_notEq),
		OPCODE(o_gt),
		/* 16 */
		OPCODE(o_lt),
		OPCODE(o_eqf),
		OPCODE(o_notEqf),
		OPCODE(o_ltf),
		/* 20 */
		OPCODE(o_gtf),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_chance),
		/* 24 */
		OPCODE(o_invalid),
		OPCODE(o_isRoom),
		OPCODE(o_isObject),
		OPCODE(o_state),
		/* 28 */
		OPCODE(o_oflag),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_destroy),
		/* 32 */
		OPCODE(o_invalid),
		OPCODE(o_place),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 36 */
		OPCODE(o_copyff),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 40 */
		OPCODE(o_invalid),
		OPCODE(o_clear),
		OPCODE(o_let),
		OPCODE(o_add),
		/* 44 */
		OPCODE(o_sub),
		OPCODE(o_addf),
		OPCODE(o_subf),
		OPCODE(o_mul),
		/* 48 */
		OPCODE(o_div),
		OPCODE(o_mulf),
		OPCODE(o_divf),
		OPCODE(o_mod),
		/* 52 */
		OPCODE(o_modf),
		OPCODE(o_random),
		OPCODE(o_invalid),
		OPCODE(o_goto),
		/* 56 */
		OPCODE(o_oset),
		OPCODE(o_oclear),
		OPCODE(o_putBy),
		OPCODE(o_inc),
		/* 60 */
		OPCODE(o_dec),
		OPCODE(o_setState),
		OPCODE(o_print),
		OPCODE(o_message),
		/* 64 */
		OPCODE(o_msg),
		OPCODE(oww_addTextBox),
		OPCODE(oww_setShortText),
		OPCODE(oww_setLongText),
		/* 68 */
		OPCODE(o_end),
		OPCODE(o_done),
		OPCODE(os2_printLongText),
		OPCODE(o_process),
		/* 72 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 76 */
		OPCODE(o_when),
		OPCODE(o_if1),
		OPCODE(o_if2),
		OPCODE(o_isCalled),
		/* 80 */
		OPCODE(o_is),
		OPCODE(o_invalid),
		OPCODE(o_debug),
		OPCODE(os2_rescan),
		/* 84 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_comment),
		/* 88 */
		OPCODE(o_haltAnimation),
		OPCODE(o_restartAnimation),
		OPCODE(o_getParent),
		OPCODE(o_getNext),
		/* 92 */
		OPCODE(o_getChildren),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 96 */
		OPCODE(o_picture),
		OPCODE(o_loadZone),
		OPCODE(os2_animate),
		OPCODE(os2_stopAnimate),
		/* 100 */
		OPCODE(o_killAnimate),
		OPCODE(o_defWindow),
		OPCODE(o_window),
		OPCODE(o_cls),
		/* 104 */
		OPCODE(o_closeWindow),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_addBox),
		/* 108 */
		OPCODE(o_delBox),
		OPCODE(o_enableBox),
		OPCODE(o_disableBox),
		OPCODE(o_moveBox),
		/* 112 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_doIcons),
		OPCODE(o_isClass),
		/* 116 */
		OPCODE(o_setClass),
		OPCODE(o_unsetClass),
		OPCODE(o_invalid),
		OPCODE(o_waitSync),
		/* 120 */
		OPCODE(o_sync),
		OPCODE(o_defObj),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 124 */
		OPCODE(o_invalid),
		OPCODE(o_here),
		OPCODE(o_doClassIcons),
		OPCODE(os2_playTune),
		/* 128 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_setAdjNoun),
		OPCODE(o_invalid),
		/* 132 */
		OPCODE(o_saveUserGame),
		OPCODE(o_loadUserGame),
		OPCODE(o_invalid),
		OPCODE(os1_pauseGame),
		/* 136 */
		OPCODE(o_copysf),
		OPCODE(o_restoreIcons),
		OPCODE(o_freezeZones),
		OPCODE(o_placeNoIcons),
		/* 140 */
		OPCODE(o_clearTimers),
		OPCODE(o_setDollar),
		OPCODE(o_isBox),
		OPCODE(oe2_doTable),
		/* 144 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 148 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(oe2_storeItem),
		/* 152 */
		OPCODE(oe2_getItem),
		OPCODE(oe2_bSet),
		OPCODE(oe2_bClear),
		OPCODE(oe2_bZero),
		/* 156C */
		OPCODE(oe2_bNotZero),
		OPCODE(oe2_getOValue),
		OPCODE(oe2_setOValue),
		OPCODE(o_invalid),
		/* 160 */
		OPCODE(oe2_ink),
		OPCODE(os1_screenTextBox),
		OPCODE(os1_screenTextMsg),
		OPCODE(os1_playEffect),
		/* 164 */
		OPCODE(oe2_getDollar2),
		OPCODE(oe2_isAdjNoun),
		OPCODE(oe2_b2Set),
		OPCODE(oe2_b2Clear),
		/* 168 */
		OPCODE(oe2_b2Zero),
		OPCODE(oe2_b2NotZero),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 172 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(oww_lockZones),
		/* 176 */
		OPCODE(oww_unlockZones),
		OPCODE(os2_screenTextPObj),
		OPCODE(os1_getPathPosn),
		OPCODE(os1_scnTxtLongText),
		/* 180 */
		OPCODE(os2_mouseOn),
		OPCODE(os2_mouseOff),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 184 */
		OPCODE(os1_unloadZone),
		OPCODE(o_invalid),
		OPCODE(os1_unfreezeZones),
		OPCODE(o_invalid),
		/* 188 */
		OPCODE(os2_isShortText),
		OPCODE(os2_clearMarks),
		OPCODE(os2_waitMark),
	};

	_opcodesSimon2 = opcodes;
	_numOpcodes = 191;
}

void AGOSEngine_Simon2::executeOpcode(int opcode) {
	OpcodeProcSimon2 op = _opcodesSimon2[opcode].proc;
	(this->*op) ();
}

// -----------------------------------------------------------------------
// Simon 2 Opcodes
// -----------------------------------------------------------------------

void AGOSEngine_Simon2::os2_printLongText() {
	// 70: show string from array
	const char *str = (const char *)getStringPtrByID(_longText[getVarOrByte()]);
	writeVariable(51, strlen(str) / 53 * 8 + 8);
	showMessageFormat("%s\n", str);
}

void AGOSEngine_Simon2::os2_rescan() {
	// 83: restart subroutine
	if (_exitCutscene) {
		if (getBitFlag(9)) {
			endCutscene();
		}
	} else {
		processSpecialKeys();
	}

	setScriptReturn(-10);
}

void AGOSEngine_Simon2::os2_animate() {
	// 98: start vga
	uint16 zoneNum = getVarOrWord();
	uint16 vgaSpriteId = getVarOrWord();
	uint16 windowNum = getVarOrByte();
	int16 x = getVarOrWord();
	int16 y = getVarOrWord();
	uint16 palette = (getVarOrWord() & 15);

	_videoLockOut |= 0x40;
	animate(windowNum, zoneNum, vgaSpriteId, x, y, palette);
	_videoLockOut &= ~0x40;
}

void AGOSEngine_Simon2::os2_stopAnimate() {
	// 99: kill sprite
	uint16 a = getVarOrWord();
	uint16 b = getVarOrWord();
	stopAnimateSimon2(a, b);
}

void AGOSEngine_Simon2::os2_playTune() {
	// 127: deals with music
	int music = getVarOrWord();
	int track = getVarOrWord();
	int loop = getVarOrByte();

	// Jamieson630:
	// This appears to be a "load or play music" command.
	// The music resource is specified, and optionally
	// a track as well. Normally we see two calls being
	// made, one to load the resource and another to
	// actually start a track (so the resource is
	// effectively preloaded so there's no latency when
	// starting playback).

	_midi->setLoop(loop != 0);
	if (_lastMusicPlayed != music)
		_nextMusicToPlay = music;
	else
		playMusic(0, track);
}

void AGOSEngine_Simon2::os2_screenTextPObj() {
	// 177: inventory descriptions
	uint vgaSpriteId = getVarOrByte();
	uint color = getVarOrByte();

	SubObject *subObject = (SubObject *)findChildOfType(getNextItemPtr(), kObjectType);
	if (getFeatures() & GF_TALKIE) {
		if (subObject != nullptr && subObject->objectFlags & kOFVoice) {
			uint speechId = subObject->objectFlagValue[getOffsetOfChild2Param(subObject, kOFVoice)];

			if (subObject->objectFlags & kOFNumber) {
				uint speechIdOffs = subObject->objectFlagValue[getOffsetOfChild2Param(subObject, kOFNumber)];

				if (speechId == 116)
					speechId = speechIdOffs + 115;
				if (speechId == 92)
					speechId = speechIdOffs + 98;
				if (speechId == 99)
					speechId = 9;
				if (speechId == 97) {
					switch (speechIdOffs) {
					case 12:
						speechId = 109;
						break;
					case 14:
						speechId = 108;
						break;
					case 18:
						speechId = 107;
						break;
					case 20:
						speechId = 106;
						break;
					case 22:
						speechId = 105;
						break;
					case 28:
						speechId = 104;
						break;
					case 90:
						speechId = 103;
						break;
					case 92:
						speechId = 102;
						break;
					case 100:
						speechId = 51;
						break;
					default:
						error("os2_screenTextPObj: invalid case %d", speechIdOffs);
					}
				}
			}

			if (_speech)
				playSpeech(speechId, vgaSpriteId);
		}

	}

	if (subObject != nullptr && subObject->objectFlags & kOFText && _subtitles) {
		const char *stringPtr = (const char *)getStringPtrByID(subObject->objectFlagValue[0]);
		TextLocation *tl = getTextLocation(vgaSpriteId);
		char buf[256];
		int j, k;

		if (subObject->objectFlags & kOFNumber) {
			if (_language == Common::HE_ISR) {
				j = subObject->objectFlagValue[getOffsetOfChild2Param(subObject, kOFNumber)];
				k = (j % 10) * 10;
				k += j / 10;
				if (!(j % 10))
					Common::sprintf_s(buf,"0%d%s", k, stringPtr);
				else
					Common::sprintf_s(buf,"%d%s", k, stringPtr);
			} else {
				Common::sprintf_s(buf,"%d%s", subObject->objectFlagValue[getOffsetOfChild2Param(subObject, kOFNumber)], stringPtr);
			}
			stringPtr = buf;
		}
		if (stringPtr != nullptr)
			printScreenText(vgaSpriteId, color, stringPtr, tl->x, tl->y, tl->width);
	}
}

void AGOSEngine_Simon2::os2_mouseOn() {
	// 180: force mouseOn
	if (getGameType() == GType_SIMON2 && getBitFlag(79)) {
		_mouseCursor = 0;
	}
	_mouseHideCount = 0;
}

void AGOSEngine_Simon2::os2_mouseOff() {
	// 181: force mouseOff
	scriptMouseOff();
	changeWindow(1);
	showMessageFormat("\xC");
}

void AGOSEngine_Simon2::os2_isShortText() {
	// 188: string2 is
	uint i = getVarOrByte();
	uint str = getNextStringID();
	setScriptCondition(str < _numTextBoxes && _shortText[i] == str);
}

void AGOSEngine_Simon2::os2_clearMarks() {
	// 189: clear_op189_flag
	_marks = 0;
}

void AGOSEngine_Simon2::os2_waitMark() {
	// 190
	uint i = getVarOrByte();
	if (!(_marks & (1 << i)))
		waitForMark(i);
}

void AGOSEngine::stopAnimateSimon2(uint16 a, uint16 b) {
	uint16 items[2];

	items[0] = to16Wrapper(a);
	items[1] = to16Wrapper(b);

	_videoLockOut |= 0x8000;
	_vcPtr = (byte *)&items;
	vc60_stopAnimation();
	_videoLockOut &= ~0x8000;
}

void AGOSEngine::waitForMark(uint i) {
	_exitCutscene = false;
	while (!(_marks & (1 << i))) {
		if (_exitCutscene) {
			if (getGameType() == GType_PP) {
				if (_picture8600)
					break;
			} else {
				if (getBitFlag(9)) {
					endCutscene();
					break;
				}
			}
		} else {
			processSpecialKeys();
		}

		delay(10);
	}
}

} // End of namespace AGOS

================
File: script_ww.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */



#include "agos/agos.h"
#include "agos/intern.h"

namespace AGOS {

#define OPCODE(x)	_OPCODE(AGOSEngine_Waxworks, x)

void AGOSEngine_Waxworks::setupOpcodes() {
	static const OpcodeEntryWaxworks opcodes[] = {
		/* 00 */
		OPCODE(o_invalid),
		OPCODE(o_at),
		OPCODE(o_notAt),
		OPCODE(o_invalid),
		/* 04 */
		OPCODE(o_invalid),
		OPCODE(o_carried),
		OPCODE(o_notCarried),
		OPCODE(o_isAt),
		/* 08 */
		OPCODE(oe1_isNotAt),
		OPCODE(oe1_sibling),
		OPCODE(oe1_notSibling),
		OPCODE(o_zero),
		/* 12 */
		OPCODE(o_notZero),
		OPCODE(o_eq),
		OPCODE(o_notEq),
		OPCODE(o_gt),
		/* 16 */
		OPCODE(o_lt),
		OPCODE(o_eqf),
		OPCODE(o_notEqf),
		OPCODE(o_ltf),
		/* 20 */
		OPCODE(o_gtf),
		OPCODE(oe1_isIn),
		OPCODE(oe1_isNotIn),
		OPCODE(o_chance),
		/* 24 */
		OPCODE(oe1_isPlayer),
		OPCODE(o_isRoom),
		OPCODE(o_isObject),
		OPCODE(o_state),
		/* 28 */
		OPCODE(o_oflag),
		OPCODE(oe1_canPut),
		OPCODE(o_invalid),
		OPCODE(o_destroy),
		/* 32 */
		OPCODE(o_invalid),
		OPCODE(o_place),
		OPCODE(oe1_copyof),
		OPCODE(oe1_copyfo),
		/* 36 */
		OPCODE(o_copyff),
		OPCODE(oe1_whatO),
		OPCODE(o_invalid),
		OPCODE(oe1_weigh),
		/* 40 */
		OPCODE(o_invalid),
		OPCODE(o_clear),
		OPCODE(o_let),
		OPCODE(o_add),
		/* 44 */
		OPCODE(o_sub),
		OPCODE(o_addf),
		OPCODE(o_subf),
		OPCODE(o_mul),
		/* 48 */
		OPCODE(o_div),
		OPCODE(o_mulf),
		OPCODE(o_divf),
		OPCODE(o_mod),
		/* 52 */
		OPCODE(o_modf),
		OPCODE(o_random),
		OPCODE(oe2_moveDirn),
		OPCODE(oww_goto),
		/* 56 */
		OPCODE(o_oset),
		OPCODE(o_oclear),
		OPCODE(o_putBy),
		OPCODE(o_inc),
		/* 60 */
		OPCODE(o_dec),
		OPCODE(o_setState),
		OPCODE(o_print),
		OPCODE(o_message),
		/* 64 */
		OPCODE(o_msg),
		OPCODE(oww_addTextBox),
		OPCODE(oww_setShortText),
		OPCODE(oww_setLongText),
		/* 68 */
		OPCODE(o_end),
		OPCODE(o_done),
		OPCODE(o_invalid),
		OPCODE(o_process),
		/* 72 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 76 */
		OPCODE(o_when),
		OPCODE(o_if1),
		OPCODE(o_if2),
		OPCODE(o_isCalled),
		/* 80 */
		OPCODE(o_is),
		OPCODE(o_invalid),
		OPCODE(o_debug),
		OPCODE(oe1_rescan),
		/* 84 */
		OPCODE(o_invalid),
		OPCODE(oww_whereTo),
		OPCODE(o_invalid),
		OPCODE(o_comment),
		/* 88 */
		OPCODE(o_invalid),
		OPCODE(oe1_loadGame),
		OPCODE(o_getParent),
		OPCODE(o_getNext),
		/* 92 */
		OPCODE(o_getChildren),
		OPCODE(o_invalid),
		OPCODE(oe1_findMaster),
		OPCODE(oe1_nextMaster),
		/* 96 */
		OPCODE(o_picture),
		OPCODE(o_loadZone),
		OPCODE(oe1_animate),
		OPCODE(oe1_stopAnimate),
		/* 100 */
		OPCODE(o_killAnimate),
		OPCODE(o_defWindow),
		OPCODE(o_window),
		OPCODE(o_cls),
		/* 104 */
		OPCODE(o_closeWindow),
		OPCODE(oe2_menu),
		OPCODE(oww_textMenu),
		OPCODE(o_addBox),
		/* 108 */
		OPCODE(o_delBox),
		OPCODE(o_enableBox),
		OPCODE(o_disableBox),
		OPCODE(o_moveBox),
		/* 112 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_doIcons),
		OPCODE(o_isClass),
		/* 116 */
		OPCODE(o_setClass),
		OPCODE(o_unsetClass),
		OPCODE(o_invalid),
		OPCODE(o_waitSync),
		/* 120 */
		OPCODE(o_sync),
		OPCODE(o_defObj),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 124 */
		OPCODE(o_invalid),
		OPCODE(o_here),
		OPCODE(o_doClassIcons),
		OPCODE(o_playTune),
		/* 128 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_setAdjNoun),
		OPCODE(o_invalid),
		/* 132 */
		OPCODE(o_saveUserGame),
		OPCODE(o_loadUserGame),
		OPCODE(o_invalid),
		OPCODE(oww_pauseGame),
		/* 136 */
		OPCODE(o_copysf),
		OPCODE(o_restoreIcons),
		OPCODE(o_freezeZones),
		OPCODE(o_placeNoIcons),
		/* 140 */
		OPCODE(o_clearTimers),
		OPCODE(o_setDollar),
		OPCODE(o_isBox),
		OPCODE(oe2_doTable),
		/* 144 */
		OPCODE(oe2_setDoorOpen),
		OPCODE(oe2_setDoorClosed),
		OPCODE(oe2_setDoorLocked),
		OPCODE(oe2_setDoorClosed),
		/* 148 */
		OPCODE(oe2_ifDoorOpen),
		OPCODE(oe2_ifDoorClosed),
		OPCODE(oe2_ifDoorLocked),
		OPCODE(oe2_storeItem),
		/* 152 */
		OPCODE(oe2_getItem),
		OPCODE(oe2_bSet),
		OPCODE(oe2_bClear),
		OPCODE(oe2_bZero),
		/* 156 */
		OPCODE(oe2_bNotZero),
		OPCODE(oe2_getOValue),
		OPCODE(oe2_setOValue),
		OPCODE(o_invalid),
		/* 160 */
		OPCODE(oe2_ink),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 164 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 168 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		/* 172 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(oe2_getDollar2),
		/* 176 */
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(o_invalid),
		OPCODE(oe2_isAdjNoun),
		/* 180 */
		OPCODE(oe2_b2Set),
		OPCODE(oe2_b2Clear),
		OPCODE(oe2_b2Zero),
		OPCODE(oe2_b2NotZero),
		/* 184 */
		OPCODE(oww_boxMessage),
		OPCODE(oww_boxMsg),
		OPCODE(oww_boxLongText),
		OPCODE(oww_printBox),
		/* 188 */
		OPCODE(oww_boxPObj),
		OPCODE(oww_lockZones),
		OPCODE(oww_unlockZones),
	};

	_opcodesWaxworks = opcodes;
	_numOpcodes = 191;
}

void AGOSEngine_Waxworks::executeOpcode(int opcode) {
	OpcodeProcWaxworks op = _opcodesWaxworks[opcode].proc;
	(this->*op) ();
}

// -----------------------------------------------------------------------
// Waxworks Opcodes
// -----------------------------------------------------------------------

void AGOSEngine_Waxworks::oww_goto() {
	// 55: set itemA parent
	uint item = getNextItemID();
	if (derefItem(item) == nullptr) {
		setItemParent(me(), nullptr);
		loadRoomItems(item);
	}
	setItemParent(me(), derefItem(item));
}

void AGOSEngine_Waxworks::oww_addTextBox() {
	// 65: add hit area
	uint id = getVarOrWord();
	uint x = getVarOrWord();
	uint y = getVarOrWord();
	uint w = getVarOrWord();
	uint h = getVarOrWord();
	uint number = getVarOrByte();
	if (number < _numTextBoxes)
		defineBox(id, x, y, w, h, (number << 8) + 129, 208, _dummyItem2);
}

void AGOSEngine_Waxworks::oww_setShortText() {
	// 66: set item name
	uint var = getVarOrByte();
	uint stringId = getNextStringID();
	if (var < _numTextBoxes) {
		_shortText[var] = stringId;
	}
}

void AGOSEngine_Waxworks::oww_setLongText() {
	// 67: set item description
	uint var = getVarOrByte();
	uint stringId = getNextStringID();
	if (getFeatures() & GF_TALKIE) {
		uint speechId = getNextWord();
		if (var < _numTextBoxes) {
			_longText[var] = stringId;
			_longSound[var] = speechId;
		}
	} else {
		if (var < _numTextBoxes) {
			_longText[var] = stringId;
		}
	}
}

void AGOSEngine_Waxworks::oww_printLongText() {
	// 70: show string from array
	const char *str = (const char *)getStringPtrByID(_longText[getVarOrByte()]);
	showMessageFormat("%s\n", str);
}

void AGOSEngine_Waxworks::oww_whereTo() {
	// 85: where to
	Item *i = getNextItemPtr();
	int16 d = getVarOrByte();
	int16 f = getVarOrByte();

	if (f == 1)
		_subjectItem = derefItem(getExitOf(i, d));
	else
		_objectItem = derefItem(getExitOf(i, d));
}

void AGOSEngine_Waxworks::oww_textMenu() {
	// 106: set text menu
	byte slot = getVarOrByte();
	_textMenu[slot] = getVarOrByte();
}

void AGOSEngine_Waxworks::oww_pauseGame() {
	// 135: pause game
	HitArea *ha;

	uint32 pauseTime = getTime();
	haltAnimation();

	while (!shouldQuit()) {
		_lastHitArea = nullptr;
		_lastHitArea3 = nullptr;

		while (!shouldQuit()) {
			if (_lastHitArea3 != nullptr)
				break;
			delay(1);
		}

		ha = _lastHitArea;

		if (ha == nullptr) {
		} else if (ha->id == 200) {
			break;
		} else if (ha->id == 201) {
			break;
		}
	}

	restartAnimation();
	_gameStoppedClock = getTime() - pauseTime + _gameStoppedClock;
}

void AGOSEngine_Waxworks::oww_boxMessage() {
	// 184: print message to box
	boxTextMessage((const char *)getStringPtrByID(getNextStringID()));
}

void AGOSEngine_Waxworks::oww_boxMsg() {
	// 185: print msg to box
	boxTextMsg((const char *)getStringPtrByID(getNextStringID()));
}

void AGOSEngine_Waxworks::oww_boxLongText() {
	// 186: print long text to box
	boxTextMsg((const char *)getStringPtrByID(_longText[getVarOrByte()]));
}

void AGOSEngine_Waxworks::oww_printBox() {
	// 187: print box
	printBox();
}

void AGOSEngine_Waxworks::oww_boxPObj() {
	// 188: print object name to box
	SubObject *subObject = (SubObject *)findChildOfType(getNextItemPtr(), kObjectType);

	if (subObject != nullptr && subObject->objectFlags & kOFText)
		boxTextMsg((const char *)getStringPtrByID(subObject->objectFlagValue[0]));
}

void AGOSEngine_Waxworks::oww_lockZones() {
	// 189: lock zone
	_vgaMemBase = _vgaMemPtr;
}

void AGOSEngine_Waxworks::oww_unlockZones() {
	// 190: unlock zone
	_vgaMemPtr = _vgaFrozenBase;
	_vgaMemBase = _vgaFrozenBase;
}
void AGOSEngine_Waxworks::startSubroutineByVerb(uint16 verb) {
	// Find HitArea with the given verb and trigger its subroutine
	for (HitArea *ha = _hitAreas; ha->flags != 0; ha++) {
		if (ha->verb == verb) {
			Subroutine *sub = getSubroutineByID(ha->itemPtr->subroutine_id);
			if (sub) {
				startSubroutineEx(sub);
			}
			break;
		}
	}
}

} // End of namespace AGOS

================
File: sfxparser_accolade.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "agos/sfxparser_accolade.h"

#include "common/stream.h"
#include "common/textconsole.h"

namespace AGOS {

SfxParser_Accolade::SfxSlot::SfxSlot() {
	clear();
}

void SfxParser_Accolade::SfxSlot::reset() {
	noteFractionDelta = 0;
	vibratoTime = 0;
	vibratoCounter = 0;
	vibratoDelta = 0;
	waitCounter = 0;
	loopStart = 0;
	loopCounter = 0;
}

void SfxParser_Accolade::SfxSlot::clear() {
	allocated = false;
	active = false;
	source = -1;
	scriptPos = 0;
	playTime = 0;
	lastEventTime = 0;
	lastPlayedNote = -1;
	currentNoteFraction = 0;
	programChanged = false;
	reset();
}

bool SfxParser_Accolade::SfxSlot::atEndOfScript() {
	return scriptPos >= sfxData->scriptSize;
}

int16 SfxParser_Accolade::SfxSlot::readScript(bool opCode) {
	if (atEndOfScript())
		error("SfxParser_Accolade::SfxData::readScript - attempt to read past the end of the script");

	int16 data = sfxData->scriptData[scriptPos];
	scriptPos++;

	if (opCode && (data <= 0 || data > 0xC)) {
		// Any opcode outside the range 1-B will cause the script to stop.
		data = 0xC;
	}

	return data;
}

const byte SfxParser_Accolade::INSTRUMENT_SIZE_MT32;
const uint16 SfxParser_Accolade::SCRIPT_TIMER_FREQUENCY;
const uint16 SfxParser_Accolade::SCRIPT_TIMER_RATE;

SfxParser_Accolade::SfxParser_Accolade() : _driver(nullptr), _timerRate(0), _sfxData(),
	_numSfx(0), _sourceAllocations { -1, -1, -1, -1 }, _paused(false) { }

SfxParser_Accolade::~SfxParser_Accolade() {
	stopAll();

	if (_sfxData) {
		delete[] _sfxData;
		_sfxData = nullptr;
	}
}

void SfxParser_Accolade::load(Common::SeekableReadStream *in, int32 size) {
	// First word is the total data size.
	uint16 dataSize = in->readUint16LE();
	if (dataSize > size)
		error("SfxParser_Accolade::load - Sound effect bank lists size %d but has file size %d", dataSize, size);

	// Next word is the number of SFX definitions.
	_numSfx = in->readUint16LE();
	_sfxData = new SfxData[_numSfx];

	// Next is a list of start offsets for each SFX definition. Combined with
	// the total size the size of each SFX definition can be determined.
	int64 indexStartPos = in->pos();
	for (int i = 0; i < _numSfx; i++) {
		in->seek(indexStartPos + (i * 2));
		uint16 sfxDataOffset = in->readUint16LE();
		uint16 sfxDataEndOffset = i < _numSfx - 1 ? in->readUint16LE() : dataSize - 4;
		in->seek(indexStartPos + sfxDataOffset);
		uint16 sfxDataSize = sfxDataEndOffset - sfxDataOffset;

		// Read instrument definition.
		readInstrument(&_sfxData[i], in);

		// Instrument data size is fixed; the reset of the SFX definition is
		// the script.
		int scriptSize = sfxDataSize - INSTRUMENT_SIZE_MT32 - INSTRUMENT_SIZE_ADLIB;
		if (scriptSize < 2)
			error("SfxParser_Accolade::load - Unexpected script size %d", scriptSize);
		if (scriptSize % 2 != 0)
			warning("SfxParser_Accolade::load - Script has odd number of bytes %d", scriptSize);
		scriptSize >>= 1;
		// Script size is stored in words.
		_sfxData[i].scriptSize = scriptSize;

		// Read each word into the script data.
		for (int j = 0; j < scriptSize; j++) {
			_sfxData[i].scriptData[j] = in->readSint16LE();
		}
	}
}

void SfxParser_Accolade::setTimerRate(uint32 rate) {
	_timerRate = rate;
}

void SfxParser_Accolade::play(uint8 sfxNumber) {
	Common::StackLock lock(_mutex);

	if (sfxNumber >= _numSfx) {
		warning("SfxParser_Accolade::play - Sound effect %d requested but bank has only %d sound effects", sfxNumber, _numSfx);
		return;
	}

	// Find an unallocated slot.
	SfxSlot *sfxSlot = nullptr;
	int sfxSlotNum = -1;
	for (int i = 0; i < ARRAYSIZE(_sfxSlots); i++) {
		if (!_sfxSlots[i].allocated) {
			_sfxSlots[i].allocated = true;
			sfxSlot = &_sfxSlots[i];
			sfxSlotNum = i;
			break;
		}
	}

	// Note that the original interpreter would only output MIDI data from 2
	// slots simultaneously, but potentially *all* SFX could be active at the
	// same time (but the same sound effect could not play more than once at
	// the same time).
	// This implementation only allows 4 SFX active at the same time, which
	// seems to be more than enough for Elvira 2 and Waxworks.
	if (!sfxSlot)
		return;

	// Allocate a source.
	for (int i = 0; i < getNumberOfSfxSources(); i++) {
		if (_sourceAllocations[i] == -1) {
			_sourceAllocations[i] = sfxSlotNum;
			sfxSlot->source = i + 1;
			break;
		}
	}

	// Set the SFX data and load the instrument into the allocated channel.
	sfxSlot->sfxData = &_sfxData[sfxNumber];
	sfxSlot->programChanged = loadInstrument(sfxSlot);

	// Activate the slot to start script execution.
	sfxSlot->active = true;
}

void SfxParser_Accolade::stopAll() {
	Common::StackLock lock(_mutex);

	for (int i = 0; i < ARRAYSIZE(_sfxSlots); i++) {
		if (_sfxSlots[i].active)
			stop(&_sfxSlots[i]);
	}
}

void SfxParser_Accolade::pauseAll(bool paused) {
	Common::StackLock lock(_mutex);

	if (_paused == paused)
		return;

	_paused = paused;

	if (_paused) {
		// Stop the current note for all active SFX.
		for (int i = 0; i < ARRAYSIZE(_sfxSlots); i++) {
			if (_sfxSlots[i].active)
				noteOff(&_sfxSlots[i]);
		}
	}
}

void SfxParser_Accolade::stop(SfxSlot *sfxSlot) {
	noteOff(sfxSlot);

	// Deallocate the source.
	if (sfxSlot->source >= 0) {
		_driver->deinitSource(sfxSlot->source);
		_sourceAllocations[sfxSlot->source - 1] = -1;
	}

	// The original interpreter would try to re-assign the source to an active
	// sound effect without a source. This is not implemented here because
	// Elvira 2 and Waxworks use SFX very sparingly, so it seems very unlikely
	// that more than 2 SFX would be active at the same time.

	sfxSlot->clear();
}

void SfxParser_Accolade::processOpCode(SfxSlot *sfxSlot, byte opCode) {
	switch (opCode) {
	case 0x1:
		// Set note and note fraction delta.
		sfxSlot->noteFractionDelta = sfxSlot->readScript(false);
		break;
	case 0x2:
		// Clear note and note fraction delta.
		sfxSlot->noteFractionDelta = 0;
		break;
	case 0x3:
		// Set vibrato.
		int16 vibratoTime;
		vibratoTime = sfxSlot->readScript(false);
		assert(vibratoTime >= 0);
		sfxSlot->vibratoTime = vibratoTime;
		// The counter starts at half the vibrato time, which causes the note
		// frequency to move above and below the note fraction (like a sine
		// wave).
		sfxSlot->vibratoCounter = (vibratoTime >> 1) | 1;
		sfxSlot->vibratoDelta = sfxSlot->readScript(false);
		break;
	case 0x4:
		// Clear vibrato.
		sfxSlot->vibratoTime = 0;
		sfxSlot->vibratoDelta = 0;
		break;
	case 0x5:
		// Wait.
		sfxSlot->waitCounter = sfxSlot->readScript(false);
		assert(sfxSlot->waitCounter >= 0);
		break;
	case 0x6:
		// Play note.
		noteOff(sfxSlot);
		int8 note;
		note = sfxSlot->readScript(false) & 0xFF;
		assert(note >= 0);
		sfxSlot->currentNoteFraction = note << 8;
		noteOn(sfxSlot);
		break;
	case 0x7:
		// Loop start.

		// Just register the loop start position.
		sfxSlot->loopStart = sfxSlot->scriptPos;
		break;
	case 0x8:
		// Loop next.
		int16 loopParam;
		loopParam = sfxSlot->readScript(false);
		assert(loopParam >= 0);
		if (sfxSlot->loopCounter == 0) {
			// Loop counter has not been set yet, so do this now.
			if (loopParam == 0)
				// Loop infinitely.
				loopParam = -1;
			sfxSlot->loopCounter = loopParam;
			// Go back to loop start.
			sfxSlot->scriptPos = sfxSlot->loopStart;
		} else {
			// Decrease loop counter, unless the loop is infinite.
			if (sfxSlot->loopCounter != -1)
				sfxSlot->loopCounter--;
			if (sfxSlot->loopCounter != 0)
				// Go back to loop start.
				sfxSlot->scriptPos = sfxSlot->loopStart;
			// Else continue the script.
		}
		break;
	case 0x9:
		// Stop the current note.
		noteOff(sfxSlot);
		break;
	case 0xA:
		// Reset sound effect data.
		sfxSlot->reset();
		// The original interpreter does this; not sure why...
		sfxSlot->vibratoCounter = 1;
		break;
	case 0xB:
		// Noop. Consumes 1 script parameter.
		sfxSlot->scriptPos++;
		break;
	case 0xC:
	default:
		// Stop the sound effect.
		stop(sfxSlot);
		break;
	}
}

void SfxParser_Accolade::noteOn(SfxSlot *sfxSlot) {
	byte note = sfxSlot->currentNoteFraction >> 8;
	if (sfxSlot->source >= 0)
		// Send a note on with maximum velocity.
		_driver->send(sfxSlot->source, 0x90 | (note << 8) | (0x7F << 16));
	sfxSlot->lastPlayedNote = note;
}

void SfxParser_Accolade::noteOff(SfxSlot *sfxSlot) {
	if (sfxSlot->lastPlayedNote < 0)
		return;

	if (sfxSlot->source >= 0)
		// Send a note off.
		_driver->send(sfxSlot->source, 0x80 | (sfxSlot->lastPlayedNote << 8));
	sfxSlot->lastPlayedNote = -1;
}

void SfxParser_Accolade::onTimer() {
	Common::StackLock lock(_mutex);

	if (_paused)
		return;

	for (int i = 0; i < ARRAYSIZE(_sfxSlots); i++) {
		if (!_sfxSlots[i].active)
			continue;

		if (!_sfxSlots[i].programChanged) {
			// If the SFX instrument has not yet been set on the allocated
			// channel, wait until the driver is ready.
			if (!_driver->isReady(_sfxSlots[i].source))
				continue;

			// Then change to the SFX instrument.
			changeInstrument(&_sfxSlots[i]);
			_sfxSlots[i].programChanged = true;
		}

		// Determine the end time of the timer callback period that will be
		// processed.
		uint32 endTime = _sfxSlots[i].playTime + _timerRate;
		// Process script ticks while the sound effect remains active.
		while (_sfxSlots[i].active) {
			// Determine the end time of the script tick that will be
			// processed.
			uint32 eventTime = _sfxSlots[i].lastEventTime + SCRIPT_TIMER_RATE;
			if (eventTime > endTime)
				// Script tick end time is after this timer callback period, so
				// leave it to the next callback invocation.
				break;

			// Process this script tick.
			_sfxSlots[i].lastEventTime = eventTime;

			// Process vibrato counter.
			if (_sfxSlots[i].vibratoCounter > 0) {
				// Count down the vibrato counter.
				_sfxSlots[i].vibratoCounter--;
			} else {
				// Vibrato counter has reached zero. The vibrato note fraction
				// delta is negated, so that it will now be subtracted from the
				// note fraction instead of added, or the other way around.
				_sfxSlots[i].vibratoDelta = -_sfxSlots[i].vibratoDelta;
				// Reset the vibrato counter so it counts down to the next
				// delta negation.
				_sfxSlots[i].vibratoCounter = _sfxSlots[i].vibratoTime;
			}

			// Calculate the new note and note fraction by adding the deltas.
			uint16 newNoteFraction = _sfxSlots[i].currentNoteFraction;
			newNoteFraction += _sfxSlots[i].noteFractionDelta;
			newNoteFraction += _sfxSlots[i].vibratoDelta;

			if (newNoteFraction != _sfxSlots[i].currentNoteFraction) {
				// Update the note fraction.
				_sfxSlots[i].currentNoteFraction = newNoteFraction;
				updateNote(&_sfxSlots[i]);
			}

			// Process the script.
			if (_sfxSlots[i].waitCounter > 0) {
				// Count down the wait counter. No script opcode will be
				// processsed.
				_sfxSlots[i].waitCounter--;
			} else if (_sfxSlots[i].atEndOfScript()) {
				// The end of the script has been reached, so stop the sound
				// effect.
				// Note that the original interpreter did not do any bounds
				// checking. Some scripts are not terminated properly and would
				// cause the original interpreter to overread into the
				// instrument data of the next sound effect.
				stop(&_sfxSlots[i]);
			} else {
				// Process the next script opcode.
				byte opCode = _sfxSlots[i].readScript(true) & 0xFF;
				processOpCode(&_sfxSlots[i], opCode);
			}
		}
		
		// If the sound effect is still active, update the play timestamp.
		if (_sfxSlots[i].active)
			_sfxSlots[i].playTime = endTime;
	}
}

void SfxParser_Accolade::timerCallback(void *data) {
	((SfxParser_Accolade *)data)->onTimer();
}

void SfxParser_Accolade_AdLib::setMidiDriver(MidiDriver_Multisource *driver) {
	_driver = driver;
	_adLibDriver = dynamic_cast<MidiDriver_Accolade_AdLib *>(driver);
	assert(_adLibDriver);
}

byte SfxParser_Accolade_AdLib::getNumberOfSfxSources() {
	// The number of available sources depends on the OPL chip emulation used.
	return _adLibDriver->getNumberOfSfxSources();
}

void SfxParser_Accolade_AdLib::readInstrument(SfxData *sfxData, Common::SeekableReadStream *in) {
	in->skip(INSTRUMENT_SIZE_MT32);
	in->read(sfxData->instrumentDefinition, INSTRUMENT_SIZE_ADLIB);
}

bool SfxParser_Accolade_AdLib::loadInstrument(SfxSlot *sfxSlot) {
	if (sfxSlot->source < 0)
		return true;

	_adLibDriver->loadSfxInstrument(sfxSlot->source, sfxSlot->sfxData->instrumentDefinition);
	// No separate instrument change is necessary for AdLib, so true is
	// returned to indicate the instrument is already changed.
	return true;
}

void SfxParser_Accolade_AdLib::noteOn(SfxSlot *sfxSlot) {
	if (sfxSlot->source >= 0)
		// Set the current note fraction first.
		_adLibDriver->setSfxNoteFraction(sfxSlot->source, sfxSlot->currentNoteFraction);
	// Then start the note.
	SfxParser_Accolade::noteOn(sfxSlot);
}

void SfxParser_Accolade_AdLib::updateNote(SfxSlot *sfxSlot) {
	if (sfxSlot->source < 0)
		return;

	// Set the current note fraction first.
	_adLibDriver->setSfxNoteFraction(sfxSlot->source, sfxSlot->currentNoteFraction);
	// Then update the note.
	_adLibDriver->updateSfxNote(sfxSlot->source);
}

void SfxParser_Accolade_MT32::setMidiDriver(MidiDriver_Multisource *driver) {
	_driver = driver;
	_mt32Driver = dynamic_cast<MidiDriver_Accolade_MT32 *>(driver);
	assert(_mt32Driver);
}

byte SfxParser_Accolade_MT32::getNumberOfSfxSources() {
	// MT-32 always uses 2 SFX sources.
	return 2;
}

void SfxParser_Accolade_MT32::readInstrument(SfxData *sfxSlot, Common::SeekableReadStream *in) {
	in->read(sfxSlot->instrumentDefinition, INSTRUMENT_SIZE_MT32);
	in->skip(INSTRUMENT_SIZE_ADLIB);
}

bool SfxParser_Accolade_MT32::loadInstrument(SfxSlot *sfxSlot) {
	if (sfxSlot->source < 0)
		return true;

	_mt32Driver->loadSfxInstrument(sfxSlot->source, sfxSlot->sfxData->instrumentDefinition);
	// MT-32 requires a program change after the SysExes to load the instrument
	// have been processed. Return false to indicate this.
	return false;
}

void SfxParser_Accolade_MT32::changeInstrument(SfxSlot *sfxData) {
	if (sfxData->source < 0)
		return;

	_mt32Driver->changeSfxInstrument(sfxData->source);
}

} // End of namespace AGOS

================
File: sfxparser_accolade.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_SFXPARSER_ACCOLADE_H
#define AGOS_SFXPARSER_ACCOLADE_H

#include "agos/drivers/accolade/adlib.h"
#include "agos/drivers/accolade/mt32.h"

#include "common/mutex.h"
#include "common/stream.h"

namespace AGOS {

class SfxParser_Accolade {
public:
	// Size in bytes of MT-32 instrument data in the SFX data.
	static const byte INSTRUMENT_SIZE_MT32 = 0xF9;
	// Number of script ticks per second.
	static const uint16 SCRIPT_TIMER_FREQUENCY = 292;
	// Number of microseconds per script tick.
	static const uint16 SCRIPT_TIMER_RATE = 1000000 / SCRIPT_TIMER_FREQUENCY;

protected:
	// Size in bytes of AdLib instrument data in the SFX data.
	static const byte INSTRUMENT_SIZE_ADLIB = 0x09;
	// Maximum number of words in an SFX script.
	static const byte MAX_SCRIPT_SIZE = 0x30;
	// Maximum number of simultaneous sources for OPL2.
	static const byte OPL2_NUM_SOURCES = 2;
	// Maximum number of simultaneous sources for OPL3.
	static const byte OPL3_NUM_SOURCES = 4;

	// Data for a single SFX. Taken from the game's SFX bank.
	struct SfxData {
		// The instrument data for the used sound device (OPL or MT-32).
		byte instrumentDefinition[INSTRUMENT_SIZE_MT32];
		// The SFX script.
		int16 scriptData[MAX_SCRIPT_SIZE];
		// The size in words of the SFX script.
		int scriptSize;
	};

	// State data a SFX playback slot.
	struct SfxSlot {
		SfxSlot();

		// The data of the SFX currently played by this slot.
		SfxData *sfxData;

		// True if this slot has been allocated to playing a SFX.
		bool allocated;
		// True if SFX playback is active.
		bool active;
		// The source used to send data to the MIDI driver.
		int8 source;
		// Current position in the SFX script.
		byte scriptPos;

		// Current playback time in microseconds.
		uint32 playTime;
		// The timestamp of the last processed script tick.
		uint32 lastEventTime;
		// The last MIDI note that was sent as a note on event.
		int16 lastPlayedNote;
		// The current MIDI note (upper byte) and note fraction (1/256th notes;
		// lower byte) value.
		uint16 currentNoteFraction;
		// True if the allocated channel on the MIDI device has been changed to
		// the SFX instrument.
		bool programChanged;

		// Delta to the note fraction. This is added to/subtracted from the
		// note fraction every script tick.
		int16 noteFractionDelta;
		// The vibrato time. The number of script ticks it takes for the note
		// difference to go from lowest to highest (or the other way around).
		int16 vibratoTime;
		// The number of script ticks that have passed since the vibrato has
		// started.
		int16 vibratoCounter;
		// Vibrato delta to the note fraction. This is added to/subtracted
		// from the note fraction every script tick.
		int16 vibratoDelta;
		// The number of ticks that remain before the next script event is
		// processed.
		int16 waitCounter;
		// The script position at which the current loop has started.
		byte loopStart;
		// The number of times the looped section will be repeated (-1 for
		// infinite loop).
		int16 loopCounter;

		// Completely clears the SFX slot data.
		void clear();
		// Resets the SFX slot data as needed by the reset opcode.
		void reset();
		// True if the current position is at the end of the script.
		bool atEndOfScript();
		// Reads the next script word. Specify the opCode flag to return a
		// valid opcode.
		int16 readScript(bool opCode);
	};

public:
	SfxParser_Accolade();
	virtual ~SfxParser_Accolade();

	// Loads the specified sound effects bank (FXB file).
	void load(Common::SeekableReadStream *in, int32 size);

	// Sets the MIDI driver that should be used to output the SFX.
	virtual void setMidiDriver(MidiDriver_Multisource *driver) = 0;
	// Sets the number of microseconds between timer callbacks.
	void setTimerRate(uint32 rate);

	// Starts playback of the specified sound effect.
	void play(uint8 sfxNumber);
	// Stops all active SFX.
	void stopAll();
	// Pauses or unpauses all active SFX.
	void pauseAll(bool paused);

	void onTimer();
	static void timerCallback(void *data);

protected:
	// Stops the sound effect playing in the specified slot.
	void stop(SfxSlot *sfxSlot);
	// Processes the specified opcode for the specified slot.
	void processOpCode(SfxSlot *sfxSlot, byte opCode);

	// Returns the number of sources available for SFX playback.
	virtual byte getNumberOfSfxSources() = 0;
	// Reads the SFX instrument data into the specified SfxData from the
	// specified SFX bank data. This is positioned at the start of the data of
	// a sound effect in the bank; when the function returns is should be
	// positioned right after all instrument data for the sound effect.
	virtual void readInstrument(SfxData *sfxData, Common::SeekableReadStream *in) = 0;

	// Loads the SFX instrument for the specified slot into the channel
	// allocated to the sound effect. Returns true if the channel needs to be
	// changed to the new instrument when the driver is ready.
	virtual bool loadInstrument(SfxSlot *sfxSlot) = 0;
	// Changes the channel allocated to the sound effect to the SFX instrument.
	virtual void changeInstrument(SfxSlot *sfxSlot) { };
	// Starts a note at the current note / note fraction for the slot.
	virtual void noteOn(SfxSlot *sfxSlot);
	// Stops the current note for the slot.
	virtual void noteOff(SfxSlot *sfxSlot);
	// Updates the note / note fraction for the slot.
	virtual void updateNote(SfxSlot *sfxSlot) { };

	Common::Mutex _mutex;

	MidiDriver_Multisource *_driver;
	uint32 _timerRate;

	// Array of SFX data loaded from the SFX bank.
	SfxData *_sfxData;
	// The number of SFX data loaded.
	uint16 _numSfx;
	// The slots available for SFX playback.
	SfxSlot _sfxSlots[4];
	// The slot numbers allocated to the available SFX sources. -1 if no slot
	// is using the source.
	int8 _sourceAllocations[4];

	// True if SFX playback is paused.
	bool _paused;
};

class SfxParser_Accolade_AdLib : public SfxParser_Accolade {
public:
	SfxParser_Accolade_AdLib() : _adLibDriver(nullptr) { }

protected:
	void setMidiDriver(MidiDriver_Multisource *driver) override;
	byte getNumberOfSfxSources() override;
	void readInstrument(SfxData *sfxData, Common::SeekableReadStream *in) override;
	bool loadInstrument(SfxSlot *sfxSlot) override;
	void noteOn(SfxSlot *sfxSlot) override;
	void updateNote(SfxSlot *sfxSlot) override;

	MidiDriver_Accolade_AdLib *_adLibDriver;
};

class SfxParser_Accolade_MT32 : public SfxParser_Accolade {
public:
	SfxParser_Accolade_MT32() : _mt32Driver(nullptr) { }

protected:
	void setMidiDriver(MidiDriver_Multisource *driver) override;
	byte getNumberOfSfxSources() override;
	void readInstrument(SfxData *sfxData, Common::SeekableReadStream *in) override;
	bool loadInstrument(SfxSlot *sfxSlot) override;
	void changeInstrument(SfxSlot *sfxSlot) override;

	MidiDriver_Accolade_MT32 *_mt32Driver;
};

} // End of namespace AGOS

#endif

================
File: sound.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/file.h"
#include "common/memstream.h"
#include "common/textconsole.h"
#include "common/util.h"
#include "common/substream.h"

#include "agos/agos.h"
#include "agos/sound.h"

#include "audio/audiostream.h"
#include "audio/decoders/flac.h"
#include "audio/mixer.h"
#include "audio/decoders/mp3.h"
#include "audio/decoders/raw.h"
#include "audio/decoders/voc.h"
#include "audio/decoders/vorbis.h"
#include "audio/decoders/wave.h"

namespace AGOS {

#define SOUND_BIG_ENDIAN true

class BaseSound : Common::NonCopyable {
protected:
	const Common::Path _filename;
	uint32 *_offsets;
	Audio::Mixer *_mixer;
	bool _freeOffsets;

	Common::SeekableReadStream *getSoundStream(uint sound) const;
public:
	BaseSound(Audio::Mixer *mixer, const Common::Path &filename, uint32 base, bool bigEndian);
	BaseSound(Audio::Mixer *mixer, const Common::Path &filename, uint32 *offsets);
	virtual ~BaseSound();

	void playSound(uint sound, Audio::Mixer::SoundType type, Audio::SoundHandle *handle, bool loop, int vol = 0) {
		playSound(sound, sound, type, handle, loop, vol);
	}
	virtual void playSound(uint sound, uint loopSound, Audio::Mixer::SoundType type, Audio::SoundHandle *handle, bool loop, int vol = 0);
	virtual Audio::RewindableAudioStream *makeAudioStream(uint sound) = 0;
};

BaseSound::BaseSound(Audio::Mixer *mixer, const Common::Path &filename, uint32 base, bool bigEndian)
	: _mixer(mixer), _filename(filename), _offsets(nullptr) {

	uint res = 0;
	uint32 size;

	Common::File file;
	if (!file.open(_filename))
		error("BaseSound: Could not open file \"%s\"", filename.toString(Common::Path::kNativeSeparator).c_str());

	file.seek(base + sizeof(uint32), SEEK_SET);
	if (bigEndian)
		size = file.readUint32BE();
	else
		size = file.readUint32LE();

	// The Feeble Files uses set amount of voice offsets
	if (size == 0)
		size = 40000;

	res = size / sizeof(uint32);

	_offsets = (uint32 *)malloc(size + sizeof(uint32));
	_freeOffsets = true;

	file.seek(base, SEEK_SET);

	for (uint i = 0; i < res; i++) {
		if (bigEndian)
			_offsets[i] = base + file.readUint32BE();
		else
			_offsets[i] = base + file.readUint32LE();
	}

	_offsets[res] = file.size();
}

BaseSound::BaseSound(Audio::Mixer *mixer, const Common::Path &filename, uint32 *offsets)
	: _mixer(mixer), _filename(filename), _offsets(offsets), _freeOffsets(false) {
}

BaseSound::~BaseSound() {
	if (_freeOffsets)
		free(_offsets);
}

Common::SeekableReadStream *BaseSound::getSoundStream(uint sound) const {
	if (_offsets == nullptr)
		return nullptr;

	Common::File *file = new Common::File();
	if (!file->open(_filename)) {
		warning("BaseSound::getSoundStream: Could not open file \"%s\"", _filename.toString(Common::Path::kNativeSeparator).c_str());
		delete file;
		return nullptr;
	}

	int i = 1;
	while (_offsets[sound + i] == _offsets[sound])
		i++;
	uint end;
	if (_offsets[sound + i] > _offsets[sound]) {
		end = _offsets[sound + i];
	} else {
		end = file->size();
	}

	return new Common::SeekableSubReadStream(file, _offsets[sound], end, DisposeAfterUse::YES);
}

///////////////////////////////////////////////////////////////////////////////
#pragma mark -

static void convertVolume(int &vol) {
	// DirectSound was originally used, which specifies volume
	// and panning differently than ScummVM does, using a logarithmic scale
	// rather than a linear one.
	//
	// Volume is a value between -10,000 and 0.
	//
	// In both cases, the -10,000 represents -100 dB. When panning, only
	// one speaker's volume is affected - just like in ScummVM - with
	// negative values affecting the left speaker, and positive values
	// affecting the right speaker. Thus -10,000 means the left speaker is
	// silent.

	int v = CLIP(vol, -10000, 0);
	if (v) {
		vol = (int)((double)Audio::Mixer::kMaxChannelVolume * pow(10.0, (double)v / 2000.0) + 0.5);
	} else {
		vol = Audio::Mixer::kMaxChannelVolume;
	}
}

static void convertPan(int &pan) {
	// DirectSound was originally used, which specifies volume
	// and panning differently than ScummVM does, using a logarithmic scale
	// rather than a linear one.
	//
	// Panning is a value between -10,000 and 10,000.
	//
	// In both cases, the -10,000 represents -100 dB. When panning, only
	// one speaker's volume is affected - just like in ScummVM - with
	// negative values affecting the left speaker, and positive values
	// affecting the right speaker. Thus -10,000 means the left speaker is
	// silent.

	int p = CLIP(pan, -10000, 10000);
	if (p < 0) {
		pan = (int)(255.0 * pow(10.0, (double)p / 2000.0) + 127.5);
	} else if (p > 0) {
		pan = (int)(255.0 * pow(10.0, (double)p / -2000.0) - 127.5);
	} else {
		pan = 0;
	}
}

///////////////////////////////////////////////////////////////////////////////
#pragma mark -

// TODO: Move to a better place?
void BaseSound::playSound(uint sound, uint loopSound, Audio::Mixer::SoundType type, Audio::SoundHandle *handle, bool loop, int vol) {
	convertVolume(vol);
	_mixer->playStream(type, handle, Audio::makeLoopingAudioStream(makeAudioStream(sound), loop ? loopSound : 1), -1, vol);
}

class WavSound : public BaseSound {
public:
	WavSound(Audio::Mixer *mixer, const Common::Path &filename, uint32 base = 0)
		: BaseSound(mixer, filename, base, false) {}
	WavSound(Audio::Mixer *mixer, const Common::Path &filename, uint32 *offsets) : BaseSound(mixer, filename, offsets) {}
	Audio::RewindableAudioStream *makeAudioStream(uint sound) override;
};

Audio::RewindableAudioStream *WavSound::makeAudioStream(uint sound) {
	Common::SeekableReadStream *tmp = getSoundStream(sound);
	if (!tmp)
		return nullptr;
	return Audio::makeWAVStream(tmp, DisposeAfterUse::YES);
}

///////////////////////////////////////////////////////////////////////////////
#pragma mark -

class VocSound : public BaseSound {
	const byte _flags;
public:
	VocSound(Audio::Mixer *mixer, const Common::Path &filename, bool isUnsigned, uint32 base = 0, bool bigEndian = false)
		: BaseSound(mixer, filename, base, bigEndian), _flags(isUnsigned ? Audio::FLAG_UNSIGNED : 0) {}
	Audio::RewindableAudioStream *makeAudioStream(uint sound) override;
};

Audio::RewindableAudioStream *VocSound::makeAudioStream(uint sound) {
	Common::SeekableReadStream *tmp = getSoundStream(sound);
	if (!tmp)
		return nullptr;
	return Audio::makeVOCStream(tmp, _flags, DisposeAfterUse::YES);
}

///////////////////////////////////////////////////////////////////////////////
#pragma mark -

// This class is only used by speech in Simon1 Amiga CD32
class RawSound : public BaseSound {
	const byte _flags;
public:
	RawSound(Audio::Mixer *mixer, const Common::Path &filename, bool isUnsigned)
		: BaseSound(mixer, filename, 0, SOUND_BIG_ENDIAN), _flags(isUnsigned ? Audio::FLAG_UNSIGNED : 0) {}
	Audio::RewindableAudioStream *makeAudioStream(uint sound) override;
	void playSound(uint sound, uint loopSound, Audio::Mixer::SoundType type, Audio::SoundHandle *handle, bool loop, int vol = 0) override;
};

Audio::RewindableAudioStream *RawSound::makeAudioStream(uint sound) {
	if (_offsets == nullptr)
		return nullptr;

	Common::File *file = new Common::File();
	if (!file->open(_filename)) {
		warning("RawSound::makeAudioStream: Could not open file \"%s\"", _filename.toString(Common::Path::kNativeSeparator).c_str());
		delete file;
		return nullptr;
	}

	file->seek(_offsets[sound], SEEK_SET);
	uint size = file->readUint32BE();
	return Audio::makeRawStream(new Common::SeekableSubReadStream(file, _offsets[sound] + 4, _offsets[sound] + 4 + size, DisposeAfterUse::YES), 22050, _flags, DisposeAfterUse::YES);
}

void RawSound::playSound(uint sound, uint loopSound, Audio::Mixer::SoundType type, Audio::SoundHandle *handle, bool loop, int vol) {
	// Sound looping and volume are ignored.
	_mixer->playStream(type, handle, makeAudioStream(sound));
}

///////////////////////////////////////////////////////////////////////////////
#pragma mark -

///////////////////////////////////////////////////////////////////////////////
#pragma mark -

#ifdef USE_MAD
class MP3Sound : public BaseSound {
public:
	MP3Sound(Audio::Mixer *mixer, const Common::Path &filename, uint32 base = 0) : BaseSound(mixer, filename, base, false) {}
	Audio::RewindableAudioStream *makeAudioStream(uint sound) override {
		Common::SeekableReadStream *tmp = getSoundStream(sound);
		if (!tmp)
			return nullptr;
		return Audio::makeMP3Stream(tmp, DisposeAfterUse::YES);
	}
};
#endif

///////////////////////////////////////////////////////////////////////////////
#pragma mark -

#ifdef USE_VORBIS
class VorbisSound : public BaseSound {
public:
	VorbisSound(Audio::Mixer *mixer, const Common::Path &filename, uint32 base = 0) : BaseSound(mixer, filename, base, false) {}
	Audio::RewindableAudioStream *makeAudioStream(uint sound) override {
		Common::SeekableReadStream *tmp = getSoundStream(sound);
		if (!tmp)
			return nullptr;
		return Audio::makeVorbisStream(tmp, DisposeAfterUse::YES);
	}
};
#endif

///////////////////////////////////////////////////////////////////////////////
#pragma mark -

#ifdef USE_FLAC
class FLACSound : public BaseSound {
public:
	FLACSound(Audio::Mixer *mixer, const Common::Path &filename, uint32 base = 0) : BaseSound(mixer, filename, base, false) {}
	Audio::RewindableAudioStream *makeAudioStream(uint sound) override {
		Common::SeekableReadStream *tmp = getSoundStream(sound);
		if (!tmp)
			return nullptr;
		return Audio::makeFLACStream(tmp, DisposeAfterUse::YES);
	}
};
#endif

///////////////////////////////////////////////////////////////////////////////
#pragma mark -

static BaseSound *makeSound(Audio::Mixer *mixer, const Common::Path &basename) {
	Common::Path tmp;
#ifdef USE_FLAC
	tmp = basename.append(".fla");
	if (Common::File::exists(tmp))
		return new FLACSound(mixer, tmp);
#endif
#ifdef USE_VORBIS
	tmp = basename.append(".ogg");
	if (Common::File::exists(tmp))
		return new VorbisSound(mixer, tmp);
#endif
#ifdef USE_MAD
	tmp = basename.append(".mp3");
	if (Common::File::exists(tmp))
		return new MP3Sound(mixer, tmp);
#endif
	tmp = basename.append(".wav");
	if (Common::File::exists(tmp))
		return new WavSound(mixer, tmp);
	tmp = basename.append(".voc");
	if (Common::File::exists(tmp))
		return new VocSound(mixer, tmp, true);
	return nullptr;
}


///////////////////////////////////////////////////////////////////////////////
#pragma mark -

Sound::Sound(AGOSEngine *vm, const GameSpecificSettings *gss, Audio::Mixer *mixer)
	: _vm(vm), _mixer(mixer) {
	_voice = nullptr;
	_effects = nullptr;

	_filenums = nullptr;
	_lastVoiceFile = 0;
	_offsets = nullptr;

	_hasEffectsFile = false;
	_hasVoiceFile = false;

	_ambientPlaying = 0;

	_soundQueuePtr = nullptr;
	_soundQueueNum = 0;
	_soundQueueSize = 0;
	_soundQueueFreq = 0;

	if (_vm->getFeatures() & GF_TALKIE) {
		loadVoiceFile(gss);

		if (_vm->getGameType() == GType_SIMON1)
			loadSfxFile(gss);
	}
}

Sound::~Sound() {
	delete _voice;
	delete _effects;

	free(_filenums);
	free(_offsets);
}

void Sound::loadVoiceFile(const GameSpecificSettings *gss) {
	// Game versions which use separate voice files
	if (_hasVoiceFile || _vm->getGameType() == GType_FF || _vm->getGameId() == GID_SIMON1CD32)
		return;

	_voice = makeSound(_mixer, gss->speech_filename);
	_hasVoiceFile = (_voice != nullptr);

	if (_hasVoiceFile)
		return;

	if (_vm->getGameType() == GType_SIMON2) {
		// for simon2 mac/amiga, only read index file
		Common::File file;
		if (file.open("voices.idx")) {
			int end = file.size();
			_filenums = (uint16 *)malloc((end / 6 + 1) * 2);
			_offsets = (uint32 *)malloc((end / 6 + 1 + 1) * 4);

			for (int i = 1; i <= end / 6; i++) {
				_filenums[i] = file.readUint16BE();
				_offsets[i] = file.readUint32BE();
			}
			// We need to add a terminator entry otherwise we get an out of
			// bounds read when the offset table is accessed in
			// BaseSound::getSoundStream.
			_offsets[end / 6 + 1] = 0;

			_hasVoiceFile = true;
			return;
		}
	}

	const bool dataIsUnsigned = true;

	if (Common::File::exists(gss->speech_filename)) {
		_hasVoiceFile = true;
		if (_vm->getGameType() == GType_PP)
			_voice = new WavSound(_mixer, gss->speech_filename);
		else
			_voice = new VocSound(_mixer, gss->speech_filename, dataIsUnsigned);
	}
}

void Sound::loadSfxFile(const GameSpecificSettings *gss) {
	if (_hasEffectsFile)
		return;

	_effects = makeSound(_mixer, gss->effects_filename);
	_hasEffectsFile = (_effects != nullptr);

	if (_hasEffectsFile)
		return;

	const bool dataIsUnsigned = true;

	if (Common::File::exists(gss->effects_filename)) {
		_hasEffectsFile = true;
		_effects = new VocSound(_mixer, gss->effects_filename, dataIsUnsigned);
	}
}

// This method is only used by Simon1 Amiga CD32 & Windows
void Sound::readSfxFile(const Common::Path &filename) {
	if (_hasEffectsFile)
		return;

	_mixer->stopHandle(_effectsHandle);

	if (!Common::File::exists(filename)) {
		error("readSfxFile: Can't load sfx file %s", filename.toString(Common::Path::kNativeSeparator).c_str());
	}

	const bool dataIsUnsigned = (_vm->getGameId() != GID_SIMON1CD32);

	delete _effects;
	if (_vm->getGameId() == GID_SIMON1CD32) {
		_effects = new VocSound(_mixer, filename, dataIsUnsigned, 0, SOUND_BIG_ENDIAN);
	} else
		_effects = new WavSound(_mixer, filename);
}

// This method is only used by Simon2
void Sound::loadSfxTable(const char *gameFilename, uint32 base) {
	stopAllSfx();

	delete _effects;
	const bool dataIsUnsigned = true;
	if (_vm->getPlatform() == Common::kPlatformWindows || (_vm->getFeatures() & GF_WAVSFX))
		_effects = new WavSound(_mixer, gameFilename, base);
	else
		_effects = new VocSound(_mixer, gameFilename, dataIsUnsigned, base, false);
}

// This method is only used by Simon1 Amiga CD32
void Sound::readVoiceFile(const Common::Path &filename) {
	_mixer->stopHandle(_voiceHandle);

	if (!Common::File::exists(filename))
		error("readVoiceFile: Can't load voice file %s", filename.toString(Common::Path::kNativeSeparator).c_str());

	const bool dataIsUnsigned = false;

	delete _voice;
	_voice = new RawSound(_mixer, filename, dataIsUnsigned);
}

void Sound::playVoice(uint sound) {
	if (_filenums) {
		if (_lastVoiceFile != _filenums[sound]) {
			_mixer->stopHandle(_voiceHandle);

			char filename[16];
			_lastVoiceFile = _filenums[sound];
			Common::sprintf_s(filename, "voices%d.dat", _filenums[sound]);
			if (!Common::File::exists(filename))
				error("playVoice: Can't load voice file %s", filename);

			delete _voice;
			_voice = new WavSound(_mixer, filename, _offsets);
		}
	}

	if (!_voice)
		return;

	_mixer->stopHandle(_voiceHandle);
	if (_vm->getGameType() == GType_PP) {
		if (sound < 11)
			_voice->playSound(sound, sound + 1, Audio::Mixer::kMusicSoundType, &_voiceHandle, true, -1500);
		else
			_voice->playSound(sound, sound, Audio::Mixer::kMusicSoundType, &_voiceHandle, true);
	} else {
		_voice->playSound(sound, Audio::Mixer::kSpeechSoundType, &_voiceHandle, false);
	}
}

void Sound::playEffects(uint sound) {
	if (!_effects)
		return;

	if (_vm->getGameType() == GType_SIMON1)
		_mixer->stopHandle(_effectsHandle);
	_effects->playSound(sound, Audio::Mixer::kSFXSoundType, &_effectsHandle, false);
}

void Sound::playAmbient(uint sound) {
	if (!_effects)
		return;

	if (sound == _ambientPlaying)
		return;

	_ambientPlaying = sound;

	_mixer->stopHandle(_ambientHandle);
	_effects->playSound(sound, Audio::Mixer::kSFXSoundType, &_ambientHandle, true);
}

bool Sound::hasVoice() const {
	return _hasVoiceFile;
}

bool Sound::isSfxActive() const {
	return _mixer->isSoundHandleActive(_effectsHandle);
}

bool Sound::isVoiceActive() const {
	return _mixer->isSoundHandleActive(_voiceHandle);
}

void Sound::stopAllSfx() {
	_mixer->stopHandle(_ambientHandle);
	_mixer->stopHandle(_effectsHandle);
	_mixer->stopHandle(_sfx5Handle);
	_ambientPlaying = 0;
}

void Sound::stopSfx() {
	_mixer->stopHandle(_effectsHandle);
}

void Sound::stopVoice() {
	_mixer->stopHandle(_voiceHandle);
}

void Sound::stopAll() {
	_mixer->stopAll();
	_ambientPlaying = 0;
}

void Sound::effectsMute(bool mute, uint16 effectsVolume) {
	_mixer->setChannelVolume(_effectsHandle, mute ? 0 : effectsVolume);
	_mixer->setChannelVolume(_sfx5Handle, mute ? 0 : effectsVolume);
}

void Sound::ambientMute(bool mute, uint16 effectsVolume) {
	_mixer->setChannelVolume(_ambientHandle, mute ? 0 : effectsVolume);
}

// Personal Nightmare specific
void Sound::handleSoundQueue() {
	if (isSfxActive())
		return;

	_vm->_sampleEnd = 1;

	if (_soundQueuePtr) {
		playRawData(_soundQueuePtr, _soundQueueNum, _soundQueueSize, _soundQueueFreq);

		_vm->_sampleWait = 1;
		_vm->_sampleEnd = 0;
		_soundQueuePtr = nullptr;
		_soundQueueNum = 0;
		_soundQueueSize = 0;
		_soundQueueFreq = 0;
	}
}

void Sound::queueSound(byte *ptr, uint16 sound, uint32 size, uint16 freq) {
	// Only a single sound can be queued
	_soundQueuePtr = ptr;
	_soundQueueNum = sound;
	_soundQueueSize = size;
	_soundQueueFreq = freq;
}

// Elvira 1/2 and Waxworks specific
void Sound::playRawData(byte *soundData, uint sound, uint size, uint freq) {
	byte *buffer = (byte *)malloc(size);
	memcpy(buffer, soundData, size);

	byte flags = 0;
	if (_vm->getPlatform() == Common::kPlatformDOS &&  _vm->getGameId() != GID_ELVIRA2)
		flags = Audio::FLAG_UNSIGNED;

	Audio::AudioStream *stream = Audio::makeRawStream(buffer, size, freq, flags);
	_mixer->playStream(Audio::Mixer::kSFXSoundType, &_effectsHandle, stream);
}

// Feeble Files specific
void Sound::playAmbientData(byte *soundData, uint sound, uint pan, uint vol) {
	if (sound == _ambientPlaying)
		return;

	_ambientPlaying = sound;

	_mixer->stopHandle(_ambientHandle);
	playSoundData(&_ambientHandle, soundData, sound, pan, vol, true);
}

void Sound::playSfxData(byte *soundData, uint sound, uint pan, uint vol) {
	playSoundData(&_effectsHandle, soundData, sound, pan, vol, false);
}

void Sound::playSfx5Data(byte *soundData, uint sound, uint pan, uint vol) {
	_mixer->stopHandle(_sfx5Handle);
	playSoundData(&_sfx5Handle, soundData, sound, pan, vol, true);
}

void Sound::playVoiceData(byte *soundData, uint sound) {
	_mixer->stopHandle(_voiceHandle);
	playSoundData(&_voiceHandle, soundData, sound);
}

void Sound::playSoundData(Audio::SoundHandle *handle, byte *soundData, uint sound, int pan, int vol, bool loop) {
	int size = READ_LE_UINT32(soundData + 4) + 8;
	Common::SeekableReadStream *stream = new Common::MemoryReadStream(soundData, size);
	Audio::RewindableAudioStream *sndStream = Audio::makeWAVStream(stream, DisposeAfterUse::YES);

	convertVolume(vol);
	convertPan(pan);

	_mixer->playStream(Audio::Mixer::kSFXSoundType, handle, Audio::makeLoopingAudioStream(sndStream, loop ? 0 : 1), -1, vol, pan);
}

void Sound::stopSfx5() {
	_mixer->stopHandle(_sfx5Handle);
}

void Sound::switchVoiceFile(const GameSpecificSettings *gss, uint disc) {
	if (_lastVoiceFile == disc)
		return;

	_mixer->stopHandle(_voiceHandle);
	delete _voice;

	_hasVoiceFile = false;
	_lastVoiceFile = disc;

	char filename[16];

	Common::sprintf_s(filename, "%s%u", gss->speech_filename, disc);
	_voice = makeSound(_mixer, filename);
	_hasVoiceFile = (_voice != nullptr);

	if (!_hasVoiceFile)
		error("switchVoiceFile: Can't load voice file %s", filename);
}

} // End of namespace AGOS

================
File: sound.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_SOUND_H
#define AGOS_SOUND_H

#include "audio/audiostream.h"
#include "audio/mixer.h"
#include "agos/intern.h"
#include "common/str.h"

namespace Common {
class File;
}

namespace AGOS {

class BaseSound;

class AGOSEngine;

class Sound {
private:
	AGOSEngine *_vm;

	Audio::Mixer *_mixer;

	BaseSound *_voice;
	BaseSound *_effects;

	uint16 *_filenums;
	uint32 *_offsets;
	uint16 _lastVoiceFile;

	Audio::SoundHandle _voiceHandle;
	Audio::SoundHandle _effectsHandle;
	Audio::SoundHandle _ambientHandle;
	Audio::SoundHandle _sfx5Handle;

	bool _hasEffectsFile;
	bool _hasVoiceFile;
	uint16 _ambientPlaying;

	// Personal Nightmare specific
	byte *_soundQueuePtr;
	uint16 _soundQueueNum;
	uint32 _soundQueueSize;
	uint16 _soundQueueFreq;
public:
	Sound(AGOSEngine *vm, const GameSpecificSettings *gss, Audio::Mixer *mixer);
	~Sound();

	enum TypeFlags {
		TYPE_AMBIENT = 1 << 0,
		TYPE_SFX     = 1 << 1,
		TYPE_SFX5    = 1 << 2
	};

protected:
	void loadVoiceFile(const GameSpecificSettings *gss);
	void loadSfxFile(const GameSpecificSettings *gss);

public:
	void readSfxFile(const Common::Path &filename);
	void loadSfxTable(const char *gameFilename, uint32 base);
	void readVoiceFile(const Common::Path &filename);

	void playVoice(uint sound);
	void playEffects(uint sound);
	void playAmbient(uint sound);

	// Personal Nightmare specific
	void handleSoundQueue();
	void queueSound(byte *ptr, uint16 sound, uint32 size, uint16 freq);

	// Elvira 1/2 and Waxworks specific
	void playRawData(byte *soundData, uint sound, uint size, uint freq);

	// Feeble Files specific
	void playAmbientData(byte *soundData, uint sound, uint pan, uint vol);
	void playSfxData(byte *soundData, uint sound, uint pan, uint vol);
	void playSfx5Data(byte *soundData, uint sound, uint pan, uint vol);
	void playSoundData(Audio::SoundHandle *handle, byte *soundData, uint sound, int pan = 0, int vol = 0, bool loop = false);
	void playVoiceData(byte *soundData, uint sound);
	void switchVoiceFile(const GameSpecificSettings *gss, uint disc);

	bool hasVoice() const;
	bool isSfxActive() const;
	bool isVoiceActive() const;
	void stopAllSfx();
	void stopSfx();
	void stopSfx5();
	void stopVoice();
	void stopAll();
	void effectsMute(bool mute, uint16 effectsVolume);
	void ambientMute(bool mute, uint16 effectsVolume);
};

} // End of namespace AGOS

#endif

================
File: string.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */



#include "common/file.h"
#include "common/textconsole.h"

#include "gui/message.h"

#include "agos/agos.h"
#include "agos/intern.h"

namespace AGOS {

void AGOSEngine::uncompressText(byte *ptr) {
	byte a;
	while (true) {
		if (_awaitTwoByteToken != 0)
			a = _awaitTwoByteToken;
		else
			a = *ptr++;
		if (a == 0)
			return;
		ptr = uncompressToken(a, ptr);
		if (ptr == nullptr)
			return;
	}
}

byte *AGOSEngine::uncompressToken(byte a, byte *ptr) {
	byte *ptr1 = nullptr;
	byte *ptr2 = nullptr;
	byte b;
	int count1 = 0;

	if (a == 0xFF || a == 0xFE || a == 0xFD) {
		if (a == 0xFF)
			ptr2 = _twoByteTokenStrings;
		if (a == 0xFE)
			ptr2 = _secondTwoByteTokenStrings;
		if (a == 0xFD)
			ptr2 = _thirdTwoByteTokenStrings;
		_awaitTwoByteToken = a;
		b = a;
		a = *ptr++;
		if (a == 0)		/* Need to return such that next byte   */
			return nullptr;	/* is used as two byte token		*/

		_awaitTwoByteToken = 0;
		ptr1 = _twoByteTokens;
		while (*ptr1 != a) {
			ptr1++;
			count1++;
			if (*ptr1 == 0)	{	/* If was not a two byte token  */
				count1 = 0;	/* then was a byte token.	*/
				ptr1 = _byteTokens;
				while (*ptr1 != a) {
					ptr1++;
					count1++;
				}
				ptr1 = _byteTokenStrings;		/* Find it */
				while (count1--)	{
					while (*ptr1++)
						;
				}
				ptr1 = uncompressToken(b, ptr1);	/* Try this one as a two byte token */
				uncompressText(ptr1);			/* Uncompress rest of this token    */
				return ptr;
			}
		}
		while (count1--) {
			while (*ptr2++)
				;
		}
		uncompressText(ptr2);
	} else {
		ptr1 = _byteTokens;
		while (*ptr1 != a) {
			ptr1++;
			count1++;
			if (*ptr1 == 0) {
				_textBuffer[_textCount++] = a;	/* Not a byte token */
				return ptr;			/* must be real character */
			}
		}
		ptr1 = _byteTokenStrings;
		while (count1--)	{		/* Is a byte token so count */
			while (*ptr1++)		/* to start of token */
				;
		}
		uncompressText(ptr1);			/* and do it */
	}
	return ptr;
}

const byte *AGOSEngine::getStringPtrByID(uint16 stringId, bool upperCase) {
	const byte *stringPtr;
	byte *dst;

	_freeStringSlot ^= 1;
	dst = _stringReturnBuffer[_freeStringSlot];

	if (getGameType() == GType_ELVIRA1 && getPlatform() == Common::kPlatformAtariST) {
		byte *ptr = _stringTabPtr[stringId];
		_textCount = 0;
		_awaitTwoByteToken = 0;
		uncompressText(ptr);
		_textBuffer[_textCount] = 0;
		Common::strlcpy((char *)dst, (const char *)_textBuffer, 180);
	} else {
		if (stringId < 0x8000) {
			stringPtr = _stringTabPtr[stringId];
		} else {
			stringPtr = getLocalStringByID(stringId);
		}
		Common::strlcpy((char *)dst, (const char *)stringPtr, 180);
	}

	// WORKAROUND bug #2780: The French version of Simon 1 and the
	// Polish version of Simon 2 used excess spaces, at the end of many
	// messages, so we strip off those excess spaces.
	if ((getGameType() == GType_SIMON1 && _language == Common::FR_FRA) ||
		(getGameType() == GType_SIMON2 && _language == Common::PL_POL)) {
		uint16 len = strlen((const char *)dst) - 1;

		while (len && dst[len] == 32) {
			dst[len] = 0;
			len--;
		}

	}

	if (upperCase && *dst) {
		if (Common::isLower(*dst))
			*dst = toupper(*dst);
	}

	return dst;
}

const byte *AGOSEngine::getLocalStringByID(uint16 stringId) {
	if (stringId < _stringIdLocalMin || stringId >= _stringIdLocalMax) {
		loadTextIntoMem(stringId);
	}
	byte *localString = _localStringtable[stringId - _stringIdLocalMin];
	if (getGameType() == GType_SIMON1 && (getFeatures() & GF_TALKIE) && (strlen((char *)localString) == 0)) {
		// WORKAROUND bug for Simon 1 (only in CD-ROM versions) missing subtitles text when using the map at the dungeon, strings taken from Floppy versions
		if (stringId == 36034) {
			if (_language == Common::HE_ISR)
				return (const byte *)"@PI L@ IKEL LV@Z NK@O KXBR.";
			if (_language == Common::ES_ESP)
				return (const byte *)"Ahora no puedo salir de aqu<.";
			if (_language == Common::IT_ITA)
				return (const byte *)"Non posso uscire per il momento.";
		}

		if (stringId == 36035 && _language == Common::FR_FRA)
			return (const byte *)"Je ne peux pas sortir de l; pour l'instant.";
	}
	return localString;
}

TextLocation *AGOSEngine::getTextLocation(uint a) {
	switch (a) {
	case 1:
		return &_textLocation1;
	case 2:
		return &_textLocation2;
	case 101:
		return &_textLocation3;
	case 102:
		return &_textLocation4;
	default:
		error("getTextLocation: Invalid text location %d", a);
	}
	return nullptr;	// for compilers that don't support NORETURN
}

void AGOSEngine::allocateStringTable(int num) {
	_stringTabPtr = (byte **)calloc(num, sizeof(byte *));
	_stringTabPos = 0;
	_stringTabSize = num;
}

void AGOSEngine::setupStringTable(byte *mem, int num) {
	int i = 0;

	if (getGameType() == GType_ELVIRA1 && getPlatform() == Common::kPlatformAtariST) {
		int ct1;

		_twoByteTokens = mem;
		while (*mem++) {
			i++;
		}
		_twoByteTokenStrings = mem;
		ct1 = i;
		while (*mem++) {
			while (*mem++)
				;
			i--;
			if ((i == 0) && (ct1 != 0)) {
				_secondTwoByteTokenStrings = mem;
				i = ct1;
				ct1 = 0;
			}
			if (i == 0)
				_thirdTwoByteTokenStrings = mem;
		}
		_byteTokens = mem;
		while (*mem++)
			;
		_byteTokenStrings = mem;
		while (*mem++) {
			while (*mem++)
				;
		}
		i = 0;
l1:		_stringTabPtr[i++] = mem;
		num--;
		if (!num) {
			_stringTabPos = i;
			return;
		}
		while (*mem++)
			;
		goto l1;
	} else {
		for (;;) {
			_stringTabPtr[i++] = mem;
			if (--num == 0)
				break;
			for (; *mem; mem++)
				;
			mem++;
		}

		_stringTabPos = i;
	}
}

void AGOSEngine::setupLocalStringTable(byte *mem, int num) {
	int i = 0;
	for (;;) {
		_localStringtable[i++] = mem;
		if (--num == 0)
			break;
		for (; *mem; mem++)
			;
		mem++;
	}
}

uint AGOSEngine::loadTextFile(const char *filename, byte *dst) {
	if (getFeatures() & GF_OLD_BUNDLE)
		return loadTextFile_simon1(filename, dst);
	else
		return loadTextFile_gme(filename, dst);
}

uint AGOSEngine::loadTextFile_simon1(const char *filename, byte *dst) {
	Common::File fo;
	fo.open(filename);
	uint32 size;

	if (fo.isOpen() == false)
		error("loadTextFile: Can't open '%s'", filename);

	size = fo.size();

	if (fo.read(dst, size) != size)
		error("loadTextFile: fread failed");
	fo.close();

	return size;
}

uint AGOSEngine::loadTextFile_gme(const char *filename, byte *dst) {
	uint res;
	uint32 offs;
	uint32 size;

	res = atoi(filename + 4) + _textIndexBase - 1;
	offs = _gameOffsetsPtr[res];
	size = _gameOffsetsPtr[res + 1] - offs;

	readGameFile(dst, offs, size);

	return size;
}

void AGOSEngine::loadTextIntoMem(uint16 stringId) {
	byte *p;
	uint16 baseMin = 0x8000, baseMax, size;

	_tablesHeapPtr = _tablesheapPtrNew;
	_tablesHeapCurPos = _tablesHeapCurPosNew;

	p = _strippedTxtMem;

	// get filename
	while (*p) {
		Common::String filename;
		while (*p)
			filename += *p++;
		p++;

		baseMax = (p[0] * 256) | p[1];
		p += 2;

		if (stringId < baseMax) {
			_stringIdLocalMin = baseMin;
			_stringIdLocalMax = baseMax;

			_localStringtable = (byte **)_tablesHeapPtr;

			size = (baseMax - baseMin + 1) * sizeof(byte *);
			_tablesHeapPtr += size;
			_tablesHeapCurPos += size;

			size = loadTextFile(filename.c_str(), _tablesHeapPtr);

			setupLocalStringTable(_tablesHeapPtr, baseMax - baseMin + 1);

			_tablesHeapPtr += size;
			_tablesHeapCurPos += size;
			alignTableMem();

			if (_tablesHeapCurPos > _tablesHeapSize) {
				error("loadTextIntoMem: Out of table memory");
			}
			return;
		}

		baseMin = baseMax;
	}

	error("loadTextIntoMem: didn't find %d", stringId);
}

static const byte polish_charWidth[226] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 6, 2, 8, 7, 6,10, 8, 2,
	4, 4, 7, 6, 3, 4, 2, 3, 6, 4,
	6, 6, 7, 6, 6, 6, 6, 6, 2, 8,
	6, 9, 7, 6, 6, 8, 7, 8, 8, 7,
	6, 9, 8, 2, 6, 7, 6,10, 8, 9,
	7, 9, 7, 7, 8, 8, 8,12, 8, 8,
	7, 6, 7, 6, 4, 7, 7, 7, 7, 6,
	7, 7, 4, 7, 6, 2, 3, 6, 2,10,
	6, 7, 7, 7, 5, 6, 4, 6, 6,10,
	6, 6, 6, 0, 0, 0, 0, 0, 8, 6,
	7, 7, 7, 7, 7, 6, 7, 7, 7, 4,
	4, 3, 8, 8, 7, 0, 0, 7, 7, 7,
	6, 6, 6, 9, 8, 0, 0, 0, 0, 0,
	7, 3, 7, 6, 6, 8, 0, 0, 6, 0,
	0, 0, 0, 2, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 7
};

static const byte charWidth[226] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 6, 2, 4, 8, 6,10, 9, 2,
	4, 4, 6, 6, 3, 4, 2, 3, 6, 4,
	6, 6, 7, 6, 6, 6, 6, 6, 2, 3,
	7, 7, 7, 6,11, 8, 7, 8, 8, 7,
	6, 9, 8, 2, 6, 7, 6,10, 8, 9,
	7, 9, 7, 7, 8, 8, 8,12, 8, 8,
	7, 3, 3, 3, 6, 8, 3, 7, 7, 6,
	7, 7, 4, 7, 6, 2, 3, 6, 2,10,
	6, 7, 7, 7, 5, 6, 4, 7, 7,10,
	6, 6, 6, 0, 0, 0, 0, 0, 8, 6,
	7, 7, 7, 7, 7, 6, 7, 7, 7, 4,
	4, 3, 8, 8, 7, 0, 0, 7, 7, 7,
	6, 6, 6, 9, 8, 0, 0, 0, 0, 0,
	7, 3, 7, 6, 6, 8, 0, 6, 0, 0,
	0, 0, 0, 2, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 7
};

const char *AGOSEngine::getPixelLength(const char *string, uint16 maxWidth, uint16 &pixels) {
	pixels = 0;

	while (*string != 0) {
		byte chr = *string;
		uint8 len = (_language == Common::PL_POL) ? polish_charWidth[chr] : charWidth[chr];
		if ((pixels + len) > maxWidth)
			break;
		pixels += len;
		string++;
	}

	return string;
}

bool AGOSEngine::printTextOf(uint a, uint x, uint y) {
	const byte *stringPtr;
	uint16 pixels, w;

	if (getGameType() == GType_SIMON2) {
		if (getBitFlag(79)) {
			Subroutine *sub;
			_variableArray[84] = a;
			sub = getSubroutineByID(5003);
			if (sub != nullptr)
				startSubroutineEx(sub);
			return true;
		}
	}

	if (a >= _numTextBoxes)
		return false;


	stringPtr = getStringPtrByID(_shortText[a]);
	if (getGameType() == GType_FF) {
		getPixelLength((const char *)stringPtr, 400, pixels);
		w = pixels + 1;
		x -= w / 2;
		printScreenText(6, 0, (const char *)stringPtr, x, y, w);
	} else {
		showActionString(stringPtr);
	}

	return true;
}

bool AGOSEngine::printNameOf(Item *item, uint x, uint y) {
	SubObject *subObject;
	const byte *stringPtr;
	uint16 pixels, w;

	if (item == nullptr || item == _dummyItem2 || item == _dummyItem3)
		return false;

	subObject = (SubObject *)findChildOfType(item, kObjectType);
	if (subObject == nullptr)
		return false;

	stringPtr = getStringPtrByID(subObject->objectName);
	if (getGameType() == GType_FF) {
		getPixelLength((const char *)stringPtr, 400, pixels);
		w = pixels + 1;
		x -= w / 2;
		printScreenText(6, 0, (const char *)stringPtr, x, y, w);
	} else {
		showActionString(stringPtr);
	}

	return true;
}

void AGOSEngine::printScreenText(uint vgaSpriteId, uint color, const char *string, int16 x, int16 y, int16 width) {
	char convertedString[320];
	char *convertedString2 = convertedString;
	int16 height, talkDelay;
	int stringLength = strlen(string);
	int padding, lettersPerRow, lettersPerRowJustified;
	const int textHeight = 10;

	height = textHeight;
	lettersPerRow = width / 6;
	lettersPerRowJustified = stringLength / (stringLength / lettersPerRow + 1) + 1;

	talkDelay = (stringLength + 3) / 3;
	if (getGameType() == GType_SIMON1 && (getFeatures() & GF_TALKIE)) {
		if (_variableArray[141] == 0)
			_variableArray[141] = 9;
		_variableArray[85] = _variableArray[141] * talkDelay;

		if (_language == Common::HE_ISR)
			_variableArray[85] += talkDelay * 2;
	} else {
		if (_variableArray[86] == 0)
			talkDelay /= 2;
		if (_variableArray[86] == 2)
			talkDelay *= 2;
		_variableArray[85] = talkDelay * 5;
	}

	assert(stringLength > 0);

	while (stringLength > 0) {
		int pos = 0;
		if (stringLength > lettersPerRow) {
			int removeLastWord = 0;
			if (lettersPerRow > lettersPerRowJustified) {
				pos = lettersPerRowJustified;
				while (string[pos] != ' ')
					pos++;
				if (pos > lettersPerRow)
					removeLastWord = 1;
			}
			if (lettersPerRow <= lettersPerRowJustified || removeLastWord) {
				pos = lettersPerRow;
				while (string[pos] != ' ' && pos > 0)
					pos--;
			}
			height += textHeight;
			y -= textHeight;
		} else
			pos = stringLength;
		padding = ((lettersPerRow - pos) % 2) ? (lettersPerRow - pos) / 2 + 1 : (lettersPerRow - pos) / 2;
		while (padding--)
			*convertedString2++ = ' ';
		stringLength -= pos;
		while (pos--)
			*convertedString2++ = *string++;
		*convertedString2++ = '\n';
		string++; // skip space
		stringLength--; // skip space
	}
	*(convertedString2 - 1) = '\0';

	if (getGameType() == GType_SIMON1)
		stopAnimate(vgaSpriteId + 199);
	else
		stopAnimateSimon2(2, vgaSpriteId);

	if (getPlatform() == Common::kPlatformAmiga) {
		color = color * 3 + 1;
		renderStringAmiga(vgaSpriteId, color, width, height, convertedString);
	} else {
		color = color * 3 + 192;
		renderString(vgaSpriteId, color, width, height, convertedString);
	}

	uint16 windowNum = (!getBitFlag(133)) ? 3 : 4;
	if (getGameType() == GType_SIMON1 && (getFeatures() & GF_DEMO))
		windowNum = 4;

	x /= 8;
	if (y < 2)
		y = 2;

	if (getGameType() == GType_SIMON1) {
		uint16 id = 199 + vgaSpriteId;
		animate(windowNum, id / 100, id, x, y, 12);
	} else {
		animate(windowNum, 2, vgaSpriteId, x, y, 12);
	}
}

#ifdef ENABLE_AGOS2
// Swampy Adventures specific
void AGOSEngine_PuzzlePack::printInfoText(const char *itemText) {
	const char *itemName = NULL;
	int flag = (_mouse.y / 32) * 20 + (_mouse.x / 32) + 1300;

	switch (_variableArray[999]) {
		case 80:
			if (_variableArray[flag]) {
				if (_variableArray[flag] == 201)
					itemName = " Bridge: ";
				if (_variableArray[flag] == 231 || _variableArray[flag] == 241)
					itemName = " Log: ";
				if (_variableArray[flag] == 281)
					itemName = " Rubble: ";
				if (_variableArray[flag] == 291)
					itemName = " Boulder: ";
				if (_variableArray[flag] == 311)
					itemName = " Key: ";
				if (_variableArray[flag] == 312)
					itemName = " Spanner: ";
				if (_variableArray[flag] == 321)
					itemName = " Gate: ";
				if (_variableArray[flag] == 331)
					itemName = " Crate: ";
			} else {
				flag -= 300;
				if (_variableArray[flag] == 2)
					itemName = " Water: ";
				if (_variableArray[flag] == 5)
					itemName = " Exit: ";
				if ((_variableArray[flag] == 5) && (_variableArray[81] == 10))
					itemName = " Gem: ";
				if (_variableArray[flag] == 236 || _variableArray[flag] == 246)
					itemName = " Floating Log: ";
				if (_variableArray[flag] == 400)
					itemName = " Valve: ";
			}
			break;

		case 81:
			if (_variableArray[flag]) {
				if (_variableArray[flag] == 281)
					itemName = " Cracked Block: ";
				if (_variableArray[flag] == 291)
					itemName = " Boulder: ";
				if (_variableArray[flag] == 331)
					itemName = " Block: ";
				if (_variableArray[flag] == 341)
					itemName = " Switch: ";
				if (_variableArray[flag] == 343)
					itemName = " Button: ";
				if ((_variableArray[flag] > 430) && (_variableArray[flag] < 480))
					itemName = " Mosaic Block: ";
			} else {
				flag -= 300;
				if (_variableArray[flag] == 5)
					itemName = " Exit: ";
				if ((_variableArray[flag] == 5) && (_variableArray[82] == 10))
					itemName = " Gem: ";
			}
			break;

		case 82:
			if (_variableArray[flag]) {
				if (_variableArray[flag] == 201 || _variableArray[flag] == 211)
					itemName = " Unstable Track: ";
				if (_variableArray[flag] == 281)
					itemName = " Rubble Pile: ";
				if (_variableArray[flag] == 291)
					itemName = " Boulder: ";
				if (_variableArray[flag] == 331)
					itemName = " Crate: ";
				if (_variableArray[flag] == 401 || _variableArray[flag] == 405)
					itemName = " Cart: ";
			} else {
				flag -= 300;
				if (_variableArray[flag] == 4)
					itemName = " Hole: ";
				if (_variableArray[flag] == 5)
					itemName = " Exit: ";
				if ((_variableArray[flag] == 5) && (_variableArray[83] == 10))
					itemName = " Gem: ";
				if ((_variableArray[flag] > 5) && (_variableArray[flag] < 10))
					itemName = " Buffer Track: ";
				if ((_variableArray[flag] > 9) && (_variableArray[flag] < 40))
					itemName = " Track: ";
				if (_variableArray[flag] == 300)
					itemName = " Boulder: ";
			}
			break;

		case 83:
			if (_variableArray[flag]) {
				if (_variableArray[flag] == 201)
					itemName = " Broken Floor: ";
				if (_variableArray[flag] == 231 || _variableArray[flag] == 241)
					itemName = " Barrel: ";
				if (_variableArray[flag] == 281)
					itemName = " Cracked Rock: ";
				if (_variableArray[flag] == 291)
					itemName = " Spacehopper: ";
				if (_variableArray[flag] == 311)
					itemName = " Key: ";
				if (_variableArray[flag] == 321)
					itemName = " Trapdoor: ";
				if (_variableArray[flag] == 324)
					itemName = " Trapdoor: ";
				if (_variableArray[flag] == 331)
					itemName = " Crate: ";
			} else {
				flag -= 300;
				if (_variableArray[flag] == 4)
					itemName = " Hole: ";
				if (_variableArray[flag] == 239 || _variableArray[flag] == 249)
					itemName = " Barrel: ";
			}
			break;

		case 84:
			if (_variableArray[flag]) {
				if (_variableArray[flag] == 201)
					itemName = " Floating Platform: ";
				if (_variableArray[flag] == 231)
					itemName = " Cauldron: ";
				if (_variableArray[flag] == 281)
					itemName = " Cracked Block: ";
				if (_variableArray[flag] == 311 || _variableArray[flag] == 312)
					itemName = " Key: ";
				if (_variableArray[flag] == 321 || _variableArray[flag] == 361 || _variableArray[flag] == 371)
					itemName = " Gate: ";
				if (_variableArray[flag] == 331)
					itemName = " Chest: ";
				if (_variableArray[flag] == 332)
					itemName = " Jewel: ";
				if (_variableArray[flag] == 351 || _variableArray[flag] == 352)
					itemName = " Babies: ";
			} else {
				flag -= 300;
				if (_variableArray[flag] == 6)
					itemName = " Slime: ";
				if (_variableArray[flag] == 334)
					itemName = " Chest: ";
			}
			break;

		default:
			break;
	}

	if (itemName != NULL) {
		Common::String buf = Common::String::format("%s\n%s", itemName, itemText);
		GUI::TimedMessageDialog dialog(buf, 1500);
		dialog.runModal();
	}
}

// The Feeble Files specific
void AGOSEngine_Feeble::printScreenText(uint vgaSpriteId, uint color, const char *string, int16 x, int16 y, int16 width) {
	char convertedString[320];
	char *convertedString2 = convertedString;
	const char *string2 = string;
	int16 height, talkDelay;
	int stringLength = strlen(string);
	const int textHeight = 15;

	height = textHeight;

	talkDelay = (stringLength + 3) / 3;
		if (_variableArray[86] == 0)
			talkDelay /= 2;
		if (_variableArray[86] == 2)
			talkDelay *= 2;
		_variableArray[85] = talkDelay * 5;

	assert(stringLength > 0);

	uint16 b, pixels, spaces;

	while (1) {
		string2 = getPixelLength(string, width, pixels);
		if (*string2 == 0) {
			spaces = (width - pixels) / 12;
			if (spaces != 0)
				spaces--;
			while (spaces) {
					*convertedString2++ = ' ';
					spaces--;
			}
			Common::strcpy_s(convertedString2, sizeof(convertedString) - (convertedString2 - convertedString), string);
			break;
		}
		while (*string2 != ' ') {
			byte chr = *string2;
			pixels -= (_language == Common::PL_POL) ? polish_charWidth[chr] : charWidth[chr];
			string2--;
		}
		spaces = (width - pixels) / 12;
		if (spaces != 0)
			spaces--;
		while (spaces) {
				*convertedString2++ = ' ';
				spaces--;
		}
		b = string2 - string;
		strncpy(convertedString2, string, b);
		convertedString2 += b;
		*convertedString2++ = '\n';
		height += textHeight;
		y -= textHeight;
		if (y < 2)
			y = 2;
		string = string2;
	}

	stopAnimateSimon2(2, vgaSpriteId);

	renderString(1, color, width, height, convertedString);

	animate(4, 2, vgaSpriteId, x, y, 12);
}

void AGOSEngine_Feeble::printInteractText(uint16 num, const char *string) {
	char convertedString[320];
	char *convertedString2 = convertedString;
	const char *string2 = string;
	uint16 height = 15;
	uint16 w = 0xFFFF;
	uint16 b, pixels, x;

	// It doesn't really matter what 'w' is to begin with, as long as it's
	// something that cannot be generated by getPixelLength(). The original
	// used 620, which was a potential problem.

	while (1) {
		string2 = getPixelLength(string, 620, pixels);
		if (*string2 == 0x00) {
			if (w == 0xFFFF)
				w = pixels;
			Common::strlcpy(convertedString2, string, 320);
			break;
		}
		while (*string2 != ' ') {
			byte chr = *string2;
			pixels -= (_language == Common::PL_POL) ? polish_charWidth[chr] : charWidth[chr];
			string2--;
		}
		if (w == 0xFFFF)
			w = pixels;
		b = string2 - string;
		strncpy(convertedString2, string, b);
		convertedString2 += b;
		*convertedString2++ = '\n';
		height += 15;
		string = string2;
	}

	// ScrollX
	x = _variableArray[251];
	x += 20;

	if (num == 1)
		_interactY = 385;

	// Returned values for box definition
	_variableArray[51] = x;
	_variableArray[52] = _interactY;
	_variableArray[53] = w;
	_variableArray[54] = height;

	stopAnimateSimon2(2, num + 6);
	renderString(num, 0, w, height, convertedString);
	animate(4, 2, num + 6, x, _interactY, 12);

	_interactY += height;
}

void AGOSEngine_Feeble::sendInteractText(uint16 num, const char *fmt, ...) {
	va_list arglist;

	va_start(arglist, fmt);
	Common::String string = Common::String::vformat(fmt, arglist);
	va_end(arglist);

	printInteractText(num, string.c_str());
}
#endif

// Waxworks specific
uint16 AGOSEngine_Waxworks::getBoxSize() {
	int x;
	switch (_boxLineCount) {
	case 1: x = _lineCounts[0];
		if (x <= 26)
			return 1;
		if (x <= 64)
			if (checkFit(_linePtrs[0], 32, 2))
				return 2;
		if (x <= 111)
			if (checkFit(_linePtrs[0], 37, 3))
				return 3;
		if (x <= 168)
			if (checkFit(_linePtrs[0], 42, 4))
				return 4;
		if (x <= 240)
			if (checkFit(_linePtrs[0], 48, 5))
				return 5;
		return 6;
	case 2: if (_lineCounts[0] <= 32) {
			if (_lineCounts[1] <= 32)
				return 2;
			if (_lineCounts[1] <= 74)
				if (checkFit(_linePtrs[1], 37, 2))
					return 3;
			if (_lineCounts[1] <= 126)
				if (checkFit(_linePtrs[1], 42, 3))
					return 4;
			if (_lineCounts[1] <= 172)
				if (checkFit(_linePtrs[1], 48, 4))
					return 5;
			return 6;
		}
		if ((_lineCounts[0] <= 74) && (checkFit(_linePtrs[0], 37, 2))) {
			if (_lineCounts[1] <= 37)
				return 3;
			if (_lineCounts[1] <= 84)
				if (checkFit(_linePtrs[1], 42, 2))
					return 4;
			if (_lineCounts[1] <= 144)
				if (checkFit(_linePtrs[1], 48, 3))
					return 5;
			return 6;
		}
		if ((_lineCounts[0] <= 126) && (checkFit(_linePtrs[0], 42, 3))) {
			if (_lineCounts[1] <= 42)
				return 4;
			if (_lineCounts[1] <= 84)
				if (checkFit(_linePtrs[1], 48, 2))
					return 5;
			return 6;
		}
		if ((_lineCounts[0] <= 192) && (checkFit(_linePtrs[0], 48, 4))) {
			if (_lineCounts[1] <= 48)
				return 5;
			return 6;
		}
		return 6;
	case 3: if (_lineCounts[0] <= 37) {
			if (_lineCounts[1] <= 37) {
				if (_lineCounts[2] <= 37)
						return 3;
				if (_lineCounts[2] <= 84)
					if (checkFit(_linePtrs[2], 42, 2))
						return 4;
				if (_lineCounts[2] <= 144)
					if (checkFit(_linePtrs[2], 48, 3))
						return 5;
				return 6;
			}
			if ((_lineCounts[1] <= 84) && (checkFit(_linePtrs[1], 42, 2))) {
				if (_lineCounts[2] <= 42)
					return 4;
				if (_lineCounts[2] <= 96)
					if (checkFit(_linePtrs[2], 48, 2))
						return 5;
				return 6;
			}
			if ((_lineCounts[1] <= 144) && (checkFit(_linePtrs[1], 48, 3))) {
				if (_lineCounts[2] <= 48)
					return 5;
				return 6;
			}
			return 6;
		}
		if ((_lineCounts[0] <= 84) && (checkFit(_linePtrs[0], 42, 2))) {
			if (_lineCounts[1] <= 42) {
				if (_lineCounts[2] <= 42)
					return 4;
				if (_lineCounts[2] <= 96)
					if (checkFit(_linePtrs[2], 48, 2))
						return 5;
				return 6;
			}
			if ((_lineCounts[1] <= 96) && (checkFit(_linePtrs[1], 48, 2))) {
				if (_lineCounts[2] <= 48)
					return 5;
				return 6;
			}
			return 6;
		}
		if ((_lineCounts[0] <= 96) && (checkFit(_linePtrs[0], 48, 3))) {
			if (_lineCounts[1] <= 48) {
				if (_lineCounts[2] <= 48)
					return 5;
			}
			return 6;
		}
		return 6;
	case 4: if (_lineCounts[0] <= 42) {
			if (_lineCounts[1] <= 42) {
				if (_lineCounts[2] <= 42) {
					if (_lineCounts[3] <= 42)
						return 4;
					if (_lineCounts[3] <= 96)
						if (checkFit(_linePtrs[3], 48, 2))
							return 5;
					return 6;
				}
				if ((_lineCounts[2] <= 96) && (checkFit(_linePtrs[2], 48, 2)))
					if (_lineCounts[3] <= 48)
						return 5;
				return 6;
			}
			if ((_lineCounts[1] <= 96) && (checkFit(_linePtrs[1], 48, 2)))
					if ((_lineCounts[2] <= 48) && (_lineCounts[3] <= 48))
						return 5;
			return 6;
		}
		if ((_lineCounts[0] <= 96) && (checkFit(_linePtrs[0], 48, 2)))
			if ((_lineCounts[1] <= 48) && (_lineCounts[2] <= 48) && (_lineCounts[3] <= 48))
				return 5;
		return 6;
	case 5: if ((_lineCounts[0] > 48) || (_lineCounts[1] > 48) || (_lineCounts[2] > 48)
			|| (_lineCounts[3] > 48) || (_lineCounts[4] > 48))
			return 6;
		else
			return 5;
	default:
		return 6;
	}
}


uint16 AGOSEngine_Waxworks::checkFit(char *ptr, int width, int lines) {
	int countw = 0;
	int countl = 0;
	char *x = nullptr;
	while (*ptr) {
		if (*ptr == '\n')
			return 1;
		if (countw == width) {
			countl++;
			countw = 0;
			ptr = x;
		}
		if (*ptr == ' ') {
			x = ptr;
			x++;
		}
		countw++;
		if (countl == lines)
			return 0;
		ptr++;
	}

	return 1;
}

void AGOSEngine_Waxworks::boxTextMessage(const char *x) {
	Common::sprintf_s(_boxBufferPtr, sizeof(_boxBuffer) - (_boxBufferPtr - _boxBuffer), "%s\n", x);
	if (_boxLineCount < ARRAYSIZE(_lineCounts))
		_lineCounts[_boxLineCount] += strlen(x);
	_boxBufferPtr += strlen(x) + 1;
	_boxLineCount++;
	if (_boxLineCount < ARRAYSIZE(_linePtrs))
		_linePtrs[_boxLineCount] = _boxBufferPtr;
	_boxCR = 1;
}

void AGOSEngine_Waxworks::boxTextMsg(const char *x) {
	Common::sprintf_s(_boxBufferPtr, sizeof(_boxBuffer) - (_boxBufferPtr - _boxBuffer), "%s", x);
	if (_boxLineCount < ARRAYSIZE(_lineCounts))
		_lineCounts[_boxLineCount] += strlen(x);
	_boxBufferPtr += strlen(x);
	_boxCR = 0;
}

void AGOSEngine_Waxworks::printBox() {
	uint16 BoxSize;

	*_boxBufferPtr = 0;
	_linePtrs[0] = _boxBuffer;
	if (_boxCR == 0)
		_boxLineCount++;
	stopAnimate(105);
	BoxSize = getBoxSize();
	_variableArray[53] = BoxSize;
	animate(3, 1, 100, 0, 0, 0);
	changeWindow(5);

	switch (BoxSize) {
	case 1: _textWindow->x = 10;
		_textWindow->y = 163;
		_textWindow->width = 20;
		_textWindow->height = 1;
		_textWindow->textMaxLength = 26;
		break;
	case 2: _textWindow->x = 8;
		_textWindow->y = 160;
		_textWindow->width = 24;
		_textWindow->height = 2;
		_textWindow->textMaxLength = 32;
		break;
	case 3: _textWindow->x = 6;
		_textWindow->y = 156;
		_textWindow->width = 28;
		_textWindow->height = 3;
		_textWindow->textMaxLength = 37;
		break;
	case 4: _textWindow->x = 4;
		_textWindow->y = 153;
		_textWindow->width = 32;
		_textWindow->height = 4;
		_textWindow->textMaxLength = 42;
		break;
	case 5: _textWindow->x = 2;
		_textWindow->y = 150;
		_textWindow->width = 36;
		_textWindow->height = 5;
		_textWindow->textMaxLength = 48;
		break;
	default:_textWindow->x = 1;
		_textWindow->y = 147;
		_textWindow->width = 38;
		_textWindow->height = 6;
		_textWindow->textMaxLength = 50;
		break;
	}
	_textWindow->textColumn = 0;
	_textWindow->textRow = 0;
	_textWindow->textColumnOffset = 0;
	_textWindow->textLength = 0;
	justifyStart();
	waitForSync(99);
	_boxBufferPtr = _boxBuffer;
	while (*_boxBufferPtr)
		justifyOutPut(*_boxBufferPtr++);
	_boxLineCount = 0;
	_boxBufferPtr = _boxBuffer;
	_lineCounts[0] = 0;
	_lineCounts[1] = 0;
	_lineCounts[2] = 0;
	_lineCounts[3] = 0;
	_lineCounts[4] = 0;
	_lineCounts[5] = 0;
	changeWindow(0);
}

} // End of namespace AGOS

================
File: string_pn.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "agos/agos.h"
#include "agos/intern.h"

#include "common/textconsole.h"

namespace AGOS {

uint32 AGOSEngine_PN::ftext(uint32 base, int n) {
	uint32 b = base;
	int ct = n;
	while (ct) {
		while (_textBase[b++])
			;
		ct--;
	}
	return b;
}

char *AGOSEngine_PN::unctok(char *c, int n) {
	int x;
	uint8 *tokbase;
	tokbase = _textBase + getlong(30);
	x = n;
	while (x-=(*tokbase++ > 127))
		;
	while (*tokbase < 128)
		*c++=*tokbase++;
	*c++ = *tokbase & 127;
	*c = 0;
	return c;
}

void AGOSEngine_PN::uncomstr(char *c, uint32 x) {
	if (x > _textBaseSize)
		error("UNCOMSTR: TBASE over-run");
	while (_textBase[x]) {
		if (_textBase[x] < 244) {
			c = unctok(c, _textBase[x]);
		} else {
			c = unctok(c, (_textBase[x] - 244) * 254 + _textBase[x + 1] - 1);
			x++;
		}
		x++;
	}
	*c++ = 13;
	*c = 0;
}

#define OBJECT_NAME_SIZE 15

static const char *const objectNames[30] = {
	"\0",
	"Take \0",
	"Inventory\r",
	"Open \0",
	"Close \0",
	"Lock \0",
	"Unlock \0",
	"Examine \0",
	"Look in \0",
	"Exits \r",
	"Look\r",
	"Wait\r",
	"Pause\r",
	"\0",
	"Save\r",
	"Restore\r",
	"\0",
	"N\r",
	"NE\r",
	"E\r",
	"SE\r",
	"S\r",
	"SW\r",
	"W\r",
	"NW\r",
	"INVENTORY\r",
	"ROOM DESCRIPTION\r",
	"x\r",
	"MORE\r",
	"CLOSE\r"
};

void AGOSEngine_PN::getObjectName(char *v, uint16 x) {
	if (x & 0x8000) {
		x &= ~0x8000;
		if (x > getptr(51))
			error("getObjectName: Object %d out of range", x);
		uncomstr(v, ftext(getlong(27), x * _dataBase[47]));
	} else {
		assert(x < 30);
		Common::strcpy_s(v, OBJECT_NAME_SIZE, objectNames[x]);
	}
}

void AGOSEngine_PN::pcl(const char *s) {
	Common::strlcat(_sb, s, 80);
	if (strchr(s, '\n') == nullptr) {
		for (char *str = _sb; *str; str++)
			windowPutChar(_windowArray[_curWindow], *str);
		_sb[0] = '\0'; // Reset to empty string
	}
}

void AGOSEngine_PN::pcf(uint8 ch) {
	int ct = 0;
	if (ch == '[')
		ch = '\n';
	if (ch == 0)
		return;	/* Trap any C EOS chrs */
	if (ch == 255) {
		_bp = 0;
		_xofs = 0;
		return;		/* pcf(255) initializes the routine */
	}			/* pcf(254) flushes its working _buffer */
	if (ch != 254) {
		if ((ch != 32) || (_bp + _xofs != 50))
			_buffer[_bp++] = ch;
	}
	if ((ch != 254) && (!Common::isSpace(ch)) && (_bp < 60))
		return;
	/* We know have a case of needing to print the text */
	if (_bp + _xofs > 50) {
		pcl("\n");
		if (_buffer[0] == ' ')
			ct = 1;	/* Skip initial space */
		/* Note '  ' will give a single start of line space */
		_xofs = 0;
	}
	_buffer[_bp] = 0;
	pcl(_buffer + ct);
	_xofs += _bp;
	_bp = 0;
	if (ch == '\n')
		_xofs = 0;	/* At Newline! */
}

void AGOSEngine_PN::patok(int n) {
	int x;
	uint8 *tokbase;
	tokbase = _textBase + getlong(30);
	x = n;
	while (x -= (*tokbase++ > 127))
		;
	while (*tokbase < 128)
		pcf(*tokbase++);
	pcf((uint8)(*tokbase & 127));
}

void AGOSEngine_PN::pmesd(int n) {
	ptext(ftext(getlong(24), n));
}

void AGOSEngine_PN::plocd(int n, int m) {
	if (n > getptr(53))
		error("Location out of range");
	ptext(ftext(getlong(21), n * _dataBase[48] + m));
}

void AGOSEngine_PN::pobjd(int n, int m) {
	if (n > getptr(51))
		error("Object out of range");
	ptext(ftext(getlong(27), n * _dataBase[47] + m));
}

void AGOSEngine_PN::ptext(uint32 tptr) {
	if (tptr > _textBaseSize)
		error("ptext: attempt to print beyond end of TBASE");

	while (_textBase[tptr]) {
		if (_textBase[tptr] < 244) {
			patok(_textBase[tptr++]);
		} else {
			patok((_textBase[tptr] - 244) * 254 + _textBase[tptr + 1] - 1);
			tptr += 2;
		}
	}
}

const uint8 characters[11][80] = {
// PETERMASON
	{
		118, 225,
		 91, 118,
		 94, 124,
		236, 161,
		241, 166,
		168,   4,
		138,  46,
		139,  46,
		249,  50,
		 38,  56,
		 80,  59,
		149,  69,
		 37,  77,
		 93,  93,
		 86,  95,
		  0,
		  0,
		 58, 130,
		 62, 178,
		 83,  95,
		  0,
		121,  58,
		122,  59,
		126,  60,
		124,  61,
		240,  62,
		123,  63,
		0
	},
// JBLANDFORD
	{
		0,
		0,
		0,
		0
	},
// SBLANDFORD
	{
		120, 223,
		 94, 126,
		112, 134,
		 45, 152,
		241, 166,
		168,   3,
		150,  26,
		220,  29,
		138,  42,
		139,  47,
		249,  50,
		 38,  56,
		230,  64,
		 37,  77,
		 93,  94,
		 86,  96,
		  0,
		  0,
		 58, 129,
		 59, 112,
		 83,  96,
		 81, 106,
		 62, 169,
		  0,
		121,  54,
		122,  55,
		119,  56,
		118,  57,
		  0
	},
// MRJONES
	{
		121, 218,
		 91, 118,
		253, 121,
		154, 138,
		235, 173,
		236, 161,
		241, 165,
		168,   0,
		150,  21,
		 36,  33,
		138,  42,
		249,  50,
		 80,  60,
		  4,  60,
		 37,  78,
		 68,  33,
		 93,  92,
		101, 109,
		  0,
		 36,  35,
		 68,  90,
		  0,
		 58, 128,
		 59, 111,
		 62, 182,
		  0,
		122,  13,
		126,  14,
		124,  15,
		240,  16,
		120,  17,
		119,  18,
		118,  19,
		 52,  20,
		125,  21,
		127,  22,
		123,  23,
		117,  24,
		  0
	},
// MRSJONES
	{
		122, 219,
		 91, 119,
		253, 123,
		112, 136,
		154, 137,
		 95, 142,
		 45, 152,
		109, 155,
		235, 160,
		168,   1,
		151,  13,
		145,  15,
		150,  22,
		220,  28,
		 36,  33,
		138,  43,
		 13,  51,
		 80,  59,
		230,  64,
		149,  69,
		 86, 100,
		  0,
		 36,  36,
		  0,
		 58, 127,
		 62, 179,
		 83, 100,
		 81, 102,
		  0,
		121,  25,
		126,  26,
		124,  27,
		120,  28,
		119,  29,
		118,  30,
		 52,  31,
		125,  32,
		127,  33,
		123,  34,
		117,  35,
		0
	},
// MRROBERTS
	{
		123, 229,
		 91, 117,
		253, 120,
		 94, 125,
		112, 134,
		109, 156,
		235, 172,
		236, 162,
		241, 165,
		168,   3,
		 36,  33,
		249,  50,
		 38,  56,
		 80,  58,
		 37,  75,
		 34,  81,
		 68,  33,
		101, 109,
		  0,
		 36,  40,
		 68,  88,
		  0,
		 59, 111,
		 62, 181,
		  0,
		  0
	},
// POSTMISTRESS
	{
		124, 221,
		 91, 119,
		253, 122,
		112, 136,
		 95, 142,
		130, 149,
		109, 155,
		235, 176,
		220,  29,
		 36,  33,
		138,  43,
		 13,  51,
		 80,  57,
		149,  68,
		 37,  73,
		 34,  33,
		 68,  33,
		 86, 100,
		  0,
		 36,  39,
		 34,  80,
		 68,  86,
		  0,
		 58, 130,
		 62, 181,
		 83, 100,
		 81, 103,
		  0,
		121,  41,
		122,  42,
		126,  43,
		240,  44,
		120,  45,
		119,  46,
		118,  47,
		 52,  48,
		123,  49,
		 83,  50,
		117,  51,
		  0
	},
// MWILLIAMS
	{
		125, 227,
		 94, 124,
		 95, 141,
		241, 166,
		168,   4,
		150,  26,
		 38,  54,
		  4,  60,
		230,  65,
		149,  68,
		 37,  76,
		101, 109,
		  0,
		230,  63,
		  0,
		 59, 112,
		 62, 183,
		  0,
		240,  71,
		120,  72,
		118,  73,
		 52,  74,
		117,  75,
		  0
	},
// TONY
	{
		126, 220,
		 95, 143,
		130, 149,
		 45, 153,
		109, 154,
		235, 158,
		241, 166,
		168,   2,
		145,  15,
		150,  24,
		220,  20,
		 36,  20,
		  4,  60,
		 37,  79,
		 86,  97,
		  0,
		150,  23,
		220,  27,
		 36,  34,
		  0,
		 83,  97,
		  0,
		121,  36,
		122,  37,
		124,  38,
		240,  39,
		 52,  40,
		  0
	},
// PIG
	{
		127, 228,
		112, 133,
		 45, 153,
		235, 157,
		236, 163,
		241, 165,
		 36,  33,
		 80,  58,
		 34,  81,
		 68,  33,
		 86,  98,
		  0,
		 36,  37,
		 68,  90,
		  0,
		 62, 184,
		 83,  98,
		  0,
		121,  76,
		122,  77,
		126,  78,
		124,  79,
		240,  80,
		120,  81,
		118,  82,
		 52,  83,
		125,  84,
		123,  85,
		 83,  86,
		117,  87,
		  0
	},
// JUDY
	{
			  0,
			  0,
			  0,
			240, 52,
			117, 53,
			  0
	}
};

void AGOSEngine_PN::getResponse(uint16 charNum, uint16 objNum, uint16 &msgNum1, uint16 &msgNum2) {
	const uint8 *ptr;
	uint16 num;

	msgNum1 = 0;
	msgNum2 = 0;

	if (charNum == 83)
		charNum += 45;

	if (charNum < 118 || charNum > 128) {
		return;
	}

	ptr = characters[charNum - 118];

	while ((num = *ptr++) != 0) {
		if (num == objNum) {
			msgNum1 = *ptr++;
			msgNum1 += 400;

			while ((num = *ptr++) != 0)
				ptr++;
			break;
		}
		ptr++;
	}

	while ((num = *ptr++) != 0) {
		if (num == objNum) {
			msgNum2 = *ptr++;
			msgNum2 += 400;

			if (msgNum1 == 569)
				msgNum1 += 400;
			if (msgNum2 == 0)
				msgNum2 = msgNum1;
			return;
		}
		ptr++;
	}

	if (objNum >= 200)
		msgNum1 = 0;

	objNum -= 200;
	while ((num = *ptr++) != 0) {
		if (num == objNum) {
			msgNum1 = *ptr++;
			msgNum1 += 400;

			if (msgNum1 == 569)
				msgNum1 += 400;
			if (msgNum2 == 0)
				msgNum2 = msgNum1;
			return;
		}
		ptr++;
	}

	objNum += 200;
	while ((num = *ptr++) != 0) {
		if (num == objNum) {
			msgNum1 = *ptr++;
			msgNum1 += 200;

			if (msgNum1 == 569)
				msgNum1 += 400;
			if (msgNum2 == 0)
				msgNum2 = msgNum1;
			return;
		}
		ptr++;
	}

	if (msgNum1 == 569)
		msgNum1 += 400;
	if (msgNum2 == 0)
		msgNum2 = msgNum1;
}

char *AGOSEngine_PN::getMessage(char *msg, uint16 num) {
	char *origPtr, *strPtr1 = msg;
	uint8 count;

	getObjectName(strPtr1, num);
	if (!(num & 0x8000)) {
		return msg;
	}

	if (strPtr1[0] == 0x41 || strPtr1[0] == 0x61) {
		if (strPtr1[1] != 0x20)
			strPtr1 += 2;
	} else if (strPtr1[0] == 0x54 || strPtr1[0] == 0x74) {
		if (strPtr1[1] == 0x68 &&
		    strPtr1[2] == 0x65 &&
		    strPtr1[3] == 0x20)
			strPtr1 += 4;
	}

	origPtr = strPtr1;
	while (*strPtr1 != 13)
		strPtr1++;

	strPtr1[0] = 32;
	strPtr1[1] = 13;
	strPtr1[2] = 0;

	if (_videoLockOut & 0x10) {
		strPtr1 = origPtr;
		count = 6;
		while (*strPtr1) {
			if (*strPtr1 == 32) {
				count = 6;
			} else {
				count--;
				if (count == 0) {
					char *tmpPtr = strPtr1;
					char *strPtr2 = strPtr1;

					while (*strPtr2 != 0 && *strPtr2 != 32)
						strPtr2++;

					while (*strPtr2) {
						*strPtr1++ = *strPtr2++;
					}
					*strPtr1++ = *strPtr2++;

					strPtr1 = tmpPtr;
					count = 6;
				}
			}
			strPtr1++;
		}
	}

	return origPtr;
}

} // End of namespace AGOS

================
File: subroutine.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "common/debug-channels.h"
#include "common/file.h"
#include "common/textconsole.h"
#include "common/memstream.h"

#include "agos/agos.h"
#include "agos/intern.h"
#include "agos/sound.h"

namespace AGOS {

// Script opcodes to load into memory
static const char *const opcodeArgTable_elvira1[300] = {
	"I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ",	 "II ",	"II ", "II ", "II ", "F ", "F ", "FN ",
	"FN ", "FN ", "FN ", "FF ", "FF ", "FF ", "FF ", "II ", "II ", "a ", "a ", "n ", "n ", "p ",
	"N ", "I ", "I ", "I ",	 "I ",	"IN ",	"IB ", "IB ", "II ", "IB ", "N ", " ", " ", " ", "I ",
	"I ","I ","I ", "I ","I ","I ",	"II ","II ","II ","II ","IBF ", "FIB ", "FF ", "N ", "NI ",
	"IF ", "F ", "F ", "IB ", "IB ", "FN ",	"FN ", "FN ", "FF ", "FF ", "FN ", "FN ", "FF ", "FF ",
	"FN ", "FF ", "FN ", "F ", "I ", "IN ", "IN ", "IB ", "IB ", "IB ", "IB ", "II ", "I ", "I ",
	"IN ", "T ", "F ", " ", "T ", "T ", "I ", "I ", " ", " ", "T ", " ", " ", " ", " ", " ", "T ",
	" ", "N ", "INN ", "II ", "II ", "ITN ", "ITIN ", "ITIN ", "I3 ", "IN ", "I ",	 "I ", "Ivnn ",
	"vnn ", "Ivnn ", "NN ",	"IT ", "INN ", " ", "N ", "N ", "N ", "T ", "v ", " ", " ", " ", " ",
	"FN ", "I ", "TN ", "IT ", "II ", "I ", " ", "N ", "I ", " ", "I ", "NI ", "I ", "I ", "T ",
	"I ", "I ", "N ", "N ", " ", "N ", "IF ", "IF ", "IF ", "IF ", "IF ", "IF ", "T ", "IB ",
	"IB ", "IB ", "I ", " ", "vnnN ", "Ivnn ", "T ", "T ", "T ", "IF ", " ", " ", " ", "Ivnn ",
	"IF ", "INI ", "INN ", "IN ", "II ", "IFF ", "IIF ", "I ", "II ", "I ", "I ", "IN ", "IN ",
	"II ", "II ", "II ", "II ", "IIN ", "IIN ", "IN ", "II ", "IN ", "IN ", "T ", "vanpan ",
	"vIpI ", "T ", "T ", " ", " ",	"IN ", "IN ", "IN ", "IN ", "N ", "INTTT ", "ITTT ",
	"ITTT ", "I ", "I ", "IN ", "I ", " ", "F ", "NN ", "INN ", "INN ", "INNN ", "TF ", "NN ",
	"N ", "NNNNN ", "N ", " ", "NNNNNNN ", "N ", " ", "N ",	"NN ", "N ", "NNNNNIN ", "N ", "N ",
	"N ", "NNN ", "NNNN ", "INNN ", "IN ", "IN ", "TT ", "I ", "I ", "I ", "TTT ", "IN ", "IN ",
	"FN ", "FN ", "FN ", "N ", "N ", "N ", "NI ", " ", " ",	 "N ", "I ", "INN ", "NN ", "N ",
	"N ", "Nan ", "NN ", " ", " ", " ", " ", " ", " ", " ", "IF ", "N ", " ", " ",	 " ", "II ",
	" ", "NI ","N ",
};

static const char *const opcodeArgTable_elvira2[256] = {
	" ", "I ", "I ", "I ", "I ", "I ", "I ", "II ", "II ", "II ", "II ", "B ", "B ", "BN ", "BN ",
	"BN ", "BN ", "BB ", "BB ", "BB ", "BB ", "II ", "II ", "N ", "I ", "I ", "I ", "IN ", "IB ",
	"II ", "I ", "I ", "II ", "II ", "IBB ", "BIB ", "BB ", "B ", "BI ", "IB ", "B ", "B ", "BN ",
	"BN ", "BN ", "BB ", "BB ", "BN ", "BN ", "BB ", "BB ", "BN ", "BB ", "BN ", "B ", "I ", "IB ",
	"IB ", "II ", "I ", "I ", "IN ", "B ", "T ", "T ", "I  ", "I ", " ", "T ", " ", " ",
	"N ", "IBN ", "I ", "I ", "I ", "NN ", " ", " ", "IT ", "II ", "I ", "B ", " ", "IB ", "IBB ",
	"IIB ", "T ", "T ", "T ", "IB ", "IB ", "IB ", "B ", "BB ", "IBB ", "NB ", "N ", "NBNNN ", "N ",
	" ", "BNNNNNN ", "B ", " ", "B ", "B ", "N ", "NNNNNIN ", "N ", "N ", "N ", "NNN ", "NBNN ",
	"IBNN ", "IB ", "IB ", "IB ", "IB ", "N ", "N ", "N ", "BI ", " ", " ", "N ", "I ", "IBB ",
	"NN ", "N ", "N ", "Ban ", "BB ", " ", " ", " ", " ", "IB ", "B ", " ", "II ", " ", "BI ", "N ",
	"I ", "IB ", "IB ", "IB ", "IB ", "IB ", "IB ", "IB ", "BI ", "BB ", "B ", "B ", "B ",	"B ",
	"IBB ", "IBN ", "IB ", "B ", " ", "TB ", "TB ", "I ", "N ", "B ", "INB ", "INB ", "INB ", "INB ",
	"INB ", "INB ", "INB ", "N ", " ", "INBB ", "B ", "B ", "Ian ", "B ", "B ", "B ", "B ", "T ",
	"T ", "B ", " ", "I ", " ", " "
};

static const char *const opcodeArgTable_waxworks[256] = {
	" ", "I ", "I ", "I ", "I ", "I ", "I ", "II ", "II ", "II ", "II ", "B ", "B ", "BN ", "BN ",
	"BN ", "BN ", "BB ", "BB ", "BB ", "BB ", "II ", "II ", "N ", "I ", "I ", "I ", "IN ", "IB ",
	"II ", "I ", "I ", "II ", "II ", "IBB ", "BIB ", "BB ", "B ", "BI ", "IB ", "B ", "B ", "BN ",
	"BN ", "BN ", "BB ", "BB ", "BN ", "BN ", "BB ", "BB ", "BN ", "BB ", "BN ", "B ", "I ", "IB ",
	"IB ", "II ", "I ", "I ", "IN ", "B ", "T ", "T ", "NNNNNB ", "BT ", "BT ", "T ", " ", "B ",
	"N ", "IBN ", "I ", "I ", "I ", "NN ", " ", " ", "IT ", "II ", "I ", "B ", " ", "IB ", "IBB ",
	"IIB ", "T ", "T ", "T ", "IB ", "IB ", "IB ", "B ", "BB ", "IBB ", "NB ", "N ", "NBNNN ", "N ",
	" ", "BNNNNNN ", "B ", " ", "B ", "B ", "BB ", "NNNNNIN ", "N ", "N ", "N ", "NNN ", "NBNN ",
	"IBNN ", "IB ", "IB ", "IB ", "IB ", "N ", "N ", "N ", "BI ", " ", " ", "N ", "I ", "IBB ",
	"NN ", "N ", "N ", "Ban ", "BB ", " ", " ", " ", " ", "IB ", "B ", " ", "II ", " ", "BI ", "N ",
	"I ", "IB ", "IB ", "IB ", "IB ", "IB ", "IB ", "IB ", "BI ", "BB ", "B ", "B ", "B ",	"B ",
	"IBB ", "IBN ", "IB ", "B ", " ", "TB ", "TB ", "I ", "N ", "B ", "INB ", "INB ", "INB ", "INB ",
	"INB ", "INB ", "INB ", "N ", " ", "INBB ", "B ", "B ", "Ian ", "B ", "B ", "B ", "B ", "T ",
	"T ", "B ", " ", "I ", " ", " "
};

static const char *const opcodeArgTable_simon1talkie[256] = {
	" ", "I ", "I ", "I ", "I ", "I ", "I ", "II ", "II ", "II ", "II ", "B ", "B ", "BN ", "BN ",
	"BN ", "BN ", "BB ", "BB ", "BB ", "BB ", "II ", "II ", "N ", "I ", "I ", "I ", "IN ", "IB ",
	"II ", "I ", "I ", "II ", "II ", "IBB ", "BIB ", "BB ", "B ", "BI ", "IB ", "B ", "B ", "BN ",
	"BN ", "BN ", "BB ", "BB ", "BN ", "BN ", "BB ", "BB ", "BN ", "BB ", "BN ", "B ", "I ", "IB ",
	"IB ", "II ", "I ", "I ", "IN ", "B ", "T ", "T ", "NNNNNB ", "BT ", "BTS ", "T ", " ", "B ",
	"N ", "IBN ", "I ", "I ", "I ", "NN ", " ", " ", "IT ", "II ", "I ", "B ", " ", "IB ", "IBB ",
	"IIB ", "T ", " ", " ", "IB ", "IB ", "IB ", "B ", "BB ", "IBB ", "NB ", "N ", "NBNNN ", "N ",
	" ", "BNNNNNN ", "B ", " ", "B ", "B ", "BB ", "NNNNNIN ", "N ", "N ", "N ", "NNN ", "NBNN ",
	"IBNN ", "IB ", "IB ", "IB ", "IB ", "N ", "N ", "N ", "BI ", " ", " ", "N ", "I ", "IBB ",
	"NN ", "N ", "N ", "Ban ", "BB ", " ", " ", " ", " ", "IB ", "B ", " ", "II ", " ", "BI ", "N ",
	"I ", "IB ", "IB ", "IB ", "IB ", "IB ", "IB ", "IB ", "BI ", "BB ", "B ", "B ", "B ", "B ",
	"IBB ", "IBN ", "IB ", "B ", "BNBN ", "BBTS ", "N ", " ", "Ian ", "B ", "B ", "B ", "B ", "T ",
	"T ", "B ", " ", "I ", " ", " ", "BBI ", "NNBB ", "BBB ", " ", " ", " ", " ", "N ", "N ", " ",
	" ",
};

static const char *const opcodeArgTable_simon1dos[256] = {
	" ", "I ", "I ", "I ", "I ", "I ", "I ", "II ", "II ", "II ", "II ", "B ", "B ", "BN ", "BN ",
	"BN ", "BN ", "BB ", "BB ", "BB ", "BB ", "II ", "II ", "N ", "I ", "I ", "I ", "IN ", "IB ",
	"II ", "I ", "I ", "II ", "II ", "IBB ", "BIB ", "BB ", "B ", "BI ", "IB ", "B ", "B ", "BN ",
	"BN ", "BN ", "BB ", "BB ", "BN ", "BN ", "BB ", "BB ", "BN ", "BB ", "BN ", "B ", "I ", "IB ",
	"IB ", "II ", "I ", "I ", "IN ", "B ", "T ", "T ", "NNNNNB ", "BT ", "BT ", "T ", " ", "B ",
	"N ", "IBN ", "I ", "I ", "I ", "NN ", " ", " ", "IT ", "II ", "I ", "B ", " ", "IB ", "IBB ",
	"IIB ", "T ", " ", " ", "IB ", "IB ", "IB ", "B ", "BB ", "IBB ", "NB ", "N ", "NBNNN ", "N ",
	" ", "BNNNNNN ", "B ", " ", "B ", "B ", "BB ", "NNNNNIN ", "N ", "N ", "N ", "NNN ", "NBNN ",
	"IBNN ", "IB ", "IB ", "IB ", "IB ", "N ", "N ", "N ", "BI ", " ", " ", "N ", "I ", "IBB ",
	"NN ", "N ", "N ", "Ban ", "BB ", " ", " ", " ", " ", "IB ", "B ", " ", "II ", " ", "BI ", "N ",
	"I ", "IB ", "IB ", "IB ", "IB ", "IB ", "IB ", "IB ", "BI ", "BB ", "B ", "B ", "B ", "B ",
	"IBB ", "IBN ", "IB ", "B ", "BNBN ", "BBT ", "N ", " ", "Ian ", "B ", "B ", "B ", "B ", "T ",
	"T ", "B ", " ", "I ", " ", " ", "BBI ", "NNBB ", "BBB ", " ", " ", " ", " ", "N ", "N ", " ",
	" ",
};

static const char *const opcodeArgTable_simon2talkie[256] = {
	" ", "I ", "I ", "I ", "I ", "I ", "I ", "II ", "II ", "II ", "II ", "B ", "B ", "BN ", "BN ",
	"BN ", "BN ", "BB ", "BB ", "BB ", "BB ", "II ", "II ", "N ", "I ", "I ", "I ", "IN ", "IB ",
	"II ", "I ", "I ", "II ", "II ", "IBB ", "BIB ", "BB ", "B ", "BI ", "IB ", "B ", "B ", "BN ",
	"BN ", "BN ", "BB ", "BB ", "BN ", "BN ", "BB ", "BB ", "BN ", "BB ", "BN ", "B ", "I ", "IB ",
	"IB ", "II ", "I ", "I ", "IN ", "B ", "T ", "T ", "NNNNNB ", "BT ", "BTS ", "T ", " ", "B ",
	"N ", "IBN ", "I ", "I ", "I ", "NN ", " ", " ", "IT ", "II ", "I ", "B ", " ", "IB ", "IBB ",
	"IIB ", "T ", " ", " ", "IB ", "IB ", "IB ", "B ", "BB ", "IBB ", "NB ", "N ", "NNBNNN ", "NN ",
	" ", "BNNNNNN ", "B ", " ", "B ", "B ", "BB ", "NNNNNIN ", "N ", "N ", "N ", "NNN ", "NBNN ",
	"IBNN ", "IB ", "IB ", "IB ", "IB ", "N ", "N ", "N ", "BI ", " ", " ", "N ", "I ", "IBB ",
	"NNB ", "N ", "N ", "Ban ", "BB ", " ", " ", " ", " ", "IB ", "B ", " ", "II ", " ", "BI ",
	"N ", "I ", "IB ", "IB ", "IB ", "IB ", "IB ", "IB ", "IB ", "BI ", "BB ", "B ", "B ", "B ",
	"B ", "IBB ", "IBN ", "IB ", "B ", "BNBN ", "BBTS ", "N ", " ", "Ian ", "B ", "B ", "B ", "B ",
	"T ", "T ", "B ", " ", "I ", " ", " ", "BBI ", "NNBB ", "BBB ", " ", " ", " ", " ", "N ", "N ",
	" ", " ", "BT ", " ", "B "
};

static const char *const opcodeArgTable_simon2dos[256] = {
	" ", "I ", "I ", "I ", "I ", "I ", "I ", "II ", "II ", "II ", "II ", "B ", "B ", "BN ", "BN ",
	"BN ", "BN ", "BB ", "BB ", "BB ", "BB ", "II ", "II ", "N ", "I ", "I ", "I ", "IN ", "IB ",
	"II ", "I ", "I ", "II ", "II ", "IBB ", "BIB ", "BB ", "B ", "BI ", "IB ", "B ", "B ", "BN ",
	"BN ", "BN ", "BB ", "BB ", "BN ", "BN ", "BB ", "BB ", "BN ", "BB ", "BN ", "B ", "I ", "IB ",
	"IB ", "II ", "I ", "I ", "IN ", "B ", "T ", "T ", "NNNNNB ", "BT ", "BT ", "T ", " ", "B ",
	"N ", "IBN ", "I ", "I ", "I ", "NN ", " ", " ", "IT ", "II ", "I ", "B ", " ", "IB ", "IBB ",
	"IIB ", "T ", " ", " ", "IB ", "IB ", "IB ", "B ", "BB ", "IBB ", "NB ", "N ", "NNBNNN ", "NN ",
	" ", "BNNNNNN ", "B ", " ", "B ", "B ", "BB ", "NNNNNIN ", "N ", "N ", "N ", "NNN ", "NBNN ",
	"IBNN ", "IB ", "IB ", "IB ", "IB ", "N ", "N ", "N ", "BI ", " ", " ", "N ", "I ", "IBB ",
	"NNB ", "N ", "N ", "Ban ", "BB ", " ", " ", " ", " ", "IB ", "B ", " ", "II ", " ", "BI ",
	"N ", "I ", "IB ", "IB ", "IB ", "IB ", "IB ", "IB ", "IB ", "BI ", "BB ", "B ", "B ", "B ",
	"B ", "IBB ", "IBN ", "IB ", "B ", "BNBN ", "BBT ", "N ", " ", "Ian ", "B ", "B ", "B ", "B ",
	"T ", "T ", "B ", " ", "I ", " ", " ", "BBI ", "NNBB ", "BBB ", " ", " ", " ", " ", "N ", "N ",
	" ", " ", "BT ", " ", "B "
};

static const char *const opcodeArgTable_feeblefiles[256] = {
	" ", "I ", "I ", "I ", "I ", "I ", "I ", "II ", "II ", "II ", "II ", "B ", "B ", "BN ", "BN ",
	"BN ", "BN ", "BB ", "BB ", "BB ", "BB ", "II ", "II ", "N ", "I ", "I ", "I ", "IN ", "IB ",
	"II ", "I ", "I ", "II ", "II ", "IBB ", "BIB ", "BB ", "B ", "BI ", "IB ", "B ", "B ", "BN ",
	"BN ", "BN ", "BB ", "BB ", "BN ", "BN ", "BB ", "BB ", "BN ", "BB ", "BN ", "B ", "I ", "IB ",
	"IB ", "II ", "I ", "I ", "IN ", "B ", "T ", "T ", "NNNNNB ", "BT ", "BTS ", "T ", " ", "B ",
	"N ", "IBN ", "I ", "I ", "I ", "NN ", " ", " ", "IT ", "II ", "I ", "B ", " ", "IB ", "IBB ",
	"IIB ", "T ", " ", " ", "IB ", "IB ", "IB ", "B ", "BB ", "IBB ", "NB ", "N ", "NNBNNN ", "NN ",
	" ", "BNNNNNN ", "B ", " ", "B ", "B ", "BB ", "NNNNNIN ", "N ", "N ", "N ", "NNN ", "NBNN ",
	"IBNN ", "IB ", "IB ", "IB ", "IB ", "N ", "N ", "N ", "BI ", " ", " ", "N ", "I ", "IBB ",
	"NNB ", "N ", "N ", "Ban ", " ", " ", " ", " ", " ", "IB ", "B ", " ", "II ", " ", "BI ",
	"N ", "I ", "IB ", "IB ", "IB ", "IB ", "IB ", "IB ", "IB ", "BI ", "BB ", "B ", "B ", "B ",
	"B ", "IBB ", "IBN ", "IB ", "B ", "BNNN ", "BBTS ", "N ", " ", "Ian ", "B ", "B ", "B ", "B ",
	"T ", "N ", " ", " ", "I ", " ", " ", "BBI ", "NNBB ", "BBB ", " ", " ", "T ", " ", "N ", "N ",
	" ", " ", "BT ", " ", "B ", " ", "BBBB ", " ", " ", "BBBB ", "B ", "B ", "B ", "B "
};

static const char *const opcodeArgTable_puzzlepack[256] = {
	" ", "I ", "I ", "I ", "I ", "I ", "I ", "II ", "II ", "II ", "II ", "N ", "N ", "NN ", "NN ",
	"NN ", "NN ", "NN ", "NN ", "NN ", "NN ", "II ", "II ", "N ", "I ", "I ", "I ", "IN ", "IB ",
	"II ", "I ", "I ", "II ", "II ", "IBN ", "NIB ", "NN ", "B ", "BI ", "IN ", "N ", "N ", "NN ",
	"NN ", "NN ", "NN ", "NN ", "NN ", "NN ", "NN ", "NN ", "NN ", "NN ", "NN ", "B ", "I ", "IB ",
	"IB ", "II ", "I ", "I ", "IN ", "N ", "T ", "T ", "NNNNNB ", "BTNN ", "BTS ", "T ", " ", "B ",
	"N ", "IBN ", "I ", "I ", "I ", "NN ", " ", " ", "IT ", "II ", "I ", "B ", " ", "IB ", "IBB ",
	"IIB ", "T ", " ", " ", "IB ", "IB ", "IB ", "B ", "BB ", "IBB ", "NB ", "N ", "NNBNNN ", "NN ",
	" ", "BNNNNNN ", "B ", " ", "B ", "B ", "BB ", "NNNNNIN ", "N ", "N ", "N ", "NNN ", "NBNN ",
	"IBNN ", "IB ", "IB ", "IB ", "IB ", "N ", "N ", "N ", "BI ", " ", " ", "N ", "I ", "IBB ",
	"NNB ", "N ", "N ", "Ban ", " ", " ", " ", " ", " ", "IN ", "B ", " ", "II ", " ", "BI ",
	"N ", "I ", "IB ", "IB ", "IB ", "IB ", "IB ", "IB ", "IB ", "BI ", "BB ", "N ", "N ", "N ",
	"N ", "IBN ", "IBN ", "IN ", "B ", "BNNN ", "BBTS ", "N ", " ", "Ian ", "B ", "B ", "B ", "B ",
	"T ", "N ", " ", " ", "I ", " ", " ", "BBI ", "NNBB ", "BBB ", " ", " ", "T ", " ", "N ", "N ",
	" ", " ", "BT ", " ", "B ", " ", "BBBB ", " ", " ", "BBBB ", "B ", "B ", "B ", "B "
};

Subroutine *AGOSEngine::getSubroutineByID(uint subroutineId) {
	Subroutine *cur;

	for (cur = _subroutineList; cur; cur = cur->next) {
		if (cur->id == subroutineId)
			return cur;
	}

	if (loadXTablesIntoMem(subroutineId)) {
		for (cur = _subroutineList; cur; cur = cur->next) {
			if (cur->id == subroutineId)
				return cur;
		}
	}

	if (loadTablesIntoMem(subroutineId)) {
		for (cur = _subroutineList; cur; cur = cur->next) {
			if (cur->id == subroutineId)
				return cur;
		}
	}

	debug(0,"getSubroutineByID: subroutine %d not found", subroutineId);
	return nullptr;
}

void AGOSEngine::alignTableMem() {
	while (!IS_ALIGNED(_tablesHeapPtr, sizeof(byte *))) {
		_tablesHeapPtr++;
		_tablesHeapCurPos++;
	}
}

void *AGOSEngine::allocateTable(uint size) {
	byte *org = _tablesHeapPtr;

	size = (size + 1) & ~1;

	_tablesHeapPtr += size;
	_tablesHeapCurPos += size;

	if (_tablesHeapCurPos > _tablesHeapSize)
		error("Tablesheap overflow");

	return org;
}

void AGOSEngine::allocTablesHeap() {
	_tablesHeapSize = _tableMemSize;
	_tablesHeapCurPos = 0;
	_tablesHeapPtr = (byte *)calloc(_tableMemSize, 1);
	if (!_tablesHeapPtr)
		error("Out Of Memory - Tables");
}

void AGOSEngine::endCutscene() {
	Subroutine *sub;

	_sound->stopVoice();

	sub = getSubroutineByID(170);
	if (sub != nullptr)
		startSubroutineEx(sub);

	_runScriptReturn1 = true;
}

Common::SeekableReadStream *AGOSEngine::openTablesFile(const char *filename) {
	if (getPlatform() == Common::kPlatformPC98)
		return openTablesFile_pak98(filename);
	else if (getFeatures() & GF_OLD_BUNDLE)
		return openTablesFile_simon1(filename);
	else
		return openTablesFile_gme(filename);
}

Common::SeekableReadStream *AGOSEngine::openTablesFile_simon1(const char *filename) {
	Common::File *in = new Common::File();
	if (!in->open(filename))
		error("openTablesFile: Can't open '%s'", filename);
	return in;
}

Common::SeekableReadStream *AGOSEngine::openTablesFile_pak98(const char *filename) {
	Common::SeekableReadStream *in = createPak98FileStream(filename);
	if (!in)
		error("openTablesFile_pak98: Can't open '%s'", filename);
	return in;
}

Common::SeekableReadStream *AGOSEngine::openTablesFile_gme(const char *filename) {
	uint res;
	uint32 offs;

	res = atoi(filename + 6) + _tableIndexBase - 1;
	offs = _gameOffsetsPtr[res];

	_gameFile->seek(offs, SEEK_SET);
	return _gameFile;
}

bool AGOSEngine::loadTablesIntoMem(uint16 subrId) {
	byte *p;
	uint16 min_num, max_num, file_num;
	Common::SeekableReadStream *in;

	if (_tblList == nullptr)
		return 0;

	p = _tblList + 32;

	min_num = READ_BE_UINT16(p);
	max_num = READ_BE_UINT16(p + 2);
	file_num = *(p + 4);
	p += 6;

	while (min_num) {
		if ((subrId >= min_num) && (subrId <= max_num)) {
			_subroutineList = _subroutineListOrg;
			_tablesHeapPtr = _tablesHeapPtrOrg;
			_tablesHeapCurPos = _tablesHeapCurPosOrg;
			_stringIdLocalMin = 1;
			_stringIdLocalMax = 0;
			Common::String filename = Common::String::format("TABLES%.2d%s", file_num, getPlatform() == Common::kPlatformPC98 ? ".PAK" : "");
			in = openTablesFile(filename.c_str());
			readSubroutineBlock(in);
			closeTablesFile(in);

			alignTableMem();

			_tablesheapPtrNew = _tablesHeapPtr;
			_tablesHeapCurPosNew = _tablesHeapCurPos;

			if (_tablesHeapCurPos > _tablesHeapSize)
				error("loadTablesIntoMem: Out of table memory");
			return 1;
		}

		min_num = READ_BE_UINT16(p);
		max_num = READ_BE_UINT16(p + 2);
		file_num = *(p + 4);
		p += 6;
	}

	debug(1,"loadTablesIntoMem: didn't find %d", subrId);
	return 0;
}

bool AGOSEngine_Waxworks::loadTablesIntoMem(uint16 subrId) {
	byte *p;
	uint min_num, max_num;
	Common::SeekableReadStream *in;

	p = _tblList;
	if (p == nullptr)
		return 0;

	while (*p) {
		Common::String filename;
		while (*p)
			filename += *p++;
		p++;

		for (;;) {
			min_num = READ_BE_UINT16(p); p += 2;
			if (min_num == 0)
				break;

			max_num = READ_BE_UINT16(p); p += 2;

			if (subrId >= min_num && subrId <= max_num) {
				_subroutineList = _subroutineListOrg;
				_tablesHeapPtr = _tablesHeapPtrOrg;
				_tablesHeapCurPos = _tablesHeapCurPosOrg;
				_stringIdLocalMin = 1;
				_stringIdLocalMax = 0;

				in = openTablesFile(filename.c_str());
				readSubroutineBlock(in);
				closeTablesFile(in);
				if (getGameType() == GType_SIMON2) {
					_sound->loadSfxTable(getFileName(GAME_GMEFILE), _gameOffsetsPtr[atoi(filename.c_str() + 6) - 1 + _soundIndexBase]);
				} else if (getGameType() == GType_SIMON1 && getPlatform() == Common::kPlatformWindows) {
					filename.setChar('S', 0);
					filename.setChar('F', 1);
					filename.setChar('X', 2);
					filename.setChar('X', 3);
					filename.setChar('X', 4);
					filename.setChar('X', 5);
					if (atoi(filename.c_str() + 6) != 1 && atoi(filename.c_str() + 6) != 30)
						_sound->readSfxFile(Common::Path(filename));
				}

				alignTableMem();

				_tablesheapPtrNew = _tablesHeapPtr;
				_tablesHeapCurPosNew = _tablesHeapCurPos;

				if (_tablesHeapCurPos > _tablesHeapSize)
					error("loadTablesIntoMem: Out of table memory");
				return 1;
			}
		}
	}

	debug(1,"loadTablesIntoMem: didn't find %d", subrId);
	return 0;
}

bool AGOSEngine::loadXTablesIntoMem(uint16 subrId) {
	byte *p;
	int i;
	uint min_num, max_num;
	char filename[30];
	Common::SeekableReadStream *in;

	p = _xtblList;
	if (p == nullptr)
		return 0;

	while (*p) {
		for (i = 0; *p; p++, i++)
			filename[i] = *p;
		filename[i] = 0;
		p++;

		for (;;) {
			min_num = READ_BE_UINT16(p);
			p += 2;

			if (min_num == 0)
				break;

			max_num = READ_BE_UINT16(p);
			p += 2;

			if (subrId >= min_num && subrId <= max_num) {
				_subroutineList = _xsubroutineListOrg;
				_tablesHeapPtr = _xtablesHeapPtrOrg;
				_tablesHeapCurPos = _xtablesHeapCurPosOrg;
				_stringIdLocalMin = 1;
				_stringIdLocalMax = 0;

				in = openTablesFile(filename);
				readSubroutineBlock(in);
				closeTablesFile(in);

				alignTableMem();

				_subroutineListOrg = _subroutineList;
				_tablesHeapPtrOrg = _tablesHeapPtr;
				_tablesHeapCurPosOrg = _tablesHeapCurPos;
				_tablesheapPtrNew = _tablesHeapPtr;
				_tablesHeapCurPosNew = _tablesHeapCurPos;

				return 1;
			}
		}
	}

	debug(1,"loadXTablesIntoMem: didn't find %d", subrId);
	return 0;
}

void AGOSEngine::closeTablesFile(Common::SeekableReadStream *in) {
	if (getFeatures() & GF_OLD_BUNDLE) {
		delete in;
	}
}

Subroutine *AGOSEngine::createSubroutine(uint16 id) {
	Subroutine *sub;

	alignTableMem();

	sub = (Subroutine *)allocateTable(sizeof(Subroutine));
	sub->id = id;
	sub->first = 0;
	sub->next = _subroutineList;
	_subroutineList = sub;
	return sub;
}

SubroutineLine *AGOSEngine::createSubroutineLine(Subroutine *sub, int where) {
	SubroutineLine *sl, *cur_sl = nullptr, *last_sl = nullptr;

	if (sub->id == 0)
		sl = (SubroutineLine *)allocateTable(SUBROUTINE_LINE_BIG_SIZE);
	else
		sl = (SubroutineLine *)allocateTable(SUBROUTINE_LINE_SMALL_SIZE);

	// where is what offset to insert the line at, locate the proper beginning line
	if (sub->first != 0) {
		cur_sl = (SubroutineLine *)((byte *)sub + sub->first);
		while (where) {
			last_sl = cur_sl;
			cur_sl = (SubroutineLine *)((byte *)sub + cur_sl->next);
			if ((byte *)cur_sl == (byte *)sub)
				break;
			where--;
		}
	}

	if (last_sl != nullptr) {
		// Insert the subroutine line in the middle of the link
		last_sl->next = (byte *)sl - (byte *)sub;
		sl->next = (byte *)cur_sl - (byte *)sub;
	} else {
		// Insert the subroutine line at the head of the link
		sl->next = sub->first;
		sub->first = (byte *)sl - (byte *)sub;
	}

	return sl;
}

void AGOSEngine::runSubroutine101() {
	Subroutine *sub;

	sub = getSubroutineByID(101);
	if (sub != nullptr)
		startSubroutineEx(sub);

	permitInput();
}

int AGOSEngine::startSubroutine(Subroutine *sub) {
	int result = -1;
	SubroutineLine *sl = (SubroutineLine *)((byte *)sub + sub->first);

	const byte *old_code_ptr = _codePtr;
	Subroutine *old_currentTable = _currentTable;
	SubroutineLine *old_currentLine = _currentLine;
	SubroutineLine *old_classLine = _classLine;
	int16 old_classMask = _classMask;
	int16 old_classMode1 = _classMode1;
	int16 old_classMode2 = _classMode2;

	_classLine = nullptr;
	_classMask = 0;
	_classMode1 = 0;
	_classMode2 = 0;

	if (DebugMan.isDebugChannelEnabled(kDebugSubroutine))
		dumpSubroutine(sub);

	if (++_recursionDepth > 40)
		error("Recursion error");

	// WORKAROUND: If the game is saved, right after Simon is thrown in the dungeon of Sordid's Fortress of Doom,
	// the saved game fails to load correctly. When loading the saved game, the sequence of Simon waking is started,
	// before the scene is actually reloaded, due to a script bug. We manually add the extra script code from the
	// updated DOS CD release, which fixed this particular script bug.
	if (getGameType() == GType_SIMON2 && sub->id == 12101) {
		const byte bit = 228;
		if ((_bitArrayTwo[bit / 16] & (1 << (bit & 15))) != 0 && (int)readVariable(34) == -1) {
			_bitArrayTwo[228 / 16] &= ~(1 << (bit & 15));
			writeVariable(34, 1);
		}
	}

	_currentTable = sub;
restart:

	if (shouldQuit())
		return result;

	while ((byte *)sl != (byte *)sub) {
		_currentLine = sl;
		if (checkIfToRunSubroutineLine(sl, sub)) {
			_codePtr = (byte *)sl;
			if (sub->id)
				_codePtr += 2;
			else
				_codePtr += 8;

			debugC(kDebugOpcode, "; %d", sub->id);
			result = runScript();
			if (result != 0) {
				break;
			}
		}
		sl = (SubroutineLine *)((byte *)sub + sl->next);
	}

	// WORKAROUND: Feeble walks in the incorrect direction, when looking at the Vent in the Research and Testing area of
	// the Company Central Command Compound. We manually add the extra script code from the updated English 2CD release,
	// which fixed this particular script bug.
	if (getGameType() == GType_FF && _language == Common::EN_ANY) {
		if (sub->id == 39125 && readVariable(84) == 2) {
			writeVariable(1, 1136);
			writeVariable(2, 346);
		}
		if (sub->id == 39126 && readVariable(84) == 2) {
			Subroutine *tmpSub = getSubroutineByID(80);
			if (tmpSub != nullptr) {
				startSubroutine(tmpSub);
			}
		}
	}

	if (_classMode1) {
		_subjectItem = nextInByClass(_subjectItem, _classMask);
		if (!_subjectItem) {
			_classMode1 = 0;
		} else {
			delay(0);
			sl = _classLine;	/* Rescanner */
			goto restart;
		}
	}
	if (_classMode2) {
		_objectItem = nextInByClass(_objectItem, _classMask);
		if (!_objectItem) {
			_classMode2 = 0;
		} else {
			delay(0);
			sl = _classLine;	/* Rescanner */
			goto restart;
		}
	}

	/* result -10 means restart subroutine */
	if (result == -10) {
		delay(0);
		sl = (SubroutineLine *)((byte *)sub + sub->first);
		goto restart;
	}

	_codePtr = old_code_ptr;
	_currentLine = old_currentLine;
	_currentTable = old_currentTable;
	_classLine = old_classLine;
	_classMask = old_classMask;
	_classMode1 = old_classMode2;
	_classMode2 = old_classMode1;
	_findNextPtr = nullptr;

	_recursionDepth--;
	return result;
}

int AGOSEngine::startSubroutineEx(Subroutine *sub) {
	return startSubroutine(sub);
}

bool AGOSEngine::checkIfToRunSubroutineLine(SubroutineLine *sl, Subroutine *sub) {
	if (sub->id)
		return true;

	if (sl->verb != -1 && sl->verb != _scriptVerb &&
			(sl->verb != -2 || _scriptVerb != -1))
		return false;

	if (sl->noun1 != -1 && sl->noun1 != _scriptNoun1 &&
			(sl->noun1 != -2 || _scriptNoun1 != -1))
		return false;

	if (sl->noun2 != -1 && sl->noun2 != _scriptNoun2 &&
			(sl->noun2 != -2 || _scriptNoun2 != -1))
		return false;

	return true;
}

void AGOSEngine::readSubroutineBlock(Common::SeekableReadStream *in) {
	while (in->readUint16BE() == 0) {
		readSubroutine(in, createSubroutine(in->readUint16BE()));
	}
}
void AGOSEngine::readSubroutine(Common::SeekableReadStream *in, Subroutine *sub) {
	while (in->readUint16BE() == 0) {
		readSubroutineLine(in, createSubroutineLine(sub, 0xFFFF), sub);
	}
}

void AGOSEngine::readSubroutineLine(Common::SeekableReadStream *in, SubroutineLine *sl, Subroutine *sub) {
	byte line_buffer[2048], *q = line_buffer;
	int size;

	if (sub->id == 0) {
		sl->verb = in->readUint16BE();
		sl->noun1 = in->readUint16BE();
		sl->noun2 = in->readUint16BE();
	} else if (getGameType() == GType_ELVIRA1) {
		in->readUint16BE();
		in->readUint16BE();
		in->readUint16BE();
	}

	if (getGameType() == GType_ELVIRA1) {
		int16 tmp = in->readUint16BE();
		WRITE_BE_UINT16(q, tmp);
		while (tmp != 10000) {
			if (READ_BE_UINT16(q) == 198) {
				in->readUint16BE();
			} else {
				q = readSingleOpcode(in, q);
			}

			tmp = in->readUint16BE();
			WRITE_BE_UINT16(q, tmp);
		}
	} else {
		while ((*q = in->readByte()) != 0xFF) {
			if (*q == 87) {
				in->readUint16BE();
			} else {
				q = readSingleOpcode(in, q);
			}
		}
	}

	size = (q - line_buffer + 2);
	memcpy(allocateTable(size), line_buffer, size);
}

byte *AGOSEngine::readSingleOpcode(Common::SeekableReadStream *in, byte *ptr) {
	int i, l;
	const char *stringPtr;
	uint16 opcode, val;

	const char *const *table;

	if (getGameType() == GType_PP)
		table = opcodeArgTable_puzzlepack;
	else if (getGameType() == GType_FF)
		table = opcodeArgTable_feeblefiles;
	else if (getGameType() == GType_SIMON2 && (getFeatures() & GF_TALKIE))
		table = opcodeArgTable_simon2talkie;
	else if (getGameType() == GType_SIMON2)
		table = opcodeArgTable_simon2dos;
	else if (getGameType() == GType_SIMON1 && (getFeatures() & GF_TALKIE))
		table = opcodeArgTable_simon1talkie;
	else if (getGameType() == GType_SIMON1)
		table = opcodeArgTable_simon1dos;
	else if (getGameType() == GType_WW)
		table = opcodeArgTable_waxworks;
	else if (getGameType() == GType_ELVIRA2)
		table = opcodeArgTable_elvira2;
	else
		table = opcodeArgTable_elvira1;

	i = 0;
	if (getGameType() == GType_ELVIRA1) {
		opcode = READ_BE_UINT16(ptr);
		ptr += 2;
	} else {
		opcode = *ptr++;
	}

	stringPtr = table[opcode];
	if (!stringPtr)
		error("Unable to locate opcode table. Perhaps you are using the wrong game target?");

	for (;;) {
		if (stringPtr[i] == ' ')
			return ptr;

		l = stringPtr[i++];

		switch (l) {
		case 'F':
		case 'N':
		case 'S':
		case 'a':
		case 'n':
		case 'p':
		case 'v':
		case '3':
			val = in->readUint16BE();
			WRITE_BE_UINT16(ptr, val); ptr += 2;
			break;

		case 'B':
			if (getGameType() == GType_ELVIRA1) {
				val = in->readUint16BE();
				WRITE_BE_UINT16(ptr, val); ptr += 2;
			} else {
				*ptr++ = in->readByte();
				if (ptr[-1] == 0xFF) {
					*ptr++ = in->readByte();
				}
			}
			break;

		case 'I':
			val = in->readUint16BE();
			switch (val) {
			case 1:
				val = 0xFFFF;
				break;
			case 3:
				val = 0xFFFD;
				break;
			case 5:
				val = 0xFFFB;
				break;
			case 7:
				val = 0xFFF9;
				break;
			case 9:
				val = 0xFFF7;
				break;
			default:
				val = fileReadItemID(in);
				break;
			}
			WRITE_BE_UINT16(ptr, val); ptr += 2;
			break;

		case 'T':
			val = in->readUint16BE();
			switch (val) {
			case 0:
				val = 0xFFFF;
				break;
			case 3:
				val = 0xFFFD;
				break;
			default:
				val = (uint16)in->readUint32BE();
				break;
			}
			WRITE_BE_UINT16(ptr, val); ptr += 2;
			break;
		default:
			error("readSingleOpcode: Bad cmd table entry %c", l);
		}
	}
}

} // End of namespace AGOS

================
File: verb.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Verb and hitarea handling

#include "common/system.h"

#include "graphics/surface.h"

#include "agos/agos.h"
#include "agos/intern.h"

namespace AGOS {

static const char *const russian_verb_names[] = {
	"Ietj _",
	"Qnotrft< pa",
	"Nt_r[t<",
	"Ecjdat<",
	"Q=fst<",
	"C^]t<",
	"Ha_r[t<",
	"Isqom<^ocat<",
	"Docorjt<",
	"Qp]t<",
	"Neft<",
	"Eat<"
};

static const char *const hebrew_verb_names[] = {
	"LJ @L",
	"DQZKL RL",
	"TZG",
	"DFF",
	"@KEL",
	"DXM",
	"QBEX",
	"DYZNY",
	"CAX @L",
	"DQX",
	"LAY",
	"ZO"
};

static const char *const spanish_verb_names[] = {
	"Caminar",
	"Mirar",
	"Abrir",
	"Mover",
	"Consumir",
	"Coger",
	"Cerrar",
	"Usar",
	"Hablar",
	"Quitar",
	"Llevar",
	"Dar"
};

static const char *const italian_verb_names[] = {
	"Vai verso",
	"Osserva",
	"Apri",
	"Sposta",
	"Mangia",
	"Raccogli",
	"Chiudi",
	"Usa",
	"Parla a",
	"Togli",
	"Indossa",
	"Dai"
};

static const char *const french_verb_names[] = {
	"Aller vers",
	"Regarder",
	"Ouvrir",
	"D/placer",
	"Consommer",
	"Prendre",
	"Fermer",
	"Utiliser",
	"Parler ;",
	"Enlever",
	"Mettre",
	"Donner"
};

static const char *const german_verb_names[] = {
	"Gehe zu",
	"Schau an",
	";ffne",
	"Bewege",
	"Verzehre",
	"Nimm",
	"Schlie+e",
	"Benutze",
	"Rede mit",
	"Entferne",
	"Trage",
	"Gib"
};

static const char *const english_verb_names[] = {
	"Walk to",
	"Look at",
	"Open",
	"Move",
	"Consume",
	"Pick up",
	"Close",
	"Use",
	"Talk to",
	"Remove",
	"Wear",
	"Give"
};

static const char *const czech_verb_names[] = {
	"Jit",
	"Podivat se",
	"Otevrit",
	"Pohnout s",
	"Snist",
	"Sebrat",
	"Zavrit",
	"Pouzit",
	"Mluvit s",
	"Odstranit",
	"Oblect",
	"Dat"
};

static const char *const russian_verb_prep_names[] = {
	"", "", "", "",
	"", "", "", "s yfn?",
	"", "", "", "_onu ?"
};

static const char *const hebrew_verb_prep_names[] = {
	"", "", "", "",
	"", "", "", "RM ND ?",
	"", "", "", "LNI ?"
};

static const char *const spanish_verb_prep_names[] = {
	"", "", "", "",
	"", "", "", "^con qu/?",
	"", "", "", "^a qui/n?"
};

static const char *const italian_verb_prep_names[] = {
	"", "", "", "",
	"", "", "", "con cosa ?",
	"", "", "", "a chi ?"
};

static const char *const french_verb_prep_names[] = {
	"", "", "", "",
	"", "", "", "avec quoi ?",
	"", "", "", "; qui ?"
};

static const char *const german_verb_prep_names[] = {
	"", "", "", "",
	"", "", "", "mit was ?",
	"", "", "", "zu wem ?"
};

static const char *const english_verb_prep_names[] = {
	"", "", "", "",
	"", "", "", "with what ?",
	"", "", "", "to whom ?"
};

static const char *const czech_verb_prep_names[] = {
	"", "", "", "",
	"", "", "", "s cim ?",
	"", "", "", "komu ?"
};

#ifdef ENABLE_AGOS2
void AGOSEngine_Feeble::clearName() {
	stopAnimateSimon2(2, 6);
	_lastNameOn = NULL;
	_animatePointer = false;
	_mouseAnim = 1;
	return;
}
#endif

void AGOSEngine_Simon2::clearName() {
	if (getBitFlag(79)) {
		sendSync(202);
		_lastNameOn = nullptr;
		return;
	}

	if (_currentVerbBox == _lastVerbOn)
		return;

	resetNameWindow();
	_lastVerbOn = _currentVerbBox;

	if (_currentVerbBox != nullptr && !(_currentVerbBox->flags & kBFBoxDead))
		printVerbOf(_currentVerbBox->id);
}

void AGOSEngine_Simon1::clearName() {
	HitArea *ha;

	if (_currentVerbBox == _lastVerbOn)
		return;

	resetNameWindow();
	_lastVerbOn = _currentVerbBox;

	if (_currentVerbBox != nullptr && (ha = findBox(200)) && (ha->flags & kBFBoxDead) && !(_currentVerbBox->flags & kBFBoxDead))
		printVerbOf(_currentVerbBox->id);
}

void AGOSEngine::clearName() {
	if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2)
		return;

	if (_nameLocked || !_lastNameOn)
		return;

	resetNameWindow();
}

static const byte convertVerbID[9] = {
	0, 1, 5, 11, 8, 7, 10, 3, 2
};

void AGOSEngine::printVerbOf(uint hitarea_id) {
	const char *txt;
	const char * const *verb_names;
	const char * const *verb_prep_names;

	hitarea_id -= 101;
	if (getGameType() == GType_SIMON2)
		hitarea_id = convertVerbID[hitarea_id];

	if (_showPreposition) {
		switch (_language) {
		case Common::RU_RUS:
			verb_prep_names = russian_verb_prep_names;
			break;
		case Common::HE_ISR:
			verb_prep_names = hebrew_verb_prep_names;
			break;
		case Common::ES_ESP:
			verb_prep_names = spanish_verb_prep_names;
			break;
		case Common::IT_ITA:
			verb_prep_names = italian_verb_prep_names;
			break;
		case Common::FR_FRA:
			verb_prep_names = french_verb_prep_names;
			break;
		case Common::DE_DEU:
			verb_prep_names = german_verb_prep_names;
			break;
		case Common::CS_CZE:
			verb_prep_names = czech_verb_prep_names;
			break;
		default:
			verb_prep_names = english_verb_prep_names;
			break;
		}
		CHECK_BOUNDS(hitarea_id, english_verb_prep_names);
		txt = verb_prep_names[hitarea_id];
	} else {
		switch (_language) {
		case Common::RU_RUS:
			verb_names = russian_verb_names;
			break;
		case Common::HE_ISR:
			verb_names = hebrew_verb_names;
			break;
		case Common::ES_ESP:
			verb_names = spanish_verb_names;
			break;
		case Common::IT_ITA:
			verb_names = italian_verb_names;
			break;
		case Common::FR_FRA:
			verb_names = french_verb_names;
			break;
		case Common::DE_DEU:
			verb_names = german_verb_names;
			break;
		case Common::CS_CZE:
			verb_names = czech_verb_names;
			break;
		default:
			verb_names = english_verb_names;
			break;
		}
		CHECK_BOUNDS(hitarea_id, english_verb_names);
		txt = verb_names[hitarea_id];
	}
	showActionString((const byte *)txt);
}

void AGOSEngine::showActionString(const byte *string) {
	WindowBlock *window;
	uint x;
	const uint len = (getGameType() == GType_WW) ? 29 : 53;

	window = _windowArray[1];
	if (window == nullptr || window->textColor == 0)
		return;

	// Arisme : hack for long strings in the French version
	if ((strlen((const char*)string) - 1) <= len)
		x = (len - (strlen((const char *)string) - 1)) * 3;
	else
		x = 0;

	window->textColumn = x / 8;
	window->textColumnOffset = x & 7;
	if (_language == Common::HE_ISR && window->textColumnOffset != 0) {
		window->textColumnOffset = 8 - window->textColumnOffset;
		window->textColumn++;
	}

	for (; *string; string++)
		windowPutChar(window, *string);
}

void AGOSEngine::handleVerbClicked(uint verb) {
	Subroutine *sub;
	int result;

	if (shouldQuit())
		return;

	_objectItem = _hitAreaObjectItem;
	if (_objectItem == _dummyItem2) {
		_objectItem = me();
	}
	if (_objectItem == _dummyItem3) {
		_objectItem = derefItem(me()->parent);
	}

	_subjectItem = _hitAreaSubjectItem;
	if (_subjectItem == _dummyItem2) {
		_subjectItem = me();
	}
	if (_subjectItem == _dummyItem3) {
		_subjectItem = derefItem(me()->parent);
	}

	if (_subjectItem) {
		_scriptNoun1 = _subjectItem->noun;
		_scriptAdj1 = _subjectItem->adjective;
	} else {
		_scriptNoun1 = -1;
		_scriptAdj1 = -1;
	}

	if (_objectItem) {
		_scriptNoun2 = _objectItem->noun;
		_scriptAdj2 = _objectItem->adjective;
	} else {
		_scriptNoun2 = -1;
		_scriptAdj2 = -1;
	}

	_scriptVerb = _verbHitArea;

	sub = getSubroutineByID(0);
	if (sub == nullptr)
		return;

	result = startSubroutine(sub);
	if (result == -1)
		showMessageFormat("I don't understand");

	_runScriptReturn1 = false;

	sub = getSubroutineByID(100);
	if (sub)
		startSubroutine(sub);

	if (getGameType() == GType_SIMON2 || getGameType() == GType_FF || getGameType() == GType_PP)
		_runScriptReturn1 = false;

	permitInput();
}

void AGOSEngine::resetNameWindow() {
	WindowBlock *window;

	if (getGameType() == GType_SIMON2 && getBitFlag(79))
		return;

	window = _windowArray[1];
	if (window != nullptr && window->textColor != 0)
		clearWindow(window);

	_lastNameOn = nullptr;
	_lastVerbOn = nullptr;
}

HitArea *AGOSEngine::findBox(uint hitarea_id) {
	HitArea *ha = _hitAreas;
	uint count = ARRAYSIZE(_hitAreas);

	do {
		if (getGameType() == GType_FF || getGameType() == GType_PP) {
			if (ha->id == hitarea_id && ha->flags != 0)
				return ha;
		} else {
			if (ha->id == hitarea_id)
				return ha;
		}
	} while (ha++, --count);
	return nullptr;
}

HitArea *AGOSEngine::findEmptyHitArea() {
	HitArea *ha = _hitAreas;
	uint count = ARRAYSIZE(_hitAreas) - 1;

	do {
		if (ha->flags == 0)
			return ha;
	} while (ha++, --count);

	// The last box is overwritten, if too many boxes are allocated.
	return ha;
}

void AGOSEngine::freeBox(uint index) {
	CHECK_BOUNDS(index, _hitAreas);
	_hitAreas[index].flags = 0;
}

void AGOSEngine::enableBox(uint hitarea) {
	HitArea *ha = findBox(hitarea);
	if (ha != nullptr)
		ha->flags &= ~kBFBoxDead;
}

void AGOSEngine::disableBox(uint hitarea) {
	HitArea *ha = findBox(hitarea);
	if (ha != nullptr) {
		ha->flags |= kBFBoxDead;
		ha->flags &= ~kBFBoxSelected;
		if ((getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) &&
			hitarea == 102) {
			resetVerbs();
		}
	}
}

void AGOSEngine::moveBox(uint hitarea, int x, int y) {
	HitArea *ha = findBox(hitarea);
	if (ha != nullptr) {
		if (getGameType() == GType_FF || getGameType() == GType_PP) {
			ha->x += x;
			ha->y += y;
		} else {
			ha->x = x;
			ha->y = y;
		}
	}
}

void AGOSEngine::undefineBox(uint hitarea) {
	HitArea *ha = findBox(hitarea);
	if (ha != nullptr) {
		ha->flags = 0;
		if (ha == _lastNameOn)
			clearName();
		_needHitAreaRecalc++;
	}
}

bool AGOSEngine::isBoxDead(uint hitarea) {
	HitArea *ha = findBox(hitarea);
	if (ha == nullptr)
		return false;
	return (ha->flags & kBFBoxDead) == 0;
}

void AGOSEngine::defineBox(uint16 id, uint16 x, uint16 y, uint16 height, uint16 width, uint16 msg1, uint16 msg2, uint16 flags) {
	HitArea *ha = _hitAreaList + id;
	ha->x = x;
	ha->y = y;
	ha->width = width;
	ha->height = height;
	ha->msg1 = msg1;
	ha->msg2 = msg2;
	ha->flags = flags;
	ha->id = ha->priority = id;
}

void AGOSEngine::defineBox(int id, int x, int y, int width, int height, int flags, int verb, Item *itemPtr) {
	HitArea *ha;
	undefineBox(id);

	ha = findEmptyHitArea();
	ha->x = x;
	ha->y = y;
	ha->width = width;
	ha->height = height;
	ha->flags = flags | kBFBoxInUse;
	ha->id = ha->priority = id;
	ha->verb = verb;
	ha->itemPtr = itemPtr;

	if (getGameType() == GType_FF && (ha->flags & kBFHyperBox)) {
		ha->data = _hyperLink;
		ha->priority = 50;
	}

	_needHitAreaRecalc++;
}

#ifdef ENABLE_AGOS2
void AGOSEngine_PuzzlePack::resetVerbs() {
	_verbHitArea = 300;
}

void AGOSEngine_Feeble::resetVerbs() {
	_verbHitArea = 300;
	int cursor = 0;
	int animMax = 16;

	if (getBitFlag(203)) {
		cursor = 14;
		animMax = 9;
	} else if (getBitFlag(204)) {
		cursor = 15;
		animMax = 9;
	} else if (getBitFlag(207)) {
		cursor = 26;
		animMax = 2;
	}

	_mouseCursor = cursor;
	_mouseAnimMax = animMax;
	_mouseAnim = 1;
	_needHitAreaRecalc++;

	if (getBitFlag(99)) {
		setVerb(NULL);
	}
}
#endif

void AGOSEngine::resetVerbs() {
	if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2)
		return;

	uint id;
	HitArea *ha;

	if (getGameType() == GType_SIMON2) {
		id = 2;
		if (!getBitFlag(79))
		id = (_mouse.y >= 136) ? 102 : 101;
	} else {
		id = (_mouse.y >= 136) ? 102 : 101;
	}

	_defaultVerb = id;

	ha = findBox(id);
	if (ha == nullptr)
		return;

	if (ha->flags & kBFBoxDead) {
		_defaultVerb = 999;
		_currentVerbBox = nullptr;
	} else {
		_verbHitArea = ha->verb;
		setVerb(ha);
	}
}

#ifdef ENABLE_AGOS2
void AGOSEngine_Feeble::setVerb(HitArea *ha) {
	int cursor = _mouseCursor;
	if (_noRightClick)
		return;

	if (cursor > 13)
		cursor = 0;
	cursor++;
	if (cursor == 5)
		cursor = 1;
	if (cursor == 4) {
		if (getBitFlag(72)) {
			cursor = 1;
		}
	} else if (cursor == 2) {
		if (getBitFlag(99)) {
			cursor = 3;
		}
	}

	_mouseCursor = cursor;
	_mouseAnimMax = (cursor == 4) ? 14: 16;
	_mouseAnim = 1;
	_needHitAreaRecalc++;
	_verbHitArea = cursor + 300;
}
#endif

void AGOSEngine::setVerb(HitArea *ha) {
	HitArea *tmp = _currentVerbBox;

	if (ha == tmp)
		return;

	if (getGameType() == GType_SIMON1) {
		if (tmp != nullptr) {
			tmp->flags |= kBFInvertTouch;
			if (getFeatures() & GF_32COLOR)
				invertBox(tmp, 212, 208, 212, 8);
			else
				invertBox(tmp, 213, 208, 213, 10);
		}

		if (ha->flags & kBFBoxSelected) {
			if (getFeatures() & GF_32COLOR)
				invertBox(ha, 216, 212, 212, 4);
			else
				invertBox(ha, 218, 213, 213, 5);
		} else {
			if (getFeatures() & GF_32COLOR)
				invertBox(ha, 220, 216, 216, 8);
			else
				invertBox(ha, 223, 218, 218, 10);
		}

		ha->flags &= ~(kBFBoxSelected + kBFInvertTouch);
	} else {
		if (ha->id < 101)
			return;
		_mouseCursor = ha->id - 101;
		_needHitAreaRecalc++;
	}
	_currentVerbBox = ha;
}

#ifdef ENABLE_AGOS2
void AGOSEngine_Feeble::hitarea_leave(HitArea *ha, bool state) {
	invertBox(ha, state);
}
#endif

void AGOSEngine::hitarea_leave(HitArea *ha, bool state) {
	if (getGameType() == GType_SIMON2) {
		invertBox(ha, 231, 229, 230, 1);
	} else {
		if (getFeatures() & GF_32COLOR)
			invertBox(ha, 220, 212, 216, 4);
		else
			invertBox(ha, 223, 213, 218, 5);
	}
}

void AGOSEngine::leaveHitAreaById(uint hitarea_id) {
	HitArea *ha = findBox(hitarea_id);
	if (ha)
		hitarea_leave(ha);
}

void AGOSEngine::inventoryUp(WindowBlock *window) {
	if (window->iconPtr->line == 0)
		return;

	mouseOff();
	uint index = getWindowNum(window);
	drawIconArray(index, window->iconPtr->itemRef, window->iconPtr->line - 1, window->iconPtr->classMask);
	mouseOn();
}

void AGOSEngine::inventoryDown(WindowBlock *window) {
	mouseOff();
	uint index = getWindowNum(window);
	drawIconArray(index, window->iconPtr->itemRef, window->iconPtr->line + 1, window->iconPtr->classMask);
	mouseOn();
}

void AGOSEngine::boxController(uint x, uint y, uint mode) {
	HitArea *best_ha;
	HitArea *ha = _hitAreas;
	uint count = ARRAYSIZE(_hitAreas);
	uint16 priority = 0;

	best_ha = nullptr;

	do {
		if (ha->flags & kBFBoxInUse) {
			if (!(ha->flags & kBFBoxDead)) {
				if (x >= ha->x && y >= ha->y &&
						x - ha->x < ha->width && y - ha->y < ha->height && priority <= ha->priority) {
					priority = ha->priority;
					best_ha = ha;
				} else {
					if (ha->flags & kBFBoxSelected) {
						hitarea_leave(ha , true);
						ha->flags &= ~kBFBoxSelected;
					}
				}
			} else {
				ha->flags &= ~kBFBoxSelected;
			}
		}
	} while (ha++, --count);

	_currentBoxNum = 0;
	_currentBox = best_ha;

	if (best_ha == nullptr)
		return;

	_currentBoxNum = best_ha->id;

	if (mode != 0) {
		if (mode == 3) {
			if (best_ha->verb & 0x4000) {
				if (getGameType() == GType_ELVIRA1 && _variableArray[500] == 0) {
					_variableArray[500] = best_ha->verb & 0xBFFF;
				}

				if (_clickOnly && best_ha->id < 8) {
					uint id = best_ha->id;
					if (id >= 4)
						id -= 4;

					invertBox(findBox(id), 0, 0, 0, 0);
					_clickOnly = false;
					return;
				}
			}

			if (best_ha->flags & kBFDragBox)
				_lastClickRem = best_ha;
		} else {
			_lastHitArea = best_ha;
		}
	}

	if (_clickOnly)
		return;

	if (best_ha->flags & kBFInvertTouch) {
		if (!(best_ha->flags & kBFBoxSelected)) {
			hitarea_leave(best_ha, false);
			best_ha->flags |= kBFBoxSelected;
		}
	} else {
		if (mode == 0)
			return;

		if (!(best_ha->flags & kBFInvertSelect))
			return;

		if (best_ha->flags & kBFToggleBox) {
			hitarea_leave(best_ha, false);
			best_ha->flags ^= kBFInvertSelect;
		} else if (!(best_ha->flags & kBFBoxSelected)) {
			hitarea_leave(best_ha, false);
			best_ha->flags |= kBFBoxSelected;
		}
	}
}

void AGOSEngine_Waxworks::boxController(uint x, uint y, uint mode) {
	HitArea *best_ha;
	HitArea *ha = _hitAreas;
	uint count = ARRAYSIZE(_hitAreas);
	uint16 priority = 0;
	uint16 x_ = x;
	uint16 y_ = y;

	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		x_ += _scrollX;
		y_ += _scrollY;
	} else if (getGameType() == GType_SIMON2) {
		if (getBitFlag(79) || y < 134) {
			x_ += _scrollX * 8;
		}
	}

	best_ha = nullptr;

	do {
		if (ha->flags & kBFBoxInUse) {
			if (!(ha->flags & kBFBoxDead)) {
				if (x_ >= ha->x && y_ >= ha->y &&
						x_ - ha->x < ha->width && y_ - ha->y < ha->height && priority <= ha->priority) {
					priority = ha->priority;
					best_ha = ha;
				} else {
					if (ha->flags & kBFBoxSelected) {
						hitarea_leave(ha , true);
						ha->flags &= ~kBFBoxSelected;
					}
				}
			} else {
				ha->flags &= ~kBFBoxSelected;
			}
		}
	} while (ha++, --count);

	_currentBoxNum = 0;
	_currentBox = best_ha;

	if (best_ha == nullptr) {
		clearName();
		if (getGameType() == GType_WW && _mouseCursor >= 4) {
			_mouseCursor = 0;
			_needHitAreaRecalc++;
		}
		return;
	}

	_currentBoxNum = best_ha->id;

	if (mode != 0) {
		if (mode == 3) {
			if (best_ha->flags & kBFDragBox) {
				_lastClickRem = best_ha;
			}
		} else {
			_lastHitArea = best_ha;
			if (getGameType() == GType_PP) {
				_variableArray[400] = x;
				_variableArray[401] = y;
			} else if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2 ||
				getGameType() == GType_FF) {
				_variableArray[1] = x;
				_variableArray[2] = y;
			}
		}
	}

	if ((getGameType() == GType_WW) && (_mouseCursor == 0 || _mouseCursor >= 4)) {
		uint verb = best_ha->verb & 0x3FFF;
		uint cursor = (verb >= 239 && verb <= 242) ? verb - 235 : 0;
		if (_mouseCursor != cursor) {
			_mouseCursor = cursor;
			_needHitAreaRecalc++;
		}
	}

	if (getGameType() != GType_WW || !_nameLocked) {
		if (best_ha->flags & kBFNoTouchName) {
			clearName();
		} else if (best_ha != _lastNameOn) {
			displayName(best_ha);
		}
	}

	if (best_ha->flags & kBFInvertTouch && !(best_ha->flags & kBFBoxSelected)) {
		hitarea_leave(best_ha, false);
		best_ha->flags |= kBFBoxSelected;
	}
}

void AGOSEngine::displayName(HitArea *ha) {
	if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2 || getGameType() == GType_PP)
		return;

	bool result;
	int x = 0, y = 0;

	if (getGameType() == GType_FF) {
		if (ha->flags & kBFHyperBox) {
			_lastNameOn = ha;
			return;
		}
		if (findBox(50))
			return;

		if (getBitFlag(99))
			_animatePointer = ((ha->flags & kBFTextBox) == 0);
		else
			_animatePointer = true;

		if (!getBitFlag(73))
			return;

		y = ha->y;
		if (getBitFlag(99) && y > 288)
			y = 288;
		y -= 17;
		if (y < 0)
			y = 0;
		y += 2;
		x = ha->width / 2 + ha->x;
	} else {
		resetNameWindow();
	}

	if (ha->flags & kBFTextBox) {
		result = printTextOf(ha->flags / 256, x, y);
	} else {
		result = printNameOf(ha->itemPtr, x, y);
	}

	if (result)
		_lastNameOn = ha;
}

#ifdef ENABLE_AGOS2
void AGOSEngine_Feeble::invertBox(HitArea *ha, bool state) {
	if (getBitFlag(205) || getBitFlag(206)) {
		if (state != 0) {
			_mouseAnimMax = _oldMouseAnimMax;
			_mouseCursor = _oldMouseCursor;
		} else if (_mouseCursor != 18) {
			_oldMouseCursor = _mouseCursor;
			_animatePointer = false;
			_oldMouseAnimMax = _mouseAnimMax;
			_mouseAnimMax = 2;
			_mouseCursor = 18;
		}
	} else {
		if (getBitFlag(207)) {
			if (state != 0) {
				_noRightClick = 0;
				resetVerbs();
			} else {
				int cursor = ha->id + 9;
				if (cursor >= 23)
					cursor = 21;
				_mouseCursor = cursor;
				_mouseAnimMax = 8;
				_noRightClick = 1;
			}
		} else {
			VgaSprite *vsp = _vgaSprites;

			int id = ha->id - 43;
			while (vsp->id) {
				if (vsp->id == id && vsp->zoneNum == 2) {
					if (state == 0)
						vsp->flags |= kDFShaded;
					else
						vsp->flags &= ~kDFShaded;
					break;
				}
				vsp++;
			}
		}
	}
}
#endif

void AGOSEngine::invertBox(HitArea *ha, byte a, byte b, byte c, byte d) {
	byte *src, color;
	int w, h, i;

	_videoLockOut |= 0x8000;

	Graphics::Surface *screen = getBackendSurface();
	src = (byte *)screen->getBasePtr(ha->x, ha->y);

	// WORKAROUND: Hitareas for saved game names aren't adjusted for scrolling locations
	if (getGameType() == GType_SIMON2 && ha->id >= 208 && ha->id <= 213) {
		src -= _scrollX * 8;
	}

	_litBoxFlag = true;

	w = ha->width;
	h = ha->height;

	do {
		for (i = 0; i != w; ++i) {
			color = src[i];
			if (getGameType() == GType_WW) {
				if (!(color & 0xF) || (color & 0xF) == 10) {
					color ^= 10;
					src[i] = color;
				}
			} else if (getGameType() == GType_ELVIRA2) {
				if (!(color & 1)) {
					color ^= 2;
					src[i] = color;
				}
			} else if (getGameType() == GType_ELVIRA1) {
				if (color & 1) {
					color ^= 2;
					src[i] = color;
				}
			} else if (getGameType() == GType_PN) {
				if (getPlatform() == Common::kPlatformDOS) {
					if (color != 15) {
						color ^= 7;
						src[i] = color;
					}
				} else {
					if (color != 14) {
						color ^= 15;
						src[i] = color;
					}
				}
			} else {
				if (a >= color && b < color) {
					if (c >= color)
						color += d;
					else
						color -= d;
					src[i] = color;
				}
			}
		}
		src += screen->pitch;
	} while (--h);

	Common::Rect dirtyRect(ha->x, ha->y, ha->x + w, ha->y + ha->height);
	updateBackendSurface(&dirtyRect);

	_videoLockOut &= ~0x8000;
}

} // End of namespace AGOS

================
File: verb_pn.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Verb and hitarea handling


#include "agos/agos.h"
#include "agos/intern.h"

namespace AGOS {

void AGOSEngine_PN::boxController(uint x, uint y, uint mode) {
	HitArea *best_ha;
	HitArea *ha = _hitAreaList;

	best_ha = nullptr;

	do {
		if (!(ha->flags & kOBFBoxDisabled)) {
			if (x >= ha->x && y >= ha->y && x - ha->x < ha->width && y - ha->y < ha->height &&
				best_ha == nullptr) {
				best_ha = ha;
			} else {
				if (ha->flags & kOBFBoxSelected) {
					hitarea_leave(ha , true);
					ha->flags &= ~kOBFBoxSelected;
				}
			}
		} else {
			ha->flags &= ~kOBFBoxSelected;
		}
	} while (ha++, ha->id != 0xFFFF);

	if (mode != 0) {
		_lastHitArea = best_ha;
	}

	if (best_ha == nullptr) {
		return;
	}

	if (best_ha->flags & kOBFInvertTouch && !(best_ha->flags & kOBFBoxSelected)) {
		hitarea_leave(best_ha, false);
		best_ha->flags |= kOBFBoxSelected;
	}
}

void AGOSEngine_PN::mouseHit() {
	if (_hitCalled == 5) {
		execMouseHit(nullptr);
	} else {
		boxController(_mouse.x, _mouse.y, 1);
		if (_hitCalled == 4 || _lastHitArea != nullptr) {
			execMouseHit(_lastHitArea);
		}
	}
	_hitCalled = 0;
	_oneClick = 0;
}

void AGOSEngine_PN::execMouseHit(HitArea *ha) {
	if (_hitCalled == 1) {
		if (ha->flags & kOBFUseMessageList)
			hitBox11(ha);
		else if (ha->flags & kOBFMoreBox)
			hitBox9(ha);
		else if (ha->flags & kOBFExit)
			hitBox7(ha);
		else if (ha->flags & kOBFUseEmptyLine)
			hitBox2(ha);
		else
			hitBox1(ha);
	} else if (_hitCalled == 2) {
		if (ha->flags & (kOBFObject | kOBFInventoryBox | kOBFRoomBox))
			hitBox3(ha);
		else if (ha->flags & kOBFUseMessageList)
			hitBox11(ha);
		else if (ha->flags & kOBFMoreBox)
			hitBox9(ha);
		else if (ha->flags & kOBFExit)
			hitBox7(ha);
		else if (ha->flags & kOBFUseEmptyLine)
			hitBox2(ha);
		else
			hitBox1(ha);
	} else if (_hitCalled == 3) {
		if ((ha->flags & kOBFDraggable) && !_dragFlag) {
			_dragFlag = true;
			_dragStore = ha;
			_needHitAreaRecalc++;
		}
	} else if (_hitCalled == 4) {
		_dragFlag = false;
		_hitCalled = 0;
		_oneClick = 0;
		_dragCount = 0;
		_needHitAreaRecalc++;
		if (ha != nullptr) {
			if (ha->flags & kOBFInventoryBox)
				hitBox5(ha);
			else if (ha->flags & kOBFRoomBox)
				hitBox6(ha);
			else if (_videoLockOut & 10)
				hitBox8(ha);
		}
	} else {
		_hitCalled = 0;
		if (_mouseString == nullptr) {
			_mouseString = (const char *)"\r";
		}
	}
}

void AGOSEngine_PN::hitBox1(HitArea *ha) {
	if (_mouseString)
		return;

	_mouseString = getMessage(_objectName1, ha->msg1);
	if (_intputCounter) {
		char *msgPtr = getMessage(_objectName1, ha->msg1);
		while (*msgPtr != 13)
			msgPtr++;
		*msgPtr = 0;
	} else if (!(ha->flags & kOBFNoShowName)) {
		_mousePrintFG++;
		_mouseString1 = _mouseString;
		_mouseString = (const char*)"showname \0";

	}
}

void AGOSEngine_PN::hitBox2(HitArea *ha) {
	if (!_intputCounter)
		hitBox1(ha);
}

void AGOSEngine_PN::hitBox3(HitArea *ha) {
	if (!_intputCounter)
		hitBox4(ha);
}

void AGOSEngine_PN::hitBox4(HitArea *ha) {
	if (_mouseString)
		return;

	uint16 num = ha->msg1 & ~0x8000;
	if ((_videoLockOut & 0x10) && !(ha->flags & (kOBFInventoryBox | kOBFRoomBox)) &&
		!testContainer(num)) {
		return;
	}

	_mouseString = getMessage(_objectName2, ha->msg2);
	_mouseString1 = getMessage(_objectName1, ha->msg1);
	_mousePrintFG++;
}

void AGOSEngine_PN::hitBox5(HitArea *ha) {
	if (_intputCounter || _mouseString)
		return;

	if (_dragStore && (_dragStore->flags & kOBFInventoryBox))
		return;

	_mousePrintFG++;
	_mouseString = (const char *)"take \0";
	_mouseString1 = _dragStore ? getMessage(_objectName1, _dragStore->msg1) : "";

	if (_dragStore->flags & kOBFRoomBox)
		_mouseString1 = (const char *)"all\r";
}

void AGOSEngine_PN::hitBox6(HitArea *ha) {
	if (_intputCounter || _mouseString)
		return;

	if (_dragStore->flags & kOBFRoomBox)
		return;

	_mousePrintFG++;
	_mouseString = (const char *)"drop \0";
	_mouseString1 = getMessage(_objectName1, _dragStore->msg1);

	if (_dragStore->flags & kOBFInventoryBox)
		_mouseString1 = (const char *)"all\r";
}

void AGOSEngine_PN::hitBox7(HitArea *ha) {
	if (_intputCounter) {
		if (!(ha->flags & kOBFUseEmptyLine)) {
			hitBox1(ha);
		}
		return;
	}

	if (_mouseString)
		return;

	_mousePrintFG++;
	_mouseString1 = getMessage(_objectName1, ha->msg1);

	uint16 num = ha->msg1 & ~0x8000;
	uint16 state = getptr(_quickptr[0] + num * _quickshort[0] + 2);
	if (state == 3) {
		_mouseString = (const char *)"unlock \0";
	} else if (state == 2) {
		_mouseString = (const char *)"open \0";
	} else {
		_mouseString = (const char *)"go through \0";
	}
}

void AGOSEngine_PN::hitBox8(HitArea *ha) {
	char *msgPtr, *tmpPtr;

	if (_intputCounter || _mouseString)
		return;

	if (_dragStore == ha)
		return;

	uint16 num = ha->msg1 & ~0x8000;
	if (!testSeen(num))
		return;

	msgPtr = getMessage(_objectName1, ha->msg1);
	Common::sprintf_s(_inMessage, " in %s", msgPtr);
	_mouseString1 = _inMessage;

	msgPtr = getMessage(_objectName1, _dragStore->msg1);
	*(tmpPtr = strchr(msgPtr, 13)) = 0;
	Common::sprintf_s(_placeMessage, "put %s", msgPtr);
	_mouseString = _placeMessage;
}

void AGOSEngine_PN::hitBox9(HitArea *ha) {
	if (_objectCountS == _objects) {
		_objectCountS = -1;
	}
	iconPage();
}

static const char *const messageList[9] = {
	"North\r",
	"East\r",
	"South\r",
	"West\r",
	"Up\r",
	"Down\r",
	"Push grey button\r",
	"Push red button\r",
	"Go under car\r"
};

void AGOSEngine_PN::hitBox11(HitArea *ha) {
	if (_intputCounter || _mouseString)
		return;

	_mouseString = messageList[ha->msg1];
	_mousePrintFG++;
}

} // End of namespace AGOS

================
File: vga.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Video script opcodes for Simon1/Simon2


#include "agos/agos.h"
#include "agos/intern.h"
#include "agos/sound.h"
#include "agos/vga.h"

#include "common/debug-channels.h"
#include "common/endian.h"
#include "common/system.h"
#include "common/textconsole.h"

#include "graphics/surface.h"

namespace AGOS {

// Opcode tables
void AGOSEngine::setupVideoOpcodes(VgaOpcodeProc *op) {
	op[1] = &AGOSEngine::vc1_fadeOut;
	op[2] = &AGOSEngine::vc2_call;
	op[3] = &AGOSEngine::vc3_loadSprite;
	op[4] = &AGOSEngine::vc4_fadeIn;
	op[5] = &AGOSEngine::vc5_ifEqual;
	op[6] = &AGOSEngine::vc6_ifObjectHere;
	op[7] = &AGOSEngine::vc7_ifObjectNotHere;
	op[8] = &AGOSEngine::vc8_ifObjectIsAt;
	op[9] = &AGOSEngine::vc9_ifObjectStateIs;
	op[10] = &AGOSEngine::vc10_draw;
	op[12] = &AGOSEngine::vc12_delay;
	op[13] = &AGOSEngine::vc13_addToSpriteX;
	op[14] = &AGOSEngine::vc14_addToSpriteY;
	op[15] = &AGOSEngine::vc15_sync;
	op[16] = &AGOSEngine::vc16_waitSync;
	op[18] = &AGOSEngine::vc18_jump;
	op[20] = &AGOSEngine::vc20_setRepeat;
	op[21] = &AGOSEngine::vc21_endRepeat;
	op[23] = &AGOSEngine::vc23_setPriority;
	op[24] = &AGOSEngine::vc24_setSpriteXY;
	op[25] = &AGOSEngine::vc25_halt_sprite;
	op[26] = &AGOSEngine::vc26_setSubWindow;
	op[27] = &AGOSEngine::vc27_resetSprite;
	op[29] = &AGOSEngine::vc29_stopAllSounds;
	op[30] = &AGOSEngine::vc30_setFrameRate;
	op[31] = &AGOSEngine::vc31_setWindow;
	op[33] = &AGOSEngine::vc33_setMouseOn;
	op[34] = &AGOSEngine::vc34_setMouseOff;
	op[35] = &AGOSEngine::vc35_clearWindow;
	op[36] = &AGOSEngine::vc36_setWindowImage;
	op[38] = &AGOSEngine::vc38_ifVarNotZero;
	op[39] = &AGOSEngine::vc39_setVar;
	op[40] = &AGOSEngine::vc40_scrollRight;
	op[41] = &AGOSEngine::vc41_scrollLeft;
	op[42] = &AGOSEngine::vc42_delayIfNotEQ;
	op[43] = &AGOSEngine::vc43_ifBitSet;
	op[44] = &AGOSEngine::vc44_ifBitClear;
	op[45] = &AGOSEngine::vc45_setSpriteX;
	op[46] = &AGOSEngine::vc46_setSpriteY;
	op[47] = &AGOSEngine::vc47_addToVar;
	op[49] = &AGOSEngine::vc49_setBit;
	op[50] = &AGOSEngine::vc50_clearBit;
	op[51] = &AGOSEngine::vc51_enableBox;
	op[52] = &AGOSEngine::vc52_playSound;
	op[55] = &AGOSEngine::vc55_moveBox;
}

void AGOSEngine_Elvira1::setupVideoOpcodes(VgaOpcodeProc *op) {
	op[1] = &AGOSEngine::vc1_fadeOut;
	op[2] = &AGOSEngine::vc2_call;
	op[3] = &AGOSEngine::vc3_loadSprite;
	op[4] = &AGOSEngine::vc4_fadeIn;
	op[5] = &AGOSEngine::vc5_ifEqual;
	op[6] = &AGOSEngine::vc6_ifObjectHere;
	op[7] = &AGOSEngine::vc7_ifObjectNotHere;
	op[8] = &AGOSEngine::vc8_ifObjectIsAt;
	op[9] = &AGOSEngine::vc9_ifObjectStateIs;
	op[10] = &AGOSEngine::vc10_draw;
	op[13] = &AGOSEngine::vc12_delay;
	op[14] = &AGOSEngine::vc13_addToSpriteX;
	op[15] = &AGOSEngine::vc14_addToSpriteY;
	op[16] = &AGOSEngine::vc15_sync;
	op[17] = &AGOSEngine::vc16_waitSync;
	op[18] = &AGOSEngine::vc17_waitEnd;
	op[19] = &AGOSEngine::vc18_jump;
	op[20] = &AGOSEngine::vc19_loop;
	op[21] = &AGOSEngine::vc20_setRepeat;
	op[22] = &AGOSEngine::vc21_endRepeat;
	op[23] = &AGOSEngine::vc22_setPalette;
	op[24] = &AGOSEngine::vc23_setPriority;
	op[25] = &AGOSEngine::vc24_setSpriteXY;
	op[26] = &AGOSEngine::vc25_halt_sprite;
	op[27] = &AGOSEngine::vc26_setSubWindow;
	op[28] = &AGOSEngine::vc27_resetSprite;
	op[29] = &AGOSEngine::vc28_playSFX;
	op[30] = &AGOSEngine::vc29_stopAllSounds;
	op[31] = &AGOSEngine::vc30_setFrameRate;
	op[32] = &AGOSEngine::vc31_setWindow;
	op[33] = &AGOSEngine::vc32_saveScreen;
	op[34] = &AGOSEngine::vc33_setMouseOn;
	op[35] = &AGOSEngine::vc34_setMouseOff;
	op[38] = &AGOSEngine::vc35_clearWindow;
	op[40] = &AGOSEngine::vc36_setWindowImage;
	op[41] = &AGOSEngine::vc37_pokePalette;
	op[51] = &AGOSEngine::vc38_ifVarNotZero;
	op[52] = &AGOSEngine::vc39_setVar;
	op[53] = &AGOSEngine::vc40_scrollRight;
	op[54] = &AGOSEngine::vc41_scrollLeft;
	op[56] = &AGOSEngine::vc42_delayIfNotEQ;
}

void AGOSEngine::setupVgaOpcodes() {
	memset(_vga_opcode_table, 0, sizeof(_vga_opcode_table));

	switch (getGameType()) {
	case GType_PN:
	case GType_ELVIRA1:
	case GType_ELVIRA2:
	case GType_WW:
	case GType_SIMON1:
	case GType_SIMON2:
	case GType_FF:
	case GType_PP:
		setupVideoOpcodes(_vga_opcode_table);
		break;
	default:
		error("setupVgaOpcodes: Unknown game");
	}
}

// VGA Script parser
void AGOSEngine::runVgaScript() {
	for (;;) {
		uint opcode;

		if (DebugMan.isDebugChannelEnabled(kDebugVGAOpcode)) {
			if (_vcPtr != (const byte *)&_vcGetOutOfCode) {
				debugN("%.5d %.5X: %5d %4d ", _vgaTickCounter, (unsigned int)(_vcPtr - _curVgaFile1), _vgaCurSpriteId, _vgaCurZoneNum);
				dumpVideoScript(_vcPtr, true);
			}
		}

		if (getGameType() == GType_SIMON2 || getGameType() == GType_FF || getGameType() == GType_PP) {
			opcode = *_vcPtr++;
		} else {
			opcode = READ_BE_UINT16(_vcPtr);
			_vcPtr += 2;
		}

		if (opcode == 0)
			return;

		if (opcode >= _numVideoOpcodes || !_vga_opcode_table[opcode])
			error("runVgaScript: Invalid VGA opcode '%d' encountered", opcode);

		(this->*_vga_opcode_table[opcode]) ();
	}
}

bool AGOSEngine::ifObjectHere(uint16 a) {
	Item *item;

	CHECK_BOUNDS(a, _objectArray);

	item = _objectArray[a];
	if (item == nullptr)
		return true;

	return me()->parent == item->parent;
}

bool AGOSEngine::ifObjectAt(uint16 a, uint16 b) {
	Item *item_a, *item_b;

	CHECK_BOUNDS(a, _objectArray);
	CHECK_BOUNDS(b, _objectArray);

	item_a = _objectArray[a];
	item_b = _objectArray[b];

	if (item_a == nullptr || item_b == nullptr)
		return true;

	return derefItem(item_a->parent) == item_b;
}

bool AGOSEngine::ifObjectState(uint16 a, int16 b) {
	Item *item;

	CHECK_BOUNDS(a, _objectArray);

	item = _objectArray[a];
	if (item == nullptr)
		return true;
	return item->state == b;
}

void AGOSEngine::dirtyBackGround() {
	AnimTable *animTable = _screenAnim1;
	while (animTable->srcPtr) {
		if (animTable->id == _vgaCurSpriteId && animTable->zoneNum == _vgaCurZoneNum) {
			animTable->windowNum |= 0x8000;
			break;
		}
		animTable++;
	}
}

VgaSprite *AGOSEngine::findCurSprite() {
	VgaSprite *vsp = _vgaSprites;
	while (vsp->id) {
		if (vsp->id == _vgaCurSpriteId && vsp->zoneNum == _vgaCurZoneNum)
			break;
		vsp++;
	}
	return vsp;
}

bool AGOSEngine::isSpriteLoaded(uint16 id, uint16 zoneNum) {
	VgaSprite *vsp = _vgaSprites;
	while (vsp->id) {
		if (vsp->id == id && vsp->zoneNum == zoneNum)
			return true;
		vsp++;
	}
	return false;
}

bool AGOSEngine::getBitFlag(uint bit) {
	uint16 *bits = &_bitArray[bit / 16];
	return (*bits & (1 << (bit & 15))) != 0;
}

void AGOSEngine::setBitFlag(uint bit, bool value) {
	uint16 *bits = &_bitArray[bit / 16];
	*bits = (*bits & ~(1 << (bit & 15))) | (value << (bit & 15));
}

int AGOSEngine::vcReadVarOrWord() {
	if (getGameType() == GType_PN || getGameType() == GType_ELVIRA1) {
		return vcReadNextWord();
	} else {
		int16 var = vcReadNextWord();
		if (var < 0)
			var = vcReadVar(-var);
		return var;
	}
}

uint AGOSEngine::vcReadNextWord(bool forceLERead) {
	uint a;
	a = readUint16Wrapper(_vcPtr);
	if (forceLERead)
		a = FROM_BE_16(a);
	_vcPtr += 2;
	return a;
}

uint AGOSEngine::vcReadNextByte() {
	return *_vcPtr++;
}

uint AGOSEngine::vcReadVar(uint var) {
	assert(var < _numVars);
	return (uint16)_variableArrayPtr[var];
}

void AGOSEngine::vcWriteVar(uint var, int16 value) {
	assert(var < _numVars);
	_variableArrayPtr[var] = value;
}

void AGOSEngine::vcSkipNextInstruction() {

	static const byte opcodeParamLenPN[] = {
		0, 6,  2, 10, 6, 4, 2, 2,
		4, 4,  8,  2, 0, 2, 2, 2,
		0, 2,  2,  2, 0, 4, 2, 2,
		2, 8,  0, 10, 0, 8, 0, 2,
		2, 0,  0,  0, 0, 2, 4, 2,
		4, 4,  0,  0, 2, 2, 2, 4,
		4, 0, 18,  2, 4, 4, 4, 0,
		4
	};

	static const byte opcodeParamLenElvira1[] = {
		0, 6,  2, 10, 6, 4, 2, 2,
		4, 4,  8,  2, 0, 2, 2, 2,
		2, 2,  2,  2, 0, 4, 2, 2,
		2, 8,  0, 10, 0, 8, 0, 2,
		2, 0,  0,  0, 0, 2, 4, 2,
		4, 4,  0,  0, 2, 2, 2, 4,
		4, 0, 18,  2, 4, 4, 4, 0,
		4
	};

	static const byte opcodeParamLenWW[] = {
		0, 6,  2, 10, 6, 4, 2, 2,
		4, 4,  8,  2, 2, 2, 2, 2,
		2, 2,  2,  0, 4, 2, 2, 2,
		8, 0, 10,  0, 8, 0, 2, 2,
		0, 0,  0,  4, 4, 4, 2, 4,
		4, 4,  4,  2, 2, 4, 2, 2,
		2, 2,  2,  2, 2, 4, 6, 6,
		0, 0,  0,  0, 2, 2, 0, 0,
	};

	static const byte opcodeParamLenSimon1[] = {
		0, 6,  2, 10, 6, 4, 2, 2,
		4, 4, 10,  0, 2, 2, 2, 2,
		2, 0,  2,  0, 4, 2, 4, 2,
		8, 0, 10,  0, 8, 0, 2, 2,
		4, 0,  0,  4, 4, 2, 2, 4,
		4, 4,  4,  2, 2, 2, 2, 4,
		0, 2,  2,  2, 2, 4, 6, 6,
		0, 0,  0,  0, 2, 6, 0, 0,
	};

	static const byte opcodeParamLenSimon2[] = {
		0, 6,  2, 12, 6, 4, 2, 2,
		4, 4,  9,  0, 1, 2, 2, 2,
		2, 0,  2,  0, 4, 2, 4, 2,
		7, 0, 10,  0, 8, 0, 2, 2,
		4, 0,  0,  4, 4, 2, 2, 4,
		4, 4,  4,  2, 2, 2, 2, 4,
		0, 2,  2,  2, 2, 4, 6, 6,
		2, 0,  6,  6, 4, 6, 0, 0,
		0, 0,  4,  4, 4, 4, 4, 0,
		4, 2,  2
	};

	static const byte opcodeParamLenFeebleFiles[] = {
		0, 6, 2, 12, 6, 4, 2, 2,
		4, 4, 9, 0, 1, 2, 2, 2,
		2, 0, 2, 0, 4, 2, 4, 2,
		7, 0, 10, 0, 8, 0, 2, 2,
		4, 0, 0, 4, 4, 2, 2, 4,
		4, 4, 4, 2, 2, 2, 2, 4,
		0, 2, 2, 2, 6, 6, 6, 6,
		2, 0, 6, 6, 4, 6, 0, 0,
		0, 0, 4, 4, 4, 4, 4, 0,
		4, 2, 2, 4, 6, 6, 0, 0,
		6, 4, 2, 6, 0
	};

	uint16 opcode;
	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		opcode = vcReadNextByte();
		_vcPtr += opcodeParamLenFeebleFiles[opcode];
	} else if (getGameType() == GType_SIMON2) {
		opcode = vcReadNextByte();
		_vcPtr += opcodeParamLenSimon2[opcode];
	} else if (getGameType() == GType_SIMON1) {
		opcode = vcReadNextWord();
		_vcPtr += opcodeParamLenSimon1[opcode];
	} else if (getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) {
		opcode = vcReadNextWord();
		_vcPtr += opcodeParamLenWW[opcode];
	} else if (getGameType() == GType_ELVIRA1) {
		opcode = vcReadNextWord();
		_vcPtr += opcodeParamLenElvira1[opcode];
	} else {
		opcode = vcReadNextWord();
		_vcPtr += opcodeParamLenPN[opcode];
	}

	debugCN(kDebugVGAOpcode, "; skipped\n");
}

// VGA Script commands
void AGOSEngine::vc1_fadeOut() {
	/* dummy opcode */
	_vcPtr += 6;
}

void AGOSEngine::vc2_call() {
	uint16 num;
	byte *old_file_1, *old_file_2;

	if (getGameType() == GType_ELVIRA2) {
		num = vcReadNextWord();
	} else {
		num = vcReadVarOrWord();
	}

	old_file_1 = _curVgaFile1;
	old_file_2 = _curVgaFile2;

	setImage(num, true);

	_curVgaFile1 = old_file_1;
	_curVgaFile2 = old_file_2;
}

void AGOSEngine::vc3_loadSprite() {
	uint16 windowNum, zoneNum, palette, vgaSpriteId;
	int16 x, y;
	byte *old_file_1;

	windowNum = vcReadNextWord();
	if (getGameType() == GType_SIMON1 && windowNum == 3) {
		_window3Flag = 1;
	}

	if (getGameType() == GType_SIMON2 || getGameType() == GType_FF || getGameType() == GType_PP) {
		zoneNum = vcReadNextWord();
		vgaSpriteId = vcReadNextWord();
	} else {
		vgaSpriteId = vcReadNextWord();
		zoneNum = (getGameType() == GType_PN) ? 0 : vgaSpriteId / 100;
	}

	x = vcReadNextWord();
	y = vcReadNextWord();
	palette = vcReadNextWord();

	old_file_1 = _curVgaFile1;

	animate(windowNum, zoneNum, vgaSpriteId, x, y, palette, true);

	_curVgaFile1 = old_file_1;
}

void AGOSEngine::vc4_fadeIn() {
	/* dummy opcode */
	_vcPtr += 6;
}

void AGOSEngine::vc5_ifEqual() {
	uint16 var;

	if (getGameType() == GType_PP)
		var = vcReadVarOrWord();
	else
		var = vcReadNextWord();

	uint16 value = vcReadNextWord();
	if (vcReadVar(var) != value)
		vcSkipNextInstruction();
}

void AGOSEngine::vc6_ifObjectHere() {
	if (!ifObjectHere(vcReadNextWord())) {
		vcSkipNextInstruction();
	}
}

void AGOSEngine::vc7_ifObjectNotHere() {
	if (ifObjectHere(vcReadNextWord()))
		vcSkipNextInstruction();
}

void AGOSEngine::vc8_ifObjectIsAt() {
	uint16 a = vcReadNextWord();
	uint16 b = vcReadNextWord();
	if (!ifObjectAt(a, b))
		vcSkipNextInstruction();
}

void AGOSEngine::vc9_ifObjectStateIs() {
	uint16 a = vcReadNextWord();
	uint16 b = vcReadNextWord();
	if (!ifObjectState(a, b))
		vcSkipNextInstruction();
}

byte *AGOSEngine::vc10_uncompressFlip(const byte *src, uint16 w, uint16 h) {
	w *= 8;

	byte *dst, *dstPtr, *srcPtr;
	byte color;
	int8 cur = -0x80;
	uint i, w_cur = w;

	dstPtr = _videoBuf1 + w;

	do {
		dst = dstPtr;
		uint h_cur = h;

		if (cur == -0x80)
			cur = *src++;

		for (;;) {
			if (cur >= 0) {
				/* rle_same */
				color = *src++;
				do {
					*dst = color;
					dst += w;
					if (!--h_cur) {
						if (--cur < 0)
							cur = -0x80;
						else
							src--;
						goto next_line;
					}
				} while (--cur >= 0);
			} else {
				/* rle_diff */
				do {
					*dst = *src++;
					dst += w;
					if (!--h_cur) {
						if (++cur == 0)
							cur = -0x80;
						goto next_line;
					}
				} while (++cur != 0);
			}
			cur = *src++;
		}
	next_line:
		dstPtr++;
	} while (--w_cur);

	srcPtr = dstPtr = _videoBuf1 + w;

	do {
		dst = dstPtr;
		for (i = 0; i != w; ++i) {
			byte b = srcPtr[i];
			b = (b >> 4) | (b << 4);
			*--dst = b;
		}

		srcPtr += w;
		dstPtr += w;
	} while (--h);

	return _videoBuf1;
}

byte *AGOSEngine::vc10_flip(const byte *src, uint16 w, uint16 h) {
	byte *dstPtr;
	uint i;

	if (getFeatures() & GF_32COLOR) {
		w *= 16;
		dstPtr = _videoBuf1 + w;

		do {
			byte *dst = dstPtr;
			for (i = 0; i != w; ++i) {
				*--dst = src[i];
			}

			src += w;
			dstPtr += w;
		} while (--h);
	} else {
		w *= 8;
		dstPtr = _videoBuf1 + w;

		do {
			byte *dst = dstPtr;
			for (i = 0; i != w; ++i) {
				byte b = src[i];
				b = (b >> 4) | (b << 4);
				*--dst = b;
			}

			src += w;
			dstPtr += w;
		} while (--h);
	}

	return _videoBuf1;
}

void AGOSEngine::vc10_draw() {
	uint16 palette, x, y, flags;
	int16 image;

	image = (int16)vcReadNextWord();

	palette = 0;
	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		palette = _vcPtr[0];
		_vcPtr += 2;
	} else if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
		palette = _vcPtr[1];
		_vcPtr += 2;
	}

	x = (int16)vcReadNextWord();
	y = (int16)vcReadNextWord();

	if (getGameType() == GType_SIMON2 || getGameType() == GType_FF || getGameType() == GType_PP) {
		flags = vcReadNextByte();
	} else {
		flags = vcReadNextWord();
	}

	drawImage_init(image, palette, x, y, flags);
}

void AGOSEngine::drawImage_init(int16 image, uint16 palette, int16 x, int16 y, uint16 flags) {
	if (image == 0)
		return;

	byte *src;
	uint width, height;
	VC10_state state;

	state.image = image;
	if (state.image < 0)
		state.image = vcReadVar(-state.image);

	state.palette = (getGameType() == GType_PN) ? 0 : palette * 16;
	state.paletteMod = 0;

	state.x = x - _scrollX;
	state.y = y - _scrollY;

	state.flags = flags;

	src = _curVgaFile2 + state.image * 8;
	state.srcPtr = _curVgaFile2 + (getPlatform() == Common::kPlatformPC98 ? READ_LE_UINT32(src) : readUint32Wrapper(src));
	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		width = READ_LE_UINT16(src + 6);
		height = READ_LE_UINT16(src + 4) & 0x7FFF;
		flags = src[5];
	} else {
		width = (getPlatform() == Common::kPlatformPC98 ? READ_LE_UINT16(src + 6) : READ_BE_UINT16(src + 6)) / 16;
		height = src[5];
		flags = src[4];
	}

	if (height == 0 || width == 0)
		return;

	if (DebugMan.isDebugChannelEnabled(kDebugImageDump))
		dumpSingleBitmap(_vgaCurZoneNum, state.image, state.srcPtr, width, height,
											 state.palette);
	state.width = state.draw_width = width;		/* cl */
	state.height = state.draw_height = height;	/* ch */

	state.depack_cont = -0x80;

	state.x_skip = 0;				/* colums to skip = bh */
	state.y_skip = 0;				/* rows to skip   = bl */

	if (getFeatures() & GF_PLANAR) {
		if (getGameType() == GType_PN) {
			state.srcPtr = convertAmigaImage(&state, ((state.flags & (kDFCompressed | kDFCompressedFlip)) != 0));
		} else
			state.srcPtr = convertAmigaImage(&state, ((flags & 0x80) != 0));

		// converted planar clip is already uncompressed
		if (state.flags & kDFCompressedFlip) {
			state.flags &= ~kDFCompressedFlip;
			state.flags |= kDFFlip;
		}
		if (state.flags & kDFCompressed) {
			state.flags &= ~kDFCompressed;
		}
	} else if (getGameType() == GType_FF || getGameType() == GType_PP) {
		if (flags & 0x80) {
			state.flags |= kDFCompressed;
		}
	} else {
		if (flags & 0x80 && !(state.flags & kDFCompressedFlip)) {
			if (state.flags & kDFFlip) {
				state.flags &= ~kDFFlip;
				state.flags |= kDFCompressedFlip;
			} else {
				state.flags |= kDFCompressed;
			}
		}
	}

	if (getPlatform() == Common::kPlatformPC98)
		convertPC98Image(state);

	uint maxWidth = (getGameType() == GType_FF || getGameType() == GType_PP) ? 640 : 20;
	if ((getGameType() == GType_SIMON2 || getGameType() == GType_FF) && width > maxWidth) {
		horizontalScroll(&state);
		return;
	}
	if (getGameType() == GType_FF && height > 480) {
		verticalScroll(&state);
		return;
	}

	if (getGameType() != GType_FF && getGameType() != GType_PP) {
		if (state.flags & kDFCompressedFlip) {
			state.srcPtr = vc10_uncompressFlip(state.srcPtr, width, height);
		} else if (state.flags & kDFFlip) {
			state.srcPtr = vc10_flip(state.srcPtr, width, height);
		}
	}

	drawImage(&state);
}

void AGOSEngine::checkOnStopTable() {
	VgaSleepStruct *vfs = _onStopTable, *vfs_tmp;
	while (vfs->ident != 0) {
		if (vfs->ident == _vgaCurSpriteId) {
			VgaSprite *vsp = findCurSprite();
			animate(vsp->windowNum, vsp->zoneNum, vfs->id, vsp->x, vsp->y, vsp->palette, true);
			vfs_tmp = vfs;
			do {
				memcpy(vfs_tmp, vfs_tmp + 1, sizeof(VgaSleepStruct));
				vfs_tmp++;
			} while (vfs_tmp->ident != 0);
		} else {
			vfs++;
		}
	}
}

void AGOSEngine::vc11_onStop() {
	uint16 id = vcReadNextWord();

	VgaSleepStruct *vfs = _onStopTable;
	while (vfs->ident)
		vfs++;

	vfs->ident = _vgaCurSpriteId;
	vfs->codePtr = _vcPtr;
	vfs->id = id;
	vfs->zoneNum = _vgaCurZoneNum;
}

void AGOSEngine::vc12_delay() {
	uint16 num;

	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		num = vcReadNextByte();
	} else if (getGameType() == GType_SIMON2) {
		num = vcReadNextByte() * _frameCount;
	} else {
		num = vcReadVarOrWord() * _frameCount;
	}

	num += _vgaBaseDelay;

	addVgaEvent(num, ANIMATE_EVENT, _vcPtr, _vgaCurSpriteId, _vgaCurZoneNum);
	_vcPtr = (byte *)&_vcGetOutOfCode;
}

void AGOSEngine::vc13_addToSpriteX() {
	VgaSprite *vsp = findCurSprite();
	vsp->x += (int16)vcReadNextWord();

	vsp->windowNum |= 0x8000;
	dirtyBackGround();
	_vgaSpriteChanged++;
}

void AGOSEngine::vc14_addToSpriteY() {
	VgaSprite *vsp = findCurSprite();
	vsp->y += (int16)vcReadNextWord();

	vsp->windowNum |= 0x8000;
	dirtyBackGround();
	_vgaSpriteChanged++;
}

void AGOSEngine::vc15_sync() {
	VgaSleepStruct *vfs = _waitSyncTable, *vfs_tmp;
	uint16 id;

	if (getGameType() == GType_PN)
		id = _vgaCurSpriteId;
	else
		id = vcReadNextWord();

	while (vfs->ident != 0) {
		if (vfs->ident == id) {
			addVgaEvent(_vgaBaseDelay, ANIMATE_EVENT, vfs->codePtr, vfs->id, vfs->zoneNum);
			vfs_tmp = vfs;
			do {
				memcpy(vfs_tmp, vfs_tmp + 1, sizeof(VgaSleepStruct));
				vfs_tmp++;
			} while (vfs_tmp->ident != 0);
		} else {
			vfs++;
		}
	}

	_lastVgaWaitFor = id;
	/* clear a wait event */
	if (id == _vgaWaitFor)
		_vgaWaitFor = 0;
}

void AGOSEngine::vc16_waitSync() {
	VgaSleepStruct *vfs = _waitSyncTable;
	while (vfs->ident)
		vfs++;

	vfs->ident = vcReadNextWord();
	vfs->codePtr = _vcPtr;
	vfs->id = _vgaCurSpriteId;
	vfs->zoneNum = _vgaCurZoneNum;

	_vcPtr = (byte *)&_vcGetOutOfCode;
}

void AGOSEngine::checkWaitEndTable() {
	VgaSleepStruct *vfs = _waitEndTable, *vfs_tmp;
	while (vfs->ident != 0) {
		if (vfs->ident == _vgaCurSpriteId) {
			addVgaEvent(_vgaBaseDelay, ANIMATE_EVENT, vfs->codePtr, vfs->id, vfs->zoneNum);
			vfs_tmp = vfs;
			do {
				memcpy(vfs_tmp, vfs_tmp + 1, sizeof(VgaSleepStruct));
				vfs_tmp++;
			} while (vfs_tmp->ident != 0);
		} else {
			vfs++;
		}
	}
}

void AGOSEngine::vc17_waitEnd() {
	uint16 id = vcReadNextWord();
	uint16 zoneNum = (getGameType() == GType_PN) ? 0 : id / 100;

	VgaSleepStruct *vfs = _waitEndTable;
	while (vfs->ident)
		vfs++;

	if (isSpriteLoaded(id, zoneNum)) {
		vfs->ident = id;
		vfs->codePtr = _vcPtr;
		vfs->id = _vgaCurSpriteId;
		vfs->zoneNum = _vgaCurZoneNum;
		_vcPtr = (byte *)&_vcGetOutOfCode;
	}
}

void AGOSEngine::vc18_jump() {
	int16 offs = vcReadNextWord();
	_vcPtr += offs;
}

void AGOSEngine::vc19_loop() {
	uint16 count;
	byte *b, *bb;

	bb = _curVgaFile1;
	b = _curVgaFile1 + READ_BE_UINT16(bb + 10);
	b += 20;

	count = READ_BE_UINT16(&((VgaFile1Header_Common *) b)->animationCount);
	b = bb + READ_BE_UINT16(&((VgaFile1Header_Common *) b)->animationTable);

	while (count--) {
		if (READ_BE_UINT16(&((AnimationHeader_WW *) b)->id) == _vgaCurSpriteId)
			break;
		b += sizeof(AnimationHeader_WW);
	}
	assert(READ_BE_UINT16(&((AnimationHeader_WW *) b)->id) == _vgaCurSpriteId);

	_vcPtr = _curVgaFile1 + READ_BE_UINT16(&((AnimationHeader_WW *) b)->scriptOffs);
}

void AGOSEngine::vc20_setRepeat() {
	// Sets counter used by the endRepeat opcode below.
	uint16 a = vcReadNextWord();
	WRITE_LE_UINT16(const_cast<byte *>(_vcPtr), a);
	_vcPtr += 2;
}

void AGOSEngine::vc21_endRepeat() {
	int16 a = vcReadNextWord();
	const byte *tmp = _vcPtr + a;
	if (getGameType() == GType_SIMON2 || getGameType() == GType_FF || getGameType() == GType_PP)
		tmp += 3;
	else
		tmp += 4;

	uint16 val = READ_LE_UINT16(tmp);
	if (val != 0) {
		// Decrement counter
		WRITE_LE_UINT16(const_cast<byte *>(tmp), val - 1);
		_vcPtr = tmp + 2;
	}
}

static const uint8 iconPalette[64] = {
	0x00, 0x00, 0x00,
	0x77, 0x77, 0x55,
	0x55, 0x00, 0x00,
	0x77, 0x00, 0x00,
	0x22, 0x00, 0x00,
	0x00, 0x11, 0x00,
	0x11, 0x22, 0x11,
	0x22, 0x33, 0x22,
	0x44, 0x55, 0x44,
	0x33, 0x44, 0x00,
	0x11, 0x33, 0x00,
	0x00, 0x11, 0x44,
	0x77, 0x44, 0x00,
	0x66, 0x22, 0x00,
	0x00, 0x22, 0x66,
	0x77, 0x55, 0x00,
};

void AGOSEngine::vc22_setPalette() {
	byte *offs, *palptr, *src;
	uint16 b, num;

	b = vcReadNextWord();

	// PC EGA version of Personal Nightmare uses standard EGA palette
	if (getGameType() == GType_PN && (getFeatures() & GF_EGA))
		return;

	num = 16;

	palptr = _displayPalette;
	_bottomPalette = 1;

	if (getGameType() == GType_PN) {
		if (b > 128) {
			b -= 128;
			palptr = _displayPalette + 3 * 16;
		}
	} else if (getGameType() == GType_ELVIRA1) {
		if (b >= 1000) {
			b -= 1000;
			_bottomPalette = 0;
		} else {
			const byte extraColors[19 * 3] = {
				40,  0,  0,   24, 24, 16,   48, 48, 40,
				 0,  0,  0,   16,  0,  0,    8,  8,  0,
				48, 24,  0,   56, 40,  0,    0,  0, 24,
				 8, 16, 24,   24, 32, 40,   16, 24,  0,
				24,  8,  0,   16, 16,  0,   40, 40, 32,
				32, 32, 24,   40,  0,  0,   24, 24, 16,
				48, 48, 40
			};

			num = 13;

			for (int i = 0; i < 19; i++) {
				palptr[(13 + i) * 3 + 0] = extraColors[i * 3 + 0] * 4;
				palptr[(13 + i) * 3 + 1] = extraColors[i * 3 + 1] * 4;
				palptr[(13 + i) * 3 + 2] = extraColors[i * 3 + 2] * 4;
			}
		}
	}

	if (getGameType() == GType_ELVIRA2 && getPlatform() == Common::kPlatformAtariST) {
		// Custom palette used for icon area
		palptr = &_displayPalette[13 * 3 * 16];
		for (uint8 c = 0; c < 16; c++) {
			palptr[0] = iconPalette[c * 3 + 0] * 2;
			palptr[1] = iconPalette[c * 3 + 1] * 2;
			palptr[2] = iconPalette[c * 3 + 2] * 2;

			palptr += 3;
		};
		palptr = _displayPalette;
	}

	offs = _curVgaFile1 + READ_BE_UINT16(_curVgaFile1 + 6);
	src = offs + b * 32;

	do {
		uint16 color = READ_BE_UINT16(src);
		palptr[0] = ((color & 0xf00) >> 8) * 32;
		palptr[1] = ((color & 0x0f0) >> 4) * 32;
		palptr[2] = ((color & 0x00f) >> 0) * 32;

		palptr += 3;
		src += 2;
	} while (--num);

	_paletteFlag = 2;
	_vgaSpriteChanged++;
}

void AGOSEngine::vc23_setPriority() {
	VgaSprite *vsp = findCurSprite(), *vus2;
	uint16 pri = vcReadNextWord();
	VgaSprite bak;

	if (vsp->id == 0)
		return;

	memcpy(&bak, vsp, sizeof(bak));
	bak.priority = pri;
	bak.windowNum |= 0x8000;

	vus2 = vsp;

	if (vsp != _vgaSprites && pri < vsp[-1].priority) {
		do {
			vsp--;
		} while (vsp != _vgaSprites && pri < vsp[-1].priority);
		do {
			memcpy(vus2, vus2 - 1, sizeof(VgaSprite));
		} while (--vus2 != vsp);
		memcpy(vus2, &bak, sizeof(VgaSprite));
	} else if (vsp[1].id != 0 && pri >= vsp[1].priority) {
		do {
			vsp++;
		} while (vsp[1].id != 0 && pri >= vsp[1].priority);
		do {
			memcpy(vus2, vus2 + 1, sizeof(VgaSprite));
		} while (++vus2 != vsp);
		memcpy(vus2, &bak, sizeof(VgaSprite));
	} else {
		vsp->priority = pri;
	}
	_vgaSpriteChanged++;
}

void AGOSEngine::vc24_setSpriteXY() {
	VgaSprite *vsp = findCurSprite();

	if (getGameType() == GType_ELVIRA2) {
		vsp->image = vcReadNextWord();
	} else {
		vsp->image = vcReadVarOrWord();
	}

	vsp->x += (int16)vcReadNextWord();
	vsp->y += (int16)vcReadNextWord();
	if (getGameType() == GType_SIMON2 || getGameType() == GType_FF || getGameType() == GType_PP) {
		vsp->flags = vcReadNextByte();
	} else {
		vsp->flags = vcReadNextWord();
	}

	vsp->windowNum |= 0x8000;
	dirtyBackGround();
	_vgaSpriteChanged++;
}

void AGOSEngine::vc25_halt_sprite() {
	checkWaitEndTable();
	checkOnStopTable();

	VgaSprite *vsp = findCurSprite();
	while (vsp->id != 0) {
		memcpy(vsp, vsp + 1, sizeof(VgaSprite));
		vsp++;
	}
	_vcPtr = (byte *)&_vcGetOutOfCode;

	dirtyBackGround();
	_vgaSpriteChanged++;
}

void AGOSEngine::vc26_setSubWindow() {
	uint16 *as = &_videoWindows[vcReadNextWord() * 4]; // number
	as[0] = vcReadNextWord(); // x
	as[1] = vcReadNextWord(); // y
	as[2] = vcReadNextWord(); // width
	as[3] = vcReadNextWord(); // height
}

void AGOSEngine::vc27_resetSprite() {
	VgaSprite bak, *vsp;
	VgaSleepStruct *vfs;
	VgaTimerEntry *vte, *vte2;

	_videoLockOut |= 8;

	_lastVgaWaitFor = 0;

	bak.reset();

	vsp = _vgaSprites;
	while (vsp->id) {
		// For animated heart in Elvira 2
		if (getGameType() == GType_ELVIRA2 && vsp->id == 100) {
			memcpy(&bak, vsp, sizeof(VgaSprite));
		}
		vsp->id = 0;
		vsp++;
	}

	if (bak.id != 0)
		memcpy(_vgaSprites, &bak, sizeof(VgaSprite));

	vfs = _waitEndTable;
	while (vfs->ident) {
		vfs->ident = 0;
		vfs++;
	}

	vfs = _waitSyncTable;
	while (vfs->ident) {
		vfs->ident = 0;
		vfs++;
	}

	vfs = _onStopTable;
	while (vfs->ident) {
		vfs->ident = 0;
		vfs++;
	}

	vte = _vgaTimerList;
	while (vte->delay) {
		// Skip the animateSprites event in earlier games
		if (vte->type == ANIMATE_INT) {
			vte++;
		// For animated heart in Elvira 2
		} else if (getGameType() == GType_ELVIRA2 && vte->id == 100) {
			vte++;
		} else {
			vte2 = vte;
			while (vte2->delay) {
				memcpy(vte2, vte2 + 1, sizeof(VgaTimerEntry));
				vte2++;
			}
		}
	}

	if (_videoLockOut & 0x20) {
		AnimTable *animTable = _screenAnim1;
		while (animTable->srcPtr) {
			animTable->srcPtr = nullptr;
			animTable++;
		}
	}

	if (getGameType() == GType_SIMON2 || getGameType() == GType_FF || getGameType() == GType_PP)
		vcWriteVar(254, 0);

	// Stop any OmniTV video that is currently been played
	if (getGameType() == GType_FF || getGameType() == GType_PP)
		setBitFlag(42, true);

	_videoLockOut &= ~8;
}

void AGOSEngine::vc28_playSFX() {
	uint16 sound = vcReadNextWord();
	uint16 chans = vcReadNextWord();
	uint16 freq = vcReadNextWord();
	uint16 flags = vcReadNextWord();
	debug(0, "vc28_playSFX: (sound %d, channels %d, frequency %d, flags %d)", sound, chans, freq, flags);

	// Waxworks uses 2 opcodes to play SFX: vc28 for digital SFX and vc52
	// for MIDI SFX. If a sound effect has both a MIDI and a digital
	// version, both opcodes are triggered. Only one of them should play
	// a sound effect.
	playSfx(sound, freq, flags, getGameType() == GType_WW);
}

void AGOSEngine::vc29_stopAllSounds() {
	if (getGameType() != GType_PP)
		_sound->stopVoice();

	stopAllSfx();
}

void AGOSEngine::vc30_setFrameRate() {
	_frameCount = vcReadNextWord();
}

void AGOSEngine::vc31_setWindow() {
	_windowNum = vcReadNextWord();
}

void AGOSEngine::vc32_saveScreen() {
	if (getGameType() == GType_PN) {
		Graphics::Surface *screen = getBackendSurface();
		byte *dst = getBackGround();
		byte *src = (byte *)screen->getPixels();
		for (int i = 0; i < _screenHeight; i++) {
			memcpy(dst, src, _screenWidth);
			dst += _backGroundBuf->pitch;
			src += screen->pitch;
		}
		updateBackendSurface();
	} else {
		uint16 xoffs = _videoWindows[4 * 4 + 0] * 16;
		uint16 yoffs = _videoWindows[4 * 4 + 1];
		uint16 width = _videoWindows[4 * 4 + 2] * 16;
		uint16 height = _videoWindows[4 * 4 + 3];

		byte *dst = (byte *)_backGroundBuf->getBasePtr(xoffs, yoffs);
		byte *src = (byte *)_window4BackScn->getPixels();
		uint16 srcWidth = _videoWindows[4 * 4 + 2] * 16;
		for (; height > 0; height--) {
			memcpy(dst, src, width);
			dst += _backGroundBuf->pitch;
			src += srcWidth;
		}
	}
}

void AGOSEngine::vc33_setMouseOn() {
	if (_mouseHideCount != 0) {
		_mouseHideCount = 1;
		if (getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) {
			// Set mouse palette
			_displayPalette[65 * 3 + 0] = 48 * 4;
			_displayPalette[65 * 3 + 1] = 48 * 4;
			_displayPalette[65 * 3 + 2] = 40 * 4;
			_paletteFlag = 1;
		}
		mouseOn();
	}
}

void AGOSEngine::vc34_setMouseOff() {
	mouseOff();
	_mouseHideCount = 200;
	_leftButtonDown = false;
}

void AGOSEngine::clearVideoBackGround(uint16 num, uint16 color) {
	const uint16 *vlut = &_videoWindows[num * 4];
	byte *dst = (byte *)_backGroundBuf->getBasePtr(vlut[0] * 16, vlut[1]);

	for (uint h = 0; h < vlut[3]; h++) {
		memset(dst, color, vlut[2] * 16);
		dst += _backGroundBuf->pitch;
	}
}

void AGOSEngine::clearVideoWindow(uint16 num, uint16 color) {
	if (getGameType() == GType_ELVIRA1) {
		if (num == 2 || num == 6)
			return;
	} else if (getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) {
		if (num != 4 && num < 10)
			return;
	} else if (getGameType() == GType_SIMON1) {
		if (num != 4)
			return;
	}

	if (getGameType() == GType_ELVIRA1 && num == 3) {
		Graphics::Surface *screen = getBackendSurface();
		byte *dst = (byte *)screen->getPixels();
		for (int i = 0; i < _screenHeight; i++) {
			memset(dst, color, _screenWidth);
			dst += screen->pitch;
		}
		clearHiResTextLayer();
		updateBackendSurface();
	} else {
		const uint16 *vlut = &_videoWindows[num * 4];
		uint16 xoffs = (vlut[0] - _videoWindows[16]) * 16;
		uint16 yoffs = (vlut[1] - _videoWindows[17]);
		uint16 dstWidth = _videoWindows[18] * 16;
		// TODO: Is there any known connection between dstWidth and the pitch
		// of the _window4BackScn Surface? If so, we might be able to pass
		// yoffs as proper y parameter to getBasePtr.
		byte *dst = (byte *)_window4BackScn->getBasePtr(xoffs, 0) + yoffs * dstWidth;

		setMoveRect(0, 0, vlut[2] * 16, vlut[3]);

		for (uint h = 0; h < vlut[3]; h++) {
			memset(dst, color, vlut[2] * 16);
			dst += dstWidth;
		}

		_window4Flag = 1;
	}
}

void AGOSEngine::vc35_clearWindow() {
	uint16 num = vcReadNextWord();
	uint16 color = vcReadNextWord();

	// Clear video background
	if (getGameType() == GType_ELVIRA1) {
		if (num == 2 || num == 6)
			return;
	} else if (getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) {
		if (num != 4 && num < 10)
			return;
	} else if (getGameType() == GType_SIMON1) {
		if (num != 4)
			return;
	}

	// Clear video window
	clearVideoWindow(num, color);
	clearVideoBackGround(num, color);
	_vgaSpriteChanged++;
}

void AGOSEngine::vc36_setWindowImage() {
	_displayFlag = 0;
	uint16 vga_res = vcReadNextWord();
	uint16 windowNum = vcReadNextWord();
	setWindowImage(windowNum, vga_res);
}

void AGOSEngine::vc37_pokePalette() {
	uint16 offs = vcReadNextWord();
	uint16 color = vcReadNextWord();

	// PC EGA version of Personal Nightmare uses standard EGA palette
	if (getGameType() == GType_PN && (getFeatures() & GF_EGA))
		return;

	byte *palptr = _displayPalette + offs * 3;
	palptr[0] = ((color & 0xf00) >> 8) * 32;
	palptr[1] = ((color & 0x0f0) >> 4) * 32;
	palptr[2] = ((color & 0x00f) >> 0) * 32;

	if (!(_videoLockOut & 0x20)) {
		_paletteFlag = 1;
		_displayFlag++;
	}
}

void AGOSEngine::vc38_ifVarNotZero() {
	uint16 var;
	if (getGameType() == GType_PP)
		var = vcReadVarOrWord();
	else
		var = vcReadNextWord();

	if (vcReadVar(var) == 0)
		vcSkipNextInstruction();
}

void AGOSEngine::vc39_setVar() {
	uint16 var;
	if (getGameType() == GType_PP)
		var = vcReadVarOrWord();
	else
		var = vcReadNextWord();

	int16 value = vcReadNextWord();
	vcWriteVar(var, value);
}

void AGOSEngine::vc40_scrollRight() {
	uint16 var = vcReadNextWord();
	int16 value = vcReadVar(var) + vcReadNextWord();

	if (getGameType() == GType_SIMON2 && var == 15 && !getBitFlag(80)) {
		if ((_scrollCount < 0) || (_scrollCount == 0 && _scrollFlag == 0)) {
			_scrollCount = 0;
			if (value - _scrollX >= 30) {
				_scrollCount = MIN(20, _scrollXMax - _scrollX);
				addVgaEvent(6, SCROLL_EVENT, nullptr, 0, 0);
			}
		}
	}

	vcWriteVar(var, value);
}

void AGOSEngine::vc41_scrollLeft() {
	uint16 var = vcReadNextWord();
	int16 value = vcReadVar(var) - vcReadNextWord();

	if (getGameType() == GType_SIMON2 && var == 15 && !getBitFlag(80)) {
		if ((_scrollCount > 0) || (_scrollCount == 0 && _scrollFlag == 0)) {
			_scrollCount = 0;
			if ((uint16)(value - _scrollX) < 11) {
				_scrollCount = -MIN(20, (int)_scrollX);
				addVgaEvent(6, SCROLL_EVENT, nullptr, 0, 0);
			}
		}
	}

	vcWriteVar(var, value);
}

void AGOSEngine::vc42_delayIfNotEQ() {
	uint16 val = vcReadVar(vcReadNextWord());
	if (val != vcReadNextWord()) {
		addVgaEvent(_frameCount + 1, ANIMATE_EVENT, _vcPtr - 4, _vgaCurSpriteId, _vgaCurZoneNum);
		_vcPtr = (byte *)&_vcGetOutOfCode;
	}
}

} // End of namespace AGOS

================
File: vga.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_VGA_H
#define AGOS_VGA_H

namespace AGOS {

#include "common/pack-start.h"	// START STRUCT PACKING

// Feeble Files
struct VgaFile1Header_Feeble {
	uint16 imageCount;
	uint16 x_2;
	uint16 animationCount;
	uint16 x_3;
	uint16 imageTable;
	uint16 x_4;
	uint16 animationTable;
	uint16 x_5;
} PACKED_STRUCT;

struct ImageHeader_Feeble {
	uint16 id;
	uint16 x_1;
	uint16 scriptOffs;
	uint16 x_2;
} PACKED_STRUCT;

struct AnimationHeader_Feeble {
	uint16 scriptOffs;
	uint16 x_2;
	uint16 id;
} PACKED_STRUCT;

// Simon 1/2
struct ImageHeader_Simon {
	uint16 id;
	uint16 color;
	uint16 x_2;
	uint16 scriptOffs;
} PACKED_STRUCT;

struct AnimationHeader_Simon {
	uint16 id;
	uint16 x_2;
	uint16 scriptOffs;
} PACKED_STRUCT;


// Elvira 1/2 and Waxworks
struct ImageHeader_WW {
	uint16 id;
	uint16 color;
	uint16 x_2;
	uint16 scriptOffs;
} PACKED_STRUCT;

struct AnimationHeader_WW {
	uint16 id;
	uint16 x_1;
	uint16 x_2;
	uint16 scriptOffs;
} PACKED_STRUCT;

// Common
struct VgaFile1Header_Common {
	uint16 x_1;
	uint16 imageCount;
	uint16 x_2;
	uint16 animationCount;
	uint16 x_3;
	uint16 imageTable;
	uint16 x_4;
	uint16 animationTable;
	uint16 x_5;
} PACKED_STRUCT;

#include "common/pack-end.h"	// END STRUCT PACKING

enum DrawFlags {
	kDFFlip           = 0x1,
	kDFNonTrans       = 0x2,
	kDFSkipStoreBG    = 0x4,
	kDFCompressed     = 0x8,
	kDFCompressedFlip = 0x10,
	kDFMasked         = 0x20,

	// Feeble specific
	kDFOverlayed      = 0x10,
	kDFScaled         = 0x40,
	kDFShaded         = 0x80
};

struct VC10_state {
	int16 image;
	uint16 flags;
	byte palette;
	byte paletteMod;

	int16 x, y;
	uint16 width, height;
	uint16 draw_width, draw_height;
	uint16 x_skip, y_skip;

	byte *surf2_addr;
	uint surf2_pitch;

	byte *surf_addr;
	uint surf_pitch;

	uint16 dl, dh;

	const byte *srcPtr;
	int8 depack_cont;

	byte depack_dest[480];

	VC10_state() { memset(this, 0, sizeof(*this)); }
};

byte *vc10_depackColumn(VC10_state *vs);

} // End of namespace AGOS

#endif

================
File: vga_e2.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Video script opcodes for Simon1/Simon2


#include "agos/agos.h"
#include "agos/intern.h"
#include "agos/sound.h"

#include "common/endian.h"
#include "common/system.h"

#include "graphics/surface.h"
#include "graphics/paletteman.h"

namespace AGOS {

void AGOSEngine_Elvira2::setupVideoOpcodes(VgaOpcodeProc *op) {
	AGOSEngine::setupVideoOpcodes(op);

	op[17] = &AGOSEngine::vc17_waitEnd;
	op[19] = &AGOSEngine::vc19_loop;
	op[22] = &AGOSEngine::vc22_setPalette;
	op[28] = &AGOSEngine::vc28_playSFX;
	op[32] = &AGOSEngine::vc32_saveScreen;
	op[37] = &AGOSEngine::vc37_pokePalette;
	op[45] = &AGOSEngine::vc45_setWindowPalette;
	op[46] = &AGOSEngine::vc46_setPaletteSlot1;
	op[47] = &AGOSEngine::vc47_setPaletteSlot2;
	op[48] = &AGOSEngine::vc48_setPaletteSlot3;
	op[53] = &AGOSEngine::vc53_dissolveIn;
	op[54] = &AGOSEngine::vc54_dissolveOut;
	op[57] = &AGOSEngine::vc57_blackPalette;
	op[56] = &AGOSEngine::vc56_fullScreen;
	op[58] = &AGOSEngine::vc58_checkCodeWheel;
	op[59] = &AGOSEngine::vc59_ifEGA;
}

void AGOSEngine::vc43_ifBitSet() {
	if (!getBitFlag(vcReadNextWord())) {
		vcSkipNextInstruction();
	}
}

void AGOSEngine::vc44_ifBitClear() {
	if (getBitFlag(vcReadNextWord())) {
		vcSkipNextInstruction();
	}
}

void AGOSEngine::vc45_setWindowPalette() {
	uint16 num = vcReadNextWord();
	uint16 color = vcReadNextWord();

	const uint16 *vlut = &_videoWindows[num * 4];
	uint8 width = vlut[2] * 8;
	uint8 height = vlut[3];

	if (num == 4) {
		byte *dst = (byte *)_window4BackScn->getPixels();

		for (uint8 h = 0; h < height; h++) {
			for (uint8 w = 0; w < width; w++) {
				uint16 val = READ_LE_UINT16(dst + w * 2);
				val &= 0xF0F;
				val |= color * 16;
				WRITE_LE_UINT16(dst + w * 2, val);
			}
			dst += width * 2;
		}
	} else {
		Graphics::Surface *screen = getBackendSurface();
		byte *dst = (byte *)screen->getBasePtr(vlut[0] * 16, vlut[1]);

		if (getGameType() == GType_ELVIRA2 && num == 7) {
			dst -= 8;
			width += 4;
		}

		for (uint8 h = 0; h < height; h++) {
			for (uint8 w = 0; w < width; w++) {
				uint16 val = READ_LE_UINT16(dst + w * 2);
				val &= 0xF0F;
				val |= color * 16;
				WRITE_LE_UINT16(dst + w * 2, val);
			}
			dst += screen->pitch;
		}

		updateBackendSurface();
	}
}

void AGOSEngine::setPaletteSlot(uint16 srcOffs, uint8 dstOffs) {
	byte *offs, *palptr, *src;
	uint16 num;

	palptr = _displayPalette + dstOffs * 3 * 16;
	offs = _curVgaFile1 + READ_BE_UINT16(_curVgaFile1 + 6);
	src = offs + srcOffs * 32;
	num = 16;

	do {
		uint16 color = READ_BE_UINT16(src);
		palptr[0] = ((color & 0xf00) >> 8) * 32;
		palptr[1] = ((color & 0x0f0) >> 4) * 32;
		palptr[2] = ((color & 0x00f) >> 0) * 32;

		palptr += 3;
		src += 2;
	} while (--num);

	_paletteFlag = 2;
}

void AGOSEngine::vc46_setPaletteSlot1() {
	uint16 srcOffs = vcReadNextWord();
	setPaletteSlot(srcOffs, 1);
}

void AGOSEngine::vc47_setPaletteSlot2() {
	uint16 srcOffs = vcReadNextWord();
	setPaletteSlot(srcOffs, 2);
}

void AGOSEngine::vc48_setPaletteSlot3() {
	uint16 srcOffs = vcReadNextWord();
	setPaletteSlot(srcOffs, 3);
}

void AGOSEngine::vc49_setBit() {
	uint16 bit = vcReadNextWord();
	if (getGameType() == GType_FF && bit == 82) {
		_variableArrayPtr = _variableArray2;
	}
	setBitFlag(bit, true);
}

void AGOSEngine::vc50_clearBit() {
	uint16 bit = vcReadNextWord();
	if (getGameType() == GType_FF && bit == 82) {
		_variableArrayPtr = _variableArray;
	}
	setBitFlag(bit, false);
}

void AGOSEngine::vc51_enableBox() {
	enableBox(vcReadNextWord());
}

void AGOSEngine::vc52_playSound() {
	bool ambient = false;

	uint16 sound = vcReadNextWord();
	if (sound >= 0x8000) {
		ambient = true;
		sound = -sound;
	}

	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		int16 pan = vcReadNextWord();
		int16 vol = vcReadNextWord();

		if (ambient)
			loadSound(sound, pan, vol, Sound::TYPE_AMBIENT);
		else
			loadSound(sound, pan, vol, Sound::TYPE_SFX);
	} else if (getGameType() == GType_SIMON2) {
		if (ambient)
			_sound->playAmbient(sound);
		else
			_sound->playEffects(sound);
	} else if (getFeatures() & GF_TALKIE) {
		_sound->playEffects(sound);
	} else {
		// Waxworks uses 2 opcodes to play SFX: vc28 for digital SFX and vc52
		// for MIDI SFX. If a sound effect has both a MIDI and a digital
		// version, both opcodes are triggered. Only one of them should play
		// a sound effect.
		playSfx(sound, 0, 0, false, getGameType() == GType_WW);
	}
}

void AGOSEngine::vc53_dissolveIn() {
	uint16 num = vcReadNextWord();
	uint16 speed = vcReadNextWord() + 1;

	byte *src, *dst, *srcOffs, *srcOffs2, *dstOffs, *dstOffs2;
	int16 xoffs, yoffs;
	uint8 color = 0;

	// Only uses Video Window 4
	num = 4;

	uint16 dissolveX = _videoWindows[num * 4 + 2] * 8;
	uint16 dissolveY = (_videoWindows[num * 4 + 3] + 1) / 2;
	uint16 dissolveCheck = dissolveY * dissolveX * 4;
	uint16 dissolveDelay = dissolveCheck * 2 / speed;
	uint16 dissolveCount = dissolveCheck * 2 / speed;

	int16 x = _videoWindows[num * 4 + 0] * 16;
	int16 y = _videoWindows[num * 4 + 1];

	uint16 count = dissolveCheck * 2;
	while (count--) {
		Graphics::Surface *screen = getBackendSurface();
		byte *dstPtr = (byte *)screen->getBasePtr(x, y);

		yoffs = _rnd.getRandomNumber(dissolveY);
		dst = dstPtr + yoffs * screen->pitch;
		src = (byte *)_window4BackScn->getBasePtr(0, yoffs);

		xoffs = _rnd.getRandomNumber(dissolveX);
		dst += xoffs;
		src += xoffs;

		*dst &= color;
		*dst |= *src & 0xF;

		dstOffs = dst;
		srcOffs = src;

		xoffs = dissolveX * 2 - 1 - (xoffs * 2);
		dst += xoffs;
		src += xoffs;

		*dst &= color;
		*dst |= *src & 0xF;

		srcOffs2 = src;
		dstOffs2 = dst;

		yoffs = (dissolveY - 1) * 2 - (yoffs * 2);
		src = srcOffs + yoffs * _window4BackScn->pitch;
		dst = dstOffs + yoffs * screen->pitch;

		color = 0xF0;
		*dst &= color;
		*dst |= *src & 0xF;

		dst = dstOffs2 + yoffs * screen->pitch;
		src = srcOffs2 + yoffs * _window4BackScn->pitch;

		*dst &= color;
		*dst |= *src & 0xF;

		updateBackendSurface();

		dissolveCount--;
		if (!dissolveCount) {
			if (count >= dissolveCheck)
				dissolveDelay++;

			dissolveCount = dissolveDelay;
			delay(1);
		}
	}
}

void AGOSEngine::vc54_dissolveOut() {
	uint16 num = vcReadNextWord();
	uint16 color = vcReadNextWord();
	uint16 speed = vcReadNextWord() + 1;

	byte *dst, *dstOffs;
	int16 xoffs, yoffs;

	uint16 dissolveX = _videoWindows[num * 4 + 2] * 8;
	uint16 dissolveY = (_videoWindows[num * 4 + 3] + 1) / 2;
	uint16 dissolveCheck = dissolveY * dissolveX * 4;
	uint16 dissolveDelay = dissolveCheck * 2 / speed;
	uint16 dissolveCount = dissolveCheck * 2 / speed;

	int16 x = _videoWindows[num * 4 + 0] * 16;
	int16 y = _videoWindows[num * 4 + 1];

	uint16 count = dissolveCheck * 2;
	while (count--) {
		Graphics::Surface *screen = getBackendSurface();
		byte *dstPtr = (byte *)screen->getBasePtr(x, y);
		color |= dstPtr[0] & 0xF0;

		yoffs = _rnd.getRandomNumber(dissolveY);
		xoffs = _rnd.getRandomNumber(dissolveX);
		dst = dstPtr + xoffs + yoffs * screen->pitch;
		*dst = color;

		dstOffs = dst;

		xoffs = dissolveX * 2 - 1 - (xoffs * 2);
		dst += xoffs;
		*dst = color;

		yoffs = (dissolveY - 1) * 2 - (yoffs * 2);
		dst = dstOffs + yoffs * screen->pitch;
		*dst = color;

		dst += xoffs;
		*dst = color;

		updateBackendSurface();

		dissolveCount--;
		if (!dissolveCount) {
			if (count >= dissolveCheck)
				dissolveDelay++;

			dissolveCount = dissolveDelay;
			delay(1);
		}
	}
}

void AGOSEngine::vc55_moveBox() {
	HitArea *ha = _hitAreas;
	uint count = ARRAYSIZE(_hitAreas);
	uint16 id = vcReadNextWord();
	int16 x = vcReadNextWord();
	int16 y = vcReadNextWord();

	for (;;) {
		if (ha->id == id) {
			ha->x += x;
			ha->y += y;
			break;
		}
		ha++;
		if (!--count)
			break;
	}

	_needHitAreaRecalc++;
}

void AGOSEngine::fullFade() {
	uint8 *srcPal, *dstPal;
	int c, p;

	for (c = 64; c != 0; c --) {
		srcPal = _curVgaFile2 + 32;
		dstPal = _currentPalette;
		for (p = 768; p !=0; p -= 3) {
			uint8 r = srcPal[0] * 4;
			if (dstPal[0] != r)
				dstPal[0] += 4;
			uint8 g = srcPal[1] * 4;
			if (dstPal[1] != g)
				dstPal[1] += 4;
			uint8 b = srcPal[2] * 4;
			if (dstPal[2] != b)
				dstPal[2] += 4;
			srcPal += 3;
			dstPal += 3;
		}
		_system->getPaletteManager()->setPalette(_currentPalette, 0, 256);
		delay(5);
	}
}

void AGOSEngine::vc56_fullScreen() {
	Graphics::Surface *screen = getBackendSurface();
	byte *dst = (byte *)screen->getPixels();
	byte *src = _curVgaFile2 + 800;

	for (int i = 0; i < _screenHeight; i++) {
		memcpy(dst, src, _screenWidth);
		src += 320;
		dst += screen->pitch;
	}
	updateBackendSurface();

	fullFade();
}

void AGOSEngine::vc57_blackPalette() {
	memset(_currentPalette, 0, sizeof(_currentPalette));
	_system->getPaletteManager()->setPalette(_currentPalette, 0, 256);
}

void AGOSEngine::vc58_checkCodeWheel() {
	_variableArray[0] = 0;
}

void AGOSEngine::vc59_ifEGA() {
	// Skip if not EGA
	vcSkipNextInstruction();
}

} // End of namespace AGOS

================
File: vga_ff.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */



#ifdef ENABLE_AGOS2

#include "agos/agos.h"
#include "agos/intern.h"
#include "agos/sound.h"

namespace AGOS {

void AGOSEngine_Feeble::setupVideoOpcodes(VgaOpcodeProc *op) {
	AGOSEngine_Simon2::setupVideoOpcodes(op);

	op[75] = &AGOSEngine::vc75_setScale;
	op[76] = &AGOSEngine::vc76_setScaleXOffs;
	op[77] = &AGOSEngine::vc77_setScaleYOffs;
	op[78] = &AGOSEngine::vc78_computeXY;
	op[79] = &AGOSEngine::vc79_computePosNum;
	op[80] = &AGOSEngine::vc80_setOverlayImage;
	op[81] = &AGOSEngine::vc81_setRandom;
	op[82] = &AGOSEngine::vc82_getPathValue;
	op[83] = &AGOSEngine::vc83_playSoundLoop;
	op[84] = &AGOSEngine::vc84_stopSoundLoop;
}

int AGOSEngine::getScale(int16 y, int16 x) {
	int16 z;

	if (y > _baseY) {
		return((int16)(x * (1 + ((y - _baseY) * _scale))));
	} else {
		if (x == 0)
			return(0);
		if (x < 0) {
			z = ((int16)((x * (1 - ((_baseY - y)* _scale))) - 0.5));
			if (z >- 2)
				return(-2);
			return(z);
		}

		z = ((int16)((x * (1 - ((_baseY - y) * _scale))) + 0.5));
		if (z < 2)
			return(2);

		return(z);
	}
}

void AGOSEngine_Feeble::vc36_setWindowImage() {
	_displayFlag = 0;
	vcReadNextWord();
	vcReadNextWord();
	fillBackGroundFromFront();
}

void AGOSEngine_Feeble::vc48_setPathFinder() {
	uint16 a = (uint16)_variableArrayPtr[12];
	const uint16 *p = _pathFindArray[a - 1];

	VgaSprite *vsp = findCurSprite();
	int16 x, y, ydiff;
	int16 x1, y1, x2, y2;
	uint pos = 0;

	x = vsp->x;
	while (x >= (int16)readUint16Wrapper(p + 2)) {
		p += 2;
		pos++;
	}

	x1 = readUint16Wrapper(p);
	y1 = readUint16Wrapper(p + 1);
	x2 = readUint16Wrapper(p + 2);
	y2 = readUint16Wrapper(p + 3);

	if (x2 != 9999) {
		ydiff = y2 - y1;
		if (ydiff < 0) {
			ydiff = -ydiff;
			x = vsp->x & 7;
			ydiff *= x;
			ydiff /= 8;
			ydiff = -ydiff;
		} else {
			x = vsp->x & 7;
			ydiff *= x;
			ydiff /= 8;
		}
		y1 += ydiff;
	}

	y = vsp->y;
	vsp->y = y1;
	checkScrollY(y1 - y, y1);

	_variableArrayPtr[11] = x1;
	_variableArrayPtr[13] = pos;
}

void AGOSEngine::vc75_setScale() {
	_baseY = vcReadNextWord();
	_scale = vcReadNextWord() / 1000000.0f;
}

void AGOSEngine::vc76_setScaleXOffs() {
	if (getGameType() == GType_PP && getBitFlag(120)) {
		VgaSprite *vsp1, *vsp2;
		uint16 old_file_1, tmp1, tmp2;

		old_file_1 = _vgaCurSpriteId;

		_vgaCurSpriteId = vcReadVar(vcReadNextWord());
		 vsp1 = findCurSprite();
		_vgaCurSpriteId = vcReadVar(vcReadNextWord());
		 vsp2 = findCurSprite();

		tmp1 = vsp1->x;
		tmp2 = vsp2->x;
		vsp1->x = tmp2;
		vsp2->x = tmp1;
		tmp1 = vsp1->y;
		tmp2 = vsp2->y;
		vsp1->y = tmp2;
		vsp2->y = tmp1;

		_vgaCurSpriteId = old_file_1;
		_vcPtr += 2;
	} else {
		VgaSprite *vsp = findCurSprite();

		vsp->image = vcReadNextWord();
		int16 x = vcReadNextWord();
		uint16 var = vcReadNextWord();

		vsp->x += getScale(vsp->y, x);
		_variableArrayPtr[var] = vsp->x;

		checkScrollX(x, vsp->x);

		vsp->flags = kDFScaled;
	}
}

void AGOSEngine::vc77_setScaleYOffs() {
	VgaSprite *vsp = findCurSprite();

	vsp->image = vcReadNextWord();
	int16 y = vcReadNextWord();
	uint16 var = vcReadNextWord();

	vsp->y += getScale(vsp->y, y);
	_variableArrayPtr[var] = vsp->y;

	if (y != 0)
		checkScrollY(y, vsp->y);

	vsp->flags = kDFScaled;
}

void AGOSEngine::vc78_computeXY() {
	VgaSprite *vsp = findCurSprite();

	uint16 a = (uint16)_variableArrayPtr[12];
	uint16 b = (uint16)_variableArrayPtr[13];

	const uint16 *p = _pathFindArray[a - 1];
	p += b * 2;

	uint16 posx = readUint16Wrapper(p);
	_variableArrayPtr[15] = posx;
	vsp->x = posx;

	uint16 posy = readUint16Wrapper(p + 1);
	_variableArrayPtr[16] = posy;
	vsp->y = posy;

	if (getGameType() == GType_FF) {
		setBitFlag(85, false);
		if (getBitFlag(74)) {
			centerScroll();
		}
	}
}

void AGOSEngine::vc79_computePosNum() {
	uint a = (uint16)_variableArrayPtr[12];
	const uint16 *p = _pathFindArray[a - 1];
	uint pos = 0;

	int16 y = _variableArrayPtr[16];
	while (y >= (int16)readUint16Wrapper(p + 1)) {
		p += 2;
		pos++;
	}

	_variableArrayPtr[13] = pos;
}

void AGOSEngine::vc80_setOverlayImage() {
	VgaSprite *vsp = findCurSprite();

	vsp->image = vcReadVarOrWord();

	vsp->x += vcReadNextWord();
	vsp->y += vcReadNextWord();
	vsp->flags = kDFOverlayed;

	_vgaSpriteChanged++;
}

void AGOSEngine::vc81_setRandom() {
	uint16 var = vcReadNextWord();
	uint16 value = vcReadNextWord();

	_variableArray[var] = _rnd.getRandomNumber(value - 1);
}

void AGOSEngine::vc82_getPathValue() {
	uint8 val;

	uint16 var = vcReadNextWord();

	if (getGameType() == GType_FF && getBitFlag(82)) {
		val = _pathValues1[_GPVCount1++];
	} else {
		val = _pathValues[_GPVCount++];
	}

	vcWriteVar(var, val);
}

void AGOSEngine::vc83_playSoundLoop() {
	uint16 sound = vcReadNextWord();
	int16 vol = vcReadNextWord();
	int16 pan = vcReadNextWord();

	loadSound(sound, pan, vol, Sound::TYPE_SFX5);
}

void AGOSEngine::vc84_stopSoundLoop() {
	_sound->stopSfx5();
}

// Scrolling functions for Feeble Files
void AGOSEngine::checkScrollX(int16 x, int16 xpos) {
	if (_scrollXMax == 0 || x == 0)
		return;

	if (getGameType() == GType_FF && (getBitFlag(80) || getBitFlag(82)))
		return;

	int16 tmp;
	if (x > 0) {
		if (_scrollCount != 0) {
			if (_scrollCount >= 0)
				return;
			_scrollCount = 0;
		} else {
			if (_scrollFlag != 0)
				return;
		}

		if (xpos - _scrollX >= 480) {
			_scrollCount = 320;
			tmp = _scrollXMax - _scrollX;
			if (tmp < 320)
				_scrollCount = tmp;
		}
	} else {
		if (_scrollCount != 0) {
			if (_scrollCount < 0)
				return;
			_scrollCount = 0;
		} else {
			if (_scrollFlag != 0)
				return;
		}

		if (xpos - _scrollX < 161) {
			_scrollCount = -320;
			if (_scrollX < 320)
				_scrollCount = -_scrollX;
		}
	}
}

void AGOSEngine::checkScrollY(int16 y, int16 ypos) {
	if (_scrollYMax == 0)
		return;

	if (getGameType() == GType_FF && getBitFlag(80))
		return;

	int16 tmp;
	if (y >= 0) {
		if (_scrollCount != 0) {
			if (_scrollCount >= 0)
				return;
		} else {
			if (_scrollFlag != 0)
				return;
		}

		if (ypos - _scrollY >= 440) {
			_scrollCount = 240;
			tmp = _scrollYMax - _scrollY;
			if (tmp < 240)
				_scrollCount = tmp;
		}
	} else {
		if (_scrollCount != 0) {
			if (_scrollCount < 0)
				return;
		} else {
			if (_scrollFlag != 0)
				return;
		}

		if (ypos - _scrollY < 100) {
			_scrollCount = -240;
			if (_scrollY < 240)
				_scrollCount = -_scrollY;
		}
	}
}

void AGOSEngine::centerScroll() {
	int16 x, y, tmp;

	if (_scrollXMax != 0) {
		_scrollCount = 0;
		x = _variableArray[15] - _scrollX;
		if (x < 17 || (getBitFlag(85) && x < 320)) {
			x -= 320;
			if (_scrollX < -x)
				x = -_scrollX;
			_scrollCount = x;
		} else if ((getBitFlag(85) && x >= 320) || x >= 624) {
			x -= 320;
			tmp = _scrollXMax - _scrollX;
			if (tmp < x)
				x = tmp;
			_scrollCount = x;
		}
	} else if (_scrollYMax != 0) {
		_scrollCount = 0;
		y = _variableArray[16] - _scrollY;
		if (y < 30) {
			y -= 240;
			if (_scrollY < -y)
				y = -_scrollY;
			_scrollCount = y;
		} else if (y >= 460) {
			y -= 240;
			tmp = _scrollYMax - _scrollY;
			if (tmp < y)
				y = tmp;
			_scrollCount = y;
		}
	}
}

// Puzzle Pack specific code

void AGOSEngine_PuzzlePack::vc3_loadSprite() {
	if (getGameId() != GID_DIMP && getBitFlag(100)) {
		startAnOverlayAnim();
		return;
	}

	AGOSEngine::vc3_loadSprite();
}

void AGOSEngine_PuzzlePack::vc63_fastFadeIn() {
	_fastFadeInFlag = 256;
	_fastFadeOutFlag = false;

	if (getGameId() == GID_DIMP)
		return;

	if (getBitFlag(100)) {
		startOverlayAnims();
	} else if (getBitFlag(103)) {
		debug("vc63_fastFadeIn: NameAndTime");
	} else if (getBitFlag(104)) {
		debug("vc63_fastFadeIn: HiScoreTable");
	}
}

void AGOSEngine_PuzzlePack::startOverlayAnims() {
	VgaSprite *vsp = _vgaSprites;
	uint16 zoneNum;
	int i;

	zoneNum = _variableArray[999];

	for (i = 0; i < 600; i++) {
		if (_variableArray[1000 + i] < 100)
			continue;

		while (vsp->id)
			vsp++;

		vsp->windowNum = 4;
		vsp->priority = 4;
		vsp->flags = 0;
		vsp->palette = 0;
		vsp->image = _variableArray[1000 + i];
		if (i >= 300) {
			vsp->y = ((i - 300) / 20) * 32;
			vsp->x = ((i - 300) % 20) * 32;
		} else {
			vsp->y = (i / 20) * 32;
			vsp->x = (i % 20) * 32;
		}
		vsp->id = 1000 + i;
		vsp->zoneNum = zoneNum;
	}
}

void AGOSEngine_PuzzlePack::startAnOverlayAnim() {
	VgaSprite *vsp = _vgaSprites;
	const byte *vcPtrOrg;
	uint16 a, sprite, file, tmp, zoneNum;
	int16 x;

	zoneNum = _variableArray[999];

	_vcPtr += 4;
	a = vcReadNextWord();
	_vcPtr += 6;

	while (vsp->id)
		vsp++;

	vsp->windowNum = 4;
	vsp->priority = 20;
	vsp->flags = 0;
	vsp->palette = 0;
	vsp->image = vcReadVar(vcReadVar(a));

	x = vcReadVar(a) - 1300;
	if (x < 0) {
		x += 300;
		vsp->priority = 10;
	}

	vsp->y = x / 20 * 32;
	vsp->x = x % 20 * 32;
	vsp->id = vcReadVar(a);
	vsp->zoneNum = zoneNum;

	sprite = _vgaCurSpriteId;
	file = _vgaCurZoneNum;

	_vgaCurZoneNum = vsp->zoneNum;
	_vgaCurSpriteId = vsp->id;

	tmp = to16Wrapper(vsp->priority);

	vcPtrOrg = _vcPtr;
	_vcPtr = (byte *)&tmp;
	vc23_setPriority();

	_vcPtr = vcPtrOrg;
	_vgaCurSpriteId = sprite;
	_vgaCurZoneNum = file;
}

} // End of namespace AGOS

#endif // ENABLE_AGOS2

================
File: vga_pn.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "agos/agos.h"
#include "agos/intern.h"
#include "agos/vga.h"

#include "common/system.h"

#include "graphics/surface.h"

namespace AGOS {

void AGOSEngine_PN::setupVideoOpcodes(VgaOpcodeProc *op) {
	op[1] = &AGOSEngine::vc1_fadeOut;
	op[2] = &AGOSEngine::vc2_call;
	op[3] = &AGOSEngine::vc3_loadSprite;
	op[4] = &AGOSEngine::vc4_fadeIn;
	op[5] = &AGOSEngine::vc5_ifEqual;
	op[6] = &AGOSEngine::vc6_ifObjectHere;
	op[7] = &AGOSEngine::vc7_ifObjectNotHere;
	op[8] = &AGOSEngine::vc8_ifObjectIsAt;
	op[9] = &AGOSEngine::vc9_ifObjectStateIs;
	op[10] = &AGOSEngine::vc10_draw;
	op[11] = &AGOSEngine::vc11_onStop;
	op[13] = &AGOSEngine::vc12_delay;
	op[14] = &AGOSEngine::vc13_addToSpriteX;
	op[15] = &AGOSEngine::vc14_addToSpriteY;
	op[16] = &AGOSEngine::vc15_sync;
	op[17] = &AGOSEngine::vc16_waitSync;
	op[18] = &AGOSEngine::vc17_waitEnd;
	op[19] = &AGOSEngine::vc18_jump;
	op[20] = &AGOSEngine::vc19_loop;
	op[21] = &AGOSEngine::vc20_setRepeat;
	op[22] = &AGOSEngine::vc21_endRepeat;
	op[23] = &AGOSEngine::vc22_setPalette;
	op[24] = &AGOSEngine::vc23_setPriority;
	op[25] = &AGOSEngine::vc24_setSpriteXY;
	op[26] = &AGOSEngine::vc25_halt_sprite;
	op[27] = &AGOSEngine::vc26_setSubWindow;
	op[28] = &AGOSEngine::vc27_resetSprite;
	op[29] = &AGOSEngine::vc28_playSFX;
	op[30] = &AGOSEngine::vc29_stopAllSounds;
	op[31] = &AGOSEngine::vc30_setFrameRate;
	op[32] = &AGOSEngine::vc31_setWindow;
	op[33] = &AGOSEngine::vc32_saveScreen;
	op[34] = &AGOSEngine::vc33_setMouseOn;
	op[35] = &AGOSEngine::vc34_setMouseOff;
	op[36] = &AGOSEngine::vc36_pause;
	op[38] = &AGOSEngine::vc35_clearWindow;
	op[39] = &AGOSEngine::vc39_volume;
	op[40] = &AGOSEngine::vc36_setWindowImage;
	op[41] = &AGOSEngine::vc37_pokePalette;
	op[44] = &AGOSEngine::vc44_enableBox;
	op[45] = &AGOSEngine::vc45_disableBox;
	op[46] = &AGOSEngine::vc46_maxBox;
	op[48] = &AGOSEngine::vc48_specialEffect;
	op[50] = &AGOSEngine::vc50_setBox;
	op[51] = &AGOSEngine::vc38_ifVarNotZero;
	op[52] = &AGOSEngine::vc39_setVar;
	op[53] = &AGOSEngine::vc40_scrollRight;
	op[54] = &AGOSEngine::vc41_scrollLeft;
	op[55] = &AGOSEngine::vc55_scanFlag;
}

bool AGOSEngine_PN::ifObjectHere(uint16 a) {
	if (getFeatures() & GF_DEMO)
		return false;

	return _variableArray[39] == getptr(_quickptr[11] + a * _quickshort[4] + 2);
}

bool AGOSEngine_PN::ifObjectAt(uint16 a, uint16 b) {
	if (getFeatures() & GF_DEMO)
		return false;

	return b == getptr(_quickptr[11] + a * _quickshort[4] + 2);
}

bool AGOSEngine_PN::ifObjectState(uint16 a, int16 b) {
	if (getFeatures() & GF_DEMO)
		return false;

	return b == getptr(_quickptr[0] + a * _quickshort[0] + 2);
}

void AGOSEngine::vc36_pause() {
	const char *message1 = "Press any key to continue";
	bool oldWiped = _wiped;
	_wiped = 0;

	_videoLockOut |= 8;

	windowPutChar(_windowArray[2], 13);

	for (; *message1; message1++)
		windowPutChar(_windowArray[2], *message1);

	while (!shouldQuit()) {
		if (_keyPressed.ascii != 0 || _joyaction.button != Common::JoystickButton::JOYSTICK_BUTTON_INVALID || _action != kActionNone)
			break;
		delay(1);
	}

	_keyPressed.reset();
	_action = kActionNone;

	windowPutChar(_windowArray[2], 13);
	_wiped = oldWiped;

	_videoLockOut &= ~8;
}

void AGOSEngine::vc39_volume() {
	_vcPtr += 2;
}

void AGOSEngine::vc44_enableBox() {
	HitArea *ha = _hitAreas + vcReadNextWord();
	ha->flags &= ~kOBFBoxDisabled;
}

void AGOSEngine::vc45_disableBox() {
	HitArea *ha = _hitAreas + vcReadNextWord();
	ha->flags |= kOBFBoxDisabled;
}

void AGOSEngine::vc46_maxBox() {
	HitArea *ha = _hitAreas + vcReadNextWord();
	ha->id = 0xFFFF;
}

void AGOSEngine::vc48_specialEffect() {
	uint16 num = vcReadNextWord();
	vcReadNextWord();

	if (getPlatform() == Common::kPlatformDOS) {
		if (num == 1) {
			Graphics::Surface *screen = getBackendSurface();
			byte *dst = (byte *)screen->getPixels();

			for (uint h = 0; h < _screenHeight; h++) {
				for (uint w = 0; w < _screenWidth; w++) {
					if (dst[w] == 15)
						dst[w] = 4;
				}
				dst += screen->pitch;
			}
			updateBackendSurface();
		} else if (num == 2) {
			const char *str = "There are gurgling noises from the sink.";
			for (; *str; str++)
				windowPutChar(_textWindow, *str);
		}
	}
}

void AGOSEngine::vc50_setBox() {
	uint16 id, x, y, w, h, msg1, msg2, flags;
	const uint16 *vlut;

	id = vcReadNextWord();
	vlut = &_videoWindows[vcReadNextWord() * 4];
	x = vlut[0] * 16 + vcReadNextWord();
	y = vlut[1] + vcReadNextWord();
	h = vcReadNextWord();
	w = vcReadNextWord();
	msg1 = vcReadNextWord();
	msg2 = vcReadNextWord();
	flags = vcReadNextWord();

	// Compressed string
	if (!(flags & kOBFUseMessageList)) {
		msg1 += 0x8000;
	}

	defineBox(id, x, y, h, w, msg1, msg2, flags);
}

void AGOSEngine::vc55_scanFlag() {
	_scanFlag = 1;
}

void AGOSEngine_PN::clearVideoWindow(uint16 num, uint16 color) {
	const uint16 *vlut = &_videoWindows[num * 4];
	uint16 xoffs = vlut[0] * 16;
	uint16 yoffs = vlut[1];

	Graphics::Surface *screen = getBackendSurface();
	byte *dst = (byte *)screen->getBasePtr(xoffs, yoffs);
	for (uint h = 0; h < vlut[3]; h++) {
		memset(dst, color, vlut[2] * 16);
		dst += screen->pitch;
	}
	 updateBackendSurface();
}

} // End of namespace AGOS

================
File: vga_s1.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */



#include "agos/agos.h"
#include "agos/intern.h"
#include "agos/sound.h"
#include "agos/vga.h"

namespace AGOS {

void AGOSEngine_Simon1::setupVideoOpcodes(VgaOpcodeProc *op) {
	AGOSEngine::setupVideoOpcodes(op);

	op[11] = &AGOSEngine::vc11_clearPathFinder;
	op[17] = &AGOSEngine::vc17_setPathfinderItem;
	op[22] = &AGOSEngine::vc22_setPalette;
	op[32] = &AGOSEngine::vc32_copyVar;
	op[37] = &AGOSEngine::vc37_addToSpriteY;
	op[48] = &AGOSEngine::vc48_setPathFinder;
	op[59] = &AGOSEngine::vc59_ifSpeech;
	op[60] = &AGOSEngine::vc60_stopAnimation;
	op[61] = &AGOSEngine::vc61_setMaskImage;
	op[62] = &AGOSEngine::vc62_fastFadeOut;
	op[63] = &AGOSEngine::vc63_fastFadeIn;
}

void AGOSEngine::vc11_clearPathFinder() {
	memset(&_pathFindArray, 0, sizeof(_pathFindArray));
}

void AGOSEngine::vc17_setPathfinderItem() {
	uint16 a = vcReadNextWord();
	_pathFindArray[a - 1] = (const uint16 *)_vcPtr;

	int end = (getGameType() == GType_FF || getGameType() == GType_PP) ? 9999 : 999;
	while (readUint16Wrapper(_vcPtr) != end)
		_vcPtr += 4;
	_vcPtr += 2;
}

static const uint8 customPalette[96] = {
	0x00, 0x00, 0x00,
	0x99, 0x22, 0xFF,
	0x66, 0xCC, 0xFF,
	0xFF, 0x99, 0xFF,
	0xFF, 0xFF, 0xFF,
	0x66, 0x44, 0xBB,
	0x77, 0x55, 0xCC,
	0x88, 0x77, 0xCC,
	0xCC, 0xAA, 0xDD,
	0x33, 0x00, 0x09,
	0x66, 0x44, 0xCC,
	0x88, 0x55, 0xCC,
	0xAA, 0x77, 0xEE,
	0x00, 0x00, 0x00,
	0x00, 0x00, 0x00,
	0x00, 0x00, 0x00,
	0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF,
	0x33, 0x00, 0x00,
	0xCC, 0xCC, 0xDD,
	0x88, 0x99, 0xBB,
	0x44, 0x77, 0xAA,
	0x44, 0x44, 0x66,
	0x44, 0x44, 0x00,
	0x44, 0x66, 0x00,
	0x88, 0x99, 0x00,
	0x99, 0x44, 0x00,
	0xBB, 0x44, 0x22,
	0xFF, 0x55, 0x33,
	0xFF, 0x88, 0x88,
	0xFF, 0xBB, 0x33,
	0xFF, 0xFF, 0x77,
};

void AGOSEngine_Simon1::vc22_setPalette() {
	byte *offs, *palptr = nullptr, *src;
	uint16 a = 0, b, num, palSize = 0;

	a = vcReadNextWord();
	b = vcReadNextWord();

	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		num = 256;
		palSize = 768;

		palptr = _displayPalette;
	} else {
		num = a == 0 ? 32 : 16;
		palSize = 96;

		palptr = &_displayPalette[(a * 3 * 16)];
	}

	offs = _curVgaFile1 + 6;
	src = offs + b * palSize;

	do {
		palptr[0] = src[0] * 4;
		palptr[1] = src[1] * 4;
		palptr[2] = src[2] * 4;

		palptr += 3;
		src += 3;
	} while (--num);

	if (getFeatures() & GF_32COLOR) {
		// Custom palette used for verb area
		palptr = &_displayPalette[(13 * 3 * 16)];
		for (uint8 c = 0; c < 32; c++) {
			palptr[0] = customPalette[c * 3 + 0];
			palptr[1] = customPalette[c * 3 + 1];
			palptr[2] = customPalette[c * 3 + 2];

			palptr += 3;
		};
	}

	_paletteFlag = 2;
	_vgaSpriteChanged++;
}

void AGOSEngine::vc32_copyVar() {
	uint16 a = vcReadVar(vcReadNextWord());
	vcWriteVar(vcReadNextWord(), a);
}

void AGOSEngine::vc37_addToSpriteY() {
	VgaSprite *vsp = findCurSprite();
	vsp->y += vcReadVar(vcReadNextWord());

	vsp->windowNum |= 0x8000;
	dirtyBackGround();
	_vgaSpriteChanged++;
}

void AGOSEngine::vc45_setSpriteX() {
	VgaSprite *vsp = findCurSprite();
	vsp->x = vcReadVar(vcReadNextWord());

	vsp->windowNum |= 0x8000;
	dirtyBackGround();
	_vgaSpriteChanged++;
}

void AGOSEngine::vc46_setSpriteY() {
	VgaSprite *vsp = findCurSprite();
	vsp->y = vcReadVar(vcReadNextWord());

	vsp->windowNum |= 0x8000;
	dirtyBackGround();
	_vgaSpriteChanged++;
}

void AGOSEngine::vc47_addToVar() {
	uint16 var = vcReadNextWord();
	vcWriteVar(var, vcReadVar(var) + vcReadVar(vcReadNextWord()));
}

void AGOSEngine::vc48_setPathFinder() {
	uint16 a = (uint16)_variableArrayPtr[12];
	// WORKAROUND: Check if the selected path is valid. There are cases
	// where an invalid path is selected, such as when loading a save in
	// the Dwarf Cave in Simon 1 (bug #6356). In such cases, we select
	// the first available path, which fixes the problem in Simon 1.
	if (!_pathFindArray[a - 1]) {
		warning("vc48_setPathFinder: Invalid path, attempting to correct");
		a = 1;
	}

	const uint16 *p = _pathFindArray[a - 1];

	uint b = (uint16)_variableArray[13];
	p += b * 2 + 1;
	int c = _variableArray[14];

	int step;
	int y1, y2;
	int16 *vp;

	step = 2;
	if (c < 0) {
		c = -c;
		step = -2;
	}

	vp = &_variableArray[20];

	do {
		y2 = readUint16Wrapper(p);
		p += step;
		y1 = readUint16Wrapper(p) - y2;

		vp[0] = y1 / 2;
		vp[1] = y1 - (y1 / 2);

		vp += 2;
	} while (--c);
}

void AGOSEngine::vc59_ifSpeech() {
	if (!_sound->isVoiceActive())
		vcSkipNextInstruction();
}

void AGOSEngine::vc61_setMaskImage() {
	VgaSprite *vsp = findCurSprite();

	vsp->image = vcReadVarOrWord();
	vsp->x += vcReadNextWord();
	vsp->y += vcReadNextWord();
	vsp->flags = kDFMasked | kDFSkipStoreBG;

	vsp->windowNum |= 0x8000;
	dirtyBackGround();
	_vgaSpriteChanged++;
}

} // End of namespace AGOS

================
File: vga_s2.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "agos/agos.h"
#include "agos/intern.h"
#include "agos/midi.h"
#include "agos/sound.h"

#include "graphics/surface.h"

namespace AGOS {

void AGOSEngine_Simon2::setupVideoOpcodes(VgaOpcodeProc *op) {
	AGOSEngine_Simon1::setupVideoOpcodes(op);

	op[56] = &AGOSEngine::vc56_delayLong;
	op[58] = &AGOSEngine::vc58_changePriority;
	op[59] = &AGOSEngine::vc59_stopAnimations;
	op[64] = &AGOSEngine::vc64_ifSpeech;
	op[65] = &AGOSEngine::vc65_slowFadeIn;
	op[66] = &AGOSEngine::vc66_ifEqual;
	op[67] = &AGOSEngine::vc67_ifLE;
	op[68] = &AGOSEngine::vc68_ifGE;
	op[69] = &AGOSEngine::vc69_playSeq;
	op[70] = &AGOSEngine::vc70_joinSeq;
	op[71] = &AGOSEngine::vc71_ifSeqWaiting;
	op[72] = &AGOSEngine::vc72_segue;
	op[73] = &AGOSEngine::vc73_setMark;
	op[74] = &AGOSEngine::vc74_clearMark;
}

void AGOSEngine::vc56_delayLong() {
	uint16 num = vcReadVarOrWord() * _frameCount;

	addVgaEvent(num + _vgaBaseDelay, ANIMATE_EVENT, _vcPtr, _vgaCurSpriteId, _vgaCurZoneNum);
	_vcPtr = (byte *)&_vcGetOutOfCode;
}

void AGOSEngine::vc58_changePriority() {
	uint16 sprite = _vgaCurSpriteId;
	uint16 file = _vgaCurZoneNum;
	const byte *vcPtrOrg;
	uint16 tmp;

	_vgaCurZoneNum = vcReadNextWord();
	_vgaCurSpriteId = vcReadNextWord();

	tmp = to16Wrapper(vcReadNextWord());

	vcPtrOrg = _vcPtr;
	_vcPtr = (byte *)&tmp;
	vc23_setPriority();

	_vcPtr = vcPtrOrg;
	_vgaCurSpriteId = sprite;
	_vgaCurZoneNum = file;
}

void AGOSEngine::vc59_stopAnimations() {
	uint16 file = vcReadNextWord();
	uint16 start = vcReadNextWord();
	uint16 end = vcReadNextWord() + 1;

	do {
		vcStopAnimation(file, start);
	} while (++start != end);
}

void AGOSEngine::vc64_ifSpeech() {
	if ((getGameType() == GType_SIMON2 && _subtitles && _language != Common::HE_ISR) ||
		!_sound->isVoiceActive()) {
		vcSkipNextInstruction();
	}
}

void AGOSEngine::vc65_slowFadeIn() {
	_fastFadeInFlag = 624;
	_fastFadeCount = 208;
	if (_windowNum != 4) {
		_fastFadeInFlag = 768;
		_fastFadeCount = 256;
	}
	_fastFadeInFlag |= 0x8000;
	_fastFadeOutFlag = false;
}

void AGOSEngine::vc66_ifEqual() {
	uint16 a = vcReadNextWord();
	uint16 b = vcReadNextWord();

	if (vcReadVar(a) != vcReadVar(b))
		vcSkipNextInstruction();
}

void AGOSEngine::vc67_ifLE() {
	uint16 a = vcReadNextWord();
	uint16 b = vcReadNextWord();

	if (vcReadVar(a) >= vcReadVar(b))
		vcSkipNextInstruction();
}

void AGOSEngine::vc68_ifGE() {
	uint16 a = vcReadNextWord();
	uint16 b = vcReadNextWord();

	if (vcReadVar(a) <= vcReadVar(b))
		vcSkipNextInstruction();
}

void AGOSEngine::vc69_playSeq() {
	int16 track = vcReadNextWord();
	int16 loop = vcReadNextWord();

	// Jamieson630:
	// This is a "play track". The original
	// design stored the track to play if one was
	// already in progress, so that the next time a
	// "fill MIDI stream" event occurred, the MIDI
	// player would find the change and switch
	// tracks. We use a different architecture that
	// allows for an immediate response here, but
	// we'll simulate the variable changes so other
	// scripts don't get thrown off.
	// NOTE: This opcode looks very similar in function
	// to vc72(), except that vc72() may allow for
	// specifying a non-valid track number (999 or -1)
	// as a means of stopping what music is currently
	// playing.
	_midi->setLoop(loop != 0);
	playMusic(0, track);
}

void AGOSEngine::vc70_joinSeq() {
	// Simon2
	uint16 track = vcReadNextWord();
	uint16 loop = vcReadNextWord();

	// Jamieson630:
	// This sets the "on end of track" action.
	// It specifies whether to loop the current
	// track and, if not, whether to switch to
	// a different track upon completion.
	if (track != 0xFFFF && track != 999)
		_midi->queueTrack(track, loop != 0);
	else
		_midi->setLoop(loop != 0);
}

void AGOSEngine::vc71_ifSeqWaiting() {
	// Jamieson630:
	// This command skips the next instruction
	// unless (1) there is a track playing, AND
	// (2) there is a track queued to play after it.
	if (!_midi->isPlaying(true))
		vcSkipNextInstruction();
}

void AGOSEngine::vc72_segue() {
	// Jamieson630:
	// This is a "play or stop track". Note that
	// this opcode looks very similar in function
	// to vc69(), except that this opcode may allow
	// for specifying a track of 999 or -1 in order to
	// stop the music. We'll code it that way for now.

	// NOTE: It's possible that when "stopping" a track,
	// we're supposed to just go on to the next queued
	// track, if any. Must find out if there is ANY
	// case where this is used to stop a track in the
	// first place.

	int16 track = vcReadNextWord();
	int16 loop = vcReadNextWord();

	if (track == -1 || track == 999) {
		stopMusic();
	} else {
		_midi->setLoop(loop != 0);
		playMusic(0, track);
	}
}

void AGOSEngine::vc73_setMark() {
	_marks |= (1 << vcReadNextWord());
}

void AGOSEngine::vc74_clearMark() {
	_marks &= ~(1 << vcReadNextWord());
}

void AGOSEngine_Simon2::clearVideoWindow(uint16 num, uint16 color) {
	const uint16 *vlut = &_videoWindows[num * 4];

	uint16 xoffs = vlut[0] * 16;
	uint16 yoffs = vlut[1];
	uint16 dstWidth = _videoWindows[18] * 16;
	// TODO: Is there any known connection between dstWidth and the pitch
	// of the _window4BackScn Surface? If so, we might be able to pass
	// yoffs as proper y parameter to getBasePtr.
	byte *dst = (byte *)_window4BackScn->getBasePtr(xoffs, 0) + yoffs * dstWidth;

	setMoveRect(0, 0, vlut[2] * 16, vlut[3]);

	for (uint h = 0; h < vlut[3]; h++) {
		memset(dst, color, vlut[2] * 16);
		dst += dstWidth;
	}

	_window4Flag = 1;
}

} // End of namespace AGOS

================
File: vga_ww.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Video script opcodes for Simon1/Simon2


#include "agos/agos.h"
#include "agos/intern.h"
#include "agos/midi.h"

#include "common/system.h"

#include "graphics/surface.h"
#include "graphics/paletteman.h"

namespace AGOS {

void AGOSEngine_Waxworks::setupVideoOpcodes(VgaOpcodeProc *op) {
	AGOSEngine_Elvira2::setupVideoOpcodes(op);

	op[58] = &AGOSEngine::vc58_checkCodeWheel;
	op[60] = &AGOSEngine::vc60_stopAnimation;
	op[61] = &AGOSEngine::vc61;
	op[62] = &AGOSEngine::vc62_fastFadeOut;
	op[63] = &AGOSEngine::vc63_fastFadeIn;
}

void AGOSEngine::vcStopAnimation(uint16 zone, uint16 sprite) {
	uint16 oldCurSpriteId, oldCurZoneNum;
	VgaSprite *vsp;
	VgaTimerEntry *vte;
	const byte *vcPtrOrg;

	oldCurSpriteId = _vgaCurSpriteId;
	oldCurZoneNum = _vgaCurZoneNum;
	vcPtrOrg = _vcPtr;

	_vgaCurZoneNum = zone;
	_vgaCurSpriteId = sprite;

	vsp = findCurSprite();
	if (vsp->id) {
		vc25_halt_sprite();

		vte = _vgaTimerList;
		while (vte->delay) {
			if (vte->id == _vgaCurSpriteId && vte->zoneNum == _vgaCurZoneNum) {
				deleteVgaEvent(vte);
				break;
			}
			vte++;
		}
	}

	_vgaCurZoneNum = oldCurZoneNum;
	_vgaCurSpriteId = oldCurSpriteId;
	_vcPtr = vcPtrOrg;
}

void AGOSEngine_Simon1::vcStopAnimation(uint16 zone, uint16 sprite) {
	uint16 oldCurSpriteId, oldCurZoneNum;
	VgaSleepStruct *vfs;
	VgaSprite *vsp;
	VgaTimerEntry *vte;
	const byte *vcPtrOrg;

	oldCurSpriteId = _vgaCurSpriteId;
	oldCurZoneNum = _vgaCurZoneNum;
	vcPtrOrg = _vcPtr;

	_vgaCurZoneNum = zone;
	_vgaCurSpriteId = sprite;

	vfs = _waitSyncTable;
	while (vfs->ident != 0) {
		if (vfs->id == _vgaCurSpriteId && vfs->zoneNum == _vgaCurZoneNum) {
			while (vfs->ident != 0) {
				memcpy(vfs, vfs + 1, sizeof(VgaSleepStruct));
				vfs++;
			}
			break;
		}
		vfs++;
	}

	vsp = findCurSprite();
	if (vsp->id) {
		vc25_halt_sprite();

		vte = _vgaTimerList;
		while (vte->delay) {
			if (vte->id == _vgaCurSpriteId && vte->zoneNum == _vgaCurZoneNum) {
				deleteVgaEvent(vte);
				break;
			}
			vte++;
		}
	}

	_vgaCurZoneNum = oldCurZoneNum;
	_vgaCurSpriteId = oldCurSpriteId;
	_vcPtr = vcPtrOrg;
}

void AGOSEngine::vc60_stopAnimation() {
	uint16 sprite, zoneNum;

	if (getGameType() == GType_PP) {
		zoneNum = vcReadNextWord();
		sprite = vcReadVarOrWord();
	} else if (getGameType() == GType_SIMON2 || getGameType() == GType_FF) {
		zoneNum = vcReadNextWord();
		sprite = vcReadNextWord();
	} else {
		sprite = vcReadNextWord();
		zoneNum = sprite / 100;
	}

	vcStopAnimation(zoneNum, sprite);
}

void AGOSEngine::vc61() {
	uint16 a = vcReadNextWord();
	byte *src, *dst, *dstPtr;
	uint h, tmp;

	Graphics::Surface *screen = getBackendSurface();
	dstPtr = (byte *)screen->getPixels();

	if (a == 6) {
		src = _curVgaFile2 + 800;
		dst = dstPtr;

		for (int i = 0; i < _screenHeight; i++) {
			memcpy(dst, src, _screenWidth);
			src += 320;
			dst += screen->pitch;
		}

		tmp = 4 - 1;
	} else {
		tmp = a - 1;
	}

	src = _curVgaFile2 + 3840 * 16 + 3360;
	while (tmp--)
		src += 1536 * 16 + 1712;

	src += 800;

	if (a != 5) {
		dst = dstPtr + 23 * screen->pitch + 88;
		for (h = 0; h < 177; h++) {
			memcpy(dst, src, 144);
			src += 144;
			dst += screen->pitch;
		}

		if (a != 6) {
			updateBackendSurface();
			return;
		}

		src = _curVgaFile2 + 9984 * 16 + 15344;
	}

	dst = dstPtr + 157 * screen->pitch + 56;
	for (h = 0; h < 17; h++) {
		memcpy(dst, src, 208);
		src += 208;
		dst += screen->pitch;
	}

	updateBackendSurface();

	if (a == 6)
		fullFade();
}

void AGOSEngine::vc62_fastFadeOut() {
	vc29_stopAllSounds();

	if (!_neverFade && !_fastFadeOutFlag) {
		uint i, fadeSize, fadeCount;

		_fastFadeCount = 256;
		if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
			if (_windowNum == 4)
				_fastFadeCount = 208;
		}

		if (getGameType() == GType_FF || getGameType() == GType_PP) {
			if (getGameType() == GType_FF && getBitFlag(75)) {
				fadeCount = 4;
				fadeSize = 64;
			} else {
				fadeCount = 32;
				fadeSize = 8;
			}
		} else {
			fadeCount = 64;
			fadeSize = 4;
		}

		if (getGameType() == GType_SIMON2 && _nextMusicToPlay != -1)
			// Music will be stopped after the screen fade, so fade out the
			// music during the screen fade.
			_midi->fadeOut();

		for (i = fadeCount; i != 0; --i) {
			paletteFadeOut(_currentPalette, _fastFadeCount, fadeSize);
			_system->getPaletteManager()->setPalette(_currentPalette, 0, _fastFadeCount);
			delay(5);
		}
	}

	if (!_fastFadeOutFlag) {
		if (getGameType() == GType_WW || getGameType() == GType_FF || getGameType() == GType_PP) {
			clearSurfaces();
		} else {
			if (_windowNum != 4) {
				clearSurfaces();
			}
		}
	}
	if (getGameType() == GType_SIMON2) {
		if (_nextMusicToPlay != -1)
			loadMusic(_nextMusicToPlay);
	}
}

void AGOSEngine::vc63_fastFadeIn() {
	if (getGameType() == GType_FF) {
		_fastFadeInFlag = 256;
	} else if (getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) {
		_fastFadeInFlag = 208;
		if (_windowNum != 4) {
			_fastFadeInFlag = 256;
		}
	}
	_fastFadeOutFlag = false;
}

} // End of namespace AGOS

================
File: window.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */


#include "common/system.h"
#include "common/textconsole.h"

#include "graphics/surface.h"

#include "agos/agos.h"
#include "agos/intern.h"

namespace AGOS {

uint AGOSEngine::getWindowNum(WindowBlock *window) {
	uint i;

	for (i = 0; i != ARRAYSIZE(_windowArray); i++)
		if (_windowArray[i] == window)
			return i;

	error("getWindowNum: not found");
	return 0;	// for compilers that don't support NORETURN
}

WindowBlock *AGOSEngine::openWindow(uint x, uint y, uint w, uint h, uint flags, uint fillColor, uint textColor) {
	WindowBlock *window;

	window = _windowList;
	while (window->mode != 0)
		window++;

	if (getGameType() == GType_ELVIRA1 && y >= 133)
		textColor += 16;

	window->mode = 2;
	window->x = x;
	window->y = y;
	window->width = w;
	window->height = h;
	window->flags = flags;
	window->fillColor = fillColor;
	window->textColor = textColor;
	window->textColumn = 0;
	window->textColumnOffset = 0;
	window->textRow = 0;
	window->scrollY = 0;

	// Characters are 6 pixels (except Japanese: when downscaled, 1-byte characters are 4 pixels, 2-byte characters are 8 pixels)
	if (getGameType() == GType_ELVIRA2)
		window->textMaxLength = (window->width * 8 - 4) / 6;
	else if (getGameType() == GType_PN)
		window->textMaxLength = window->width * 8 / 6 + 1;
	else if (getGameType() == GType_ELVIRA1 && getPlatform() == Common::kPlatformPC98)
		window->textMaxLength = window->width << 1;
	else
		window->textMaxLength = window->width * 8 / 6;

	if (getGameType() == GType_PN || getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2 || getGameType() == GType_WW)
		clearWindow(window);

	if (getGameType() == GType_SIMON1 && getPlatform() == Common::kPlatformAmiga && window->fillColor == 225)
		window->fillColor = (getFeatures() & GF_32COLOR) ? 17 : 241;

	return window;
}

void AGOSEngine::changeWindow(uint a) {
	a &= 7;

	if (_windowArray[a] == nullptr || _curWindow == a)
		return;

	_curWindow = a;
	justifyOutPut(0);
	_textWindow = _windowArray[a];
	justifyStart();
}

void AGOSEngine::closeWindow(uint a) {
	if (_windowArray[a] == nullptr)
		return;
	removeIconArray(a);
	resetWindow(_windowArray[a]);
	_windowArray[a] = nullptr;
	if (_curWindow == a) {
		_textWindow = nullptr;
		changeWindow(0);
	}
}

void AGOSEngine::clearWindow(WindowBlock *window) {
	clearHiResTextLayer();
	if (window->flags & 0x10)
		restoreWindow(window);
	else
		colorWindow(window);

	window->textColumn = 0;
	window->textRow = 0;
	window->textColumnOffset = (getGameType() == GType_ELVIRA2) ? 4 : 0;
	window->textLength = 0;
	window->scrollY = 0;
}

#ifdef ENABLE_AGOS2
void AGOSEngine_Feeble::colorWindow(WindowBlock *window) {
	byte *dst;
	uint16 h, w;

	_videoLockOut |= 0x8000;

	dst = getBackGround() + _backGroundBuf->pitch * window->y + window->x;

	for (h = 0; h < window->height; h++) {
		for (w = 0; w < window->width; w++) {
			if (dst[w] == 113 || dst[w] == 116 || dst[w] == 252)
				dst[w] = window->fillColor;
		}
		dst += _backGroundBuf->pitch;
	}

	_videoLockOut &= ~0x8000;
}
#endif

void AGOSEngine::colorWindow(WindowBlock *window) {
	uint16 y, h;

	y = window->y;
	h = window->height * 8;

	if (getGameType() == GType_ELVIRA2 && window->y == 146) {
		if (window->fillColor == 1) {
			_displayPalette[33 * 3 + 0] = 48 * 4;
			_displayPalette[33 * 3 + 1] = 40 * 4;
			_displayPalette[33 * 3 + 2] = 32 * 4;
		} else {
			_displayPalette[33 * 3 + 0] = 56 * 4;
			_displayPalette[33 * 3 + 1] = 56 * 4;
			_displayPalette[33 * 3 + 2] = 40 * 4;
		}

		y--;
		h += 2;

		_paletteFlag = 1;
	}

	colorBlock(window, window->x * 8, y, window->width * 8, h);
}

void AGOSEngine::colorBlock(WindowBlock *window, uint16 x, uint16 y, uint16 w, uint16 h) {
	_videoLockOut |= 0x8000;

	Graphics::Surface *screen = getBackendSurface();
	byte *dst = (byte *)screen->getBasePtr(x, y);

	uint8 color = window->fillColor;
	if (getGameType() == GType_ELVIRA2 || getGameType() == GType_WW)
		color += dst[0] & 0xF0;
	uint16 h2 = h;

	do {
		memset(dst, color, w);
		dst += screen->pitch;
	} while (--h);

	Common::Rect dirtyRect(x, y, x + w, y + h2);
	updateBackendSurface(&dirtyRect);

	_videoLockOut &= ~0x8000;
}

void AGOSEngine::resetWindow(WindowBlock *window) {
	if (window->flags & 8)
		restoreWindow(window);
	window->mode = 0;
}

void AGOSEngine::restoreWindow(WindowBlock *window) {
	_videoLockOut |= 0x8000;

	if (getGameType() == GType_FF || getGameType() == GType_PP) {
		restoreBlock(window->x, window->y, window->x + window->width, window->y + window->height);
	} else if (getGameType() == GType_SIMON2) {
		if (_restoreWindow6 && _windowArray[2] == window) {
			window = _windowArray[6];
			_restoreWindow6 = 0;
		}

		restoreBlock(window->x * 8, window->y, (window->x + window->width) * 8, window->y + window->height * 8);
	} else if (getGameType() == GType_SIMON1) {
		restoreBlock(window->x * 8, window->y, (window->x + window->width) * 8, window->y + window->height * 8 + ((window == _windowArray[2]) ? 1 : 0));
	} else {
		uint16 x = window->x;
		uint16 w = window->width;

		if (getGameType() == GType_ELVIRA1) {
			// Adjustments to remove inventory arrows
			if (x & 1) {
				x--;
				w++;
			}
			if (w & 1) {
				w++;
			}
		}

		restoreBlock(x * 8, window->y, (x + w) * 8, window->y + window->height * 8);
	}

	_videoLockOut &= ~0x8000;
}

void AGOSEngine::restoreBlock(uint16 left, uint16 top, uint16 right, uint16 bottom) {
	byte *dst, *src;
	uint i;

	Graphics::Surface *screen = getBackendSurface();
	dst = (byte *)screen->getPixels();
	src = getBackGround();

	dst += top * screen->pitch;
	src += top * _backGroundBuf->pitch;

	uint8 paletteMod = 0;
	Common::Rect dirtyRect(left, top, right, bottom);
	if (getGameType() == GType_ELVIRA1 && !(getFeatures() & GF_DEMO) && top >= 133)
		paletteMod = 16;

	while (top < bottom) {
		for (i = left; i < right; i++)
			dst[i] = src[i] + paletteMod;
		top++;
		dst += screen->pitch;
		src += _backGroundBuf->pitch;
	}

	updateBackendSurface(&dirtyRect);
}

void AGOSEngine::setTextColor(uint color) {
	WindowBlock *window = _windowArray[_curWindow];

	if ((getFeatures() & GF_32COLOR) && color != 0) {
		if (window->fillColor == 17)
			color = 25;
		else
			color = 220;
	}

	window->textColor = color;
}

void AGOSEngine::sendWindow(uint a) {
	if (getGameType() == GType_PN || _textWindow != _windowArray[0]) {
		if (getGameType() == GType_ELVIRA1 || getGameType() == GType_ELVIRA2 || getGameType() == GType_WW) {
			if (!(_textWindow->flags & 1)) {
				haltAnimation();
			}
		}

		windowPutChar(_textWindow, a);
	}
}

void AGOSEngine::waitWindow(WindowBlock *window) {
	HitArea *ha;
	const char *message;

	window->textColumn = (window->width / 2) - 3;
	window->textRow = window->height - 1;
	window->textLength = 0;

	_forceAscii = true;
	message = "[ OK ]";
	for (; *message; message++)
		windowPutChar(window, *message);
	_forceAscii = false;

	ha = findEmptyHitArea();
	ha->x = (window->width / 2 + window->x - 3) * 8;
	ha->y = window->height * 8 + window->y - 8;
	ha->width = 48;
	ha->height = 8;
	ha->flags = kBFBoxInUse;
	ha->id = 0x7FFF;
	ha->priority = 999;

	while (!shouldQuit()) {
		_lastHitArea = nullptr;
		_lastHitArea3 = nullptr;

		while (!shouldQuit()) {
			if (_lastHitArea3 != nullptr)
				break;
			delay(1);
		}

		ha = _lastHitArea;
		if (ha == nullptr) {
		} else if (ha->id == 0x7FFF) {
			break;
		}
	}

	undefineBox(0x7FFF);
}

void AGOSEngine::writeChar(WindowBlock *window, int x, int y, int offs, int val) {
	int chr;
	_forceAscii = true;

	// Clear background of first digit
	window->textColumnOffset = offs;
	window->textColor = 0;
	windowDrawChar(window, x * 8, y, 129);

	if (val != -1) {
		// Print first digit
		chr = val / 10 + 48;
		window->textColor = 15;
		windowDrawChar(window, x * 8, y, chr);
	}

	offs += 6;
	if (offs >= 7) {
		offs -= 8;
		x++;
	}

	// Clear background of second digit
	window->textColumnOffset = offs;
	window->textColor = 0;
	windowDrawChar(window, x * 8, y, 129);

	if (val != -1) {
		// Print second digit
		chr = val % 10 + 48;
		window->textColor = 15;
		windowDrawChar(window, x * 8, y, chr);
	}

	_forceAscii = false;
}

} // End of namespace AGOS

================
File: zones.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */



#include "common/file.h"

#include "agos/intern.h"
#include "agos/agos.h"
#include "agos/vga.h"

namespace AGOS {

void AGOSEngine::freezeBottom() {
	_vgaMemBase = _vgaMemPtr;
	_vgaFrozenBase = _vgaMemPtr;
}

void AGOSEngine::unfreezeBottom() {
	_vgaMemPtr = _vgaRealBase;
	_vgaMemBase = _vgaRealBase;
	_vgaFrozenBase = _vgaRealBase;
}

static const uint8 zoneTable[160] = {
	0,  0,  2,  2,  2,  2,  0,  2,  2,  2,
	3,  0,  0,  0,  0,  0,  0,  0,  1,  0,
	3,  3,  3,  1,  3,  0,  0,  0,  1,  0,
	2,  0,  3,  0,  3,  3,  0,  1,  1,  0,
	1,  2,  2,  2,  0,  2,  2,  2,  0,  2,
	1,  2,  2,  2,  0,  2,  2,  2,  2,  2,
	2,  2,  2,  1,  2,  2,  2,  2,  2,  2,
	2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
	2,  2,  0,  2,  0,  3,  2,  2,  2,  3,
	2,  3,  3,  3,  1,  3,  3,  1,  1,  0,
	2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
	2,  2,  2,  2,  2,  0,  0,  2,  2,  0,
	0,  2,  0,  2,  2,  2,  0,  0,  0,  0,
	0,  0,  0,  0,  0,  2,  2,  2,  2,  2,
	2,  0,  2,  0,  0,  2,  2,  0,  2,  2,
	2,  2,  2,  2,  2,  0,  0,  0,  0,  0,
};

void AGOSEngine::loadZone(uint16 zoneNum, bool useError) {
	VgaPointersEntry *vpe;

	CHECK_BOUNDS(zoneNum, _vgaBufferPointers);

	if (getGameType() == GType_PN) {
		// Only a single zone is used in Personal Nightmare
		vpe = _vgaBufferPointers;
		vc27_resetSprite();
		_vgaMemPtr = _vgaMemBase;
	} else {
		vpe = _vgaBufferPointers + zoneNum;
		if (vpe->vgaFile1 != nullptr)
			return;
	}

	// Loading order is important due to resource management

	if (getPlatform() == Common::kPlatformAmiga && getGameType() == GType_WW &&
		zoneTable[zoneNum] == 3) {
		uint8 num = (zoneNum >= 85) ? 94 : 18;
		loadVGAVideoFile(num, 2, useError);
	} else {
		loadVGAVideoFile(zoneNum, 2, useError);
	}
	vpe->vgaFile2 = _block;
	vpe->vgaFile2End = _blockEnd;

	loadVGAVideoFile(zoneNum, 1, useError);
	vpe->vgaFile1 = _block;
	vpe->vgaFile1End = _blockEnd;

	vpe->sfxFile = nullptr;

	if (getGameType() == GType_ELVIRA2) {
		// A singe sound file is used for Amiga and AtariST versions
		if (loadVGASoundFile(1, 3)) {
			vpe->sfxFile = _block;
			vpe->sfxFileEnd = _blockEnd;
		}
	} else if (!(getFeatures() & GF_ZLIBCOMP)) {
		if (loadVGASoundFile(zoneNum, 3)) {
			vpe->sfxFile = _block;
			vpe->sfxFileEnd = _blockEnd;
		}
	}
}

void AGOSEngine::setZoneBuffers() {
	_zoneBuffers = (byte *)malloc(_vgaMemSize);

	_vgaMemPtr = _zoneBuffers;
	_vgaMemBase = _zoneBuffers;
	_vgaFrozenBase = _zoneBuffers;
	_vgaRealBase = _zoneBuffers;
	_vgaMemEnd = _zoneBuffers + _vgaMemSize;
}

byte *AGOSEngine::allocBlock(uint32 size) {
	for (;;) {
		_block = _vgaMemPtr;
		_blockEnd = _block + size;

		if (_blockEnd >= _vgaMemEnd) {
			_vgaMemPtr = _vgaMemBase;
		} else {
			_rejectBlock = false;
			checkNoOverWrite();
			if (_rejectBlock)
				continue;
			checkRunningAnims();
			if (_rejectBlock)
				continue;
			checkZonePtrs();
			_vgaMemPtr = _blockEnd;
			return _block;
		}
	}
}

void AGOSEngine::checkRunningAnims() {
	if ((getGameType() == GType_SIMON1 || getGameType() == GType_SIMON2) &&
		(_videoLockOut & 0x20)) {
		return;
	}

	VgaSprite *vsp;
	for (vsp = _vgaSprites; vsp->id; vsp++) {
		checkAnims(vsp->zoneNum);
		if (_rejectBlock == true)
			return;
	}
}

void AGOSEngine::checkNoOverWrite() {
	VgaPointersEntry *vpe;

	if (_noOverWrite == 0xFFFF)
		return;

	vpe = &_vgaBufferPointers[_noOverWrite];

	if (vpe->vgaFile1 < _blockEnd && vpe->vgaFile1End > _block) {
		_rejectBlock = true;
		_vgaMemPtr = vpe->vgaFile1End;
	} else if (vpe->vgaFile2 < _blockEnd && vpe->vgaFile2End > _block) {
		_rejectBlock = true;
		_vgaMemPtr = vpe->vgaFile2End;
	} else if (vpe->sfxFile && vpe->sfxFile < _blockEnd && vpe->sfxFileEnd > _block) {
		_rejectBlock = true;
		_vgaMemPtr = vpe->sfxFileEnd;
	} else {
		_rejectBlock = false;
	}
}

void AGOSEngine::checkAnims(uint a) {
	VgaPointersEntry *vpe;

	vpe = &_vgaBufferPointers[a];

	if (vpe->vgaFile1 < _blockEnd && vpe->vgaFile1End > _block) {
		_rejectBlock = true;
		_vgaMemPtr = vpe->vgaFile1End;
	} else if (vpe->vgaFile2 < _blockEnd && vpe->vgaFile2End > _block) {
		_rejectBlock = true;
		_vgaMemPtr = vpe->vgaFile2End;
	} else if (vpe->sfxFile && vpe->sfxFile < _blockEnd && vpe->sfxFileEnd > _block) {
		_rejectBlock = true;
		_vgaMemPtr = vpe->sfxFileEnd;
	} else {
		_rejectBlock = false;
	}
}

void AGOSEngine::checkZonePtrs() {
	uint count = ARRAYSIZE(_vgaBufferPointers);
	VgaPointersEntry *vpe = _vgaBufferPointers;
	do {
		if (((vpe->vgaFile1 < _blockEnd) && (vpe->vgaFile1End > _block)) ||
			((vpe->vgaFile2 < _blockEnd) && (vpe->vgaFile2End > _block)) ||
			((vpe->sfxFile < _blockEnd) && (vpe->sfxFileEnd > _block))) {
			vpe->vgaFile1 = nullptr;
			vpe->vgaFile1End = nullptr;
			vpe->vgaFile2 = nullptr;
			vpe->vgaFile2End = nullptr;
			vpe->sfxFile = nullptr;
			vpe->sfxFileEnd = nullptr;
		}
	} while (++vpe, --count);
}

} // End of namespace AGOS

================
File: drivers\accolade\adlib.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "agos/drivers/accolade/adlib.h"

#include "agos/drivers/accolade/mididriver.h"

namespace AGOS {

// hardcoded, dumped from Accolade music system
// same for INSTR.DAT + MUSIC.DRV, except that MUSIC.DRV does the lookup differently
// Numbers 6-A correspond to MIDI channels in the original driver, but here they
// are directly mapped to rhythm instrument types (bass drum, snare drum,
// tom tom, cymbal and hi-hat respectively). F means there is no instrument
// defined for the rhythm note.
const byte MidiDriver_Accolade_AdLib::RHYTHM_NOTE_INSTRUMENT_TYPES[] = {
	0x06, 0x07, 0x07, 0x07, 0x07, 0x08, 0x0A, 0x08, 0x0A, 0x08,
	0x0A, 0x08, 0x08, 0x09, 0x08, 0x09, 0x0F, 0x0F, 0x0A, 0x0F,
	0x0A, 0x0F, 0x0F, 0x0F, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x0A, 0x0F, 0x0F, 0x08, 0x0F, 0x08
};

// hardcoded, dumped from Accolade music system (INSTR.DAT variant)
const uint16 MidiDriver_Accolade_AdLib::OPL_NOTE_FREQUENCIES_INSTR_DAT[] = {
	0x02B2, 0x02DB, 0x0306, 0x0334, 0x0365, 0x0399,
	0x03CF, 0xFE05, 0xFE23, 0xFE44, 0xFE67, 0xFE8B
};

// hardcoded, dumped from Accolade music system (MUSIC.DRV variant)
const uint16 MidiDriver_Accolade_AdLib::OPL_NOTE_FREQUENCIES_MUSIC_DRV[] = {
	0x0205, 0x0223, 0x0244, 0x0267, 0x028B, 0x02B2,
	0x02DB, 0x0306, 0x0334, 0x0365, 0x0399, 0x03CF
};

// Accolade adlib music driver
//
// Remarks:
//
// There are at least 2 variants of this sound system.
// One for the game Elvira 1
// It seems it was also used for the game "Altered Destiny"
// Another one for the games Elvira 2 + Waxworks + Simon, the Sorcerer 1 Demo
//
// First one uses the file INSTR.DAT for instrument data, channel mapping etc.
// Second one uses the file MUSIC.DRV, which actually contains driver code + instrument data + channel mapping, etc.
//
// The second variant supported dynamic channel allocation for the FM voice channels, but this
// feature was at least definitely disabled for Simon, the Sorcerer 1 demo and for the Waxworks demo too.
//
// I have currently not implemented dynamic channel allocation.
MidiDriver_Accolade_AdLib::MidiDriver_Accolade_AdLib(OPL::Config::OplType oplType, bool newVersion, int timerFrequency) :
		MidiDriver_ADLIB_Multisource(oplType, timerFrequency) {
	_instrumentBank = nullptr;
	_rhythmBank = nullptr;
	_newVersion = newVersion;
	_oplNoteFrequencies = _newVersion ? OPL_NOTE_FREQUENCIES_MUSIC_DRV : OPL_NOTE_FREQUENCIES_INSTR_DAT;

	Common::fill(_channelRemapping, _channelRemapping + ARRAYSIZE(_channelRemapping), 0);
	Common::fill(_instrumentRemapping, _instrumentRemapping + ARRAYSIZE(_instrumentRemapping), 0);
	Common::fill(_volumeAdjustments, _volumeAdjustments + ARRAYSIZE(_volumeAdjustments), 0);
	Common::fill(_sfxNoteFractions, _sfxNoteFractions + ARRAYSIZE(_sfxNoteFractions), 0);
	memset(_sfxInstruments, 0, sizeof(_sfxInstruments));
}

MidiDriver_Accolade_AdLib::~MidiDriver_Accolade_AdLib() {
	if (_instrumentBank)
		delete[] _instrumentBank;
	if (_rhythmBank)
		delete[] _rhythmBank;
}

int MidiDriver_Accolade_AdLib::open() {
	_modulationDepth = MODULATION_DEPTH_LOW;
	_vibratoDepth = VIBRATO_DEPTH_LOW;

	int result = MidiDriver_ADLIB_Multisource::open();

	if (result == 0) {
		// Rhythm mode is always on.
		setRhythmMode(true);

		// The original driver writes out default instruments to all channels
		// here. This implementation writes instruments before note on, so this
		// is not necessary.

		// driver initialization does this here:
		// INSTR.DAT
		// noteOn(9, 0x29, 0);
		// noteOff(9, 0x26, false);
		// MUSIC.DRV
		// noteOn(9, 0x26, 0);
		// noteOff(9, 0x26, false);
	}

	return result;
}

void MidiDriver_Accolade_AdLib::send(int8 source, uint32 b) {
	// Remap the MIDI channel according to the channel map.
	// (Seems to be 1 on 1 for AdLib...)
	byte channel = b & 0xF;
	channel = _channelRemapping[channel];
	b &= 0xFFFFFFF0;
	b |= channel;
	byte command = b & 0xF0;

	if (_oplType != OPL::Config::kOpl3 && _sources[source].type != SOURCE_TYPE_SFX && command != MIDI_COMMAND_PROGRAM_CHANGE) {
		// Filter out events for channels used by SFX.
		// Program change events are always accepted; they just set the program
		// for the music source and do not affect the SFX notes.
		if (_activeNotes[channel].channelAllocated)
			return;
	}

	MidiDriver_ADLIB_Multisource::send(source, b);
}

void MidiDriver_Accolade_AdLib::deinitSource(uint8 source) {
	if (_sources[source].type == SOURCE_TYPE_SFX) {
		// When a sound effect ends, the original driver will immediately
		// rewrite the music instrument for the channel used by this sound
		// effect. This has the effect of stopping the release phase of the
		// sound effect. This is reproduced here to make sure the sound effects
		// sound the same.
		byte channel = _channelAllocations[source][0];
		// OPL3 mode has no fixed instrument assignment to the OPL channel, so
		// just use instrument 0.
		byte program = 0;
		if (_oplType != OPL::Config::kOpl3) {
			// For OPL2, get the current music instrument for this OPL channel.
			program = _controlData[0][channel].program;
			// Apply instrument remapping to instrument channels.
			program = _instrumentRemapping[program];
		}

		InstrumentInfo instrument { };
		instrument.instrumentId = program;
		instrument.instrumentDef = &_instrumentBank[program];
		instrument.oplNote = 0;

		writeInstrument(channel, instrument);

		// Clear other SFX data.
		_sfxNoteFractions[source - 1] = 0;
	}

	MidiDriver_ADLIB_Multisource::deinitSource(source);
}

uint8 MidiDriver_Accolade_AdLib::allocateOplChannel(uint8 channel, uint8 source, InstrumentInfo &instrumentInfo) {
	Common::StackLock lock(_allocationMutex);

	if (_sources[source].type == SOURCE_TYPE_SFX) {
		if (_channelAllocations[source][0] == 0xFF) {
			// Allocate a channel for this SFX source.
			byte allocatedChannel;
			if (_oplType != OPL::Config::kOpl3) {
				// For OPL2, use channels 5 and 4.
				allocatedChannel = 6 - source;
			} else {
				// For OPL3, use the dynamic allocation algorithm.
				allocatedChannel = MidiDriver_ADLIB_Multisource::allocateOplChannel(channel, source, instrumentInfo);
			}

			_activeNotesMutex.lock();

			ActiveNote *activeNote = &_activeNotes[allocatedChannel];
			if (activeNote->noteActive) {
				// Turn off the note currently playing on this OPL channel.
				writeKeyOff(allocatedChannel, activeNote->instrumentDef->rhythmType);
			}
			_channelAllocations[source][0] = allocatedChannel;
			activeNote->channelAllocated = true;
			activeNote->source = source;
			activeNote->channel = channel;
			activeNote->oplNote = 0;

			_activeNotesMutex.unlock();
		}

		// Return the allocated channel.
		return _channelAllocations[source][0];
	}

	// Channel allocation for music sources.
	if (_oplType != OPL::Config::kOpl3) {
		// Use the regular allocation algorithm for rhythm instruments.
		if (channel == MIDI_RHYTHM_CHANNEL)
			return MidiDriver_ADLIB_Multisource::allocateOplChannel(channel, source, instrumentInfo);

		// For OPL2, discard events for channels 6 and 7 and channels allocated
		// for SFX.
		if (channel >= 6 || _activeNotes[channel].channelAllocated)
			return 0xFF;

		// Then just map MIDI channels 0-5 to OPL channels 0-5.
		return channel;
	} else {
		// For OPL3, use the dynamic allocation algorithm.
		return MidiDriver_ADLIB_Multisource::allocateOplChannel(channel, source, instrumentInfo);
	}
}

byte MidiDriver_Accolade_AdLib::getNumberOfSfxSources() {
	// With OPL3 more channels are available for SFX.
	return _oplType == OPL::Config::kOpl3 ? 4 : 2;
}

void MidiDriver_Accolade_AdLib::loadSfxInstrument(uint8 source, byte *instrumentData) {
	if (source > (_oplType == OPL::Config::kOpl3 ? 4 : 2))
		return;

	// Copy instrument data into SFX instruments bank.
	loadInstrumentData(_sfxInstruments[source - 1], instrumentData, RHYTHM_TYPE_UNDEFINED, 0, _newVersion);

	_activeNotesMutex.lock();

	// Allocate a channel
	programChange(0, 0, source);
	InstrumentInfo instrument = determineInstrument(0, source, 0);
	uint8 oplChannel = allocateOplChannel(0, source, instrument);

	// Update the active note data.
	ActiveNote *activeNote = &_activeNotes[oplChannel];
	activeNote->instrumentId = instrument.instrumentId;
	activeNote->instrumentDef = instrument.instrumentDef;

	_activeNotesMutex.unlock();
}

void MidiDriver_Accolade_AdLib::setSfxNoteFraction(uint8 source, uint16 noteFraction) {
	// Note is in the upper byte.
	_activeNotes[_channelAllocations[source][0]].oplNote = noteFraction >> 8;
	// Note fraction is in the lower byte.
	_sfxNoteFractions[source - 1] = noteFraction & 0xFF;
}

void MidiDriver_Accolade_AdLib::updateSfxNote(uint8 source) {
	writeFrequency(_channelAllocations[source][0]);
}

void MidiDriver_Accolade_AdLib::patchE1Instruments() {
	// WORKAROUND One instrument in Elvira 1 has a very slow attack. This
	// causes a problem in OPL3 mode (see patchWwInstruments for more details).
	// This is fixed by shortening the attack and compensating by making the
	// decay longer.

	if (_oplType != OPL::Config::kOpl3)
		// This workaround is only needed for OPL3 mode.
		return;

	// This is allocated in readDriverData so it's not really const
	OplInstrumentDefinition *instrumentBank = const_cast<OplInstrumentDefinition *>(_instrumentBank);

	// Patch the attack and decay of instrument 0x18.
	instrumentBank[0x18].operator0.decayAttack = 0x42; // Was 0x24
}

void MidiDriver_Accolade_AdLib::patchWwInstruments() {
	// WORKAROUND Several instruments in Waxworks have a very slow attack (it
	// takes a long time for a note to reach maximum volume). When a note
	// played by this instrument is very short, only a small part of the attack
	// phase is played and the note is barely audible. Example: the rapid notes
	// in track 10 (played at the start of the London scenario).
	// This problem only occurs in OPL3 mode. In OPL2 mode, these notes are all
	// played on the same OPL channel. This means that each successive note
	// builds on the volume reached by the previous note and apart from the
	// first couple of notes they can be heard clearly. In OPL3 mode, each note
	// is played on its own channel, so each note starts from 0 volume.
	// This is fixed here by patching the attack value of this instrument to be
	// 1/4th of the original length (from 3 to 5). The notes do not sound
	// exactly as on OPL2, but they are clearly audible.

	if (_oplType != OPL::Config::kOpl3)
		// This workaround is only needed for OPL3 mode.
		return;

	// This is allocated in readDriverData so it's not really const
	OplInstrumentDefinition *instrumentBank = const_cast<OplInstrumentDefinition *>(_instrumentBank);

	// Patch the attack of instrument 0x22.
	instrumentBank[0x22].operator1.decayAttack &= 0x0F;
	instrumentBank[0x22].operator1.decayAttack |= 0x50;

	// Patch the attack of instrument 0x25.
	instrumentBank[0x25].operator1.decayAttack &= 0x0F;
	instrumentBank[0x25].operator1.decayAttack |= 0x60;

	// Patch the attack of instrument 0x7F.
	instrumentBank[0x7F].operator0.decayAttack &= 0x0F;
	instrumentBank[0x7F].operator0.decayAttack |= 0x60;
	instrumentBank[0x7F].operator1.decayAttack &= 0x0F;
	instrumentBank[0x7F].operator1.decayAttack |= 0x90;
}

MidiDriver_Accolade_AdLib::InstrumentInfo MidiDriver_Accolade_AdLib::determineInstrument(uint8 channel, uint8 source, uint8 note) {
	if (_sources[source].type == SOURCE_TYPE_SFX) {
		// For SFX sources, return an instrument from the SFX bank.
		InstrumentInfo instrument { };
		instrument.instrumentId = 0xFFFF - source;
		instrument.instrumentDef = &_sfxInstruments[source - 1];
		instrument.oplNote = note;
		return instrument;
	} else {
		return MidiDriver_ADLIB_Multisource::determineInstrument(channel, source, note);
	}
}

uint16 MidiDriver_Accolade_AdLib::calculateFrequency(uint8 channel, uint8 source, uint8 note) {
	if (!_newVersion) {
		// Elvira 1 version.
		if (channel != MIDI_RHYTHM_CHANNEL) {
			// All melodic notes are lowered by 1 octave, except the lowest notes.
			while (note < 0x18)
				note += 0xC;
			note -= 0xC;
		}
		// Highest 32 notes are clipped.
		if (note > 0x5F)
			note = 0x5F;
	} else {
		// Elvira 2 / Waxworks version.
		// Notes 19 and higher are transposed down 19 semitones.
		// Note that this is about 1.5 octave, which implies that notes 0-18 are
		// not played accurately by this driver.
		if (note >= 0x13)
			note -= 0x13;
	}

	// Determine octave and note within octave, and look up the matching OPL
	// frequency.
	int8 block = note / 12;
	if (!_newVersion)
		// Elvira 1 version lowers the octave by 1 (note that melodic notes
		// were lowered 1 octave earlier).
		block--;
	uint8 octaveNote = note % 12;

	// Look up the note frequency.
	uint16 baseFrequency = _oplNoteFrequencies[octaveNote];
	uint16 frequency;
	if (!_newVersion) {
		// Elvira 1 version has a negative frequency lookup value for notes
		// which are in a higher octave than the others.
		if (baseFrequency & 0x8000)
			block++;
		// Clear the high bits of the negative lookup values.
		frequency = baseFrequency & 0x3FF;
		if (block < 0) {
			// If octave is now negative, halve the frequency and increase
			// octave.
			frequency >>= 1;
			block++;
		}
	} else {
		// Elvira 2 / Waxworks version adds the note fraction for SFX.
		uint16 fractionFrequency = 0;
		if (_sources[source].type == SOURCE_TYPE_SFX) {
			// Because the frequency differences between notes are not constant
			// the fraction is multiplied by a factor depending on the note.
			fractionFrequency = (((octaveNote + 1) / 6) + 2) * (_sfxNoteFractions[source - 1] >> 4);
		}
		frequency = baseFrequency + fractionFrequency;
	}
	// Note that when processing sound effects, the note can be higher than the
	// MIDI maximum value of 0x7F. The original interpreter depends on this for
	// correct playback of the sound effect. However, this can cause block to
	// overflow the 3 bit range available to it in the OPL registers.
	block &= 0x7;

	return block << 10 | frequency;
}

uint8 MidiDriver_Accolade_AdLib::calculateUnscaledVolume(uint8 channel, uint8 source, uint8 velocity, const OplInstrumentDefinition &instrumentDef, uint8 operatorNum) {
	// A volume adjustment is applied to the velocity of melodic notes.
	int8 volumeAdjustment = 0;
	if (_sources[source].type != SOURCE_TYPE_SFX) {
		if (instrumentDef.rhythmType == RHYTHM_TYPE_UNDEFINED) {
			byte program = _controlData[source][channel].program;
			volumeAdjustment = _volumeAdjustments[program];
		} else if (!_newVersion) {
			// For rhythm notes, the Elvira 1 version of the driver checks the
			// current "instrument" of channel 9. In this driver channel 9
			// corresponds to the cymbal rhythm instrument, which is set to
			// instrument definition 4. It then reads the volume adjustment
			// for instrument 4 and applies this to all rhythm notes. This
			// seems quite dubious and might be a bug, but it is reproduced
			// here so rhythm volume is the same as the original interpreter.
			// The Elvira 2 / Waxworks driver skips volume adjustment
			// completely for rhythm notes.
			volumeAdjustment = _volumeAdjustments[4];
		}
	}
	// Note velocity and the volume adjustment are added, clipped to normal
	// velocity range and divided by 2 to get an OPL volume value.
	uint8 vol = CLIP(velocity + volumeAdjustment, 0, 0x7F);

	if (!_newVersion) {
		// The Elvira 1 version raises the volume a bit and clips the highest
		// values.
		vol += 0x18;
		if (vol > 0x78)
			vol = 0x78;
	}

	// Invert the volume.
	return 0x3F - (vol >> 1);
}

void MidiDriver_Accolade_AdLib::writePanning(uint8 oplChannel, OplInstrumentRhythmType rhythmType) {
	// The Elvira 1 driver does not write the Cx register for rhythm
	// instruments except the bass drum; the Elvira 2 / Waxworks driver does
	// not write it for the bass drum either.
	if (rhythmType == RHYTHM_TYPE_UNDEFINED || (rhythmType == RHYTHM_TYPE_BASS_DRUM && !_newVersion))
		MidiDriver_ADLIB_Multisource::writePanning(oplChannel, rhythmType);
}

void MidiDriver_Accolade_AdLib::writeFrequency(uint8 oplChannel, OplInstrumentRhythmType rhythmType) {
	// The original driver does not write the frequency for the cymbal and
	// hi-hat instruments.
	if (rhythmType != RHYTHM_TYPE_HI_HAT && rhythmType != RHYTHM_TYPE_CYMBAL)
		MidiDriver_ADLIB_Multisource::writeFrequency(oplChannel, rhythmType);
}

void MidiDriver_Accolade_AdLib::loadInstrumentData(OplInstrumentDefinition &definition, byte *instrumentData,
		OplInstrumentRhythmType rhythmType, byte rhythmNote, bool newVersion) {
	definition.fourOperator = false;

	definition.connectionFeedback0 = instrumentData[8];
	definition.operator0.freqMultMisc = instrumentData[0];
	// The original driver does not add the KSL bits to the calculated
	// volume when writing the level registers. To replicate this, the KSL
	// bits are set to 0 for operators affected by volume.
	// Note that the Elvira 2 / Waxworks driver has a bug which will cause
	// the operator 0 level register of the bass drum instrument to be
	// overwritten by the connection bit (usually 0) of another instrument
	// if the bass drum connection is FM (and it is). This is fixed here by
	// setting the correct value. The Elvira 1 version does not have this
	// bug.
	definition.operator0.level = (definition.connectionFeedback0 & 1) ? 0 : instrumentData[1];
	definition.operator0.decayAttack = instrumentData[2];
	definition.operator0.releaseSustain = instrumentData[3];
	// The original driver only writes 0 to the waveform select registers
	// during initialization, so only sine waveform is used.
	definition.operator0.waveformSelect = 0;
	definition.operator1.freqMultMisc = instrumentData[4];
	definition.operator1.level = 0;
	definition.operator1.decayAttack = instrumentData[6];
	definition.operator1.releaseSustain = instrumentData[7];
	definition.operator1.waveformSelect = 0;
	if (newVersion) {
		// The Elvira 2 / Waxworks driver always sets the last two bits of
		// the sustain value.
		// This was done during "programChange" in the original driver
		definition.operator0.releaseSustain |= 3;
		definition.operator1.releaseSustain |= 3;
	}

	definition.rhythmType = rhythmType;
	definition.rhythmNote = rhythmNote;
}

void MidiDriver_Accolade_AdLib::readDriverData(byte *driverData, uint16 driverDataSize, bool newVersion) {
	uint16 minDataSize = newVersion ? 468 : 354;
	if (driverDataSize < minDataSize)
		error("ACCOLADE-ADLIB: Expected minimum driver data size of %d - got %d", minDataSize, driverDataSize);

	// INSTR.DAT Data is like this:
	// 128 bytes  instrument mapping
	// 128 bytes  instrument volume adjust (signed!)
	//  16 bytes  unknown
	//  16 bytes  channel mapping
	//  64 bytes  key note mapping (not used for MT32)
	//   1 byte   instrument count
	//   1 byte   bytes per instrument
	//   x bytes  no instruments used for MT32

	// music.drv is basically a driver, but with a few fixed locations for certain data

	uint16 channelMappingOffset = newVersion ? 396 : 256 + 16;
	Common::copy(driverData + channelMappingOffset, driverData + channelMappingOffset + ARRAYSIZE(_channelRemapping), _channelRemapping);

	uint16 instrumentMappingOffset = newVersion ? 140 : 0;
	Common::copy(driverData + instrumentMappingOffset, driverData + instrumentMappingOffset + ARRAYSIZE(_instrumentRemapping), _instrumentRemapping);
	setInstrumentRemapping(_instrumentRemapping);

	uint16 volumeAdjustmentsOffset = newVersion ? 140 + 128 : 128;
	int8 *volumeAdjustmentsData = (int8 *)driverData + volumeAdjustmentsOffset;
	Common::copy(volumeAdjustmentsData, volumeAdjustmentsData + ARRAYSIZE(_volumeAdjustments), _volumeAdjustments);

	if (!newVersion) {
		byte instrDatBytesPerInstrument = driverData[256 + 16 + 16 + 64 + 1];

		// We expect 9 bytes per instrument
		if (instrDatBytesPerInstrument != 9)
			error("ACCOLADE-ADLIB: Expected instrument definitions of length 9 - got length %d", instrDatBytesPerInstrument);
	}

	byte instrumentDefinitionCount = newVersion ? 128 : driverData[256 + 16 + 16 + 64];
	uint16 rhythmNoteOffset = newVersion ? 376 + 36 : 256 + 16 + 16;
	uint16 instrumentDataOffset = newVersion ? 722 : 256 + 16 + 16 + 64 + 2;

	OplInstrumentDefinition *instrumentBank = new OplInstrumentDefinition[instrumentDefinitionCount];
	for (int i = 0; i < instrumentDefinitionCount; i++) {
		byte *instrumentData = driverData + instrumentDataOffset + (i * 9);
		loadInstrumentData(instrumentBank[i], instrumentData, RHYTHM_TYPE_UNDEFINED, 0, newVersion);
	}

	OplInstrumentDefinition *rhythmBank = new OplInstrumentDefinition[40];
	_rhythmBankFirstNote = 36;
	_rhythmBankLastNote = 75;
	// Elvira 1 version uses instruments 1-5 for rhythm, Elvira 2 / Waxworks
	// version uses 0x80-0x84.
	byte *rhythmInstrumentDefinitions = driverData + instrumentDataOffset + ((newVersion ? 0x80 : 1) * 9);
	byte *rhythmNotes = driverData + rhythmNoteOffset;
	for (int i = 0; i < 40; i++) {
		byte instrumentDefNumber = RHYTHM_NOTE_INSTRUMENT_TYPES[i] > 0xA ? 0 : RHYTHM_NOTE_INSTRUMENT_TYPES[i] - 6;
		OplInstrumentRhythmType rhythmType = RHYTHM_NOTE_INSTRUMENT_TYPES[i] > 0xA ? RHYTHM_TYPE_UNDEFINED :
			static_cast<OplInstrumentRhythmType>(11 - RHYTHM_NOTE_INSTRUMENT_TYPES[i]);
		byte *instrumentData = rhythmInstrumentDefinitions + (instrumentDefNumber * 9);

		loadInstrumentData(rhythmBank[i], instrumentData, rhythmType, rhythmNotes[i], newVersion);
	}

	// Set the const class variables with our just allocated banks
	_instrumentBank = instrumentBank;
	_rhythmBank = rhythmBank;
}

MidiDriver_Multisource *MidiDriver_Accolade_AdLib_create(Common::String driverFilename, OPL::Config::OplType oplType, int timerFrequency) {
	byte *driverData = nullptr;
	uint16 driverDataSize = 0;
	bool newVersion = false;

	MidiDriver_Accolade_readDriver(driverFilename, MT_ADLIB, driverData, driverDataSize, newVersion);
	if (!driverData)
		error("ACCOLADE-ADLIB: error during readDriver()");

	MidiDriver_Accolade_AdLib *driver = new MidiDriver_Accolade_AdLib(oplType, newVersion, timerFrequency);
	if (!driver)
		error("ACCOLADE-ADLIB: could not create driver");

	driver->readDriverData(driverData, driverDataSize, newVersion);

	delete[] driverData;
	return driver;
}

} // End of namespace AGOS

================
File: drivers\accolade\adlib.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_DRIVERS_ACCOLADE_ADLIB_H
#define AGOS_DRIVERS_ACCOLADE_ADLIB_H

#include "audio/adlib_ms.h"

namespace AGOS {

class MidiDriver_Accolade_AdLib : public MidiDriver_ADLIB_Multisource {
protected:
	static const byte RHYTHM_NOTE_INSTRUMENT_TYPES[40];
	static const uint16 OPL_NOTE_FREQUENCIES_INSTR_DAT[12];
	static const uint16 OPL_NOTE_FREQUENCIES_MUSIC_DRV[12];

public:
	MidiDriver_Accolade_AdLib(OPL::Config::OplType oplType, bool newVersion, int timerFrequency);
	~MidiDriver_Accolade_AdLib() override;

	int open() override;
	using MidiDriver_ADLIB_Multisource::send;
	void send(int8 source, uint32 b) override;
	void deinitSource(uint8 source) override;

	// Read the specified data from INSTR.DAT or MUSIC.DRV.
	void readDriverData(byte *driverData, uint16 driverDataSize, bool isMusicDrv);

	// Returns the number of simultaneous SFX sources supported by the current
	// driver configuration.
	byte getNumberOfSfxSources();
	// Loads the specified instrument for the specified instrument source.
	void loadSfxInstrument(uint8 source, byte *instrumentData);
	// Sets the note (upper byte) and note fraction (lower byte; 1/256th notes)
	// for the specified SFX source.
	void setSfxNoteFraction(uint8 source, uint16 noteFraction);
	// Writes out the current frequency for the specified SFX source.
	void updateSfxNote(uint8 source);
	// Applies a workaround for an Elvira 1 OPL3 instrument issue.
	void patchE1Instruments();
	// Applies a workaround for a Waxworks OPL3 instrument issue.
	void patchWwInstruments();

protected:
	InstrumentInfo determineInstrument(uint8 channel, uint8 source, uint8 note) override;

	uint8 allocateOplChannel(uint8 channel, uint8 source, InstrumentInfo &instrumentInfo) override;
	uint16 calculateFrequency(uint8 channel, uint8 source, uint8 note) override;
	uint8 calculateUnscaledVolume(uint8 channel, uint8 source, uint8 velocity, const OplInstrumentDefinition &instrumentDef, uint8 operatorNum) override;

	void writePanning(uint8 oplChannel, OplInstrumentRhythmType rhythmType = RHYTHM_TYPE_UNDEFINED) override;
	void writeFrequency(uint8 oplChannel, OplInstrumentRhythmType rhythmType = RHYTHM_TYPE_UNDEFINED) override;

	// Copies the specified instrument data (in INSTR.DAT/MUSIC.DRV format)
	// into the specified instrument definition.
	void loadInstrumentData(OplInstrumentDefinition &definition, byte *instrumentData,
		OplInstrumentRhythmType rhythmType, byte rhythmNote, bool newVersion);

	// False if the driver should have the behavior of the Elvira 1 driver;
	// true if it should have the behavior of the Elvira 2 / Waxworks version.
	bool _newVersion;

	// from INSTR.DAT/MUSIC.DRV - volume adjustment per instrument
	int8 _volumeAdjustments[128];
	// from INSTR.DAT/MUSIC.DRV - simple mapping between MIDI channel and AdLib channel
	byte _channelRemapping[16];
	// from INSTR.DAT/MUSIC.DRV - simple mapping between MIDI instruments and AdLib instruments
	byte _instrumentRemapping[128];
	// Points to one of the OPL_NOTE_FREQUENCIES arrays, depending on the driver version
	const uint16 *_oplNoteFrequencies;

	// Data used by AdLib SFX (Elvira 2 / Waxworks)

	// Instrument definition for each SFX source
	OplInstrumentDefinition _sfxInstruments[4];
	// Current MIDI note fraction (1/256th notes) for each SFX source
	byte _sfxNoteFractions[4];
};

} // End of namespace AGOS

#endif

================
File: drivers\accolade\casio.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "agos/drivers/accolade/casio.h"

#include "agos/drivers/accolade/mididriver.h"

namespace AGOS {

MidiDriver_Accolade_Casio::MidiDriver_Accolade_Casio() : MidiDriver_Casio(MT_CT460) {
	Common::fill(_channelRemapping, _channelRemapping + ARRAYSIZE(_channelRemapping), 0);
	Common::fill(_instrumentRemappingData, _instrumentRemappingData + ARRAYSIZE(_instrumentRemappingData), 0);
	Common::fill(_rhythmNoteRemappingData, _rhythmNoteRemappingData + ARRAYSIZE(_rhythmNoteRemappingData), 0);
}

int MidiDriver_Accolade_Casio::open() {
	int result = MidiDriver_Casio::open();

	// Apply instrument and rhythm note remapping after device initialization.
	_instrumentRemapping = _instrumentRemappingData;
	// WORKAROUND The MT-32 and Casio devices use a different mapping of notes
	// to instruments on the rhythm channel. The INSTR.DAT file of Elvira 1
	// contains a remapping of the rhythm notes in the game's MT-32 MIDI data
	// to the Casio's rhythm notes, but this does not seem to be used - the
	// game outputs the MT-32 rhythm notes when CT-460 is selected. As a result
	// the wrong rhythm instruments are played. This is fixed here by using the
	// game's remapping data to properly remap the rhythm notes to the notes
	// that the Casio devices use.
	_rhythmNoteRemapping = _rhythmNoteRemappingData;

	return result;
}

int8 MidiDriver_Accolade_Casio::mapSourceChannel(uint8 source, uint8 dataChannel) {
	if (!_isOpen)
		// Use 1 on 1 mapping during device initialization.
		return dataChannel;

	return _channelRemapping[dataChannel];
}

void MidiDriver_Accolade_Casio::readDriverData(byte *driverData, uint16 driverDataSize) {
	uint16 minDataSize = 354;
	if (driverDataSize < minDataSize)
		error("MidiDriver_Accolade_Casio::readDriverData - Expected minimum driver data size of %d - got %d", minDataSize, driverDataSize);

	// INSTR.DAT Data is like this:
	// 128 bytes  instrument mapping
	// 128 bytes  instrument volume adjust (signed!) (not used for Casio)
	//  16 bytes  unknown
	//  16 bytes  channel mapping
	//  64 bytes  key note mapping
	//   1 byte   instrument count
	//   1 byte   bytes per instrument
	//   x bytes  no instruments used for Casio

	uint16 channelMappingOffset = 256 + 16;
	Common::copy(driverData + channelMappingOffset, driverData + channelMappingOffset + ARRAYSIZE(_channelRemapping), _channelRemapping);

	uint16 instrumentMappingOffset = 0;
	Common::copy(driverData + instrumentMappingOffset, driverData + instrumentMappingOffset + ARRAYSIZE(_instrumentRemappingData), _instrumentRemappingData);

	uint16 rhythmNoteMappingOffset = 256 + 32;
	// 64 bytes are reserved for the rhythm note mapping, but only 40 seem to
	// be used. The first mapping is for note 0x24.
	Common::copy(driverData + rhythmNoteMappingOffset, driverData + rhythmNoteMappingOffset + 40, _rhythmNoteRemappingData + 0x24);
}

MidiDriver_Multisource *MidiDriver_Accolade_Casio_create(Common::String driverFilename) {
	byte *driverData = nullptr;
	uint16 driverDataSize = 0;
	bool newVersion = false;

	MidiDriver_Accolade_readDriver(driverFilename, MT_CT460, driverData, driverDataSize, newVersion);
	if (!driverData)
		error("MidiDriver_Accolade_Casio_create - Error during readDriver()");

	if (newVersion)
		// Only Elvira 1 has support for Casio and this uses the old drivers.
		error("MidiDriver_Accolade_Casio_create - Driver not supported for Elvira 2 / Waxworks / Simon 1 demo");

	MidiDriver_Accolade_Casio *driver = new MidiDriver_Accolade_Casio();
	if (!driver)
		error("MidiDriver_Accolade_Casio_create - Could not create driver");

	driver->readDriverData(driverData, driverDataSize);

	delete[] driverData;
	return driver;
}

} // End of namespace AGOS

================
File: drivers\accolade\casio.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_DRIVERS_ACCOLADE_CASIO_H
#define AGOS_DRIVERS_ACCOLADE_CASIO_H

#include "audio/casio.h"

namespace AGOS {

class MidiDriver_Accolade_Casio : public MidiDriver_Casio {
public:
	MidiDriver_Accolade_Casio();

	int open() override;
	int8 mapSourceChannel(uint8 source, uint8 dataChannel) override;

	void readDriverData(byte *driverData, uint16 driverDataSize);

protected:
	// Mapping between MT-32 data MIDI channels and Casio channels.
	byte _channelRemapping[16];
	// Mapping between MT-32 data instruments and Casio instruments.
	byte _instrumentRemappingData[128];
	// Mapping between MT-32 data rhythm notes and Casio rhythm notes.
	byte _rhythmNoteRemappingData[128];
};

} // End of namespace AGOS

#endif

================
File: drivers\accolade\cms.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "agos/drivers/accolade/cms.h"

#include "common/debug.h"

namespace AGOS {

// Hardcoded in RUNVGA.EXE.
const byte MidiDriver_Accolade_Cms::CMS_NOTE_FREQUENCIES[] = {
	0x03, 0x1F, 0x3A, 0x53, 0x6B, 0x82,
	0x97, 0xAC, 0xBF, 0xD1, 0xE2, 0xF2
};

// Hardcoded in RUNVGA.EXE; probably also used for Tandy.
const byte MidiDriver_Accolade_Cms::CMS_VOLUME_ADJUSTMENTS[] = {
	0xF7, 0xFD, 0xFB, 0x00, 0xEC, 0xEE, 0x00, 0x1E, 0x08, 0x07, 0x02, 0x03, 0x08, 0x0A, 0x00, 0x00,
	0xF6, 0xF4, 0xEF, 0x05, 0xFB, 0xFC, 0xF5, 0xF5, 0xF6, 0x28, 0x00, 0xEF, 0x00, 0x00, 0x00, 0x00,
	0x29, 0x03, 0xE9, 0x00, 0xF5, 0x50, 0xF9, 0xF9, 0xF2, 0x1E, 0xFE, 0x0B, 0xF7, 0xF7, 0xF5, 0xF8,
	0xFD, 0xFD, 0xFD, 0xE4, 0xED, 0xFB, 0xFE, 0xFB, 0xD1, 0x1F, 0x00, 0xF1, 0xF1, 0xF6, 0x00, 0x0A,
	0xEE, 0xDB, 0x0E, 0xE5, 0x0B, 0x00, 0x0A, 0x0D, 0x03, 0x06, 0xF3, 0xF5, 0x1E, 0x1E, 0x0A, 0xFA,
	0xF8, 0xF9, 0x0A, 0x00, 0xFA, 0xFA, 0xF9, 0x00, 0xF2, 0xF9, 0x00, 0xF9, 0x00, 0x04, 0xF8, 0xF7,
	0xFC, 0xF1, 0x0A, 0xF1, 0x20, 0x20, 0xF7, 0xF2, 0xF6, 0xF7, 0xFA, 0xFF, 0x20, 0x20, 0x00, 0x00,
	0xEA, 0x15, 0x00, 0xFB, 0x0E, 0x00, 0x14, 0x12, 0x00, 0xE2, 0xF7, 0xFB, 0x00, 0x00, 0xF1, 0xFF
};

MidiDriver_Accolade_Cms::MidiDriver_Accolade_Cms() : _cms(nullptr), _isOpen(false), _timer_proc(nullptr), _timer_param(nullptr) {
	Common::fill(_instruments, _instruments + ARRAYSIZE(_instruments), 0);
	Common::fill(_activeNotes, _activeNotes + ARRAYSIZE(_activeNotes), 0xFF);
	Common::fill(_octaveRegisterValues, _octaveRegisterValues + ARRAYSIZE(_octaveRegisterValues), 0);
}

MidiDriver_Accolade_Cms::~MidiDriver_Accolade_Cms() {
	if (_isOpen)
		close();
}

int MidiDriver_Accolade_Cms::open() {
	if (_isOpen)
		return MERR_ALREADY_OPEN;

	_cms = CMS::Config::create();
	if (!_cms || !_cms->init())
		return MERR_CANNOT_CONNECT;

	_isOpen = true;

	cmsInit();

	_cms->start(new Common::Functor0Mem<void, MidiDriver_Accolade_Cms>(this, &MidiDriver_Accolade_Cms::onTimer));

	return 0;
}

void MidiDriver_Accolade_Cms::close() {
	if (_cms) {
		_cms->stop();
		delete _cms;
		_cms = nullptr;
	}
	_isOpen = false;
}

bool MidiDriver_Accolade_Cms::isOpen() const {
	return _isOpen;
}

uint32 MidiDriver_Accolade_Cms::getBaseTempo() {
	return 1000000 / CMS::CMS::DEFAULT_CALLBACK_FREQUENCY;
}

MidiChannel *MidiDriver_Accolade_Cms::allocateChannel() {
	return nullptr;
}

MidiChannel *MidiDriver_Accolade_Cms::getPercussionChannel() {
	return nullptr;
}

void MidiDriver_Accolade_Cms::cmsInit() {
	for (int i = 0; i < 2; i++) {
		int chipOffset = i * 0x100;
		// Set registers 0x00 - 0x19 to 0 (note that this includes a few unused
		// registers).
		for (int j = 0; j <= 0x19; j++) {
			writeRegister(j + chipOffset, 0);
		}
		// Frequency reset.
		writeRegister(REGISTER_RESET_SOUND_ENABLE + chipOffset, 0x02);
		// Sound enable.
		writeRegister(REGISTER_RESET_SOUND_ENABLE + chipOffset, 0x01);
	}
}

void MidiDriver_Accolade_Cms::send(uint32 b) {
	byte channel = b & 0x0F;

	// WORKAROUND This check is bugged in the original interpreter. The channel
	// is first resolved through the channel mapping, which is 1 on 1 for
	// channels 0-5, and the default FF for the other channels, which means
	// they should not be played. Next, the mapped channel is checked against
	// the maximum channels for the device, >= 6. However, this check is
	// signed, which means FF is interpreted as -1, and it passes the check.
	// This comes into play when drums are played on channel 9. The code for
	// handling events does not expect channel FF and this results in writes to
	// invalid registers and interference with notes on the other channels.
	// This check is fixed here to restore the intended behavior.
	// Note that this does result in an extended period of silence during the
	// intro track where only drums are played.
	if (channel >= 6)
		return;

	byte command = b & 0xF0;
	byte op1 = (b >> 8) & 0xFF;
	byte op2 = (b >> 16) & 0xFF;

	switch (command) {
	case MIDI_COMMAND_NOTE_OFF:
		noteOff(channel, op1);
		break;
	case MIDI_COMMAND_NOTE_ON:
		noteOn(channel, op1, op2);
		break;
	case MIDI_COMMAND_CONTROL_CHANGE:
		controlChange(channel, op1, op2);
		break;
	case MIDI_COMMAND_PROGRAM_CHANGE:
		programChange(channel, op1);
		break;
	default:
		// Other MIDI events are ignored.
		break;
	}
}

void MidiDriver_Accolade_Cms::noteOff(uint8 channel, uint8 note) {
	if (_activeNotes[channel] != note)
		return;

	// Remove the note from the active note registry.
	_activeNotes[channel] = 0xFF;

	// Turn off the frequency enable bit for the channel.
	byte freqEnableRegValue = determineFrequencyEnableRegisterValue();
	writeRegister(REGISTER_FREQUENCY_ENABLE, freqEnableRegValue);
}

void MidiDriver_Accolade_Cms::noteOn(uint8 channel, uint8 note, uint8 velocity) {
	if (velocity == 0) {
		// Note on with velocity 0 is a note off.
		noteOff(channel, note);
		return;
	}

	// Add the note to the active note registry.
	_activeNotes[channel] = note;

	// Add octaves to bring the note up into the 0x15 - 0x7F range, then lower
	// the note with 0x15.
	while (note <= 0x15)
		note += 0xC;
	note -= 0x15;

	// Determine the octave and note within the octave.
	byte octave = note / 0xC;
	byte octaveNote = note % 0xC;

	// Apply the volume adjustment for the current instrument on the channel.
	int8 volumeAdjustment = static_cast<int8>(CMS_VOLUME_ADJUSTMENTS[_instruments[channel]]);
	uint8 volume = CLIP(velocity + volumeAdjustment, 0, 0x7F);
	// Calculate and write the amplitude register value.
	byte amplitude = volume >> 4;
	writeRegister(REGISTER_BASE_AMPLITUDE + channel, amplitude | (amplitude << 4));

	// Look up and write the note frequecy.
	byte frequency = CMS_NOTE_FREQUENCIES[octaveNote];
	writeRegister(REGISTER_BASE_FREQUENCY + channel, frequency);

	// An octave register contains the octaves for 2 channels.
	// Get the current value of the register containing the octave value for
	// this channel.
	byte octaveRegisterValue = _octaveRegisterValues[channel / 2];
	// Clear the bits containing the octave value for this channel.
	if (channel & 1) {
		// Octave is in the upper nibble.
		octave <<= 4;
		octaveRegisterValue &= 0x0F;
	} else {
		// Octave is in the lower nibble.
		octaveRegisterValue &= 0xF0;
	}
	// Set and write the new octave value.
	octaveRegisterValue |= octave;
	_octaveRegisterValues[channel / 2] = octaveRegisterValue;
	writeRegister(REGISTER_BASE_OCTAVE + (channel / 2), octaveRegisterValue);

	// Turn on the frequency enable bit for the channel.
	byte freqEnableRegValue = determineFrequencyEnableRegisterValue();
	writeRegister(REGISTER_FREQUENCY_ENABLE, freqEnableRegValue);
}

void MidiDriver_Accolade_Cms::programChange(uint8 channel, uint8 instrument) {
	// Just keep track of the current instrument.
	_instruments[channel] = instrument;
}

void MidiDriver_Accolade_Cms::controlChange(uint8 channel, uint8 controller, uint8 value) {
	// Only All Note Off is processed; it will turn off the active note on this
	// channel (if there is one).
	if (controller != MIDI_CONTROLLER_ALL_NOTES_OFF || _activeNotes[channel] == 0xFF)
		return;

	noteOff(channel, _activeNotes[channel]);
}

byte MidiDriver_Accolade_Cms::determineFrequencyEnableRegisterValue() {
	byte freqEnableRegValue = 0;
	for (int i = 0; i < 6; i++) {
		// If a note is active on a channel, set the frequency enable bit for
		// that channel.
		if (_activeNotes[i] != 0xFF)
			freqEnableRegValue |= 1 << i;
	}

	return freqEnableRegValue;
}

void MidiDriver_Accolade_Cms::writeRegister(uint16 reg, uint8 value) {
	//debug("Writing register %02X %02X", reg, value);

	_cms->writeReg(reg, value);
}

void MidiDriver_Accolade_Cms::setTimerCallback(void *timer_param, Common::TimerManager::TimerProc timer_proc) {
	_timer_param = timer_param;
	_timer_proc = timer_proc;
}

void MidiDriver_Accolade_Cms::onTimer() {
	if (_timer_proc && _timer_param)
		_timer_proc(_timer_param);
}

}

================
File: drivers\accolade\cms.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_DRIVERS_ACCOLADE_CMS_H
#define AGOS_DRIVERS_ACCOLADE_CMS_H

#include "audio/mididrv.h"

#include "audio/cms.h"

namespace AGOS {

// MIDI driver for the Creative Music System / Gameblaster.
// This driver uses only 6 of the available 12 channels and does not support
// stereo. It only supports note on and off and program change; the selected
// instrument only affects the note volume.
class MidiDriver_Accolade_Cms : public MidiDriver {
protected:
	static const byte REGISTER_BASE_AMPLITUDE = 0x00;
	static const byte REGISTER_BASE_FREQUENCY = 0x08;
	static const byte REGISTER_BASE_OCTAVE = 0x10;
	static const byte REGISTER_FREQUENCY_ENABLE = 0x14;
	static const byte REGISTER_RESET_SOUND_ENABLE = 0x1C;

	// Frequency register values for octave notes.
	static const byte CMS_NOTE_FREQUENCIES[12];
	// Volume adjustments for all instruments.
	static const byte CMS_VOLUME_ADJUSTMENTS[128];

public:
	MidiDriver_Accolade_Cms();
	~MidiDriver_Accolade_Cms() override;

	int open() override;
	void close() override;
	bool isOpen() const override;
	uint32 getBaseTempo() override;
	// This driver does not support MidiChannel objects.
	MidiChannel *allocateChannel() override;
	// This driver does not support MidiChannel objects.
	MidiChannel *getPercussionChannel() override;

	using MidiDriver::send;
	void send(uint32 b) override;

	void setTimerCallback(void *timer_param, Common::TimerManager::TimerProc timer_proc) override;
	void onTimer();

protected:
	void cmsInit();

	void noteOff(uint8 channel, uint8 note);
	void noteOn(uint8 channel, uint8 note, uint8 velocity);
	void programChange(uint8 channel, uint8 instrument);
	void controlChange(uint8 channel, uint8 controller, uint8 value);

	// Returns the value for the frequency enable register of the first CMS
	// chip based on the _activeNotes array (if a note is active, the bit for
	// the corresponding channel is set).
	byte determineFrequencyEnableRegisterValue();
	void writeRegister(uint16 reg, uint8 value);

	CMS::CMS *_cms;
	bool _isOpen;

	// The selected instrument on each MIDI channel.
	byte _instruments[16];
	// The active note on each CMS channel (0xFF if no note is active).
	byte _activeNotes[12];
	// The current values of the CMS octave registers (0x10 - 0x12).
	byte _octaveRegisterValues[6];

	// External timer callback
	void *_timer_param;
	Common::TimerManager::TimerProc _timer_proc;
};

} // End of namespace AGOS

#endif

================
File: drivers\accolade\driverfile.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "audio/mididrv.h"
#include "common/error.h"
#include "common/file.h"

namespace AGOS {

// this reads and gets Accolade driver data
// we need it for channel mapping, instrument mapping and other things
// this driver data chunk gets passed to the actual music driver (MT32 / AdLib)
void MidiDriver_Accolade_readDriver(Common::String filename, MusicType requestedDriverType, byte *&driverData, uint16 &driverDataSize, bool &isMusicDrvFile) {
	Common::File *driverStream = new Common::File();

	isMusicDrvFile = false;

	if (!driverStream->open(Common::Path(filename))) {
		error("%s: unable to open file", filename.c_str());
	}

	if (filename == "INSTR.DAT") {
		// INSTR.DAT: used by Elvira 1
		uint32 streamSize = driverStream->size();
		uint32 streamLeft = streamSize;
		uint16 skipChunks = 0; // 1 for MT32, 0 for AdLib
		uint16 chunkSize  = 0;

		switch (requestedDriverType) {
		case MT_ADLIB:
			skipChunks = 0;
			break;
		case MT_MT32:
			skipChunks = 1; // Skip one entry for MT32
			break;
		case MT_CT460:
			skipChunks = 2; // CT-460 data is the third entry
			break;
		default:
			assert(0);
			break;
		}

		do {
			if (streamLeft < 2)
				error("%s: unexpected EOF", filename.c_str());

			chunkSize = driverStream->readUint16LE();
			streamLeft -= 2;

			if (streamLeft < chunkSize)
				error("%s: unexpected EOF", filename.c_str());

			if (skipChunks) {
				// Skip the chunk
				driverStream->skip(chunkSize);
				streamLeft -= chunkSize;

				skipChunks--;
			}
		} while (skipChunks);

		// Seek over the ASCII string until there is a NUL terminator
		byte curByte = 0;

		do {
			if (chunkSize == 0)
				error("%s: no actual instrument data found", filename.c_str());

			curByte = driverStream->readByte();
			chunkSize--;
		} while (curByte);

		driverDataSize = chunkSize;

		// Read the requested instrument data entry
		driverData = new byte[driverDataSize];
		driverStream->read(driverData, driverDataSize);

	} else if (filename == "MUSIC.DRV") {
		// MUSIC.DRV / used by Elvira 2 / Waxworks / Simon 1 demo
		uint32 streamSize = driverStream->size();
		uint32 streamLeft = streamSize;
		uint16 getChunk   = 0; // 4 for MT32, 2 for AdLib

		switch (requestedDriverType) {
		case MT_ADLIB:
			getChunk = 2;
			break;
		case MT_MT32:
			getChunk = 4;
			break;
		default:
			assert(0);
			break;
		}

		if (streamLeft < 2)
			error("%s: unexpected EOF", filename.c_str());

		uint16 chunkCount = driverStream->readUint16LE();
		streamLeft -= 2;

		if (getChunk >= chunkCount)
			error("%s: required chunk not available", filename.c_str());

		uint16 headerOffset = 2 + (28 * getChunk);
		streamLeft -= (28 * getChunk);

		if (streamLeft < 28)
			error("%s: unexpected EOF", filename.c_str());

		// Seek to required chunk
		driverStream->seek(headerOffset);
		driverStream->skip(20); // skip over name
		streamLeft -= 20;

		uint16 musicDrvSignature = driverStream->readUint16LE();
		uint16 musicDrvType = driverStream->readUint16LE();
		uint16 chunkOffset = driverStream->readUint16LE();
		uint16 chunkSize   = driverStream->readUint16LE();

		// Security checks
		if (musicDrvSignature != 0xFEDC)
			error("%s: chunk signature mismatch", filename.c_str());
		if (musicDrvType != 1)
			error("%s: not a music driver", filename.c_str());
		if (chunkOffset >= streamSize)
			error("%s: driver chunk points outside of file", filename.c_str());

		streamLeft = streamSize - chunkOffset;
		if (streamLeft < chunkSize)
			error("%s: driver chunk is larger than file", filename.c_str());

		driverDataSize = chunkSize;

		// Read the requested instrument data entry
		driverData = new byte[driverDataSize];

		driverStream->seek(chunkOffset);
		driverStream->read(driverData, driverDataSize);
		isMusicDrvFile = true;
	}

	driverStream->close();
	delete driverStream;
}

} // End of namespace AGOS

================
File: drivers\accolade\mididriver.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_DRIVERS_ACCOLADE_MIDIDRIVER_H
#define AGOS_DRIVERS_ACCOLADE_MIDIDRIVER_H

#include "agos/agos.h"

#include "audio/fmopl.h"
#include "audio/mididrv.h"
#include "audio/mididrv_ms.h"

#include "common/error.h"

namespace AGOS {

#define AGOS_MIDI_CHANNEL_COUNT 16
#define AGOS_MIDI_INSTRUMENT_COUNT 128

#define AGOS_MIDI_KEYNOTE_COUNT 64

extern void MidiDriver_Accolade_readDriver(Common::String filename, MusicType requestedDriverType, byte *&driverData, uint16 &driverDataSize, bool &isMusicDrvFile);

extern MidiDriver_Multisource *MidiDriver_Accolade_AdLib_create(Common::String driverFilename, OPL::Config::OplType oplType, int callbackFrequency = OPL::OPL::kDefaultCallbackFrequency);
extern MidiDriver_Multisource *MidiDriver_Accolade_MT32_create(Common::String driverFilename);
extern MidiDriver_Multisource *MidiDriver_Accolade_Casio_create(Common::String driverFilename);
extern MidiDriver *MidiDriverPC98_create(MidiDriver::DeviceHandle dev);

} // End of namespace AGOS

#endif // AGOS_DRIVERS_ACCOLADE_MIDIDRIVER_H

================
File: drivers\accolade\mt32.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "agos/drivers/accolade/mt32.h"

#include "agos/drivers/accolade/mididriver.h"
#include "agos/sfxparser_accolade.h"

namespace AGOS {

const uint8 MidiDriver_Accolade_MT32::SYSEX_INSTRUMENT_ASSIGNMENT[7] = { 0x02, 0x00, 0x18, 0x32, 0x01, 0x00, 0x01 };

MidiDriver_Accolade_MT32::MidiDriver_Accolade_MT32() : MidiDriver_MT32GM(MT_MT32) {
	Common::fill(_channelRemapping, _channelRemapping + ARRAYSIZE(_channelRemapping), 0);
	Common::fill(_instrumentRemapping, _instrumentRemapping + ARRAYSIZE(_instrumentRemapping), 0);
	Common::fill(_channelLocks, _channelLocks + ARRAYSIZE(_channelLocks), false);
}

int MidiDriver_Accolade_MT32::open(MidiDriver *driver, bool nativeMT32) {
	int result = MidiDriver_MT32GM::open(driver, nativeMT32);

	setInstrumentRemapping(_instrumentRemapping);

	return result;
}

void MidiDriver_Accolade_MT32::send(int8 source, uint32 b) {
	byte dataChannel = b & 0xf;
	int8 outputChannel = mapSourceChannel(source, dataChannel);

	MidiChannelControlData &controlData = *_controlData[outputChannel];

	// Check if this event is sent by a music source and the channel is locked
	// by an SFX source.
	bool channelLockedByOtherSource = _sources[source].type != SOURCE_TYPE_SFX && _channelLocks[outputChannel];

	processEvent(source, b, outputChannel, controlData, channelLockedByOtherSource);
}

int8 MidiDriver_Accolade_MT32::mapSourceChannel(uint8 source, uint8 dataChannel) {
	if (!_isOpen)
		// Use 1 on 1 mapping during device initialization.
		return dataChannel;

	if (_sources[source].type == SOURCE_TYPE_SFX) {
		// Use channels 7 and 8 for SFX (sources 1 and 2).
		uint8 sfxChannel =  9 - source;

		_allocationMutex.lock();

		if (!_channelLocks[sfxChannel]) {
			// Lock channel
			stopAllNotes(0xFF, sfxChannel);
			_channelLocks[sfxChannel] = true;
		}

		_allocationMutex.unlock();

		return sfxChannel;
	} else {
		return _channelRemapping[dataChannel];
	}
}

void MidiDriver_Accolade_MT32::deinitSource(uint8 source) {
	_allocationMutex.lock();

	if (_sources[source].type == SOURCE_TYPE_SFX) {
		for (int i = 0; i < MIDI_CHANNEL_COUNT; i++) {
			if (_controlData[i]->source == source) {
				// Restore the music instrument.
				programChange(i, _controlData[i]->program, 0, *_controlData[i], false);
				// Unlock the channel.
				_channelLocks[i] = false;
			}
		}
	}

	_allocationMutex.unlock();

	MidiDriver_MT32GM::deinitSource(source);
}

void MidiDriver_Accolade_MT32::loadSfxInstrument(uint8 source, byte *instrumentData) {
	if (!(source == 1 || source == 2)) {
		warning("MidiDriver_Accolade_MT32::loadSfxInstrument - unexpected source %d", source);
		return;
	}

	// Send the instrument data to the timbre memory (patch 1 or 2).
	uint32 address = (0x08 << 14) | (((source - 1) * 2) << 7);
	sysExMT32(instrumentData + 3, SfxParser_Accolade::INSTRUMENT_SIZE_MT32 - 3, address, true, true, source);

	// Allocate the new patch to instrument number 0x75 or 0x76.
	byte instrNum = SFX_PROGRAM_BASE + source - 1;
	address = (0x05 << 14) | instrNum << 3;
	byte instrAssignData[7];
	Common::copy(SYSEX_INSTRUMENT_ASSIGNMENT, SYSEX_INSTRUMENT_ASSIGNMENT + ARRAYSIZE(instrAssignData), instrAssignData);
	instrAssignData[1] = source - 1;
	sysExMT32(instrAssignData, 7, address, true, true, source);
}

void MidiDriver_Accolade_MT32::changeSfxInstrument(uint8 source) {
	// Change to the newly loaded instrument.
	byte channel = mapSourceChannel(source, 0);
	MidiChannelControlData &controlData = *_controlData[channel];
	byte originalInstrument = controlData.program;
	programChange(channel, SFX_PROGRAM_BASE + source - 1, source, controlData);
	// Store the original instrument so it can be used when deinitializing
	// the source.
	controlData.program = originalInstrument;
}

void MidiDriver_Accolade_MT32::readDriverData(byte *driverData, uint16 driverDataSize, bool newVersion) {
	uint16 minDataSize = newVersion ? 468 : 354;
	if (driverDataSize < minDataSize)
		error("ACCOLADE-ADLIB: Expected minimum driver data size of %d - got %d", minDataSize, driverDataSize);

	// INSTR.DAT Data is like this:
	// 128 bytes  instrument mapping
	// 128 bytes  instrument volume adjust (signed!) (not used for MT32)
	//  16 bytes  unknown
	//  16 bytes  channel mapping
	//  64 bytes  key note mapping (not really used for MT32)
	//   1 byte   instrument count
	//   1 byte   bytes per instrument
	//   x bytes  no instruments used for MT32

	// music.drv is basically a driver, but with a few fixed locations for certain data

	uint16 channelMappingOffset = newVersion ? 396 : 256 + 16;
	Common::copy(driverData + channelMappingOffset, driverData + channelMappingOffset + ARRAYSIZE(_channelRemapping), _channelRemapping);

	uint16 instrumentMappingOffset = newVersion ? 140 : 0;
	Common::copy(driverData + instrumentMappingOffset, driverData + instrumentMappingOffset + ARRAYSIZE(_instrumentRemapping), _instrumentRemapping);
}

MidiDriver_Multisource *MidiDriver_Accolade_MT32_create(Common::String driverFilename) {
	byte *driverData = nullptr;
	uint16 driverDataSize = 0;
	bool newVersion = false;

	MidiDriver_Accolade_readDriver(driverFilename, MT_MT32, driverData, driverDataSize, newVersion);
	if (!driverData)
		error("ACCOLADE-MT32: error during readDriver()");

	MidiDriver_Accolade_MT32 *driver = new MidiDriver_Accolade_MT32();
	if (!driver)
		error("ACCOLADE-MT32: could not create driver");

	driver->readDriverData(driverData, driverDataSize, newVersion);

	delete[] driverData;
	return driver;
}

} // End of namespace AGOS

================
File: drivers\accolade\mt32.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_DRIVERS_ACCOLADE_MT32_H
#define AGOS_DRIVERS_ACCOLADE_MT32_H

#include "audio/mt32gm.h"

namespace AGOS {

class MidiDriver_Accolade_MT32 : public MidiDriver_MT32GM {
protected:
	static const uint8 SFX_PROGRAM_BASE = 0x75;
	static const uint8 SYSEX_INSTRUMENT_ASSIGNMENT[7];

public:
	MidiDriver_Accolade_MT32();

	int open(MidiDriver *driver, bool nativeMT32) override;
	using MidiDriver_MT32GM::send;
	void send(int8 source, uint32 b) override;

	int8 mapSourceChannel(uint8 source, uint8 dataChannel) override;
	void deinitSource(uint8 source) override;

	// Read the specified data from INSTR.DAT or MUSIC.DRV.
	void readDriverData(byte *driverData, uint16 driverDataSize, bool isMusicDrv);

	// Loads the specified instrument for the specified instrument source.
	void loadSfxInstrument(uint8 source, byte *instrumentData);
	// Changes the channel assigned to the specified SFX source to the SFX
	// program number.
	void changeSfxInstrument(uint8 source);

protected:
	// simple mapping between MIDI channel and MT32 channel
	byte _channelRemapping[16];
	// simple mapping between MIDI instruments and MT32 instruments
	byte _instrumentRemapping[128];

	// Indicates if a MIDI channel is locked by an SFX source and unavailable
	// for music.
	bool _channelLocks[MIDI_CHANNEL_COUNT];
};

} // End of namespace AGOS

#endif

================
File: drivers\accolade\pc98.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "audio/softsynth/fmtowns_pc98/pc98_audio.h"
#include "audio/mididrv.h"
#include "audio/mixer.h"
#include "engines/engine.h"
#include "common/config-manager.h"
#include "common/func.h"

namespace AGOS {

class PC98CommonDriver : public MidiDriver {
public:
	enum PC98DriverProperties {
		kPropMusicVolume = 0x10,
		kPropSfxVolume = 0x20,
		kPropPause = 0x30
	};
public:
	PC98CommonDriver();
	~PC98CommonDriver() override {};

	bool isOpen() const override { return _isOpen; }
	void send(uint32 b) override;
	void setTimerCallback(void *timerParam, Common::TimerManager::TimerProc timerProc) override;
	uint32 property(int prop, uint32 param) override;
	uint32 getBaseTempo() override { return _baseTempo; }
	MidiChannel *allocateChannel() override { return nullptr; }
	MidiChannel *getPercussionChannel() override { return nullptr; }

protected:
	void updateSounds();
	void updateParser();
	void reset();

	uint32 _baseTempo;
	bool _isOpen;

	Audio::Mixer *_mixer;

	const uint8 *_instrumentsRemap;
	const int8 *_instrumentLevelAdjust;
	const uint8 *_partsRemap;

	uint8 _chanUse[16];
	uint8 _ngDelay;
	bool _allNotes;
	bool _programLock;
	bool _noFadeRemap;
	bool _delayedProgramChange;

private:
	virtual void noteOn(uint8 part, uint8 note, uint8 velo) = 0;
	virtual void noteOff(uint8 part, uint8 note) = 0;
	virtual void programChange(uint8 part, uint8 prog) = 0;
	virtual void processSounds() = 0;
	virtual void setVolume(int musicVolume, int sfxVolume) = 0;
	virtual void pause(bool paused) = 0;

	class TimerCb {
	public:
		typedef void(*FuncType)(void*);
		TimerCb(const FuncType func, void *arg) : _func(func), _arg(arg) {}
		bool isValid() const { return _func && _arg; }
		void operator()() const { (*_func)(_arg); }
	private:
		const FuncType _func;
		void *_arg;
	} *_timerCb;

	uint32 _internalUpdateTimer;

	uint16 _musicVolume;
	uint16 _sfxVolume;
	int8 _fadeVolumeAdjust;
	uint8 _partPrograms[16];
};

class PC98FMDriver : public PC98CommonDriver, private PC98AudioPluginDriver {
public:
	PC98FMDriver();
	~PC98FMDriver() override;

	int open() override;
	void close() override;

private:
	void noteOn(uint8 part, uint8 note, uint8 velo) override;
	void noteOff(uint8 part, uint8 note) override;
	void programChange(uint8 part, uint8 prog) override;
	void processSounds() override;
	void setVolume(int musicVolume, int sfxVolume) override;
	void pause(bool paused) override {}

	void loadInstrument(uint8 chan, uint8 prg);
	void startNote(uint8 chan, uint8 note, uint8 velo);
	void stopNote(uint8 chan, uint8 note);

	void timerCallbackA() override {}
	void timerCallbackB() override;

	PC98AudioCore *_pc98a;

	uint8 _chanAssign[3];
	uint8 _chanNotes[3];
	uint8 _partProgramsInternal[16];
	uint8 _partNotes[16];

	static const uint8 _instrumentsRemapFM[128];
	static const uint8 _instrumentLevelAdjustFM[128];
	static const uint8 _partsRemapFM[16];
	static const uint8 _instrumentPatches[16][25];
	static const uint8 _ngMapping[76];
	static const uint8 _carrier[8];
	static const uint16 _frequency[12];
};

class PC98MidiDriver : public PC98CommonDriver {
public:
	PC98MidiDriver(DeviceHandle dev);
	~PC98MidiDriver() override;

	int open() override;
	void close() override;

	static void timerCallback(void *obj);

private:
	void noteOn(uint8 part, uint8 note, uint8 velo) override;
	void noteOff(uint8 part, uint8 note) override;
	void programChange(uint8 part, uint8 prog) override;
	void processSounds() override {}
	void setVolume(int musicVolume, int sfxVolume) override;
	void pause(bool paused) override;
	void sendSysexWithCheckSum(uint8 *data);

	MidiDriver *_drv;
	DeviceHandle _dev;
	MusicType _devType;

	uint8 _volSysex[9];
	uint8 _partAssignSysexGS[9];
	uint8 _partAssignSysexMT32[9];

	static const uint8 _instrumentsRemapMT32[128];
	static const uint8 _instrumentsRemapGM[128];
	static const uint8 _partsRemapMidi[16];
	static const uint8 _sysexMsg[3][9];
};

PC98CommonDriver::PC98CommonDriver() : _mixer(g_engine->_mixer), _baseTempo(0), _fadeVolumeAdjust(0), _allNotes(false), _programLock(false), _isOpen(false), _noFadeRemap(false), _delayedProgramChange(false), _ngDelay(0), _timerCb(nullptr), _musicVolume(0xff), _sfxVolume(0xff), _internalUpdateTimer(0) {
	memset(_partPrograms, 0, sizeof(_partPrograms));
	memset(_chanUse, 0, sizeof(_chanUse));
}

void PC98CommonDriver::send(uint32 b) {
	if (!_isOpen)
		return;

	byte para2 = (b >> 16) & 0xFF;
	byte para1 = (b >> 8) & 0xFF;
	byte ch = b & 0x0F;

	switch (b & 0xF0) {
	case 0x80:
		noteOff(ch, para1);
		break;
	case 0x90:
		if (para2) {
			int16 velo = para2;
			if (ch != 9)
				velo = CLIP<int16>(velo + _instrumentLevelAdjust[_partPrograms[ch]], 0, 127);
			velo = CLIP<int16>(velo + _fadeVolumeAdjust, 0, 127);
			noteOn(ch, para1, velo);
		} else {
			noteOff(ch, para1);
		}
		break;
	case 0xC0:
		_partPrograms[ch] = para1;
		programChange(ch, ch == 9 ? 0 : _instrumentsRemap[para1 & 0x07F]);
		break;
	default:
		// 0xA0 and 0xB0 are parsing related and will be filtered and handled in MidiParser_S1D.
		if (!((b & 0xF0) == 0xB0 && (para1 == 0x7b || para1 == 0x07)))
			warning("PC98CommonDriver::send(): Unsupported Midi Message: 0x%02x 0x%02x 0x%02x", b & 0xFF, para1, para2);
		break;
	}
}

void PC98CommonDriver::setTimerCallback(void *timerParam, Common::TimerManager::TimerProc timerProc) {
	delete _timerCb;
	_timerCb = (_isOpen && timerParam && timerProc) ? new TimerCb(timerProc, timerParam) : nullptr;
}

uint32 PC98CommonDriver::property(int prop, uint32 param) {
	uint32 res = 0;
	switch (prop) {
	case kPropMusicVolume:
	case kPropSfxVolume: {
		uint16 &v = (prop == kPropMusicVolume) ? _musicVolume : _sfxVolume;
		res = v;
		if ((int32)param != -1)
			v = param & 0x1ff;
		if (_isOpen)
			setVolume(_musicVolume, _sfxVolume);
		break;
	}
	case kPropPause: {
		if (_isOpen)
			pause(param);
		break;
	}
	default:
		break;
	}
	return res;
}

void PC98CommonDriver::updateSounds() {
	if (!_isOpen)
		return;

	_internalUpdateTimer += _baseTempo;
	if (_internalUpdateTimer >= 16667) {
		_internalUpdateTimer -= 16667;

		// I haven't implemented music fading in and out, since Elvira 1 (the
		// only game for this sound driver) does not use the feature at all.
		// The fade volume would have to be updated here...

		for (int i = 0; i < 16; ++i)
			_chanUse[i] = 0;

		processSounds();
	}
}

void PC98CommonDriver::updateParser() {
	if (_isOpen && _timerCb && _timerCb->isValid())
		(*_timerCb)();
}

void PC98CommonDriver::reset() {
	memset(_partPrograms, 0, sizeof(_partPrograms));
	memset(_chanUse, 0, sizeof(_chanUse));
	_allNotes = false;
	_programLock = false;
	_noFadeRemap = false;
	_delayedProgramChange = false;
	_ngDelay = 0;
}

PC98FMDriver::PC98FMDriver() : PC98CommonDriver(), _pc98a(nullptr) {
	_baseTempo = 10080;
	_instrumentsRemap = _instrumentsRemapFM;
	_instrumentLevelAdjust = (const int8*)_instrumentLevelAdjustFM;
	_partsRemap = _partsRemapFM;
	memset(_partProgramsInternal, 0, sizeof(_partProgramsInternal));
	memset(_partNotes, 0, sizeof(_partNotes));
	memset(_chanAssign, 0, sizeof(_chanAssign));
	memset(_chanNotes, 0, sizeof(_chanNotes));
}

PC98FMDriver::~PC98FMDriver() {
	_mixer->stopAll();
	close();
}

int PC98FMDriver::open() {
	if (_isOpen)
		return MERR_ALREADY_OPEN;

	delete _pc98a;

	_pc98a = new PC98AudioCore(g_engine->_mixer, this, kType26);
	if (_pc98a && _pc98a->init()) {
		_pc98a->writeReg(0, 0x06, 0x0a);
		_pc98a->writeReg(0, 0x07, 0x9c);
		for (int i = 8; i < 11; ++i)
			_pc98a->writeReg(0, i, 0);
		_pc98a->writeReg(0, 0x27, 0x3a);
	} else {
		return MERR_DEVICE_NOT_AVAILABLE;
	}

	memset(_partProgramsInternal, 0, sizeof(_partProgramsInternal));
	memset(_partNotes, 0, sizeof(_partNotes));
	memset(_chanAssign, 0, sizeof(_chanAssign));
	memset(_chanNotes, 0, sizeof(_chanNotes));

	reset();

	_isOpen = true;

	return 0;
}

void PC98FMDriver::close() {
	_isOpen = false;
	delete _pc98a;
	_pc98a = nullptr;
	setTimerCallback(nullptr, nullptr);
}

void PC98FMDriver::noteOn(uint8 part, uint8 note, uint8 velo) {
	if (_delayedProgramChange && part != 9) {
		int ch = 0x80;
		uint8 high = 0x80;
		for (int i = 2; i >= 0; --i) {
			if (_chanAssign[i] == 0x80) {
				ch = i;
				break;
			}
			if (part < _chanAssign[i] && high > _chanAssign[i]) {
				ch = i;
				high = _chanAssign[i];
			}
		}
		if (ch == 0x80)
			return;

		loadInstrument(ch, _partProgramsInternal[part]);

		_partNotes[ch] = note;
		_chanAssign[ch] = part;
		part = ch;
	}
	startNote(part, note, velo);
}

void PC98FMDriver::noteOff(uint8 part, uint8 note) {
	if (_delayedProgramChange) {
		if (part == 9) {
			_pc98a->writeReg(0, 6, 0);
			stopNote(part, note);
		} else {
			for (int i = 2; i >= 0; --i) {
				if (_chanAssign[i] != part || (note != _partNotes[i] && !_allNotes))
					continue;
				_chanAssign[i] = 0x80;
				_partNotes[i] = 0;
				stopNote(i, note);
			}
		}
	} else {
		stopNote(part, note);
	}
}

void PC98FMDriver::programChange(uint8 part, uint8 prog) {
	if (!_delayedProgramChange)
		loadInstrument(part, prog);
	_partProgramsInternal[part] = prog;
}

void PC98FMDriver::processSounds() {
	if (_ngDelay)
		--_ngDelay;
	if (!_ngDelay)
		_pc98a->writeReg(0, 0x0a, 0);
}

void PC98FMDriver::setVolume(int musicVolume, int sfxVolume) {
	_pc98a->setMusicVolume(musicVolume);
	_pc98a->setSoundEffectVolume(sfxVolume);
}

void PC98FMDriver::loadInstrument(uint8 chan, uint8 prg) {
	if (chan > 2)
		return;

	assert(prg < ARRAYSIZE(_instrumentPatches));
	const uint8 *src = _instrumentPatches[prg];
	_pc98a->writeReg(0, 0xB0 | chan, *src++);

	for (uint8 reg = 0x30 | chan; reg < 0x40; reg += 4) {
		_pc98a->writeReg(0, reg, *src++);
		_pc98a->writeReg(0, reg + 0x10, *src++);
		_pc98a->writeReg(0, reg + 0x20, *src++);
		_pc98a->writeReg(0, reg + 0x30, (*src++) & 0x1F);
		_pc98a->writeReg(0, reg + 0x40, (*src++) & 0x1F);
		_pc98a->writeReg(0, reg + 0x50, *src++);
	}
}

void PC98FMDriver::startNote(uint8 chan, uint8 note, uint8 velo) {
	if (chan == 9) {
		if (note >= sizeof(_ngMapping) || _ngMapping[note] == 0xff)
			return;
		_pc98a->writeReg(0, 0x06, _ngMapping[note]);
		_pc98a->writeReg(0, 0x0a, 0x0a);
		_ngDelay = 3;
	}

	if (chan > 2)
		return;

	if (_chanUse[chan] && note < _chanNotes[chan])
		return;

	_allNotes = true;
	stopNote(chan, 0);
	_allNotes = false;
	_chanNotes[chan] = note;
	_chanUse[chan]++;

	const uint8 *instr = _instrumentPatches[_partProgramsInternal[chan]];
	uint8 c = _carrier[*instr & 7];

	instr += 2;
	const uint8 *pos = instr;
	uint8 instvl = 0x7F;
	for (int i = 0; i < 4; ++i) {
		if (((c >> i) & 1) && *pos < instvl)
			instvl = *pos;
		pos += 6;
	}

	pos = instr;
	velo = 0x7f - (0x57 + (velo >> 2)) - instvl;
	for (uint8 i = 0x40 | chan; i < 0x50; i += 4) {
		if (c & 1)
			_pc98a->writeReg(0, i, MIN<uint8>(*pos + velo, 0x7f));
		pos += 6;
		c >>= 1;
	}

	if (note > 18)
		note -= 12;
	uint16 frq = _frequency[note % 12];
	uint8 bl = (note / 12) << 3;
	_pc98a->writeReg(0, 0xa4 | chan, (frq >> 8) | bl);
	_pc98a->writeReg(0, 0xa0 | chan, frq & 0xff);

	_pc98a->writeReg(0, 0x28, 0xF0 | chan);
}

void PC98FMDriver::stopNote(uint8 chan, uint8 note) {
	if (chan > 2)
		return;

	if (_allNotes || note == _chanNotes[chan])
		_pc98a->writeReg(0, 0x28, chan);
}

void PC98FMDriver::timerCallbackB() {
	updateSounds();
	PC98AudioCore::MutexLock tempUnlock = _pc98a->stackUnlockMutex();
	updateParser();
}

const uint8 PC98FMDriver::_instrumentsRemapFM[128] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,	0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x01, 0x02, 0x0f,
	0x0f, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,	0x18, 0x19, 0x19, 0x1b, 0x1c, 0x1d, 0x1e, 0x03,
	0x04, 0x21, 0x22, 0x23, 0x05, 0x25, 0x06, 0x27,	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2e,
	0x30, 0x31, 0x35, 0x07, 0x35, 0x35, 0x36, 0x37,	0x38, 0x08, 0x3a, 0x3b, 0x3c, 0x3e, 0x3e, 0x3f,
	0x40, 0x41, 0x42, 0x44, 0x44, 0x45, 0x09, 0x47,	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x0a, 0x51, 0x51,
	0x51, 0x54, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,	0x58, 0x59, 0x5a, 0x5b, 0x5a, 0x5a, 0x5e, 0x5f,
	0x60, 0x61, 0x67, 0x63, 0x0c, 0x65, 0x66, 0x67,	0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0c, 0x0c,
	0x0c, 0x0c, 0x0c, 0x0d, 0x0e, 0x0f, 0x76, 0x77,	0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f
};

const uint8 PC98FMDriver::_instrumentLevelAdjustFM[128] = {
	0x28, 0x0f, 0x28, 0x1d, 0x14, 0x14, 0x23, 0x19,	0x28, 0x13, 0x23, 0x23, 0x30, 0x23, 0x17, 0x16,
	0x23, 0x14, 0x15, 0x13, 0x23, 0x23, 0x19, 0x19,	0x32, 0x19, 0x16, 0x23, 0x05, 0x0a, 0x05, 0x0a,
	0x35, 0x28, 0x2d, 0x23, 0x19, 0x1c, 0x22, 0x23,	0x23, 0x1a, 0x2d, 0x23, 0x23, 0x23, 0x23, 0x1e,
	0x32, 0x1e, 0x37, 0x23, 0x18, 0x2e, 0x2b, 0x32,	0x11, 0x14, 0x0f, 0x0f, 0x14, 0x14, 0x14, 0x14,
	0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x0a, 0x28,	0x0d, 0x14, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
	0x23, 0x0a, 0x19, 0x19, 0x14, 0x14, 0x12, 0x14,	0x2b, 0x2c, 0x34, 0x2e, 0x30, 0x31, 0x15, 0x29,
	0x32, 0x23, 0x23, 0x23, 0x23, 0x0b, 0x23, 0x23,	0x23, 0x23, 0x23, 0x23, 0x14, 0x14, 0x1e, 0x23,
	0x23, 0x23, 0x23, 0x23, 0x2c, 0x23, 0x23, 0x23,	0x23, 0x23, 0x23, 0x23, 0x00, 0x23, 0x23, 0x23
};

const uint8 PC98FMDriver::_partsRemapFM[16] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
};

const uint8 PC98FMDriver::_instrumentPatches[16][25] = {
	{ 0x3f, 0x06, 0x6b, 0x1f, 0x0e, 0x00, 0xff, 0x03, 0x0a, 0x1f, 0x02, 0x01, 0x0f, 0x03, 0x0a, 0x1f, 0x02, 0x01, 0x0f, 0x02, 0x00, 0x1f, 0x02, 0x01, 0x0f },
	{ 0x3f, 0x38, 0x75, 0x1f, 0x81, 0x01, 0x0a, 0x01, 0x00, 0x14, 0x82, 0x01, 0x0a, 0x73, 0x00, 0x14, 0x82, 0x01, 0x0a, 0x62, 0x00, 0x14, 0x82, 0x01, 0x0a },
	{ 0x07, 0x08, 0x3e, 0xdf, 0x15, 0x00, 0x0f, 0x03, 0x11, 0x5f, 0x1f, 0x00, 0x0a, 0x02, 0x25, 0x5d, 0x1f, 0x00, 0x0a, 0x02, 0x00, 0x92, 0x1f, 0x00, 0x0a },
	{ 0x3d, 0x4a, 0x23, 0x1b, 0x11, 0x00, 0xfa, 0x41, 0x00, 0x14, 0x00, 0x00, 0x0a, 0x42, 0x00, 0x14, 0x00, 0x00, 0x0a, 0x40, 0x00, 0x14, 0x00, 0x00, 0x0a },
	{ 0x3c, 0x0b, 0x2b, 0x5a, 0x02, 0x01, 0x35, 0x63, 0x2a, 0x55, 0x01, 0x00, 0x24, 0x03, 0x19, 0x5c, 0x09, 0x05, 0x44, 0x21, 0x00, 0x4d, 0x06, 0x00, 0x44 },
	{ 0x3c, 0x01, 0x20, 0x52, 0x0c, 0x01, 0x5a, 0x22, 0x17, 0x4f, 0x0a, 0x01, 0x2a, 0x26, 0x05, 0x45, 0x0a, 0x00, 0x0f, 0x31, 0x00, 0x47, 0x02, 0x00, 0x0f },
	{ 0x2c, 0x3a, 0x2d, 0x58, 0x0e, 0x00, 0xf7, 0x05, 0x39, 0x5a, 0x0e, 0x00, 0xf4, 0x02, 0x00, 0x58, 0x08, 0x00, 0xf4, 0x01, 0x05, 0x9a, 0x08, 0x00, 0xf4 },
	{ 0x3c, 0x01, 0x20, 0x52, 0x0c, 0x01, 0x2a, 0x21, 0x17, 0x4f, 0x0a, 0x01, 0x5a, 0x11, 0x00, 0x12, 0x8a, 0x01, 0x3a, 0x61, 0x07, 0x14, 0x82, 0x01, 0x3a },
	{ 0x00, 0x01, 0x7f, 0x00, 0x00, 0x00, 0xf0, 0x01, 0x23, 0x5f, 0x05, 0x00, 0xf3, 0x71, 0x1b, 0x5f, 0x0c, 0x01, 0xf5, 0x01, 0x07, 0x5f, 0x0c, 0x00, 0xf5 },
	{ 0x18, 0x37, 0x2c, 0x9e, 0x0d, 0x08, 0xb6, 0x31, 0x18, 0x1c, 0x04, 0x03, 0x36, 0x30, 0x22, 0xdc, 0x06, 0x0a, 0xb6, 0x32, 0x00, 0x9c, 0x01, 0x05, 0x26 },
	{ 0x3b, 0x0a, 0x00, 0x1f, 0x00, 0x00, 0x0a, 0x02, 0x22, 0x18, 0x0e, 0x00, 0x0a, 0x60, 0x3a, 0x18, 0x0c, 0x00, 0xfa, 0x31, 0x00, 0x51, 0x0b, 0x00, 0x38 },
	{ 0x2c, 0x34, 0x21, 0x58, 0x0e, 0x00, 0xf7, 0x76, 0x2f, 0x58, 0x14, 0x00, 0xfa, 0x30, 0x00, 0xd8, 0x84, 0x00, 0xf2, 0x72, 0x0b, 0x98, 0x8c, 0x00, 0xf6 },
	{ 0x3b, 0x08, 0x06, 0x5f, 0x00, 0x00, 0x1a, 0x01, 0x19, 0x4e, 0x0e, 0x00, 0x0a, 0x61, 0x30, 0x58, 0x18, 0x00, 0x5a, 0x30, 0x00, 0x50, 0x0b, 0x00, 0x38 },
	{ 0x3b, 0x0a, 0x0d, 0x16, 0x00, 0x00, 0x0a, 0x00, 0x0b, 0x1a, 0x16, 0x40, 0xfb, 0x0d, 0x13, 0x1a, 0x1a, 0xc0, 0xfa, 0x01, 0x00, 0x5e, 0x8e, 0x00, 0xf7 },
	{ 0x3b, 0x0e, 0x0c, 0x1f, 0x00, 0x00, 0x05, 0x0a, 0x25, 0x1b, 0x1b, 0x80, 0xfa, 0x00, 0x31, 0x1f, 0x0a, 0xc0, 0xf5, 0x00, 0x00, 0x5c, 0x8e, 0x40, 0xf7 },
	{ 0x32, 0x02, 0x15, 0x58, 0x14, 0x00, 0xfa, 0x31, 0x25, 0x5f, 0x0a, 0x40, 0xf4, 0x01, 0x17, 0x5a, 0x0c, 0x80, 0xf6, 0x01, 0x00, 0x9a, 0x8b, 0x00, 0xf5 }
};

const uint8 PC98FMDriver::_ngMapping[76] = {
	0x18, 0x1c, 0x3c, 0x20, 0x3e, 0x24, 0x40, 0x28,	0x2c, 0x38, 0x30, 0x3c, 0x00, 0x00, 0x36, 0x00,	0x38, 0x00, 0x00,
	0x00, 0x16, 0x11, 0x16, 0x16, 0x11, 0x16, 0x11, 0x16, 0x11, 0x0f, 0x32, 0x00, 0x00, 0x0d, 0x00, 0x10, 0x1f, 0x1f,
	0x0a, 0x08, 0x0a, 0x19, 0x04, 0x19, 0x04, 0x14, 0x04, 0x14, 0x0f, 0x0c, 0x0f, 0x0c, 0xff, 0xff, 0x0d, 0xff,	0x12,
	0xff, 0xff, 0xff, 0x0f, 0x19, 0x0f, 0x0f, 0x19, 0x0f, 0x19, 0x0f, 0x19, 0x14, 0x06, 0xff, 0xff, 0x0f, 0xff, 0x00
};

const uint8 PC98FMDriver::_carrier[8] = {
	0x08, 0x08, 0x08, 0x08, 0x0C, 0x0E, 0x0E, 0x0F
};

const uint16 PC98FMDriver::_frequency[12] = {
	0x0267, 0x028d, 0x02b3, 0x02dd, 0x0308, 0x0337, 0x0368, 0x039c, 0x03d3, 0x040e, 0x044b, 0x048b
};

#define MIDIMSG32(s, p1, p2) (p2 << 16 | p1 << 8 | s)

PC98MidiDriver::PC98MidiDriver(MidiDriver::DeviceHandle dev) : _dev(dev), _drv(nullptr) {
	_devType = (getMusicType(dev) == MT_MT32 || ConfMan.getBool("native_mt32")) ? MT_MT32 : MT_GM;
	_instrumentsRemap = (_devType == MT_MT32) ? _instrumentsRemapMT32 : (_devType == MT_GM ? _instrumentsRemapGM : nullptr);
	int8 *tbl2 = new int8[128]();
	_instrumentLevelAdjust = tbl2;
	_partsRemap = _partsRemapMidi;
	memcpy(_volSysex, _sysexMsg[0], 9);
	memcpy(_partAssignSysexGS, _sysexMsg[1], 9);
	memcpy(_partAssignSysexMT32, _sysexMsg[2], 9);
}

PC98MidiDriver::~PC98MidiDriver() {
	close();
	delete[] _instrumentLevelAdjust;
}

int PC98MidiDriver::open() {
	if (_isOpen)
		return MERR_ALREADY_OPEN;

	delete _drv;

	_drv = MidiDriver::createMidi(_dev);
	if (!_drv || !_instrumentsRemap)
		return MERR_DEVICE_NOT_AVAILABLE;

	_baseTempo = _drv->getBaseTempo();
	int res = _drv->open();

	if (!res) {
		_drv->setTimerCallback(this, &timerCallback);

		for (byte i = 0xB1; i < 0xBA; ++i)
			_drv->send(MIDIMSG32(i, 0x79, 0));

		property(kPropMusicVolume, Audio::Mixer::kMaxChannelVolume);

		if (_devType == MT_MT32) {
			_partAssignSysexGS[7] = 0x10;
			for (uint8 i = 0x10; i < 0x20; ++i) {
				_partAssignSysexGS[5] = i;
				sendSysexWithCheckSum(_partAssignSysexGS);
			}

			for (uint8 i = 0x01; i < 0x0A; ++i) {
				_partAssignSysexMT32[6] = 0x0C + i;
				_partAssignSysexMT32[7] = i;
				sendSysexWithCheckSum(_partAssignSysexMT32);
			}

		} else if (_devType == MT_GM) {
			_partAssignSysexGS[5] = 0x10;
			_partAssignSysexGS[7] = 9;
			sendSysexWithCheckSum(_partAssignSysexGS);
			uint8 p = 0;
			for (uint8 i = 0x11; i < 0x20; ++i) {
				_partAssignSysexGS[5] = i;
				_partAssignSysexGS[7] = p++;
				if (p == 9)
					p++;
				sendSysexWithCheckSum(_partAssignSysexGS);
			}

			_partAssignSysexMT32[7] = 0x10;
			for (uint8 i = 0x0D; i < 0x16; ++i) {
				_partAssignSysexMT32[6] = i;
				sendSysexWithCheckSum(_partAssignSysexMT32);
			}

			_drv->send(MIDIMSG32(0xB9, 0x07, 0x46));
		}

		reset();
		_isOpen = true;
	}

	return res;
}

void PC98MidiDriver::close() {
	_isOpen = false;

	if (_drv) {
		_drv->setTimerCallback(nullptr, nullptr);
		_mixer->stopAll();
		_drv->close();
		delete _drv;
		_drv = nullptr;
	}

	setTimerCallback(nullptr, nullptr);
}

void PC98MidiDriver::timerCallback(void *obj) {
	PC98MidiDriver *drv = static_cast<PC98MidiDriver*>(obj);
	drv->updateSounds();
	drv->updateParser();
}

void PC98MidiDriver::noteOn(uint8 part, uint8 note, uint8 velo) {
	_drv->send(MIDIMSG32(0x90 | _partsRemap[part & 0x0F], note, velo));
}

void PC98MidiDriver::noteOff(uint8 part, uint8 note) {
	if (_allNotes)
		_drv->send(MIDIMSG32(0xB0 | _partsRemap[part & 0x0F], 0x7B, 0));
	else
		_drv->send(MIDIMSG32(0x80 | _partsRemap[part & 0x0F], note, 0));
}

void PC98MidiDriver::programChange(uint8 part, uint8 prog) {
	if (!_programLock)
		_drv->send(MIDIMSG32(0xC0 | _partsRemap[part & 0x0F], prog, 0));
}

void PC98MidiDriver::setVolume(int musicVolume, int sfxVolume) {
	if (!_isOpen)
		return;

	if (_devType == MT_MT32) {
		_volSysex[7] = musicVolume * 100 / Audio::Mixer::kMaxChannelVolume;
		sendSysexWithCheckSum(_volSysex);
	} else {
		uint8 vol = musicVolume * 127 / Audio::Mixer::kMaxChannelVolume;
		for (int i = 0; i < 16; ++i)
			_drv->send(MIDIMSG32(0xB0 | _partsRemap[i], 0x07, vol));
	}
}

void PC98MidiDriver::pause(bool paused) {
	if (paused) {
		_allNotes = true;
		for (int i = 0; i < 16; ++i)
			noteOff(i, 0);
		_allNotes = false;
	}
}

void PC98MidiDriver::sendSysexWithCheckSum(uint8 *data) {
	uint8 chk = 0;
	for (int i = 4; i < 8; ++i)
		chk += data[i];
	data[8] = 0x80 - (chk & 0x7f);
	_drv->sysEx(data, 9);
}

const uint8 PC98MidiDriver::_instrumentsRemapMT32[128] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
	0x60, 0x61, 0x62, 0x63, 0x6e, 0x65, 0x66, 0x67,	0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,	0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f
};

const uint8 PC98MidiDriver::_instrumentsRemapGM[128] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,	0x10, 0x09, 0x0a, 0x0b, 0x0c, 0x10, 0x10, 0x0f,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x26,
	0x58, 0x21, 0x22, 0x23, 0x61, 0x25, 0x0b, 0x27,	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
	0x30, 0x31, 0x32, 0x2d, 0x34, 0x35, 0x36, 0x37,	0x38, 0x2e, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x23, 0x47,	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4c, 0x4e, 0x4f,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
	0x60, 0x61, 0x62, 0x63, 0x4c, 0x65, 0x66, 0x67,	0x0c, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
	0x70, 0x71, 0x72, 0x75, 0x76, 0x74, 0x76, 0x77,	0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f
};

const uint8 PC98MidiDriver::_partsRemapMidi[16] = {
	0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,	0x0f, 0x09, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f
};

const uint8 PC98MidiDriver::_sysexMsg[3][9] = {
	{ 0x41, 0x10, 0x16, 0x12, 0x10, 0x00, 0x16, 0x64, 0x00 },
	{ 0x41, 0x10, 0x42, 0x12, 0x40, 0x10, 0x02, 0x10, 0x00 },
	{ 0x41, 0x10, 0x16, 0x12, 0x10, 0x00, 0x00, 0x00, 0x00 }
};

MidiDriver *MidiDriverPC98_create(MidiDriver::DeviceHandle dev) {
	MusicType type = MidiDriver::getMusicType(dev);
	if (type == MT_PC98)
		return new PC98FMDriver();
	else if (type == MT_GM || type == MT_MT32)
		return new PC98MidiDriver(dev);
	return nullptr;
}

#undef MIDIMSG32

} // End of namespace AGOS

================
File: drivers\simon1\adlib.cpp
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "agos/drivers/simon1/adlib.h"

#include "common/file.h"

namespace AGOS {

// Rhythm map hardcoded in the Simon 1 executable.
const MidiDriver_Simon1_AdLib::RhythmMapEntry MidiDriver_Simon1_AdLib::RHYTHM_MAP[39] = {
	{ 11, 123,  40 },
	{ 12, 127,  50 },
	{ 12, 124,   1 },
	{ 12, 124,  90 },
	{ 13, 125,  50 },
	{ 13, 125,  25 },
	{ 15, 127,  80 },
	{ 13, 125,  25 },
	{ 15, 127,  40 },
	{ 13, 125,  35 },
	{ 15, 127,  90 },
	{ 13, 125,  35 },
	{ 13, 125,  45 },
	{ 14, 126,  90 },
	{ 13, 125,  45 },
	{ 15, 127,  90 },
	{  0,   0,   0 },
	{ 15, 127,  60 },
	{  0,   0,   0 },
	{ 13, 125,  60 },
	{  0,   0,   0 },
	{  0,   0,   0 },
	{  0,   0,   0 },
	{ 13, 125,  45 },
	{ 13, 125,  40 },
	{ 13, 125,  35 },
	{ 13, 125,  30 },
	{ 13, 125,  25 },
	{ 13, 125,  80 },
	{ 13, 125,  40 },
	{ 13, 125,  80 },
	{ 13, 125,  40 },
	{ 14, 126,  40 },
	{ 15, 127,  60 },
	{  0,   0,   0 },
	{  0,   0,   0 },
	{ 14, 126,  80 },
	{  0,   0,   0 },
	{ 13, 125, 100 }
};

// Frequency table hardcoded in the Simon 1 executable.
// Note that only the first 12 entries are used.
const uint16 MidiDriver_Simon1_AdLib::FREQUENCY_TABLE[16] = {
	0x0157, 0x016B, 0x0181, 0x0198, 0x01B0, 0x01CA, 0x01E5, 0x0202,
	0x0220, 0x0241, 0x0263, 0x0287, 0x2100, 0xD121, 0xA307, 0x46A4
};

MidiDriver_Simon1_AdLib::MidiDriver_Simon1_AdLib(OPL::Config::OplType oplType, const byte *instrumentData) : MidiDriver_ADLIB_Multisource(oplType), _musicRhythmNotesDisabled(false) {
	// The Simon 1 MIDI data is written for MT-32 and rhythm notes are played
	// by quickly turning a note on and off. The note off has no effect on an
	// MT-32, but it will cut off the rhythm note on OPL. To prevent this, note
	// off events for rhythm notes are ignored and the rhythm note is turned
	// off right before this rhythm instrument is played again. The original
	// interpreter does this as well.
	_rhythmModeIgnoreNoteOffs = true;

	parseInstrumentData(instrumentData);
}

MidiDriver_Simon1_AdLib::~MidiDriver_Simon1_AdLib() {
	delete[] _instrumentBank;
	delete[] _rhythmBank;
}

int MidiDriver_Simon1_AdLib::open() {
	int result = MidiDriver_ADLIB_Multisource::open();
	if (result >= 0)
		// Simon 1 has the OPL rhythm mode permanently enabled.
		setRhythmMode(true);

	return result;
}

void MidiDriver_Simon1_AdLib::parseInstrumentData(const byte *instrumentData) {
	const byte *dataPtr = instrumentData;

	// The instrument data consists of 128 16-byte entries.
	OplInstrumentDefinition *instrumentBank = new OplInstrumentDefinition[128];

	for (int i = 0; i < 128; i++) {
		instrumentBank[i].fourOperator = false;

		instrumentBank[i].operator0.freqMultMisc = *dataPtr++;
		instrumentBank[i].operator1.freqMultMisc = *dataPtr++;
		instrumentBank[i].operator0.level = *dataPtr++;
		instrumentBank[i].operator1.level = *dataPtr++;
		instrumentBank[i].operator0.decayAttack = *dataPtr++;
		instrumentBank[i].operator1.decayAttack = *dataPtr++;
		instrumentBank[i].operator0.releaseSustain = *dataPtr++;
		instrumentBank[i].operator1.releaseSustain = *dataPtr++;
		instrumentBank[i].operator0.waveformSelect = *dataPtr++;
		instrumentBank[i].operator1.waveformSelect = *dataPtr++;

		instrumentBank[i].connectionFeedback0 = *dataPtr++;
		instrumentBank[i].connectionFeedback1 = 0;
		instrumentBank[i].rhythmNote = 0;
		instrumentBank[i].rhythmType = RHYTHM_TYPE_UNDEFINED;

		// Remaining bytes seem to be unused.
		dataPtr += 5;
	}

	// Construct a rhythm bank from the original rhythm map data.
	OplInstrumentDefinition *rhythmBank = new OplInstrumentDefinition[39];
	// MIDI note range 36-74.
	_rhythmBankFirstNote = 36;
	_rhythmBankLastNote = 36 + 39 - 1;

	for (int i = 0; i < 39; i++) {
		if (RHYTHM_MAP[i].channel == 0) {
			// Some notes in the range have no definition.
			rhythmBank[i].rhythmType = RHYTHM_TYPE_UNDEFINED;
		} else {
			// The rhythm bank makes use of instruments defined in the main instrument bank.
			rhythmBank[i] = instrumentBank[RHYTHM_MAP[i].program];
			// The MIDI channels used in the rhythm map correspond to OPL rhythm instrument types:
			// 11 - bass drum
			// 12 - snare drum
			// 13 - tom tom
			// 14 - cymbal
			// 15 - hi-hat
			rhythmBank[i].rhythmType = static_cast<OplInstrumentRhythmType>(6 - (RHYTHM_MAP[i].channel - 10));
			rhythmBank[i].rhythmNote = RHYTHM_MAP[i].note;
		}
	}

	// Set the const class variables with our just allocated banks
	_instrumentBank = instrumentBank;
	_rhythmBank = rhythmBank;
}

void MidiDriver_Simon1_AdLib::noteOn(uint8 channel, uint8 note, uint8 velocity, uint8 source) {
	if (_musicRhythmNotesDisabled && _sources[source].type != SOURCE_TYPE_SFX && channel == MIDI_RHYTHM_CHANNEL)
		// A music source played a rhythm note while these are disabled.
		// Ignore this event.
		return;
	if (_sources[source].type == SOURCE_TYPE_SFX)
		// The original interpreter uses max velocity for all SFX notes.
		velocity = 0x7F;

	MidiDriver_ADLIB_Multisource::noteOn(channel, note, velocity, source);
}

void MidiDriver_Simon1_AdLib::programChange(uint8 channel, uint8 program, uint8 source) {
	MidiDriver_ADLIB_Multisource::programChange(channel, program, source);

	_activeNotesMutex.lock();

	// Deallocate all inactive OPL channels for this MIDI channel and source.
	for (int i = 0; i < _numMelodicChannels; i++) {
		uint8 oplChannel = _melodicChannels[i];
		if (_activeNotes[oplChannel].channelAllocated && !_activeNotes[oplChannel].noteActive &&
			_activeNotes[oplChannel].channel == channel && _activeNotes[oplChannel].source == source) {
			_activeNotes[oplChannel].channelAllocated = false;
		}
	}

	_activeNotesMutex.unlock();

	// Note: the original also sets up the new instrument on active OPL
	// channels, i.e. channels which are currently playing a note. This is
	// against the MIDI spec, which states that program changes should not
	// affect active notes, and against the behavior of the MT-32, for which
	// the music is composed. So instead, the new instrument is set up when a
	// new note is played on these OPL channels.
}

void MidiDriver_Simon1_AdLib::deinitSource(uint8 source) {
	if (_sources[source].type != SOURCE_TYPE_MUSIC)
		// When a sound effect has finished playing, re-enable music rhythm
		// notes.
		_musicRhythmNotesDisabled = false;

	MidiDriver_ADLIB_Multisource::deinitSource(source);
}

void MidiDriver_Simon1_AdLib::disableMusicRhythmNotes() {
	_musicRhythmNotesDisabled = true;
}

uint8 MidiDriver_Simon1_AdLib::allocateOplChannel(uint8 channel, uint8 source, InstrumentInfo &instrumentInfo) {
	// Use the regular allocation algorithm for rhythm instruments.
	if (channel == MIDI_RHYTHM_CHANNEL)
		return MidiDriver_ADLIB_Multisource::allocateOplChannel(channel, source, instrumentInfo);

	// When allocating an OPL channel for playback of a note, the algorithm
	// looks for the following types of channels:
	// - An OPL channel already allocated to this source and MIDI channel that
	//   is not playing a note.
	// - An unallocated OPL channel.
	// - An OPL channel allocated to a different source and/or MIDI channel
	//   that is not playing a note.
	//
	// If no free OPL channel could be found, an active channel is "stolen" and
	// the note it is currently playing is cut off. This channel is always
	// channel 0.
	uint8 allocatedChannel = 0xFF;

	uint8 unallocatedChannel = 0xFF;
	uint8 inactiveChannel = 0xFF;
	for (int i = 0; i < _numMelodicChannels; i++) {
		uint8 oplChannel = _melodicChannels[i];
		if (_activeNotes[oplChannel].channelAllocated && _activeNotes[oplChannel].channel == channel &&
			_activeNotes[oplChannel].source == source && !_activeNotes[oplChannel].noteActive) {
			// Found an OPL channel already allocated to this source and MIDI
			// channel that is not playing a note.
			allocatedChannel = oplChannel;
			// Always use the first available channel of this type.
			break;
		}

		if (!_activeNotes[oplChannel].channelAllocated && unallocatedChannel == 0xFF)
			// Found an unallocated OPL channel.
			unallocatedChannel = oplChannel;

		if (!_activeNotes[oplChannel].noteActive && inactiveChannel == 0xFF)
			// Found an OPL channel allocated to a different source and/or MIDI
			// channel that is not playing a note.
			inactiveChannel = oplChannel;
	}
	if (allocatedChannel == 0xFF) {
		// No allocated channel found.
		if (unallocatedChannel != 0xFF) {
			// Found an unallocated channel - use this.
			allocatedChannel = unallocatedChannel;
		} else if (inactiveChannel != 0xFF) {
			// Found an inactive channel - use this.
			allocatedChannel = inactiveChannel;
		} else {
			// A channel already playing a note must be "stolen".

			// The original had some logic for a priority based reuse of
			// channels. However, the priority value is always 0, which causes
			// the first channel to be picked all the time.
			allocatedChannel = 0;
		}
	}

	if (_activeNotes[allocatedChannel].noteActive)
		// Turn off the current note if the channel was "stolen".
		writeKeyOff(allocatedChannel);
	_activeNotes[allocatedChannel].channelAllocated = true;
	_activeNotes[allocatedChannel].source = source;
	_activeNotes[allocatedChannel].channel = channel;

	return allocatedChannel;
}

uint16 MidiDriver_Simon1_AdLib::calculateFrequency(uint8 channel, uint8 source, uint8 note) {
	// Determine the octave note. Notes 120-127 are clipped to octave note 12.
	uint8 octaveNote = note >= 120 ? 12 : note % 12;
	// Determine the octave / block. Notes 12-96 are in octaves 0-7, with lower
	// and higher notes clipped to octave 0 and 7, respectively.
	uint8 octave = CLIP((note / 12) - 1, 0, 7);

	// Look up the OPL frequency / F-num.
	uint16 octaveNoteFrequency = FREQUENCY_TABLE[octaveNote];

	// Combine block and F-num in the format used by the OPL Ax and Bx
	// registers.
	return (octave << 10) | octaveNoteFrequency;
}

uint8 MidiDriver_Simon1_AdLib::calculateUnscaledVolume(uint8 channel, uint8 source, uint8 velocity, const OplInstrumentDefinition &instrumentDef, uint8 operatorNum) {
	if (channel == MIDI_RHYTHM_CHANNEL && _sources[source].type != SOURCE_TYPE_SFX)
		// The original interpreter halves the velocity for music rhythm notes.
		// Note that SFX notes always use max velocity.
		velocity >>= 1;

	// Invert the instrument definition attenuation.
	uint8 instDefVolume = 0x3F - (instrumentDef.getOperatorDefinition(operatorNum).level & 0x3F);
	// Calculate the note volume using velocity and instrument definition
	// volume.
	uint8 calculatedVolume = ((velocity | 0x80) * instDefVolume) >> 8;

	// Invert the calculated volume to an attenuation.
	return 0x3F - calculatedVolume;
}

MidiDriver_Multisource *createMidiDriverSimon1AdLib(const char *instrumentFilename, OPL::Config::OplType oplType) {
	// Load instrument data.
	Common::File ibk;

	if (!ibk.open(instrumentFilename)) {
		error("MidiDriver_Simon1_AdLib::createMidiDriverSimon1AdLib - Could not find AdLib instrument bank file %s", instrumentFilename);
	}

	// Check for the expected FourCC (IBK\x1A)
	if (ibk.readUint32BE() != 0x49424b1a) {
		error("MidiDriver_Simon1_AdLib::createMidiDriverSimon1AdLib - Invalid AdLib instrument bank file %s", instrumentFilename);
	}

	byte *instrumentData = new byte[128 * 16];
	if (ibk.read(instrumentData, 128 * 16) != 128 * 16) {
		// Failed to read the expected amount of data.
		delete[] instrumentData;
		error("MidiDriver_Simon1_AdLib::createMidiDriverSimon1AdLib - Unexpected AdLib instrument bank file %s size", instrumentFilename);
	}

	MidiDriver_Simon1_AdLib *driver = new MidiDriver_Simon1_AdLib(oplType, instrumentData);
	delete[] instrumentData;

	return driver;
}

} // End of namespace AGOS

================
File: drivers\simon1\adlib.h
================
/* ScummVM - Graphic Adventure Engine
 *
 * ScummVM is the legal property of its developers, whose names
 * are too numerous to list here. Please refer to the COPYRIGHT
 * file distributed with this source distribution.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef AGOS_SIMON1_ADLIB_H
#define AGOS_SIMON1_ADLIB_H

#include "audio/adlib_ms.h"

namespace AGOS {

class MidiDriver_Simon1_AdLib : public MidiDriver_ADLIB_Multisource {
private:
	struct RhythmMapEntry {
		// The OPL rhythm instrument to use.
		// The original interpreter would move a note played on the MIDI rhythm
		// channel to one of MIDI channels 11-15, each corresponding to an OPL
		// rhythm instrument.
		uint8 channel;
		// The instrument bank entry used to play the rhythm note.
		uint8 program;
		// The MIDI note number that is actually played.
		uint8 note;
	};

public:
	MidiDriver_Simon1_AdLib(OPL::Config::OplType oplType, const byte *instrumentData);
	~MidiDriver_Simon1_AdLib();

	int open() override;

	void noteOn(uint8 channel, uint8 note, uint8 velocity, uint8 source) override;
	void programChange(uint8 channel, uint8 program, uint8 source) override;

	void deinitSource(uint8 source) override;

	// Turns off rhythm notes for sources with type MUSIC (typically source 0).
	// This should be called when a SFX source that uses rhythm notes starts
	// playing to prevent conflicts on the rhythm channels. Deinitializing a
	// SFX source will turn rhythm notes back on.
	void disableMusicRhythmNotes();

private:
	static const RhythmMapEntry RHYTHM_MAP[];
	static const uint16 FREQUENCY_TABLE[];

	uint8 allocateOplChannel(uint8 channel, uint8 source, InstrumentInfo &instrumentInfo) override;
	uint16 calculateFrequency(uint8 channel, uint8 source, uint8 note) override;
	uint8 calculateUnscaledVolume(uint8 channel, uint8 source, uint8 velocity,
								  const OplInstrumentDefinition &instrumentDef, uint8 operatorNum) override;
	void parseInstrumentData(const byte *instrumentData);

	// True if rhythm notes for sources with type MUSIC should not be played.
	bool _musicRhythmNotesDisabled;
};

MidiDriver_Multisource *createMidiDriverSimon1AdLib(const char *instrumentFilename, OPL::Config::OplType);

} // End of namespace AGOS

#endif
